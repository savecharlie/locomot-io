<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <!-- SEO Meta Tags -->
    <title>Free Pixel Art Editor - No Ads, No Login | LOCOMOT.IO</title>
    <meta name="description" content="Create pixel art for free with our powerful browser-based editor. No ads, no login required. Perfect for game sprites, icons, and retro art. Works on desktop and mobile.">
    <meta name="keywords" content="pixel art, pixel editor, free sprite editor, pixel art maker, game sprites, retro art, no ads, no login, free pixel art tool, browser pixel editor">
    <meta name="author" content="locomot.io">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://locomot.io/pixel.html">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://locomot.io/pixel.html">
    <meta property="og:title" content="Free Pixel Art Editor - No Ads, No Login">
    <meta property="og:description" content="Create pixel art for free. No ads, no login. Perfect for game sprites and retro art. Works on desktop and mobile.">
    <meta property="og:image" content="https://locomot.io/pixel-og.png">
    <meta property="og:site_name" content="LOCOMOT.IO">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://locomot.io/pixel.html">
    <meta name="twitter:title" content="Free Pixel Art Editor - No Ads, No Login">
    <meta name="twitter:description" content="Create pixel art for free. No ads, no login. Works on desktop and mobile.">
    <meta name="twitter:image" content="https://locomot.io/pixel-og.png">

    <!-- Additional SEO -->
    <meta name="theme-color" content="#1a1a2e">
    <meta name="application-name" content="Pixel Art Studio">

    <!-- Structured Data for SEO -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "Free Pixel Art Editor",
        "url": "https://locomot.io/pixel.html",
        "applicationCategory": "DesignApplication",
        "operatingSystem": "Web Browser",
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD"
        },
        "description": "Create pixel art for free with our powerful browser-based editor. No ads, no login required. Perfect for game sprites, icons, and retro art.",
        "featureList": [
            "No login required",
            "No advertisements",
            "Mobile and desktop support",
            "Multiple drawing tools",
            "Color palette generator",
            "Selection tools with lasso",
            "Export to PNG"
        ]
    }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
        }

        :root {
            --bg-dark: #1a1a2e;
            --bg-medium: #16213e;
            --bg-light: #0f3460;
            --accent: #e94560;
            --text: #eaeaea;
            --text-dim: #888;
            --tool-size: 44px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-dark);
            color: var(--text);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Top Bar */
        .top-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            background: var(--bg-medium);
            border-bottom: 1px solid var(--bg-light);
            min-height: 48px;
        }

        .top-bar-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .menu-btn {
            width: var(--tool-size);
            height: var(--tool-size);
            background: var(--bg-light);
            border: none;
            border-radius: 8px;
            color: var(--text);
            font-size: 20px;
            cursor: pointer;
        }

        .menu-btn:active {
            background: var(--accent);
        }

        .project-name {
            font-size: 16px;
            font-weight: 500;
        }

        .top-bar-right {
            display: flex;
            gap: 4px;
        }

        .action-btn {
            width: 40px;
            height: 40px;
            background: transparent;
            border: none;
            border-radius: 8px;
            color: var(--text);
            font-size: 18px;
            cursor: pointer;
        }

        .action-btn:active {
            background: var(--bg-light);
        }

        .action-btn:disabled {
            opacity: 0.3;
        }

        /* Main Canvas Area */
        .canvas-area {
            flex: 1;
            display: flex;
            overflow: hidden;
            position: relative;
        }

        /* Desktop Side Tools */
        .side-tools {
            display: none;
            flex-direction: column;
            padding: 8px;
            background: var(--bg-medium);
            border-right: 1px solid var(--bg-light);
            gap: 4px;
        }

        @media (min-width: 768px) {
            .side-tools {
                display: flex;
            }
        }

        .tool-btn {
            width: var(--tool-size);
            height: var(--tool-size);
            background: var(--bg-light);
            border: 2px solid transparent;
            border-radius: 8px;
            color: var(--text);
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tool-btn:hover {
            background: var(--accent);
        }

        .tool-btn.active {
            border-color: var(--accent);
            background: var(--accent);
        }

        .tool-btn.active:hover {
            background: var(--accent);
        }

        /* Canvas Container */
        .canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #111;
            overflow: hidden;
            position: relative;
        }

        .canvas-wrapper {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        #mainCanvas {
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            background: repeating-conic-gradient(#333 0% 25%, #444 0% 50%) 50% / 16px 16px;
        }

        #gridCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            image-rendering: pixelated;
        }

        #previewCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            image-rendering: pixelated;
        }

        /* Desktop Side Palette */
        .side-palette {
            display: none;
            flex-direction: column;
            width: 180px;
            padding: 8px;
            background: var(--bg-medium);
            border-left: 1px solid var(--bg-light);
        }

        @media (min-width: 768px) {
            .side-palette {
                display: flex;
            }
        }

        .palette-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .palette-header h3 {
            font-size: 14px;
            color: var(--text-dim);
        }

        .palette-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 4px;
            margin-bottom: 12px;
        }

        .palette-color {
            aspect-ratio: 1;
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: pointer;
        }

        .palette-color:hover {
            transform: scale(1.1);
        }

        .palette-color.active {
            border-color: white;
        }

        .current-colors {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .current-color {
            width: 48px;
            height: 48px;
            border-radius: 8px;
            border: 2px solid var(--text-dim);
        }

        /* Bottom Bar (Mobile) */
        .bottom-bar {
            display: flex;
            flex-direction: column;
            background: var(--bg-medium);
            border-top: 1px solid var(--bg-light);
        }

        @media (min-width: 768px) {
            .bottom-bar {
                flex-direction: row;
                justify-content: space-between;
                align-items: center;
                padding: 8px 12px;
            }
        }

        .color-row {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            gap: 8px;
            overflow-x: auto;
        }

        @media (min-width: 768px) {
            .color-row {
                display: none;
            }
        }

        .mobile-current-color {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: 2px solid var(--text-dim);
            flex-shrink: 0;
        }

        .mobile-palette {
            display: flex;
            gap: 4px;
            flex-wrap: nowrap;
        }

        .mobile-palette-color {
            width: 36px;
            height: 36px;
            border-radius: 6px;
            border: 2px solid transparent;
            flex-shrink: 0;
        }

        .mobile-palette-color.active {
            border-color: white;
        }

        .mobile-tools {
            display: flex;
            padding: 8px;
            gap: 4px;
            overflow-x: auto;
            justify-content: center;
        }

        @media (min-width: 768px) {
            .mobile-tools {
                display: none;
            }
        }

        /* Status Bar (Desktop) */
        .status-bar {
            display: none;
            font-size: 12px;
            color: var(--text-dim);
            gap: 16px;
        }

        @media (min-width: 768px) {
            .status-bar {
                display: flex;
            }
        }

        /* Modals */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 100;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: var(--bg-medium);
            border-radius: 12px;
            padding: 20px;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
        }

        .modal h2 {
            margin-bottom: 16px;
        }

        .modal-buttons {
            display: flex;
            gap: 8px;
            margin-top: 16px;
            justify-content: flex-end;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
        }

        .btn-primary {
            background: var(--accent);
            color: white;
        }

        .btn-secondary {
            background: var(--bg-light);
            color: var(--text);
        }

        /* Form controls */
        .form-group {
            margin-bottom: 12px;
        }

        .form-group label {
            display: block;
            margin-bottom: 4px;
            font-size: 14px;
            color: var(--text-dim);
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--bg-light);
            border-radius: 6px;
            background: var(--bg-dark);
            color: var(--text);
            font-size: 14px;
        }

        /* Line tool indicator */
        .line-indicator {
            position: absolute;
            width: 12px;
            height: 12px;
            border: 2px solid var(--accent);
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.5; transform: translate(-50%, -50%) scale(1.2); }
        }

        /* Toast notifications */
        .toast {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-light);
            color: var(--text);
            padding: 12px 20px;
            border-radius: 8px;
            z-index: 200;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .toast.show {
            opacity: 1;
        }

        /* Zoom indicator */
        .zoom-indicator {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background: rgba(0,0,0,0.6);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
        }

        /* Eraser cursor */
        .eraser-cursor {
            position: absolute;
            pointer-events: none;
            border: 2px solid #ff69b4;
            background: rgba(255, 105, 180, 0.3);
            z-index: 50;
        }

        /* Replace color modal improvements */
        .color-pick-row {
            display: flex;
            gap: 12px;
            align-items: center;
            padding: 12px;
            background: var(--bg-dark);
            border-radius: 8px;
            margin-bottom: 12px;
        }

        .color-preview-large {
            width: 64px;
            height: 64px;
            border-radius: 8px;
            border: 3px solid var(--text-dim);
            flex-shrink: 0;
        }

        .color-pick-controls {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .color-pick-controls input[type="color"] {
            width: 100%;
            height: 44px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }

        .pick-from-canvas-btn {
            padding: 10px 16px;
            background: var(--bg-light);
            border: none;
            border-radius: 8px;
            color: var(--text);
            cursor: pointer;
            font-size: 14px;
        }

        .pick-from-canvas-btn:active {
            background: var(--accent);
        }

        .pick-from-canvas-btn.active {
            background: var(--accent);
        }

        /* Pixel Art Icons */
        .pixel-icon {
            width: 8px;
            height: 8px;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
        }

        .tool-btn .pixel-icon {
            width: 24px;
            height: 24px;
        }

        /* Palette Generator Selectable Colors */
        .palette-gen-grid {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .palette-gen-row {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .palette-gen-row-select {
            width: 20px;
            height: 28px;
            background: var(--bg-light);
            border: none;
            border-radius: 4px;
            color: var(--text);
            cursor: pointer;
            font-size: 10px;
            flex-shrink: 0;
        }

        .palette-gen-row-select:hover {
            background: var(--accent);
        }

        .palette-gen-colors {
            display: flex;
            gap: 2px;
        }

        .palette-gen-color {
            width: 28px;
            height: 28px;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: transform 0.1s, border-color 0.1s;
        }

        .palette-gen-color:hover {
            transform: scale(1.1);
        }

        .palette-gen-color.selected {
            border-color: white;
            box-shadow: 0 0 0 2px var(--accent);
        }

        .palette-gen-color.deselected {
            opacity: 0.3;
        }

        .palette-gen-col-selectors {
            display: flex;
            gap: 2px;
            margin-left: 24px;
            margin-bottom: 8px;
        }

        .palette-gen-col-select {
            width: 28px;
            height: 16px;
            background: var(--bg-light);
            border: none;
            border-radius: 4px;
            color: var(--text);
            cursor: pointer;
            font-size: 8px;
        }

        .palette-gen-col-select:hover {
            background: var(--accent);
        }

        .palette-gen-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .palette-gen-actions button {
            flex: 1;
            padding: 8px;
            background: var(--bg-light);
            border: none;
            border-radius: 6px;
            color: var(--text);
            cursor: pointer;
            font-size: 12px;
        }

        .palette-gen-actions button:hover {
            background: var(--accent);
        }

        /* Selection Canvas */
        #selectionCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            image-rendering: pixelated;
        }

        /* Selection Action Toolbar */
        .selection-toolbar {
            position: fixed;
            bottom: 140px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
            padding: 8px;
            background: var(--bg-medium);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            z-index: 100;
        }

        @media (min-width: 768px) {
            .selection-toolbar {
                bottom: 80px;
            }
        }

        .sel-action {
            width: 40px;
            height: 40px;
            background: var(--bg-light);
            border: none;
            border-radius: 8px;
            color: var(--text);
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sel-action:hover {
            background: var(--accent);
        }

        .sel-action:active {
            transform: scale(0.95);
        }

        /* Lasso start indicator */
        .lasso-start {
            position: absolute;
            width: 8px;
            height: 8px;
            background: var(--accent);
            border: 2px solid white;
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            animation: lasso-pulse 1s infinite;
            z-index: 51;
        }

        @keyframes lasso-pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.3); opacity: 0.7; }
        }
    </style>
</head>
<body>
    <!-- Top Bar -->
    <div class="top-bar">
        <div class="top-bar-left">
            <button class="menu-btn" id="menuBtn" title="Menu">‚ò∞</button>
            <span class="project-name" id="projectName">Untitled</span>
        </div>
        <div class="top-bar-right">
            <button class="action-btn" id="undoBtn" title="Undo (Ctrl+Z)">‚Ü©</button>
            <button class="action-btn" id="redoBtn" title="Redo (Ctrl+Y)">‚Ü™</button>
            <button class="action-btn" id="gridBtn" title="Toggle Grid (G)">‚ñ¶</button>
            <button class="action-btn" id="saveBtn" title="Export PNG">üíæ</button>
        </div>
    </div>

    <!-- Main Canvas Area -->
    <div class="canvas-area">
        <!-- Desktop Side Tools -->
        <div class="side-tools">
            <button class="tool-btn active" data-tool="pencil" title="Pencil (P)"><canvas class="pixel-icon" data-icon="pencil"></canvas></button>
            <button class="tool-btn" data-tool="eraser" title="Eraser (E)"><canvas class="pixel-icon" data-icon="eraser"></canvas></button>
            <button class="tool-btn" data-tool="select" title="Select (M)"><canvas class="pixel-icon" data-icon="select"></canvas></button>
            <button class="tool-btn" data-tool="lasso" title="Lasso (S)"><canvas class="pixel-icon" data-icon="lasso"></canvas></button>
            <button class="tool-btn" data-tool="line" title="Line (L)"><canvas class="pixel-icon" data-icon="line"></canvas></button>
            <button class="tool-btn" data-tool="rect" title="Rectangle (R)"><canvas class="pixel-icon" data-icon="rect"></canvas></button>
            <button class="tool-btn" data-tool="ellipse" title="Ellipse (O)"><canvas class="pixel-icon" data-icon="ellipse"></canvas></button>
            <button class="tool-btn" data-tool="fill" title="Fill Bucket (F)"><canvas class="pixel-icon" data-icon="fill"></canvas></button>
            <button class="tool-btn" data-tool="eyedropper" title="Eyedropper (I)"><canvas class="pixel-icon" data-icon="eyedropper"></canvas></button>
            <button class="tool-btn" data-tool="replace" title="Replace Color (C)"><canvas class="pixel-icon" data-icon="replace"></canvas></button>
        </div>

        <!-- Canvas Container -->
        <div class="canvas-container" id="canvasContainer">
            <div class="canvas-wrapper" id="canvasWrapper">
                <canvas id="mainCanvas"></canvas>
                <canvas id="gridCanvas"></canvas>
                <canvas id="previewCanvas"></canvas>
                <canvas id="selectionCanvas"></canvas>
                <div class="eraser-cursor" id="eraserCursor" style="display:none;"></div>
            </div>
            <div class="zoom-indicator" id="zoomIndicator">8x</div>
        </div>

        <!-- Selection Action Toolbar (outside canvas-container to avoid event capture) -->
        <div class="selection-toolbar" id="selectionToolbar" style="display:none;">
            <button class="sel-action" data-action="move" title="Move">‚úã</button>
            <button class="sel-action" data-action="copy" title="Copy">üìã</button>
            <button class="sel-action" data-action="cut" title="Cut">‚úÇÔ∏è</button>
            <button class="sel-action" data-action="delete" title="Delete">üóëÔ∏è</button>
            <button class="sel-action" data-action="fliph" title="Flip Horizontal">‚ÜîÔ∏è</button>
            <button class="sel-action" data-action="flipv" title="Flip Vertical">‚ÜïÔ∏è</button>
            <button class="sel-action" data-action="deselect" title="Deselect">‚úñÔ∏è</button>
        </div>

        <!-- Desktop Side Palette -->
        <div class="side-palette">
            <div class="palette-header">
                <h3>Colors</h3>
                <button class="action-btn" id="paletteGenBtn" title="Generate Palette">‚ú®</button>
            </div>
            <div class="current-colors">
                <div class="current-color" id="currentColor" style="background: #000000;"></div>
            </div>
            <div class="palette-grid" id="paletteGrid"></div>
            <div class="palette-header">
                <h3>Palette</h3>
                <select id="paletteSelect" style="flex:1; margin-left: 8px;">
                    <option value="pico8">PICO-8</option>
                    <option value="gameboy">GameBoy</option>
                    <option value="endesga32">ENDESGA 32</option>
                    <option value="custom">Custom</option>
                </select>
            </div>
        </div>
    </div>

    <!-- Bottom Bar (Mobile) -->
    <div class="bottom-bar">
        <div class="color-row">
            <div class="mobile-current-color" id="mobileCurrentColor" style="background: #000000;"></div>
            <select id="mobileBrushSize" style="background:var(--surface);color:var(--text);border:1px solid var(--border);border-radius:4px;padding:4px;margin:0 8px;font-size:14px;">
                <option value="1">1px</option>
                <option value="2">2px</option>
                <option value="3">3px</option>
                <option value="4">4px</option>
                <option value="5">5px</option>
            </select>
            <div class="mobile-palette" id="mobilePalette"></div>
        </div>
        <div class="mobile-tools">
            <button class="tool-btn active" data-tool="pencil" title="Pencil"><canvas class="pixel-icon" data-icon="pencil"></canvas></button>
            <button class="tool-btn" data-tool="eraser" title="Eraser"><canvas class="pixel-icon" data-icon="eraser"></canvas></button>
            <button class="tool-btn" data-tool="select" title="Select"><canvas class="pixel-icon" data-icon="select"></canvas></button>
            <button class="tool-btn" data-tool="lasso" title="Lasso"><canvas class="pixel-icon" data-icon="lasso"></canvas></button>
            <button class="tool-btn" data-tool="line" title="Line"><canvas class="pixel-icon" data-icon="line"></canvas></button>
            <button class="tool-btn" data-tool="rect" title="Rectangle"><canvas class="pixel-icon" data-icon="rect"></canvas></button>
            <button class="tool-btn" data-tool="ellipse" title="Ellipse"><canvas class="pixel-icon" data-icon="ellipse"></canvas></button>
            <button class="tool-btn" data-tool="fill" title="Fill"><canvas class="pixel-icon" data-icon="fill"></canvas></button>
            <button class="tool-btn" data-tool="eyedropper" title="Eyedropper"><canvas class="pixel-icon" data-icon="eyedropper"></canvas></button>
            <button class="tool-btn" data-tool="replace" title="Replace"><canvas class="pixel-icon" data-icon="replace"></canvas></button>
        </div>
        <div class="status-bar">
            <span id="statusTool">Tool: Pencil</span>
            <span id="statusSize">Size: 32x32</span>
            <span id="statusZoom">Zoom: 8x</span>
            <span id="statusPos">Pos: 0, 0</span>
            <span>Brush: <select id="brushSizeSelect" style="background:var(--surface);color:var(--text);border:1px solid var(--border);border-radius:4px;padding:2px;">
                <option value="1">1px</option>
                <option value="2">2px</option>
                <option value="3">3px</option>
                <option value="4">4px</option>
                <option value="5">5px</option>
            </select></span>
        </div>
    </div>

    <!-- Menu Modal -->
    <div class="modal-overlay" id="menuModal">
        <div class="modal">
            <h2>Menu</h2>
            <div class="form-group">
                <button class="btn btn-secondary" style="width:100%; margin-bottom: 8px;" id="newCanvasBtn">New Canvas</button>
                <button class="btn btn-secondary" style="width:100%; margin-bottom: 8px;" id="exportPngBtn">Export PNG</button>
                <button class="btn btn-secondary" style="width:100%; margin-bottom: 8px;" id="importImageBtn">Import Image</button>
                <button class="btn btn-secondary" style="width:100%; margin-bottom: 8px;" id="paletteGenMenuBtn">Palette Generator</button>
            </div>
            <div class="modal-buttons">
                <button class="btn btn-primary" id="closeMenuBtn">Close</button>
            </div>
        </div>
    </div>

    <!-- New Canvas Modal -->
    <div class="modal-overlay" id="newCanvasModal">
        <div class="modal">
            <h2>New Canvas</h2>
            <div class="form-group">
                <label>Width (pixels)</label>
                <input type="number" id="newWidth" value="32" min="8" max="256">
            </div>
            <div class="form-group">
                <label>Height (pixels)</label>
                <input type="number" id="newHeight" value="32" min="8" max="256">
            </div>
            <div class="form-group">
                <label>Preset</label>
                <select id="sizePreset">
                    <option value="">Custom</option>
                    <option value="8">8x8</option>
                    <option value="16">16x16</option>
                    <option value="32" selected>32x32</option>
                    <option value="64">64x64</option>
                    <option value="128">128x128</option>
                    <option value="256">256x256</option>
                </select>
            </div>
            <div class="modal-buttons">
                <button class="btn btn-secondary" id="cancelNewCanvas">Cancel</button>
                <button class="btn btn-primary" id="createNewCanvas">Create</button>
            </div>
        </div>
    </div>

    <!-- Replace Color Modal -->
    <div class="modal-overlay" id="replaceColorModal">
        <div class="modal" style="min-width: 300px;">
            <h2>Replace Color</h2>

            <div class="form-group">
                <label style="font-size: 16px; margin-bottom: 8px;">FROM (color to replace)</label>
                <div class="color-pick-row">
                    <div class="color-preview-large" id="replaceFromColor" style="background:#000;"></div>
                    <div class="color-pick-controls">
                        <input type="color" id="replaceFromInput" value="#000000">
                        <button class="pick-from-canvas-btn" id="pickFromBtn">Pick from canvas</button>
                    </div>
                </div>
            </div>

            <div class="form-group">
                <label style="font-size: 16px; margin-bottom: 8px;">TO (new color)</label>
                <div class="color-pick-row">
                    <div class="color-preview-large" id="replaceToColor" style="background:#ffffff;"></div>
                    <div class="color-pick-controls">
                        <input type="color" id="replaceToInput" value="#ffffff">
                        <button class="pick-from-canvas-btn" id="useCurrentBtn">Use current color</button>
                    </div>
                </div>
            </div>

            <div class="modal-buttons" style="margin-top: 20px;">
                <button class="btn btn-secondary" id="cancelReplace" style="padding: 14px 24px; font-size: 16px;">Cancel</button>
                <button class="btn btn-primary" id="doReplace" style="padding: 14px 24px; font-size: 16px;">Replace All</button>
            </div>
        </div>
    </div>

    <!-- Palette Generator Modal -->
    <div class="modal-overlay" id="paletteGenModal">
        <div class="modal" style="min-width: 340px; max-width: 95vw;">
            <h2>Palette Generator</h2>
            <div class="form-group">
                <label>Base Color</label>
                <input type="color" id="baseColor" value="#e94560" style="height: 40px;">
            </div>
            <div class="form-group">
                <label>Harmony Type</label>
                <select id="harmonyType">
                    <option value="monochromatic">Monochromatic</option>
                    <option value="complementary">Complementary</option>
                    <option value="analogous">Analogous</option>
                    <option value="triadic" selected>Triadic</option>
                    <option value="splitcomp">Split-Complementary</option>
                    <option value="tetradic">Tetradic</option>
                </select>
            </div>
            <div class="form-group">
                <label>Colors per Ramp: <span id="rampSizeVal">6</span></label>
                <input type="range" id="rampSize" min="3" max="9" value="6">
            </div>
            <div class="form-group">
                <label>Hue Shift: <span id="hueShiftVal">15</span>¬∞</label>
                <input type="range" id="hueShift" min="0" max="30" value="15">
            </div>
            <div class="form-group">
                <label>Click colors to select/deselect. Click row/column buttons to toggle whole rows/columns.</label>
                <div id="palettePreview" class="palette-gen-grid"></div>
                <div class="palette-gen-actions">
                    <button id="selectAllColors">Select All</button>
                    <button id="deselectAllColors">Deselect All</button>
                    <button id="invertSelection">Invert</button>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="btn btn-secondary" id="cancelPaletteGen">Cancel</button>
                <button class="btn btn-primary" id="applyPalette">Apply Selected</button>
            </div>
        </div>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <script>
        // ===== STATE =====
        const state = {
            canvasWidth: 32,
            canvasHeight: 32,
            zoom: 8,
            panX: 0,
            panY: 0,
            currentTool: 'pencil',
            currentColor: '#000000',
            brushSize: 1,
            showGrid: true,
            undoStack: [],
            redoStack: [],
            maxHistory: 50,
            isDrawing: false,
            lastX: -1,
            lastY: -1,
            lineStartPoint: null, // For two-tap line mode
            palette: [],
            pinchStartDist: 0,
            pinchStartZoom: 1,
            pickingForReplace: false, // When picking color from canvas for replace
            generatedPalette: [], // Full generated palette
            selectedColors: new Set(), // Indices of selected colors
            paletteRampSize: 6, // Current ramp size for selection
            paletteNumRamps: 1, // Current number of ramps
            // Selection state
            selection: {
                active: false,
                pixels: new Set(), // Set of "x,y" strings for selected pixels
                bounds: null, // {x, y, width, height}
                floating: false, // Is content lifted/floating?
                floatingData: null, // ImageData of floating content
                floatingOffset: {x: 0, y: 0}, // Offset from original position
            },
            clipboard: null, // ImageData for copy/paste
            lassoPixels: [], // Array of {x,y} for lasso drawing
            lassoStart: null, // Starting pixel of lasso
        };

        // ===== PALETTES =====
        const PALETTES = {
            pico8: [
                '#000000', '#1d2b53', '#7e2553', '#008751',
                '#ab5236', '#5f574f', '#c2c3c7', '#fff1e8',
                '#ff004d', '#ffa300', '#ffec27', '#00e436',
                '#29adff', '#83769c', '#ff77a8', '#ffccaa'
            ],
            gameboy: ['#0f380f', '#306230', '#8bac0f', '#9bbc0f'],
            endesga32: [
                '#be4a2f', '#d77643', '#ead4aa', '#e4a672',
                '#b86f50', '#733e39', '#3e2731', '#a22633',
                '#e43b44', '#f77622', '#feae34', '#fee761',
                '#63c74d', '#3e8948', '#265c42', '#193c3e',
                '#124e89', '#0099db', '#2ce8f5', '#ffffff',
                '#c0cbdc', '#8b9bb4', '#5a6988', '#3a4466',
                '#262b44', '#181425', '#ff0044', '#68386c',
                '#b55088', '#f6757a', '#e8b796', '#c28569'
            ],
            custom: ['#000000', '#ffffff']
        };

        // ===== DOM ELEMENTS =====
        const mainCanvas = document.getElementById('mainCanvas');
        const gridCanvas = document.getElementById('gridCanvas');
        const previewCanvas = document.getElementById('previewCanvas');
        const selectionCanvas = document.getElementById('selectionCanvas');
        const canvasWrapper = document.getElementById('canvasWrapper');
        const canvasContainer = document.getElementById('canvasContainer');
        const ctx = mainCanvas.getContext('2d');
        const gridCtx = gridCanvas.getContext('2d');
        const previewCtx = previewCanvas.getContext('2d');
        const selCtx = selectionCanvas.getContext('2d');

        // ===== INITIALIZATION =====
        // ===== PIXEL ART ICONS =====
        function drawPixelIcons() {
            const icons = document.querySelectorAll('.pixel-icon');
            icons.forEach(canvas => {
                canvas.width = 16;
                canvas.height = 16;
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;
                const icon = canvas.dataset.icon;
                drawIcon(ctx, icon);
            });
        }

        function drawIcon(ctx, type) {
            const W = '#ffffff';  // White
            const G = '#888888';  // Gray
            const D = '#444444';  // Dark gray
            const P = '#ff69b4';  // Pink (eraser)
            const B = '#4a9eff';  // Blue
            const Y = '#ffcc00';  // Yellow
            const O = '#ff8800';  // Orange
            const R = '#ff4444';  // Red
            const _ = null;       // Transparent

            const iconData = {
                // Pencil - diagonal pencil
                pencil: [
                    [_,_,_,_,_,_,_,_,_,_,_,_,Y,Y,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,Y,Y,Y,Y,_],
                    [_,_,_,_,_,_,_,_,_,_,Y,Y,O,Y,Y,_],
                    [_,_,_,_,_,_,_,_,_,Y,Y,O,O,Y,_,_],
                    [_,_,_,_,_,_,_,_,Y,Y,O,O,Y,_,_,_],
                    [_,_,_,_,_,_,_,Y,Y,O,O,Y,_,_,_,_],
                    [_,_,_,_,_,_,Y,Y,O,O,Y,_,_,_,_,_],
                    [_,_,_,_,_,Y,Y,O,O,Y,_,_,_,_,_,_],
                    [_,_,_,_,Y,Y,O,O,Y,_,_,_,_,_,_,_],
                    [_,_,_,Y,Y,O,O,Y,_,_,_,_,_,_,_,_],
                    [_,_,Y,Y,O,O,Y,_,_,_,_,_,_,_,_,_],
                    [_,Y,Y,O,O,Y,_,_,_,_,_,_,_,_,_,_],
                    [_,D,D,O,Y,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,D,D,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,D,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                ],
                // Eraser - pink cylinder from above (ellipse)
                eraser: [
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,P,P,P,P,P,P,P,P,_,_,_,_],
                    [_,_,_,P,P,P,P,P,P,P,P,P,P,_,_,_],
                    [_,_,P,P,P,P,P,P,P,P,P,P,P,P,_,_],
                    [_,P,P,P,W,W,W,W,W,W,P,P,P,P,P,_],
                    [_,P,P,W,W,W,W,W,W,W,W,P,P,P,P,_],
                    [_,P,P,W,W,W,W,W,W,W,W,P,P,P,P,_],
                    [_,P,P,W,W,W,W,W,W,W,W,P,P,P,P,_],
                    [_,P,P,P,W,W,W,W,W,W,P,P,P,P,P,_],
                    [_,_,P,P,P,P,P,P,P,P,P,P,P,P,_,_],
                    [_,_,_,P,P,P,P,P,P,P,P,P,P,_,_,_],
                    [_,_,_,_,P,P,P,P,P,P,P,P,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                ],
                // Line - diagonal line
                line: [
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,W,W,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,W,W,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,W,W,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,W,W,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,W,W,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,W,W,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,W,W,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,W,W,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,W,W,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,W,W,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,W,W,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,W,W,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,W,W,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [W,W,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [W,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                ],
                // Rectangle - square outline
                rect: [
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,W,W,W,W,W,W,W,W,W,W,W,W,_,_],
                    [_,_,W,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,_,W,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,_,W,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,_,W,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,_,W,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,_,W,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,_,W,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,_,W,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,_,W,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,_,W,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,_,W,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,_,W,W,W,W,W,W,W,W,W,W,W,W,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                ],
                // Ellipse - circle outline
                ellipse: [
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,W,W,W,W,W,W,_,_,_,_,_],
                    [_,_,_,W,W,_,_,_,_,_,_,W,W,_,_,_],
                    [_,_,W,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,_,W,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,W,_,_,_,_,_,_,_,_,_,_,_,_,W,_],
                    [_,W,_,_,_,_,_,_,_,_,_,_,_,_,W,_],
                    [_,W,_,_,_,_,_,_,_,_,_,_,_,_,W,_],
                    [_,W,_,_,_,_,_,_,_,_,_,_,_,_,W,_],
                    [_,W,_,_,_,_,_,_,_,_,_,_,_,_,W,_],
                    [_,W,_,_,_,_,_,_,_,_,_,_,_,_,W,_],
                    [_,_,W,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,_,W,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,_,_,W,W,_,_,_,_,_,_,W,W,_,_,_],
                    [_,_,_,_,_,W,W,W,W,W,W,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                ],
                // Fill bucket
                fill: [
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,W,W,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,W,_,_,W,_,_,_,_],
                    [_,_,_,_,_,_,_,W,_,_,_,_,W,_,_,_],
                    [_,_,_,_,_,_,W,_,_,_,_,_,W,_,_,_],
                    [_,_,_,_,_,W,_,_,_,_,_,_,W,_,_,_],
                    [_,_,_,_,W,_,_,_,_,_,_,W,_,_,_,_],
                    [_,_,_,W,G,_,_,_,_,_,W,_,_,_,_,_],
                    [_,_,W,G,G,G,_,_,_,W,_,_,_,_,_,_],
                    [_,W,G,G,G,G,G,_,W,_,_,_,_,_,_,_],
                    [_,W,G,G,G,G,G,G,W,_,_,_,_,_,_,_],
                    [_,_,W,G,G,G,G,W,B,B,_,_,_,_,_,_],
                    [_,_,_,W,G,G,W,B,B,B,B,_,_,_,_,_],
                    [_,_,_,_,W,W,_,B,B,B,B,B,_,_,_,_],
                    [_,_,_,_,_,_,_,_,B,B,B,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                ],
                // Eyedropper
                eyedropper: [
                    [_,_,_,_,_,_,_,_,_,_,_,W,W,W,_,_],
                    [_,_,_,_,_,_,_,_,_,_,W,W,W,W,W,_],
                    [_,_,_,_,_,_,_,_,_,_,W,W,W,W,W,_],
                    [_,_,_,_,_,_,_,_,_,W,W,W,W,W,_,_],
                    [_,_,_,_,_,_,_,_,W,W,W,W,W,_,_,_],
                    [_,_,_,_,_,_,_,W,G,W,W,W,_,_,_,_],
                    [_,_,_,_,_,_,W,G,G,W,W,_,_,_,_,_],
                    [_,_,_,_,_,W,G,G,G,W,_,_,_,_,_,_],
                    [_,_,_,_,W,G,G,G,W,_,_,_,_,_,_,_],
                    [_,_,_,W,G,G,G,W,_,_,_,_,_,_,_,_],
                    [_,_,W,G,G,G,W,_,_,_,_,_,_,_,_,_],
                    [_,W,G,G,G,W,_,_,_,_,_,_,_,_,_,_],
                    [_,W,G,G,W,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,W,W,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,W,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                ],
                // Replace - two overlapping squares with arrow
                replace: [
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,R,R,R,R,R,R,R,_,_,_,_,_,_,_,_],
                    [_,R,R,R,R,R,R,R,_,_,_,_,_,_,_,_],
                    [_,R,R,_,_,_,R,R,_,_,_,_,_,_,_,_],
                    [_,R,R,_,_,_,R,R,_,_,_,_,_,_,_,_],
                    [_,R,R,_,_,_,R,R,_,_,W,W,_,_,_,_],
                    [_,R,R,R,R,R,R,R,_,W,W,W,W,_,_,_],
                    [_,R,R,R,R,R,R,R,W,W,W,W,W,W,_,_],
                    [_,_,_,_,_,_,_,_,W,W,W,W,W,W,W,_],
                    [_,_,_,_,_,_,B,B,B,B,B,B,B,B,B,_],
                    [_,_,_,_,_,_,B,B,_,_,_,_,B,B,B,_],
                    [_,_,_,_,_,_,B,B,_,_,_,_,B,B,B,_],
                    [_,_,_,_,_,_,B,B,_,_,_,_,B,B,B,_],
                    [_,_,_,_,_,_,B,B,_,_,_,_,B,B,B,_],
                    [_,_,_,_,_,_,B,B,B,B,B,B,B,B,B,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                ],
                // Select - dashed rectangle marquee
                select: [
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,W,W,_,_,W,W,_,_,W,W,_,_,_,_],
                    [_,W,_,_,_,_,_,_,_,_,_,_,W,_,_,_],
                    [_,W,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,W,_,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,W,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,W,_,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,W,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,W,_,_,_],
                    [_,_,W,W,_,_,W,W,_,_,W,W,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                ],
                // Lasso - loop with rope tail
                lasso: [
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,W,W,W,W,_,_,_,_,_,_,_,_],
                    [_,_,_,W,W,_,_,W,W,_,_,_,_,_,_,_],
                    [_,_,_,W,_,_,_,_,W,_,_,_,_,_,_,_],
                    [_,_,_,W,_,_,_,_,W,_,_,_,_,_,_,_],
                    [_,_,_,W,W,_,_,W,W,_,_,_,_,_,_,_],
                    [_,_,_,_,W,W,W,W,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,W,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,W,_,W,W,W,_,_,_,_],
                    [_,_,_,_,_,_,_,W,W,W,_,W,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,W,W,W,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,W,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,W,W,W,W,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                ],
            };

            const data = iconData[type];
            if (!data) return;

            for (let y = 0; y < 16; y++) {
                for (let x = 0; x < 16; x++) {
                    const color = data[y][x];
                    if (color) {
                        ctx.fillStyle = color;
                        ctx.fillRect(x, y, 1, 1);
                    }
                }
            }
        }

        function init() {
            drawPixelIcons();
            loadPalette('pico8');
            initCanvas(32, 32);
            setupEventListeners();
            updateUI();
            loadAutoSave();
        }

        function initCanvas(width, height) {
            state.canvasWidth = width;
            state.canvasHeight = height;

            mainCanvas.width = width;
            mainCanvas.height = height;
            gridCanvas.width = width;
            gridCanvas.height = height;
            previewCanvas.width = width;
            previewCanvas.height = height;
            selectionCanvas.width = width;
            selectionCanvas.height = height;

            ctx.imageSmoothingEnabled = false;
            gridCtx.imageSmoothingEnabled = false;
            previewCtx.imageSmoothingEnabled = false;
            selCtx.imageSmoothingEnabled = false;

            // Clear canvas to transparent
            ctx.clearRect(0, 0, width, height);

            // Clear selection
            clearSelection();

            updateCanvasSize();
            drawGrid();
            saveState();
        }

        function updateCanvasSize() {
            const displayWidth = state.canvasWidth * state.zoom;
            const displayHeight = state.canvasHeight * state.zoom;

            mainCanvas.style.width = displayWidth + 'px';
            mainCanvas.style.height = displayHeight + 'px';
            gridCanvas.style.width = displayWidth + 'px';
            gridCanvas.style.height = displayHeight + 'px';
            previewCanvas.style.width = displayWidth + 'px';
            previewCanvas.style.height = displayHeight + 'px';
            selectionCanvas.style.width = displayWidth + 'px';
            selectionCanvas.style.height = displayHeight + 'px';

            canvasWrapper.style.transform = `translate(${state.panX}px, ${state.panY}px)`;

            document.getElementById('zoomIndicator').textContent = state.zoom + 'x';
            document.getElementById('statusZoom').textContent = 'Zoom: ' + state.zoom + 'x';
            document.getElementById('statusSize').textContent = `Size: ${state.canvasWidth}x${state.canvasHeight}`;
        }

        // ===== GRID =====
        function drawGrid() {
            gridCtx.clearRect(0, 0, state.canvasWidth, state.canvasHeight);

            if (!state.showGrid || state.zoom < 4) return;

            gridCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            gridCtx.lineWidth = 1 / state.zoom;

            for (let x = 0; x <= state.canvasWidth; x++) {
                gridCtx.beginPath();
                gridCtx.moveTo(x, 0);
                gridCtx.lineTo(x, state.canvasHeight);
                gridCtx.stroke();
            }

            for (let y = 0; y <= state.canvasHeight; y++) {
                gridCtx.beginPath();
                gridCtx.moveTo(0, y);
                gridCtx.lineTo(state.canvasWidth, y);
                gridCtx.stroke();
            }
        }

        // ===== PALETTE =====
        function loadPalette(name) {
            state.palette = [...PALETTES[name]];
            state.currentColor = state.palette[0];
            renderPalette();
        }

        function renderPalette() {
            const grid = document.getElementById('paletteGrid');
            const mobile = document.getElementById('mobilePalette');

            grid.innerHTML = '';
            mobile.innerHTML = '';

            state.palette.forEach((color, i) => {
                // Desktop
                const div = document.createElement('div');
                div.className = 'palette-color' + (color === state.currentColor ? ' active' : '');
                div.style.background = color;
                div.onclick = () => selectColor(color);
                grid.appendChild(div);

                // Mobile
                const mDiv = document.createElement('div');
                mDiv.className = 'mobile-palette-color' + (color === state.currentColor ? ' active' : '');
                mDiv.style.background = color;
                mDiv.onclick = () => selectColor(color);
                mobile.appendChild(mDiv);
            });

            updateCurrentColor();
        }

        function selectColor(color) {
            state.currentColor = color;
            renderPalette();
        }

        function updateCurrentColor() {
            document.getElementById('currentColor').style.background = state.currentColor;
            document.getElementById('mobileCurrentColor').style.background = state.currentColor;
        }

        // ===== TOOLS =====
        function setTool(tool) {
            state.currentTool = tool;
            state.lineStartPoint = null;
            state.pickingForReplace = false;
            clearPreview();

            // Hide eraser cursor when switching tools
            document.getElementById('eraserCursor').style.display = 'none';

            // Update UI
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tool === tool);
            });
            document.getElementById('statusTool').textContent = 'Tool: ' + tool.charAt(0).toUpperCase() + tool.slice(1);

            // Show replace color modal if needed
            if (tool === 'replace') {
                document.getElementById('replaceColorModal').classList.add('active');
            }
        }

        // ===== DRAWING =====
        function setPixel(x, y, color) {
            if (x < 0 || x >= state.canvasWidth || y < 0 || y >= state.canvasHeight) return;

            if (color === null || color === 'transparent') {
                ctx.clearRect(x, y, 1, 1);
            } else {
                ctx.fillStyle = color;
                ctx.fillRect(x, y, 1, 1);
            }
        }

        function setBrushPixel(cx, cy, color) {
            // Draw a square brush centered on cx, cy
            const size = state.brushSize;
            const offset = Math.floor(size / 2);
            for (let dy = 0; dy < size; dy++) {
                for (let dx = 0; dx < size; dx++) {
                    setPixel(cx - offset + dx, cy - offset + dy, color);
                }
            }
        }

        function getPixel(x, y) {
            if (x < 0 || x >= state.canvasWidth || y < 0 || y >= state.canvasHeight) return null;
            const data = ctx.getImageData(x, y, 1, 1).data;
            if (data[3] === 0) return null;
            return '#' + [data[0], data[1], data[2]].map(v => v.toString(16).padStart(2, '0')).join('');
        }

        function bresenhamLine(x0, y0, x1, y1, callback) {
            x0 = Math.floor(x0);
            y0 = Math.floor(y0);
            x1 = Math.floor(x1);
            y1 = Math.floor(y1);

            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = x0 < x1 ? 1 : -1;
            const sy = y0 < y1 ? 1 : -1;
            let err = dx - dy;

            while (true) {
                callback(x0, y0);
                if (x0 === x1 && y0 === y1) break;
                const e2 = 2 * err;
                if (e2 > -dy) { err -= dy; x0 += sx; }
                if (e2 < dx) { err += dx; y0 += sy; }
            }
        }

        function bresenhamEllipse(cx, cy, rx, ry, callback) {
            // Split ellipse: right +1, bottom +1 to create 2-pixel wide/tall center
            let x = 0, y = ry;
            let d1 = (ry * ry) - (rx * rx * ry) + (0.25 * rx * rx);
            let dx = 2 * ry * ry * x;
            let dy = 2 * rx * rx * y;

            while (dx < dy) {
                // 4 quadrants: right+1, bottom+1
                callback(cx + x + 1, cy + y + 1);  // bottom-right
                callback(cx - x, cy + y + 1);       // bottom-left
                callback(cx + x + 1, cy - y);       // top-right
                callback(cx - x, cy - y);           // top-left

                if (d1 < 0) {
                    x++;
                    dx += 2 * ry * ry;
                    d1 += dx + ry * ry;
                } else {
                    x++;
                    y--;
                    dx += 2 * ry * ry;
                    dy -= 2 * rx * rx;
                    d1 += dx - dy + ry * ry;
                }
            }

            let d2 = ((ry * ry) * ((x + 0.5) * (x + 0.5))) +
                     ((rx * rx) * ((y - 1) * (y - 1))) -
                     (rx * rx * ry * ry);

            while (y >= 0) {
                // 4 quadrants: right+1, bottom+1
                callback(cx + x + 1, cy + y + 1);  // bottom-right
                callback(cx - x, cy + y + 1);       // bottom-left
                callback(cx + x + 1, cy - y);       // top-right
                callback(cx - x, cy - y);           // top-left

                if (d2 > 0) {
                    y--;
                    dy -= 2 * rx * rx;
                    d2 += rx * rx - dy;
                } else {
                    y--;
                    x++;
                    dx += 2 * ry * ry;
                    dy -= 2 * rx * rx;
                    d2 += dx - dy + rx * rx;
                }
            }
        }

        function floodFill(startX, startY, fillColor) {
            startX = Math.floor(startX);
            startY = Math.floor(startY);

            const imageData = ctx.getImageData(0, 0, state.canvasWidth, state.canvasHeight);
            const data = imageData.data;
            const targetColor = getColorAt(data, startX, startY);
            const fillRgba = hexToRgba(fillColor);

            if (colorsMatch(targetColor, fillRgba)) return;

            const stack = [[startX, startY]];
            const visited = new Set();

            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const key = x + ',' + y;

                if (visited.has(key)) continue;
                if (x < 0 || x >= state.canvasWidth || y < 0 || y >= state.canvasHeight) continue;

                const currentColor = getColorAt(data, x, y);
                if (!colorsMatch(currentColor, targetColor)) continue;

                visited.add(key);
                setColorAt(data, x, y, fillRgba);

                stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function getColorAt(data, x, y) {
            const i = (y * state.canvasWidth + x) * 4;
            return [data[i], data[i + 1], data[i + 2], data[i + 3]];
        }

        function setColorAt(data, x, y, rgba) {
            const i = (y * state.canvasWidth + x) * 4;
            data[i] = rgba[0];
            data[i + 1] = rgba[1];
            data[i + 2] = rgba[2];
            data[i + 3] = rgba[3];
        }

        function colorsMatch(c1, c2) {
            return c1[0] === c2[0] && c1[1] === c2[1] && c1[2] === c2[2] && c1[3] === c2[3];
        }

        function hexToRgba(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return [r, g, b, 255];
        }

        function replaceColor(fromColor, toColor) {
            const imageData = ctx.getImageData(0, 0, state.canvasWidth, state.canvasHeight);
            const data = imageData.data;
            const fromRgba = hexToRgba(fromColor);
            const toRgba = hexToRgba(toColor);

            for (let i = 0; i < data.length; i += 4) {
                if (data[i] === fromRgba[0] && data[i + 1] === fromRgba[1] &&
                    data[i + 2] === fromRgba[2] && data[i + 3] === 255) {
                    data[i] = toRgba[0];
                    data[i + 1] = toRgba[1];
                    data[i + 2] = toRgba[2];
                    data[i + 3] = toRgba[3];
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // ===== PREVIEW LAYER =====
        function clearPreview() {
            previewCtx.clearRect(0, 0, state.canvasWidth, state.canvasHeight);
        }

        function drawBrushPreview(cx, cy) {
            clearPreview();
            const size = state.brushSize;
            const offset = Math.floor(size / 2);

            // Draw semi-transparent preview of brush area
            previewCtx.fillStyle = state.currentTool === 'eraser'
                ? 'rgba(255, 100, 100, 0.4)'
                : 'rgba(255, 255, 255, 0.4)';

            for (let dy = 0; dy < size; dy++) {
                for (let dx = 0; dx < size; dx++) {
                    const px = cx - offset + dx;
                    const py = cy - offset + dy;
                    if (px >= 0 && px < state.canvasWidth && py >= 0 && py < state.canvasHeight) {
                        previewCtx.fillRect(px, py, 1, 1);
                    }
                }
            }

            // Draw outline
            previewCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            previewCtx.lineWidth = 1 / state.zoom;
            previewCtx.strokeRect(
                cx - offset + 0.5 / state.zoom,
                cy - offset + 0.5 / state.zoom,
                size - 1 / state.zoom,
                size - 1 / state.zoom
            );
        }

        function drawPreviewLine(x0, y0, x1, y1, color) {
            clearPreview();
            previewCtx.fillStyle = color;
            bresenhamLine(x0, y0, x1, y1, (x, y) => {
                previewCtx.fillRect(x, y, 1, 1);
            });
        }

        function drawPreviewRect(x0, y0, x1, y1, color) {
            clearPreview();
            previewCtx.fillStyle = color;

            const minX = Math.min(x0, x1);
            const maxX = Math.max(x0, x1);
            const minY = Math.min(y0, y1);
            const maxY = Math.max(y0, y1);

            for (let x = minX; x <= maxX; x++) {
                previewCtx.fillRect(x, minY, 1, 1);
                previewCtx.fillRect(x, maxY, 1, 1);
            }
            for (let y = minY; y <= maxY; y++) {
                previewCtx.fillRect(minX, y, 1, 1);
                previewCtx.fillRect(maxX, y, 1, 1);
            }
        }

        function drawPreviewEllipse(x0, y0, x1, y1, color) {
            clearPreview();
            previewCtx.fillStyle = color;

            const cx = Math.floor((x0 + x1) / 2);
            const cy = Math.floor((y0 + y1) / 2);
            const rx = Math.floor(Math.abs(x1 - x0) / 2);
            const ry = Math.floor(Math.abs(y1 - y0) / 2);

            if (rx === 0 || ry === 0) {
                bresenhamLine(x0, y0, x1, y1, (x, y) => previewCtx.fillRect(x, y, 1, 1));
            } else {
                bresenhamEllipse(cx, cy, rx, ry, (x, y) => {
                    if (x >= 0 && x < state.canvasWidth && y >= 0 && y < state.canvasHeight) {
                        previewCtx.fillRect(x, y, 1, 1);
                    }
                });
            }
        }

        // ===== EVENT HANDLING =====
        function setupEventListeners() {
            // Tool buttons
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.onclick = () => setTool(btn.dataset.tool);
            });

            // Canvas events
            canvasContainer.addEventListener('mousedown', handlePointerStart);
            canvasContainer.addEventListener('mousemove', handlePointerMove);
            canvasContainer.addEventListener('mouseup', handlePointerEnd);
            canvasContainer.addEventListener('mouseleave', handlePointerEnd);
            canvasContainer.addEventListener('wheel', handleWheel, { passive: false });

            canvasContainer.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvasContainer.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvasContainer.addEventListener('touchend', handleTouchEnd, { passive: false });

            // Top bar actions
            document.getElementById('undoBtn').onclick = undo;
            document.getElementById('redoBtn').onclick = redo;
            document.getElementById('gridBtn').onclick = toggleGrid;
            document.getElementById('saveBtn').onclick = exportPNG;
            document.getElementById('menuBtn').onclick = () => document.getElementById('menuModal').classList.add('active');

            // Menu modal
            document.getElementById('closeMenuBtn').onclick = () => document.getElementById('menuModal').classList.remove('active');
            document.getElementById('newCanvasBtn').onclick = () => {
                document.getElementById('menuModal').classList.remove('active');
                document.getElementById('newCanvasModal').classList.add('active');
            };
            document.getElementById('exportPngBtn').onclick = () => {
                document.getElementById('menuModal').classList.remove('active');
                exportPNG();
            };
            document.getElementById('paletteGenMenuBtn').onclick = () => {
                document.getElementById('menuModal').classList.remove('active');
                showPaletteGenerator();
            };

            // New canvas modal
            document.getElementById('cancelNewCanvas').onclick = () => document.getElementById('newCanvasModal').classList.remove('active');
            document.getElementById('createNewCanvas').onclick = createNewCanvas;
            document.getElementById('sizePreset').onchange = (e) => {
                if (e.target.value) {
                    document.getElementById('newWidth').value = e.target.value;
                    document.getElementById('newHeight').value = e.target.value;
                }
            };

            // Replace color modal
            document.getElementById('cancelReplace').onclick = () => {
                document.getElementById('replaceColorModal').classList.remove('active');
                state.pickingForReplace = false;
                document.getElementById('pickFromBtn').classList.remove('active');
                setTool('pencil');
            };
            document.getElementById('doReplace').onclick = () => {
                const from = document.getElementById('replaceFromInput').value;
                const to = document.getElementById('replaceToInput').value;
                saveState();
                replaceColor(from, to);
                saveState();
                document.getElementById('replaceColorModal').classList.remove('active');
                state.pickingForReplace = false;
                setTool('pencil');
                showToast('Colors replaced!');
            };
            document.getElementById('replaceFromInput').oninput = (e) => {
                document.getElementById('replaceFromColor').style.background = e.target.value;
            };
            document.getElementById('replaceToInput').oninput = (e) => {
                document.getElementById('replaceToColor').style.background = e.target.value;
            };
            document.getElementById('pickFromBtn').onclick = () => {
                state.pickingForReplace = true;
                document.getElementById('pickFromBtn').classList.add('active');
                document.getElementById('replaceColorModal').classList.remove('active');
                showToast('Tap a color on the canvas');
            };
            document.getElementById('useCurrentBtn').onclick = () => {
                document.getElementById('replaceToInput').value = state.currentColor;
                document.getElementById('replaceToColor').style.background = state.currentColor;
            };

            // Palette generator modal
            document.getElementById('paletteGenBtn').onclick = showPaletteGenerator;
            document.getElementById('cancelPaletteGen').onclick = () => {
                document.getElementById('paletteGenModal').classList.remove('active');
                state.selectedColors.clear();
            };
            document.getElementById('applyPalette').onclick = applyGeneratedPalette;
            document.getElementById('baseColor').oninput = updatePalettePreview;
            document.getElementById('harmonyType').onchange = updatePalettePreview;
            document.getElementById('rampSize').oninput = (e) => {
                document.getElementById('rampSizeVal').textContent = e.target.value;
                state.selectedColors.clear(); // Reset selection when changing size
                updatePalettePreview();
            };
            document.getElementById('hueShift').oninput = (e) => {
                document.getElementById('hueShiftVal').textContent = e.target.value;
                updatePalettePreview();
            };
            document.getElementById('selectAllColors').onclick = selectAllColors;
            document.getElementById('deselectAllColors').onclick = deselectAllColors;
            document.getElementById('invertSelection').onclick = invertColorSelection;

            // Palette select
            document.getElementById('paletteSelect').onchange = (e) => loadPalette(e.target.value);

            // Brush size selects
            document.getElementById('brushSizeSelect').onchange = (e) => {
                state.brushSize = parseInt(e.target.value);
                document.getElementById('mobileBrushSize').value = e.target.value;
            };
            document.getElementById('mobileBrushSize').onchange = (e) => {
                state.brushSize = parseInt(e.target.value);
                document.getElementById('brushSizeSelect').value = e.target.value;
            };

            // Keyboard shortcuts
            document.addEventListener('keydown', handleKeyDown);

            // Window resize
            window.addEventListener('resize', updateCanvasSize);

            // Selection toolbar buttons - use event delegation for reliability
            document.getElementById('selectionToolbar').addEventListener('click', (e) => {
                const btn = e.target.closest('.sel-action');
                if (btn && btn.dataset.action) {
                    e.preventDefault();
                    e.stopPropagation();
                    selectionAction(btn.dataset.action);
                }
            });
            // Also handle touch for mobile
            document.getElementById('selectionToolbar').addEventListener('touchend', (e) => {
                const btn = e.target.closest('.sel-action');
                if (btn && btn.dataset.action) {
                    e.preventDefault();
                    e.stopPropagation();
                    selectionAction(btn.dataset.action);
                }
            });
        }

        function getCanvasCoords(e) {
            const rect = mainCanvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / state.zoom);
            const y = Math.floor((e.clientY - rect.top) / state.zoom);
            return { x, y };
        }

        function handlePointerStart(e) {
            if (e.button !== 0) return; // Only left click

            const { x, y } = getCanvasCoords(e);
            state.isDrawing = true;

            handleToolStart(x, y);
        }

        function handlePointerMove(e) {
            const { x, y } = getCanvasCoords(e);

            // Update status
            document.getElementById('statusPos').textContent = `Pos: ${x}, ${y}`;

            // Update eraser cursor
            updateEraserCursor(e, x, y);

            if (!state.isDrawing) {
                // Preview for shape tools
                if (state.lineStartPoint && ['line', 'rect', 'ellipse'].includes(state.currentTool)) {
                    const start = state.lineStartPoint;
                    if (state.currentTool === 'line') {
                        drawPreviewLine(start.x, start.y, x, y, state.currentColor);
                    } else if (state.currentTool === 'rect') {
                        drawPreviewRect(start.x, start.y, x, y, state.currentColor);
                    } else if (state.currentTool === 'ellipse') {
                        drawPreviewEllipse(start.x, start.y, x, y, state.currentColor);
                    }
                } else if (['pencil', 'eraser'].includes(state.currentTool)) {
                    // Show brush preview
                    drawBrushPreview(x, y);
                } else {
                    clearPreview();
                }
                return;
            }

            handleToolMove(x, y);
        }

        function updateEraserCursor(e, gridX, gridY) {
            const cursor = document.getElementById('eraserCursor');
            if (state.currentTool !== 'eraser') {
                cursor.style.display = 'none';
                return;
            }

            cursor.style.display = 'block';
            cursor.style.width = state.zoom + 'px';
            cursor.style.height = state.zoom + 'px';
            cursor.style.left = (gridX * state.zoom) + 'px';
            cursor.style.top = (gridY * state.zoom) + 'px';
        }

        function handlePointerEnd(e) {
            // Clear brush preview when leaving canvas
            clearPreview();

            if (!state.isDrawing) return;
            state.isDrawing = false;

            const { x, y } = getCanvasCoords(e);
            handleToolEnd(x, y);
        }

        // Touch handling
        let touchState = {
            touches: [],
            isPinching: false,
            lastPinchDist: 0,
            lastPinchCenter: null,
            longPressTimer: null,
            longPressTriggered: false
        };

        function handleTouchStart(e) {
            e.preventDefault();

            // Clear any existing long press timer
            if (touchState.longPressTimer) {
                clearTimeout(touchState.longPressTimer);
                touchState.longPressTimer = null;
            }
            touchState.longPressTriggered = false;

            if (e.touches.length === 2) {
                // Start pinch zoom
                touchState.isPinching = true;
                const dist = getTouchDistance(e.touches[0], e.touches[1]);
                touchState.lastPinchDist = dist;
                touchState.lastPinchCenter = getTouchCenter(e.touches[0], e.touches[1]);
                state.isDrawing = false;
                return;
            }

            if (e.touches.length === 1) {
                const touch = e.touches[0];
                const { x, y } = getCanvasCoords(touch);

                // Start long press timer for paste
                touchState.longPressTimer = setTimeout(() => {
                    if (state.clipboard) {
                        touchState.longPressTriggered = true;
                        state.isDrawing = false;
                        pasteClipboard();
                    }
                }, 500);

                state.isDrawing = true;
                handleToolStart(x, y);
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();

            // Cancel long press on any movement
            if (touchState.longPressTimer) {
                clearTimeout(touchState.longPressTimer);
                touchState.longPressTimer = null;
            }

            if (e.touches.length === 2 && touchState.isPinching) {
                // Pinch zoom
                const dist = getTouchDistance(e.touches[0], e.touches[1]);
                const center = getTouchCenter(e.touches[0], e.touches[1]);

                const scale = dist / touchState.lastPinchDist;
                let newZoom = Math.round(state.zoom * scale);
                newZoom = Math.max(1, Math.min(32, newZoom));

                if (newZoom !== state.zoom) {
                    state.zoom = newZoom;
                    updateCanvasSize();
                    drawGrid();
                }

                // Pan
                if (touchState.lastPinchCenter) {
                    const dx = center.x - touchState.lastPinchCenter.x;
                    const dy = center.y - touchState.lastPinchCenter.y;
                    state.panX += dx;
                    state.panY += dy;
                    updateCanvasSize();
                }

                touchState.lastPinchDist = dist;
                touchState.lastPinchCenter = center;
                return;
            }

            if (e.touches.length === 1 && state.isDrawing) {
                const touch = e.touches[0];
                const { x, y } = getCanvasCoords(touch);
                document.getElementById('statusPos').textContent = `Pos: ${x}, ${y}`;
                handleToolMove(x, y);
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();

            // Clear long press timer
            if (touchState.longPressTimer) {
                clearTimeout(touchState.longPressTimer);
                touchState.longPressTimer = null;
            }

            if (e.touches.length === 0) {
                touchState.isPinching = false;

                // Skip normal handling if long press was triggered
                if (touchState.longPressTriggered) {
                    touchState.longPressTriggered = false;
                    state.isDrawing = false;
                    return;
                }

                if (state.isDrawing) {
                    state.isDrawing = false;
                    // Use last known position
                    handleToolEnd(state.lastX, state.lastY);
                }
            }
        }

        function getTouchDistance(t1, t2) {
            const dx = t2.clientX - t1.clientX;
            const dy = t2.clientY - t1.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function getTouchCenter(t1, t2) {
            return {
                x: (t1.clientX + t2.clientX) / 2,
                y: (t1.clientY + t2.clientY) / 2
            };
        }

        function handleWheel(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? -1 : 1;
            let newZoom = state.zoom + delta;
            newZoom = Math.max(1, Math.min(32, newZoom));

            if (newZoom !== state.zoom) {
                state.zoom = newZoom;
                updateCanvasSize();
                drawGrid();
            }
        }

        // ===== TOOL HANDLING =====
        function handleToolStart(x, y) {
            // Handle picking for replace color
            if (state.pickingForReplace) {
                const color = getPixel(x, y);
                if (color) {
                    document.getElementById('replaceFromInput').value = color;
                    document.getElementById('replaceFromColor').style.background = color;
                    showToast('Picked: ' + color);
                } else {
                    showToast('No color at that pixel');
                }
                state.pickingForReplace = false;
                document.getElementById('pickFromBtn').classList.remove('active');
                document.getElementById('replaceColorModal').classList.add('active');
                return;
            }

            state.lastX = x;
            state.lastY = y;

            switch (state.currentTool) {
                case 'pencil':
                    saveState();
                    setBrushPixel(x, y, state.currentColor);
                    break;
                case 'eraser':
                    saveState();
                    setBrushPixel(x, y, null);
                    break;
                case 'line':
                case 'rect':
                case 'ellipse':
                    if (!state.lineStartPoint) {
                        // First tap - set start point
                        state.lineStartPoint = { x, y };
                        showToast('Tap to set end point, or drag');
                    } else {
                        // Second tap - draw shape
                        saveState();
                        drawShape(state.lineStartPoint.x, state.lineStartPoint.y, x, y);
                        state.lineStartPoint = null;
                        clearPreview();
                    }
                    break;
                case 'fill':
                    saveState();
                    floodFill(x, y, state.currentColor);
                    break;
                case 'eyedropper':
                    const color = getPixel(x, y);
                    if (color) {
                        selectColor(color);
                        showToast('Color: ' + color);
                    }
                    break;
                case 'select':
                    // If we have a floating selection, start dragging it
                    if (state.selection.floating) {
                        state.dragStartX = x;
                        state.dragStartY = y;
                        break;
                    }
                    // If there's an active selection, just deselect on tap
                    if (state.selection.active) {
                        clearSelection();
                        break;
                    }
                    // Two-tap selection like line tool
                    if (!state.lineStartPoint) {
                        state.lineStartPoint = { x, y };
                        showToast('Tap to set opposite corner, or drag');
                    } else {
                        setRectangularSelection(state.lineStartPoint.x, state.lineStartPoint.y, x, y);
                        state.lineStartPoint = null;
                        clearPreview();
                    }
                    break;
                case 'lasso':
                    // If we have a floating selection, commit it first
                    if (state.selection.floating) {
                        commitFloatingSelection();
                    }
                    // Start new lasso
                    clearSelection();
                    state.lassoStart = { x, y };
                    state.lassoPixels = [{ x, y }];
                    // Mark starting pixel
                    showLassoStart(x, y);
                    break;
            }
        }

        function handleToolMove(x, y) {
            if (x === state.lastX && y === state.lastY) return;

            switch (state.currentTool) {
                case 'pencil':
                    bresenhamLine(state.lastX, state.lastY, x, y, (px, py) => {
                        setBrushPixel(px, py, state.currentColor);
                    });
                    break;
                case 'eraser':
                    bresenhamLine(state.lastX, state.lastY, x, y, (px, py) => {
                        setBrushPixel(px, py, null);
                    });
                    break;
                case 'line':
                    if (state.lineStartPoint) {
                        drawPreviewLine(state.lineStartPoint.x, state.lineStartPoint.y, x, y, state.currentColor);
                    }
                    break;
                case 'rect':
                    if (state.lineStartPoint) {
                        drawPreviewRect(state.lineStartPoint.x, state.lineStartPoint.y, x, y, state.currentColor);
                    }
                    break;
                case 'ellipse':
                    if (state.lineStartPoint) {
                        drawPreviewEllipse(state.lineStartPoint.x, state.lineStartPoint.y, x, y, state.currentColor);
                    }
                    break;
                case 'select':
                    // Preview selection rectangle
                    if (state.lineStartPoint) {
                        drawPreviewSelection(state.lineStartPoint.x, state.lineStartPoint.y, x, y);
                    }
                    // Handle floating selection movement
                    if (state.selection.floating) {
                        const dx = x - state.lastX;
                        const dy = y - state.lastY;
                        moveFloatingSelection(dx, dy);
                    }
                    break;
                case 'lasso':
                    // Add pixel to lasso path using Bresenham for smooth line
                    if (state.lassoStart) {
                        bresenhamLine(state.lastX, state.lastY, x, y, (px, py) => {
                            // Only add if within canvas and not duplicate
                            if (px >= 0 && px < state.canvasWidth && py >= 0 && py < state.canvasHeight) {
                                const last = state.lassoPixels[state.lassoPixels.length - 1];
                                if (!last || last.x !== px || last.y !== py) {
                                    state.lassoPixels.push({ x: px, y: py });
                                }
                            }
                        });
                        drawLassoPreview();
                    }
                    break;
            }

            state.lastX = x;
            state.lastY = y;
        }

        function handleToolEnd(x, y) {
            // For drag-based shape tools
            if (['line', 'rect', 'ellipse'].includes(state.currentTool) && state.lineStartPoint) {
                // If we dragged (start != end), draw the shape
                if (state.lineStartPoint.x !== x || state.lineStartPoint.y !== y) {
                    saveState();
                    drawShape(state.lineStartPoint.x, state.lineStartPoint.y, x, y);
                    state.lineStartPoint = null;
                    clearPreview();
                }
            }

            // For select tool drag (new selection)
            if (state.currentTool === 'select' && state.lineStartPoint) {
                if (state.lineStartPoint.x !== x || state.lineStartPoint.y !== y) {
                    setRectangularSelection(state.lineStartPoint.x, state.lineStartPoint.y, x, y);
                    state.lineStartPoint = null;
                    clearPreview();
                }
            }

            // For floating selection - commit on mouse/touch up
            if (state.currentTool === 'select' && state.selection.floating) {
                commitFloatingSelection();
            }

            // For lasso tool
            if (state.currentTool === 'lasso' && state.lassoStart && state.lassoPixels.length > 2) {
                // Check if we're close enough to the start to close the loop
                const start = state.lassoStart;
                const dist = Math.sqrt((x - start.x) ** 2 + (y - start.y) ** 2);

                // Only close if returning to start point
                if (dist <= 6) {
                    setLassoSelection(state.lassoPixels);
                } else {
                    showToast('Return to green start');
                }

                // Clear lasso state
                state.lassoStart = null;
                state.lassoPixels = [];
                hideLassoStart();
                clearPreview();
            }

            autoSave();
        }

        function drawShape(x0, y0, x1, y1) {
            switch (state.currentTool) {
                case 'line':
                    bresenhamLine(x0, y0, x1, y1, (x, y) => setPixel(x, y, state.currentColor));
                    break;
                case 'rect':
                    const minX = Math.min(x0, x1);
                    const maxX = Math.max(x0, x1);
                    const minY = Math.min(y0, y1);
                    const maxY = Math.max(y0, y1);

                    for (let x = minX; x <= maxX; x++) {
                        setPixel(x, minY, state.currentColor);
                        setPixel(x, maxY, state.currentColor);
                    }
                    for (let y = minY; y <= maxY; y++) {
                        setPixel(minX, y, state.currentColor);
                        setPixel(maxX, y, state.currentColor);
                    }
                    break;
                case 'ellipse':
                    const cx = Math.floor((x0 + x1) / 2);
                    const cy = Math.floor((y0 + y1) / 2);
                    const rx = Math.floor(Math.abs(x1 - x0) / 2);
                    const ry = Math.floor(Math.abs(y1 - y0) / 2);

                    if (rx === 0 || ry === 0) {
                        bresenhamLine(x0, y0, x1, y1, (x, y) => setPixel(x, y, state.currentColor));
                    } else {
                        bresenhamEllipse(cx, cy, rx, ry, (x, y) => setPixel(x, y, state.currentColor));
                    }
                    break;
            }
        }

        // ===== KEYBOARD SHORTCUTS =====
        function handleKeyDown(e) {
            // Ignore if typing in input
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

            const key = e.key.toLowerCase();

            if (e.ctrlKey || e.metaKey) {
                switch (key) {
                    case 'z':
                        e.preventDefault();
                        if (e.shiftKey) redo();
                        else undo();
                        break;
                    case 'y':
                        e.preventDefault();
                        redo();
                        break;
                    case 's':
                        e.preventDefault();
                        exportPNG();
                        break;
                    case 'a':
                        e.preventDefault();
                        selectAll();
                        break;
                    case 'c':
                        e.preventDefault();
                        if (state.selection.active) selectionAction('copy');
                        break;
                    case 'x':
                        e.preventDefault();
                        if (state.selection.active) selectionAction('cut');
                        break;
                    case 'v':
                        e.preventDefault();
                        pasteClipboard();
                        break;
                    case 'd':
                        e.preventDefault();
                        clearSelection();
                        break;
                }
                return;
            }

            switch (key) {
                case 'p': setTool('pencil'); break;
                case 'e': setTool('eraser'); break;
                case 'l': setTool('line'); break;
                case 'r': setTool('rect'); break;
                case 'o': setTool('ellipse'); break;
                case 'f': setTool('fill'); break;
                case 'i': setTool('eyedropper'); break;
                case 'c': setTool('replace'); break;
                case 's': setTool('select'); break;
                case 'q': setTool('lasso'); break;
                case 'g': toggleGrid(); break;
                case '=':
                case '+':
                    state.zoom = Math.min(32, state.zoom + 1);
                    updateCanvasSize();
                    drawGrid();
                    break;
                case '-':
                    state.zoom = Math.max(1, state.zoom - 1);
                    updateCanvasSize();
                    drawGrid();
                    break;
                case 'escape':
                    state.lineStartPoint = null;
                    state.lassoStart = null;
                    state.lassoPixels = [];
                    hideLassoStart();
                    clearPreview();
                    if (state.selection.floating) {
                        commitFloatingSelection();
                    }
                    break;
                case 'delete':
                case 'backspace':
                    if (state.selection.active) {
                        e.preventDefault();
                        selectionAction('delete');
                    }
                    break;
            }
        }

        // ===== UNDO/REDO =====
        function saveState() {
            const imageData = ctx.getImageData(0, 0, state.canvasWidth, state.canvasHeight);
            state.undoStack.push(imageData);
            if (state.undoStack.length > state.maxHistory) {
                state.undoStack.shift();
            }
            state.redoStack = [];
            updateUndoRedoButtons();
        }

        function undo() {
            if (state.undoStack.length <= 1) return;

            const currentState = state.undoStack.pop();
            state.redoStack.push(currentState);

            const prevState = state.undoStack[state.undoStack.length - 1];
            ctx.putImageData(prevState, 0, 0);

            updateUndoRedoButtons();
            autoSave();
        }

        function redo() {
            if (state.redoStack.length === 0) return;

            const nextState = state.redoStack.pop();
            state.undoStack.push(nextState);
            ctx.putImageData(nextState, 0, 0);

            updateUndoRedoButtons();
            autoSave();
        }

        function updateUndoRedoButtons() {
            document.getElementById('undoBtn').disabled = state.undoStack.length <= 1;
            document.getElementById('redoBtn').disabled = state.redoStack.length === 0;
        }

        // ===== GRID TOGGLE =====
        function toggleGrid() {
            state.showGrid = !state.showGrid;
            drawGrid();
            document.getElementById('gridBtn').style.color = state.showGrid ? 'var(--accent)' : 'var(--text)';
        }

        // ===== FILE OPERATIONS =====
        function exportPNG() {
            mainCanvas.toBlob(async (blob) => {
                // Try Web Share API first (mobile-friendly)
                if (navigator.share && navigator.canShare) {
                    try {
                        const file = new File([blob], 'pixel-art.png', { type: 'image/png' });
                        if (navigator.canShare({ files: [file] })) {
                            await navigator.share({
                                files: [file],
                                title: 'Pixel Art'
                            });
                            showToast('Shared!');
                            return;
                        }
                    } catch (e) {
                        // Share cancelled or failed, fall through
                    }
                }

                // Fallback: open in new tab (long-press to save on mobile)
                const url = URL.createObjectURL(blob);
                const win = window.open(url, '_blank');
                if (!win) {
                    // Popup blocked, try direct download
                    const link = document.createElement('a');
                    link.download = 'pixel-art.png';
                    link.href = url;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                }
                showToast('PNG ready!');
                setTimeout(() => URL.revokeObjectURL(url), 60000);
            }, 'image/png');
        }

        function createNewCanvas() {
            const width = parseInt(document.getElementById('newWidth').value) || 32;
            const height = parseInt(document.getElementById('newHeight').value) || 32;

            state.undoStack = [];
            state.redoStack = [];
            initCanvas(width, height);

            document.getElementById('newCanvasModal').classList.remove('active');
            showToast(`Created ${width}x${height} canvas`);
        }

        function autoSave() {
            try {
                const data = {
                    width: state.canvasWidth,
                    height: state.canvasHeight,
                    image: mainCanvas.toDataURL(),
                    palette: state.palette,
                    zoom: state.zoom
                };
                localStorage.setItem('pixelArtAutoSave', JSON.stringify(data));
            } catch (e) {
                console.warn('AutoSave failed:', e);
            }
        }

        function loadAutoSave() {
            try {
                const saved = localStorage.getItem('pixelArtAutoSave');
                if (saved) {
                    const data = JSON.parse(saved);
                    state.canvasWidth = data.width;
                    state.canvasHeight = data.height;
                    state.zoom = data.zoom || 8;
                    if (data.palette) state.palette = data.palette;

                    mainCanvas.width = data.width;
                    mainCanvas.height = data.height;
                    gridCanvas.width = data.width;
                    gridCanvas.height = data.height;
                    previewCanvas.width = data.width;
                    previewCanvas.height = data.height;
                    selectionCanvas.width = data.width;
                    selectionCanvas.height = data.height;

                    // Re-set imageSmoothingEnabled after canvas resize (it resets)
                    ctx.imageSmoothingEnabled = false;
                    gridCtx.imageSmoothingEnabled = false;
                    previewCtx.imageSmoothingEnabled = false;
                    selCtx.imageSmoothingEnabled = false;

                    const img = new Image();
                    img.onload = () => {
                        ctx.imageSmoothingEnabled = false;
                        ctx.drawImage(img, 0, 0);
                        updateCanvasSize();
                        drawGrid();
                        renderPalette();
                        saveState();
                    };
                    img.src = data.image;
                }
            } catch (e) {
                console.warn('Load autosave failed:', e);
            }
        }

        // ===== PALETTE GENERATOR =====
        function showPaletteGenerator() {
            document.getElementById('paletteGenModal').classList.add('active');
            updatePalettePreview();
        }

        function updatePalettePreview() {
            const baseColor = document.getElementById('baseColor').value;
            const harmonyType = document.getElementById('harmonyType').value;
            const rampSize = parseInt(document.getElementById('rampSize').value);
            const hueShift = parseInt(document.getElementById('hueShift').value);

            const palette = generatePalette(baseColor, harmonyType, rampSize, hueShift);
            const oldLength = state.generatedPalette.length;
            state.generatedPalette = palette;
            state.paletteRampSize = rampSize;
            state.paletteNumRamps = palette.length / rampSize;

            // Reset selection if palette size changed (deselected by default)
            if (oldLength !== palette.length) {
                state.selectedColors.clear();
            }

            const preview = document.getElementById('palettePreview');
            preview.innerHTML = '';

            const numRamps = palette.length / rampSize;

            // Column selectors
            const colSelectors = document.createElement('div');
            colSelectors.className = 'palette-gen-col-selectors';
            for (let c = 0; c < rampSize; c++) {
                const colBtn = document.createElement('button');
                colBtn.className = 'palette-gen-col-select';
                colBtn.textContent = '‚Üï';
                colBtn.title = `Toggle column ${c + 1}`;
                colBtn.onclick = () => toggleColumn(c, rampSize, numRamps);
                colSelectors.appendChild(colBtn);
            }
            preview.appendChild(colSelectors);

            // Rows with row selectors
            for (let r = 0; r < numRamps; r++) {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'palette-gen-row';

                // Row selector button
                const rowBtn = document.createElement('button');
                rowBtn.className = 'palette-gen-row-select';
                rowBtn.textContent = '‚Üî';
                rowBtn.title = `Toggle row ${r + 1}`;
                rowBtn.onclick = () => toggleRow(r, rampSize);
                rowDiv.appendChild(rowBtn);

                // Colors in row
                const colorsDiv = document.createElement('div');
                colorsDiv.className = 'palette-gen-colors';

                for (let i = 0; i < rampSize; i++) {
                    const idx = r * rampSize + i;
                    const colorDiv = document.createElement('div');
                    colorDiv.className = 'palette-gen-color';
                    colorDiv.style.background = palette[idx];
                    colorDiv.dataset.idx = idx;

                    if (state.selectedColors.has(idx)) {
                        colorDiv.classList.add('selected');
                    } else {
                        colorDiv.classList.add('deselected');
                    }

                    colorDiv.onclick = () => toggleColorSelection(idx);
                    colorsDiv.appendChild(colorDiv);
                }

                rowDiv.appendChild(colorsDiv);
                preview.appendChild(rowDiv);
            }
        }

        function toggleColorSelection(idx) {
            if (state.selectedColors.has(idx)) {
                state.selectedColors.delete(idx);
            } else {
                state.selectedColors.add(idx);
            }
            updateColorSelectionUI();
        }

        function toggleRow(rowIdx, rampSize) {
            const startIdx = rowIdx * rampSize;
            const rowIndices = [];
            for (let i = 0; i < rampSize; i++) {
                rowIndices.push(startIdx + i);
            }

            // Check if all in row are selected
            const allSelected = rowIndices.every(idx => state.selectedColors.has(idx));

            if (allSelected) {
                // Deselect all in row
                rowIndices.forEach(idx => state.selectedColors.delete(idx));
            } else {
                // Select all in row
                rowIndices.forEach(idx => state.selectedColors.add(idx));
            }
            updateColorSelectionUI();
        }

        function toggleColumn(colIdx, rampSize, numRamps) {
            const colIndices = [];
            for (let r = 0; r < numRamps; r++) {
                colIndices.push(r * rampSize + colIdx);
            }

            // Check if all in column are selected
            const allSelected = colIndices.every(idx => state.selectedColors.has(idx));

            if (allSelected) {
                // Deselect all in column
                colIndices.forEach(idx => state.selectedColors.delete(idx));
            } else {
                // Select all in column
                colIndices.forEach(idx => state.selectedColors.add(idx));
            }
            updateColorSelectionUI();
        }

        function updateColorSelectionUI() {
            document.querySelectorAll('.palette-gen-color').forEach(div => {
                const idx = parseInt(div.dataset.idx);
                if (state.selectedColors.has(idx)) {
                    div.classList.add('selected');
                    div.classList.remove('deselected');
                } else {
                    div.classList.remove('selected');
                    div.classList.add('deselected');
                }
            });
        }

        function selectAllColors() {
            state.selectedColors = new Set(state.generatedPalette.map((_, i) => i));
            updateColorSelectionUI();
        }

        function deselectAllColors() {
            state.selectedColors.clear();
            updateColorSelectionUI();
        }

        function invertColorSelection() {
            const newSelection = new Set();
            state.generatedPalette.forEach((_, i) => {
                if (!state.selectedColors.has(i)) {
                    newSelection.add(i);
                }
            });
            state.selectedColors = newSelection;
            updateColorSelectionUI();
        }

        function generatePalette(baseHex, harmonyType, rampSize, hueShift) {
            const baseHsl = hexToHsl(baseHex);
            const palette = [];

            // Get harmony hues
            const hues = getHarmonyHues(baseHsl.h, harmonyType);

            // Generate ramp for each hue
            hues.forEach(hue => {
                const ramp = generateColorRamp(hue, baseHsl.s, rampSize, hueShift);
                palette.push(...ramp);
            });

            return palette;
        }

        function getHarmonyHues(baseHue, type) {
            switch (type) {
                case 'monochromatic': return [baseHue];
                case 'complementary': return [baseHue, (baseHue + 180) % 360];
                case 'analogous': return [(baseHue - 30 + 360) % 360, baseHue, (baseHue + 30) % 360];
                case 'triadic': return [baseHue, (baseHue + 120) % 360, (baseHue + 240) % 360];
                case 'splitcomp': return [baseHue, (baseHue + 150) % 360, (baseHue + 210) % 360];
                case 'tetradic': return [baseHue, (baseHue + 90) % 360, (baseHue + 180) % 360, (baseHue + 270) % 360];
                default: return [baseHue];
            }
        }

        function generateColorRamp(baseHue, baseSat, size, hueShiftAmount) {
            const ramp = [];
            const midpoint = Math.floor(size / 2);

            for (let i = 0; i < size; i++) {
                const t = i / (size - 1); // 0 to 1
                const distFromMid = (i - midpoint) / midpoint; // -1 to 1

                // Hue shifts: toward blue (240) for shadows, toward yellow (60) for highlights
                let hueOffset = distFromMid * hueShiftAmount;
                if (distFromMid < 0) {
                    // Shadow - shift toward blue
                    hueOffset = distFromMid * hueShiftAmount * 2;
                } else {
                    // Highlight - shift toward yellow
                    hueOffset = distFromMid * hueShiftAmount;
                }

                const hue = (baseHue + hueOffset + 360) % 360;

                // Saturation: peaks in middle, lower at extremes
                const satFactor = 1 - Math.abs(distFromMid) * 0.5;
                const sat = Math.min(100, baseSat * satFactor);

                // Lightness: dark to light
                const lightness = 15 + t * 70;

                ramp.push(hslToHex(hue, sat, lightness));
            }

            return ramp;
        }

        function applyGeneratedPalette() {
            // Only apply selected colors
            const selectedPalette = [];
            state.generatedPalette.forEach((color, idx) => {
                if (state.selectedColors.has(idx)) {
                    selectedPalette.push(color);
                }
            });

            if (selectedPalette.length === 0) {
                showToast('No colors selected!');
                return;
            }

            state.palette = selectedPalette;
            state.currentColor = state.palette[0];
            renderPalette();

            document.getElementById('paletteSelect').value = 'custom';
            document.getElementById('paletteGenModal').classList.remove('active');
            showToast(`Applied ${selectedPalette.length} colors!`);

            // Reset selection for next time
            state.selectedColors.clear();
        }

        // ===== SELECTION FUNCTIONS =====
        function selectAll() {
            // Select entire canvas
            state.selection.pixels.clear();
            for (let y = 0; y < state.canvasHeight; y++) {
                for (let x = 0; x < state.canvasWidth; x++) {
                    state.selection.pixels.add(`${x},${y}`);
                }
            }
            state.selection.bounds = {x: 0, y: 0, width: state.canvasWidth, height: state.canvasHeight};
            state.selection.active = true;
            drawSelection();
            showSelectionToolbar();
            showToast('All selected');
        }

        function clearSelection() {
            state.selection.active = false;
            state.selection.pixels.clear();
            state.selection.bounds = null;
            state.selection.floating = false;
            state.selection.floatingData = null;
            state.selection.floatingOffset = {x: 0, y: 0};
            state.lassoPixels = [];
            state.lassoStart = null;
            selCtx.clearRect(0, 0, state.canvasWidth, state.canvasHeight);
            document.getElementById('selectionToolbar').style.display = 'none';
            // Remove lasso start indicator if exists
            const indicator = document.querySelector('.lasso-start');
            if (indicator) indicator.remove();
        }

        function setRectangularSelection(x1, y1, x2, y2) {
            const minX = Math.max(0, Math.min(x1, x2));
            const maxX = Math.min(state.canvasWidth - 1, Math.max(x1, x2));
            const minY = Math.max(0, Math.min(y1, y2));
            const maxY = Math.min(state.canvasHeight - 1, Math.max(y1, y2));

            state.selection.pixels.clear();
            for (let y = minY; y <= maxY; y++) {
                for (let x = minX; x <= maxX; x++) {
                    state.selection.pixels.add(`${x},${y}`);
                }
            }

            state.selection.bounds = {
                x: minX,
                y: minY,
                width: maxX - minX + 1,
                height: maxY - minY + 1
            };
            state.selection.active = true;
            drawSelection();
            showSelectionToolbar();
        }

        function setLassoSelection(boundaryPixels) {
            // Use inverse flood fill to find interior
            const width = state.canvasWidth;
            const height = state.canvasHeight;

            // Create temp bitmap: 0=unknown, 1=boundary, 2=outside
            const bitmap = new Uint8Array(width * height);

            // Mark boundary pixels
            const boundarySet = new Set();
            boundaryPixels.forEach(p => {
                if (p.x >= 0 && p.x < width && p.y >= 0 && p.y < height) {
                    bitmap[p.y * width + p.x] = 1;
                    boundarySet.add(`${p.x},${p.y}`);
                }
            });

            // Flood fill from edges to find "outside"
            const stack = [];
            // Add all edge pixels that aren't boundary
            for (let x = 0; x < width; x++) {
                if (bitmap[x] === 0) stack.push({x, y: 0});
                if (bitmap[(height-1) * width + x] === 0) stack.push({x, y: height-1});
            }
            for (let y = 0; y < height; y++) {
                if (bitmap[y * width] === 0) stack.push({x: 0, y});
                if (bitmap[y * width + width - 1] === 0) stack.push({x: width-1, y});
            }

            while (stack.length > 0) {
                const {x, y} = stack.pop();
                if (x < 0 || x >= width || y < 0 || y >= height) continue;
                const idx = y * width + x;
                if (bitmap[idx] !== 0) continue;
                bitmap[idx] = 2; // outside
                stack.push({x: x+1, y}, {x: x-1, y}, {x, y: y+1}, {x, y: y-1});
            }

            // Everything not outside and not boundary is inside
            state.selection.pixels.clear();
            let minX = width, minY = height, maxX = 0, maxY = 0;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    if (bitmap[idx] !== 2) { // boundary or inside
                        state.selection.pixels.add(`${x},${y}`);
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                    }
                }
            }

            if (state.selection.pixels.size > 0) {
                state.selection.bounds = {
                    x: minX,
                    y: minY,
                    width: maxX - minX + 1,
                    height: maxY - minY + 1
                };
                state.selection.active = true;
                drawSelection();
                showSelectionToolbar();
            } else {
                clearSelection();
                showToast('Selection too small');
            }
        }

        function drawSelection() {
            selCtx.clearRect(0, 0, state.canvasWidth, state.canvasHeight);
            if (!state.selection.active) return;

            // Draw selection with marching ants pattern
            const animOffset = Math.floor(Date.now() / 200) % 4;

            state.selection.pixels.forEach(key => {
                const [x, y] = key.split(',').map(Number);

                // Check if this pixel is on the edge of selection
                const neighbors = [
                    `${x-1},${y}`, `${x+1},${y}`, `${x},${y-1}`, `${x},${y+1}`
                ];

                const isEdge = neighbors.some(n => !state.selection.pixels.has(n));

                if (isEdge) {
                    // Draw dashed border effect
                    const patternPos = (x + y + animOffset) % 4;
                    selCtx.fillStyle = patternPos < 2 ? 'rgba(255,255,255,0.8)' : 'rgba(0,0,0,0.8)';
                    selCtx.fillRect(x, y, 1, 1);
                } else {
                    // Light tint for interior
                    selCtx.fillStyle = 'rgba(100,150,255,0.2)';
                    selCtx.fillRect(x, y, 1, 1);
                }
            });

            // Draw floating content if exists
            if (state.selection.floating && state.selection.floatingData) {
                const offX = state.selection.floatingOffset.x;
                const offY = state.selection.floatingOffset.y;
                // Draw on preview canvas instead
                previewCtx.clearRect(0, 0, state.canvasWidth, state.canvasHeight);
                previewCtx.putImageData(state.selection.floatingData,
                    state.selection.bounds.x + offX,
                    state.selection.bounds.y + offY);
            }
        }

        // Animate selection marching ants
        let selectionAnimFrame;
        function animateSelection() {
            if (state.selection.active) {
                drawSelection();
            }
            selectionAnimFrame = requestAnimationFrame(animateSelection);
        }

        function showSelectionToolbar() {
            document.getElementById('selectionToolbar').style.display = 'flex';
        }

        function hideSelectionToolbar() {
            document.getElementById('selectionToolbar').style.display = 'none';
        }

        function selectionAction(action) {
            if (!state.selection.active) return;

            const bounds = state.selection.bounds;

            switch (action) {
                case 'copy':
                case 'cut':
                    // Create masked clipboard with only selected pixels
                    const copySrc = ctx.getImageData(bounds.x, bounds.y, bounds.width, bounds.height);
                    const copyMasked = new ImageData(bounds.width, bounds.height);
                    state.selection.pixels.forEach(key => {
                        const [px, py] = key.split(',').map(Number);
                        const lx = px - bounds.x;
                        const ly = py - bounds.y;
                        if (lx >= 0 && lx < bounds.width && ly >= 0 && ly < bounds.height) {
                            const idx = (ly * bounds.width + lx) * 4;
                            copyMasked.data[idx] = copySrc.data[idx];
                            copyMasked.data[idx + 1] = copySrc.data[idx + 1];
                            copyMasked.data[idx + 2] = copySrc.data[idx + 2];
                            copyMasked.data[idx + 3] = copySrc.data[idx + 3];
                        }
                    });
                    state.clipboard = copyMasked;

                    if (action === 'cut') {
                        saveState();
                        state.selection.pixels.forEach(key => {
                            const [x, y] = key.split(',').map(Number);
                            ctx.clearRect(x, y, 1, 1);
                        });
                        showToast('Cut!');
                    } else {
                        showToast('Copied!');
                    }
                    clearSelection();
                    break;

                case 'delete':
                    saveState();
                    state.selection.pixels.forEach(key => {
                        const [x, y] = key.split(',').map(Number);
                        ctx.clearRect(x, y, 1, 1);
                    });
                    showToast('Deleted!');
                    clearSelection();
                    break;

                case 'fliph':
                    flipSelection(true, false);
                    break;

                case 'flipv':
                    flipSelection(false, true);
                    break;

                case 'deselect':
                    clearSelection();
                    break;

                case 'move':
                    // Lift the pixels for moving
                    saveState();
                    state.selection.floating = true;
                    state.selection.floatingOffset = {x: 0, y: 0};

                    // Create masked ImageData with only selected pixels
                    const srcData = ctx.getImageData(bounds.x, bounds.y, bounds.width, bounds.height);
                    const maskedData = new ImageData(bounds.width, bounds.height);

                    // Only copy pixels that are in the selection
                    state.selection.pixels.forEach(key => {
                        const [px, py] = key.split(',').map(Number);
                        const localX = px - bounds.x;
                        const localY = py - bounds.y;
                        if (localX >= 0 && localX < bounds.width && localY >= 0 && localY < bounds.height) {
                            const idx = (localY * bounds.width + localX) * 4;
                            maskedData.data[idx] = srcData.data[idx];
                            maskedData.data[idx + 1] = srcData.data[idx + 1];
                            maskedData.data[idx + 2] = srcData.data[idx + 2];
                            maskedData.data[idx + 3] = srcData.data[idx + 3];
                        }
                    });

                    state.selection.floatingData = maskedData;

                    // Clear only selected pixels from canvas
                    state.selection.pixels.forEach(key => {
                        const [x, y] = key.split(',').map(Number);
                        ctx.clearRect(x, y, 1, 1);
                    });

                    // Draw floating selection on preview
                    previewCtx.putImageData(state.selection.floatingData, bounds.x, bounds.y);
                    // Switch to select tool for dragging
                    setTool('select');
                    showToast('Drag on canvas to move');
                    break;
            }
        }

        function flipSelection(horizontal, vertical) {
            if (!state.selection.active || !state.selection.bounds) return;

            const bounds = state.selection.bounds;
            saveState();

            // Get source image data
            const srcData = ctx.getImageData(bounds.x, bounds.y, bounds.width, bounds.height);

            // Create array to store flipped pixel data
            const flippedPixels = [];

            // For each selected pixel, calculate flipped position and store color
            state.selection.pixels.forEach(key => {
                const [px, py] = key.split(',').map(Number);
                const lx = px - bounds.x;
                const ly = py - bounds.y;

                // Get source color
                const srcIdx = (ly * bounds.width + lx) * 4;
                const r = srcData.data[srcIdx];
                const g = srcData.data[srcIdx + 1];
                const b = srcData.data[srcIdx + 2];
                const a = srcData.data[srcIdx + 3];

                // Calculate flipped position
                const newLx = horizontal ? (bounds.width - 1 - lx) : lx;
                const newLy = vertical ? (bounds.height - 1 - ly) : ly;
                const newPx = bounds.x + newLx;
                const newPy = bounds.y + newLy;

                flippedPixels.push({ox: px, oy: py, nx: newPx, ny: newPy, r, g, b, a});
            });

            // Clear original selected pixels
            state.selection.pixels.forEach(key => {
                const [x, y] = key.split(',').map(Number);
                ctx.clearRect(x, y, 1, 1);
            });

            // Draw flipped pixels and update selection set
            state.selection.pixels.clear();
            flippedPixels.forEach(p => {
                if (p.a > 0) {
                    ctx.fillStyle = `rgba(${p.r},${p.g},${p.b},${p.a/255})`;
                    ctx.fillRect(p.nx, p.ny, 1, 1);
                }
                state.selection.pixels.add(`${p.nx},${p.ny}`);
            });

            drawSelection();
            showToast(horizontal ? 'Flipped H!' : 'Flipped V!');
        }

        function pasteClipboard() {
            if (!state.clipboard) {
                showToast('Nothing to paste');
                return;
            }

            // Commit any existing floating selection first
            if (state.selection.floating) {
                commitFloatingSelection();
            }

            // Paste at center as floating selection (moveable)
            const x = Math.floor((state.canvasWidth - state.clipboard.width) / 2);
            const y = Math.floor((state.canvasHeight - state.clipboard.height) / 2);

            // Set up as floating selection
            state.selection.pixels.clear();
            for (let py = 0; py < state.clipboard.height; py++) {
                for (let px = 0; px < state.clipboard.width; px++) {
                    // Only add pixels that have alpha > 0
                    const idx = (py * state.clipboard.width + px) * 4;
                    if (state.clipboard.data[idx + 3] > 0) {
                        state.selection.pixels.add(`${x + px},${y + py}`);
                    }
                }
            }
            state.selection.bounds = {x, y, width: state.clipboard.width, height: state.clipboard.height};
            state.selection.active = true;
            state.selection.floating = true;
            state.selection.floatingData = state.clipboard;
            state.selection.floatingOffset = {x: 0, y: 0};

            // Draw on preview canvas (not main canvas yet)
            previewCtx.putImageData(state.clipboard, x, y);

            // Switch to select tool for dragging
            setTool('select');
            showSelectionToolbar();
            showToast('Drag to position, tap to place');
        }

        function commitFloatingSelection() {
            if (!state.selection.floating || !state.selection.floatingData) return;

            const bounds = state.selection.bounds;
            const offX = state.selection.floatingOffset.x;
            const offY = state.selection.floatingOffset.y;

            saveState();
            ctx.putImageData(state.selection.floatingData, bounds.x + offX, bounds.y + offY);
            previewCtx.clearRect(0, 0, state.canvasWidth, state.canvasHeight);
            clearSelection();
        }

        // ===== SELECTION HELPER FUNCTIONS =====
        function drawPreviewSelection(x0, y0, x1, y1) {
            previewCtx.clearRect(0, 0, state.canvasWidth, state.canvasHeight);
            const minX = Math.min(x0, x1);
            const maxX = Math.max(x0, x1);
            const minY = Math.min(y0, y1);
            const maxY = Math.max(y0, y1);

            // Draw dashed rectangle preview
            previewCtx.setLineDash([1, 1]);
            previewCtx.strokeStyle = '#fff';
            previewCtx.lineWidth = 1 / state.zoom;
            previewCtx.strokeRect(minX + 0.5, minY + 0.5, maxX - minX, maxY - minY);
            previewCtx.strokeStyle = '#000';
            previewCtx.lineDashOffset = 1;
            previewCtx.strokeRect(minX + 0.5, minY + 0.5, maxX - minX, maxY - minY);
            previewCtx.setLineDash([]);
            previewCtx.lineDashOffset = 0;
        }

        function showLassoStart(x, y) {
            // Show a visual indicator at the lasso start point
            hideLassoStart();
            const indicator = document.createElement('div');
            indicator.className = 'lasso-start';
            const rect = mainCanvas.getBoundingClientRect();
            indicator.style.left = (rect.left + x * state.zoom + state.zoom / 2) + 'px';
            indicator.style.top = (rect.top + y * state.zoom + state.zoom / 2) + 'px';
            document.body.appendChild(indicator);
        }

        function hideLassoStart() {
            const indicator = document.querySelector('.lasso-start');
            if (indicator) indicator.remove();
        }

        function drawLassoPreview() {
            previewCtx.clearRect(0, 0, state.canvasWidth, state.canvasHeight);
            if (state.lassoPixels.length < 2) return;

            // Draw the lasso path with alternating black/white
            state.lassoPixels.forEach((p, i) => {
                previewCtx.fillStyle = i % 2 === 0 ? 'rgba(0, 0, 0, 0.6)' : 'rgba(255, 255, 255, 0.6)';
                previewCtx.fillRect(p.x, p.y, 1, 1);
            });
        }

        function moveFloatingSelection(dx, dy) {
            if (!state.selection.floating || !state.selection.floatingData) return;

            state.selection.floatingOffset.x += dx;
            state.selection.floatingOffset.y += dy;

            // Draw on preview canvas
            previewCtx.clearRect(0, 0, state.canvasWidth, state.canvasHeight);
            previewCtx.putImageData(
                state.selection.floatingData,
                state.selection.bounds.x + state.selection.floatingOffset.x,
                state.selection.bounds.y + state.selection.floatingOffset.y
            );
        }

        // Start marching ants animation
        animateSelection();

        // ===== COLOR UTILITIES =====
        function hexToHsl(hex) {
            let r = parseInt(hex.slice(1, 3), 16) / 255;
            let g = parseInt(hex.slice(3, 5), 16) / 255;
            let b = parseInt(hex.slice(5, 7), 16) / 255;

            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }

            return { h: h * 360, s: s * 100, l: l * 100 };
        }

        function hslToHex(h, s, l) {
            s /= 100;
            l /= 100;

            const c = (1 - Math.abs(2 * l - 1)) * s;
            const x = c * (1 - Math.abs((h / 60) % 2 - 1));
            const m = l - c / 2;
            let r = 0, g = 0, b = 0;

            if (0 <= h && h < 60) { r = c; g = x; b = 0; }
            else if (60 <= h && h < 120) { r = x; g = c; b = 0; }
            else if (120 <= h && h < 180) { r = 0; g = c; b = x; }
            else if (180 <= h && h < 240) { r = 0; g = x; b = c; }
            else if (240 <= h && h < 300) { r = x; g = 0; b = c; }
            else if (300 <= h && h < 360) { r = c; g = 0; b = x; }

            r = Math.round((r + m) * 255);
            g = Math.round((g + m) * 255);
            b = Math.round((b + m) * 255);

            return '#' + [r, g, b].map(v => v.toString(16).padStart(2, '0')).join('');
        }

        // ===== UI HELPERS =====
        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 2000);
        }

        function updateUI() {
            updateUndoRedoButtons();
            document.getElementById('gridBtn').style.color = state.showGrid ? 'var(--accent)' : 'var(--text)';
        }

        // ===== START =====
        init();
    </script>
</body>
</html>
