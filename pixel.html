<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <!-- SEO Meta Tags -->
    <title>Free Pixel Art Editor - No Ads, No Login | LOCOMOT.IO</title>
    <meta name="description" content="Create pixel art for free with our powerful browser-based editor. No ads, no login required. Perfect for game sprites, icons, and retro art. Works on desktop and mobile.">
    <meta name="keywords" content="pixel art, pixel editor, free sprite editor, pixel art maker, game sprites, retro art, no ads, no login, free pixel art tool, browser pixel editor">
    <meta name="author" content="locomot.io">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://locomot.io/pixel.html">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://locomot.io/pixel.html">
    <meta property="og:title" content="Free Pixel Art Editor - No Ads, No Login">
    <meta property="og:description" content="Create pixel art for free. No ads, no login. Perfect for game sprites and retro art. Works on desktop and mobile.">
    <meta property="og:image" content="https://locomot.io/pixel-og.png">
    <meta property="og:site_name" content="LOCOMOT.IO">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://locomot.io/pixel.html">
    <meta name="twitter:title" content="Free Pixel Art Editor - No Ads, No Login">
    <meta name="twitter:description" content="Create pixel art for free. No ads, no login. Works on desktop and mobile.">
    <meta name="twitter:image" content="https://locomot.io/pixel-og.png">

    <!-- Additional SEO -->
    <meta name="theme-color" content="#1a1a2e">
    <meta name="application-name" content="Pixel Art Studio">

    <!-- Structured Data for SEO -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "Free Pixel Art Editor",
        "url": "https://locomot.io/pixel.html",
        "applicationCategory": "DesignApplication",
        "operatingSystem": "Web Browser",
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD"
        },
        "description": "Create pixel art for free with our powerful browser-based editor. No ads, no login required. Perfect for game sprites, icons, and retro art.",
        "featureList": [
            "No login required",
            "No advertisements",
            "Mobile and desktop support",
            "Multiple drawing tools",
            "Color palette generator",
            "Selection tools with lasso",
            "Export to PNG"
        ]
    }
    </script>
    <!-- Supabase SDK -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-dark: #1a1a2e;
            --bg-medium: #16213e;
            --bg-light: #0f3460;
            --accent: #e94560;
            --text: #eaeaea;
            --text-dim: #888;
            --tool-size: 44px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-dark);
            color: var(--text);
            height: 100vh;
            height: 100dvh; /* Dynamic viewport - accounts for mobile browser UI */
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Top Bar */
        .top-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            background: var(--bg-medium);
            border-bottom: 1px solid var(--bg-light);
            min-height: 48px;
        }

        .top-bar-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .menu-btn {
            width: var(--tool-size);
            height: var(--tool-size);
            background: var(--bg-light);
            border: none;
            border-radius: 8px;
            color: var(--text);
            font-size: 20px;
            cursor: pointer;
        }

        .menu-btn:active {
            background: var(--accent);
        }

        .project-name {
            font-size: 16px;
            font-weight: 500;
        }

        .top-bar-right {
            display: flex;
            gap: 4px;
        }

        .action-btn {
            width: 40px;
            height: 40px;
            background: transparent;
            border: none;
            border-radius: 8px;
            color: var(--text);
            font-size: 18px;
            cursor: pointer;
        }

        .action-btn:active {
            background: var(--bg-light);
        }

        .action-btn:disabled {
            opacity: 0.3;
        }

        .auth-btn {
            padding: 6px 12px;
            background: var(--accent);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 12px;
            cursor: pointer;
            white-space: nowrap;
        }

        .auth-btn:hover {
            opacity: 0.9;
        }

        .auth-btn.signed-in {
            background: var(--bg-light);
            color: var(--text);
        }

        .sync-status {
            display: none;
            align-items: center;
            padding: 0 8px;
            font-size: 16px;
        }

        .sync-status.visible {
            display: flex;
        }

        .sync-icon {
            opacity: 0.5;
        }

        .sync-status.syncing .sync-icon {
            animation: pulse 1s infinite;
            opacity: 1;
        }

        .sync-status.synced .sync-icon {
            color: #4ade80;
            opacity: 1;
        }

        .sync-status.error .sync-icon {
            color: var(--accent);
            opacity: 1;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        /* Main Canvas Area */
        .canvas-area {
            flex: 1;
            display: flex;
            overflow: hidden;
            position: relative;
        }

        /* Desktop Side Tools */
        .side-tools {
            display: none;
            flex-direction: column;
            padding: 8px;
            background: var(--bg-medium);
            border-right: 1px solid var(--bg-light);
            gap: 4px;
        }

        @media (min-width: 768px) {
            .side-tools {
                display: flex;
            }
        }

        .tool-btn {
            width: var(--tool-size);
            height: var(--tool-size);
            background: var(--bg-light);
            border: 2px solid transparent;
            border-radius: 8px;
            color: var(--text);
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tool-btn:hover {
            background: var(--accent);
        }

        .tool-btn.active {
            border-color: var(--accent);
            background: var(--accent);
        }

        .tool-btn.active:hover {
            background: var(--accent);
        }

        /* Canvas Container */
        .canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #111;
            overflow: hidden;
            position: relative;
            touch-action: none;
        }

        .canvas-wrapper {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        #mainCanvas {
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            background: repeating-conic-gradient(#333 0% 25%, #444 0% 50%) 50% / 16px 16px;
        }

        #gridCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            image-rendering: pixelated;
        }

        #previewCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            image-rendering: pixelated;
        }

        /* Desktop Side Palette */
        .side-palette {
            display: none;
            flex-direction: column;
            width: 180px;
            padding: 8px;
            background: var(--bg-medium);
            border-left: 1px solid var(--bg-light);
        }

        @media (min-width: 768px) {
            .side-palette {
                display: flex;
            }
        }

        .palette-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .palette-header h3 {
            font-size: 14px;
            color: var(--text-dim);
        }

        .palette-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 4px;
            margin-bottom: 12px;
        }

        .palette-color {
            aspect-ratio: 1;
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: pointer;
        }

        .palette-color:hover {
            transform: scale(1.1);
        }

        .palette-color.active {
            border-color: white;
        }

        .current-colors {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .current-color {
            width: 48px;
            height: 48px;
            border-radius: 8px;
            border: 2px solid var(--text-dim);
            cursor: pointer;
            transition: transform 0.1s, border-color 0.1s;
        }

        .current-color:hover {
            transform: scale(1.05);
            border-color: var(--accent);
        }

        /* Dither gradient color picker */
        .dither-colors {
            margin-bottom: 12px;
            padding: 8px;
            background: var(--bg-light);
            border-radius: 8px;
        }

        .dither-label {
            font-size: 12px;
            color: var(--text-dim);
            margin-bottom: 8px;
        }

        .dither-slots {
            display: flex;
            gap: 8px;
            justify-content: center;
        }

        .dither-slot {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            padding: 4px;
            border-radius: 6px;
            border: 2px solid transparent;
        }

        .dither-slot.active {
            border-color: var(--accent);
        }

        .dither-slot:hover {
            background: var(--bg-medium);
        }

        .dither-swatch {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            border: 1px solid var(--text-dim);
            background-image: linear-gradient(45deg, #666 25%, transparent 25%),
                              linear-gradient(-45deg, #666 25%, transparent 25%),
                              linear-gradient(45deg, transparent 75%, #666 75%),
                              linear-gradient(-45deg, transparent 75%, #666 75%);
            background-size: 8px 8px;
            background-position: 0 0, 0 4px, 4px -4px, -4px 0px;
        }

        .dither-slot span {
            font-size: 10px;
            color: var(--text-dim);
        }

        .dither-hint {
            font-size: 10px;
            color: var(--text-dim);
            text-align: center;
            margin-top: 6px;
        }

        .dither-patterns {
            margin-top: 10px;
            padding-top: 8px;
            border-top: 1px solid var(--bg-light);
        }

        .dither-pattern-label {
            font-size: 10px;
            color: var(--text-dim);
            margin-bottom: 6px;
        }

        .dither-pattern-btns {
            display: flex;
            gap: 6px;
            justify-content: center;
        }

        .dither-pattern-btn {
            width: 32px;
            height: 32px;
            border: 2px solid var(--bg-light);
            border-radius: 6px;
            background: var(--bg-dark);
            color: var(--text-main);
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .dither-pattern-btn:hover {
            border-color: var(--text-dim);
        }

        .dither-pattern-btn.active {
            border-color: var(--accent);
            background: var(--accent);
        }

        /* Bottom Bar (Mobile) */
        .bottom-bar {
            display: flex;
            flex-direction: column;
            background: var(--bg-medium);
            border-top: 1px solid var(--bg-light);
        }

        @media (min-width: 768px) {
            .bottom-bar {
                flex-direction: row;
                justify-content: space-between;
                align-items: center;
                padding: 8px 12px;
            }
        }

        .color-row {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            gap: 8px;
            touch-action: pan-x;
        }

        @media (min-width: 768px) {
            .color-row {
                display: none;
            }
        }

        .mobile-current-color {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: 2px solid var(--text-dim);
            flex-shrink: 0;
            cursor: pointer;
            transition: transform 0.1s, border-color 0.1s;
        }

        .mobile-current-color:active {
            transform: scale(0.95);
            border-color: var(--accent);
        }

        .mobile-palette {
            display: flex;
            gap: 4px;
            flex-wrap: nowrap;
            overflow-x: scroll;
            overflow-y: hidden;
            flex: 1;
            min-width: 0;
            touch-action: pan-x;
            -webkit-overflow-scrolling: touch;
            overscroll-behavior-x: contain;
            scroll-behavior: smooth;
        }

        .mobile-palette-color {
            width: 36px;
            height: 36px;
            border-radius: 6px;
            border: 2px solid transparent;
            flex-shrink: 0;
            touch-action: pan-x;
        }

        .mobile-palette-color.active {
            border-color: white;
        }

        .mobile-tools {
            display: flex;
            padding: 8px;
            gap: 4px;
            overflow-x: auto;
            justify-content: center;
            touch-action: pan-x;
        }

        @media (min-width: 768px) {
            .mobile-tools {
                display: none;
            }
        }

        /* Status Bar (Desktop) */
        .status-bar {
            display: none;
            font-size: 12px;
            color: var(--text-dim);
            gap: 16px;
        }

        @media (min-width: 768px) {
            .status-bar {
                display: flex;
            }
        }

        /* Modals */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 100;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: var(--bg-medium);
            border-radius: 12px;
            padding: 20px;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
        }

        .modal h2 {
            margin-bottom: 16px;
        }

        .modal-buttons {
            display: flex;
            gap: 8px;
            margin-top: 16px;
            justify-content: flex-end;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
        }

        .btn-primary {
            background: var(--accent);
            color: white;
        }

        .btn-secondary {
            background: var(--bg-light);
            color: var(--text);
        }

        /* Form controls */
        .form-group {
            margin-bottom: 12px;
        }

        .form-group label {
            display: block;
            margin-bottom: 4px;
            font-size: 14px;
            color: var(--text-dim);
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--bg-light);
            border-radius: 6px;
            background: var(--bg-dark);
            color: var(--text);
            font-size: 14px;
        }

        /* Line tool indicator */
        .line-indicator {
            position: absolute;
            width: 12px;
            height: 12px;
            border: 2px solid var(--accent);
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.5; transform: translate(-50%, -50%) scale(1.2); }
        }

        /* Toast notifications */
        .toast {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-light);
            color: var(--text);
            padding: 12px 20px;
            border-radius: 8px;
            z-index: 200;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .toast.show {
            opacity: 1;
        }

        /* Debug overlay */
        .debug-overlay {
            position: fixed;
            top: 100px;
            left: 10px;
            background: rgba(0, 0, 0, 0.85);
            color: #0f0;
            font-family: monospace;
            font-size: 11px;
            padding: 10px;
            border-radius: 4px;
            z-index: 999;
            pointer-events: none;
            white-space: pre;
            display: none;
        }

        .debug-overlay.show {
            display: block;
        }

        /* Zoom indicator */
        .zoom-indicator {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background: rgba(0,0,0,0.6);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
        }

        /* Eraser cursor */
        .eraser-cursor {
            position: absolute;
            pointer-events: none;
            border: 2px solid #ff69b4;
            background: rgba(255, 105, 180, 0.3);
            z-index: 50;
        }

        /* Replace color modal improvements */
        .color-pick-row {
            display: flex;
            gap: 12px;
            align-items: center;
            padding: 12px;
            background: var(--bg-dark);
            border-radius: 8px;
            margin-bottom: 12px;
        }

        .color-preview-large {
            width: 64px;
            height: 64px;
            border-radius: 8px;
            border: 3px solid var(--text-dim);
            flex-shrink: 0;
        }

        .color-pick-controls {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .color-pick-controls input[type="color"] {
            width: 100%;
            height: 44px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }

        .pick-from-canvas-btn {
            padding: 10px 16px;
            background: var(--bg-light);
            border: none;
            border-radius: 8px;
            color: var(--text);
            cursor: pointer;
            font-size: 14px;
        }

        .pick-from-canvas-btn:active {
            background: var(--accent);
        }

        .pick-from-canvas-btn.active {
            background: var(--accent);
        }

        /* Pixel Art Icons */
        .pixel-icon {
            width: 8px;
            height: 8px;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
        }

        .tool-btn .pixel-icon {
            width: 24px;
            height: 24px;
        }

        /* Palette Generator Selectable Colors */
        .palette-gen-grid {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .palette-gen-row {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .palette-gen-row-select {
            width: 20px;
            height: 28px;
            background: var(--bg-light);
            border: none;
            border-radius: 4px;
            color: var(--text);
            cursor: pointer;
            font-size: 10px;
            flex-shrink: 0;
        }

        .palette-gen-row-select:hover {
            background: var(--accent);
        }

        .palette-gen-colors {
            display: flex;
            gap: 2px;
        }

        .palette-gen-color {
            width: 28px;
            height: 28px;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: transform 0.1s, border-color 0.1s;
        }

        .palette-gen-color:hover {
            transform: scale(1.1);
        }

        .palette-gen-color.selected {
            border-color: white;
            box-shadow: 0 0 0 2px var(--accent);
        }

        .palette-gen-color.deselected {
            /* No visual change - white border on selected is enough */
        }

        .palette-gen-col-selectors {
            display: flex;
            gap: 2px;
            margin-left: 24px;
            margin-bottom: 8px;
        }

        .palette-gen-col-select {
            width: 28px;
            height: 16px;
            background: var(--bg-light);
            border: none;
            border-radius: 4px;
            color: var(--text);
            cursor: pointer;
            font-size: 8px;
        }

        .palette-gen-col-select:hover {
            background: var(--accent);
        }

        .palette-gen-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .palette-gen-actions button {
            flex: 1;
            padding: 8px;
            background: var(--bg-light);
            border: none;
            border-radius: 6px;
            color: var(--text);
            cursor: pointer;
            font-size: 12px;
        }

        .palette-gen-actions button:hover {
            background: var(--accent);
        }

        /* Selection Canvas */
        #selectionCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            image-rendering: pixelated;
        }

        /* Selection Action Toolbar */
        .selection-toolbar {
            position: fixed;
            bottom: 140px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
            padding: 8px;
            background: var(--bg-medium);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            z-index: 100;
        }

        @media (min-width: 768px) {
            .selection-toolbar {
                bottom: 80px;
            }
        }

        .sel-action {
            width: 40px;
            height: 40px;
            background: var(--bg-light);
            border: none;
            border-radius: 8px;
            color: var(--text);
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sel-action:hover {
            background: var(--accent);
        }

        .sel-action:active {
            transform: scale(0.95);
        }

        /* Mobile floating undo/redo */
        .mobile-undo-float {
            position: fixed;
            top: 100px;
            right: 8px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            z-index: 90;
        }

        @media (min-width: 768px) {
            .mobile-undo-float {
                display: none;
            }
        }

        .mobile-undo-float button {
            width: 44px;
            height: 44px;
            background: var(--bg-medium);
            border: 1px solid var(--bg-light);
            border-radius: 10px;
            color: var(--text);
            font-size: 20px;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .mobile-undo-float button:disabled {
            opacity: 0.3;
        }

        .mobile-undo-float button:active:not(:disabled) {
            background: var(--accent);
            transform: scale(0.95);
        }

        /* Lasso start indicator */
        .lasso-start {
            position: absolute;
            width: 8px;
            height: 8px;
            background: var(--accent);
            border: 2px solid white;
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            animation: lasso-pulse 1s infinite;
            z-index: 51;
        }

        @keyframes lasso-pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.3); opacity: 0.7; }
        }

        /* Analogous row buttons */
        .analogous-row-btn {
            display: flex;
            justify-content: center;
            gap: 8px;
            padding: 8px;
            background: var(--bg-dark);
            border-radius: 6px;
            margin: 4px 0;
        }

        .analogous-row-btn button {
            font-size: 12px;
        }

        /* Color Editor Modal */
        .color-editor-modal {
            min-width: 320px;
            max-width: 95vw;
        }

        .color-editor-preview {
            display: flex;
            gap: 16px;
            align-items: center;
            margin-bottom: 16px;
        }

        .color-editor-swatch {
            width: 80px;
            height: 80px;
            border-radius: 12px;
            border: 3px solid var(--text-dim);
            flex-shrink: 0;
        }

        .color-editor-info {
            flex: 1;
            font-family: monospace;
            font-size: 14px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .color-editor-info span {
            color: var(--text-dim);
        }

        .color-editor-info input[type="text"] {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--bg-light);
            border-radius: 6px;
            background: var(--bg-dark);
            color: var(--text);
            font-size: 16px;
            font-family: monospace;
            margin-top: 4px;
        }

        .color-sliders {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 16px;
            padding: 12px;
            background: var(--bg-dark);
            border-radius: 8px;
        }

        .slider-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .slider-label {
            width: 80px;
            font-size: 14px;
            color: var(--text-dim);
        }

        .slider-value {
            width: 50px;
            text-align: right;
            font-family: monospace;
            font-size: 14px;
        }

        .slider-row input[type="range"] {
            flex: 1;
            height: 8px;
            border-radius: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--bg-light);
        }

        .slider-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
        }

        .slider-row input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            border: none;
        }

        .hue-slider {
            background: linear-gradient(to right,
                hsl(0, 100%, 50%),
                hsl(60, 100%, 50%),
                hsl(120, 100%, 50%),
                hsl(180, 100%, 50%),
                hsl(240, 100%, 50%),
                hsl(300, 100%, 50%),
                hsl(360, 100%, 50%)) !important;
        }

        .palette-management {
            border-top: 1px solid var(--bg-light);
            padding-top: 16px;
            margin-top: 8px;
        }

        .palette-management h4 {
            font-size: 14px;
            color: var(--text-dim);
            margin-bottom: 12px;
        }

        .palette-colors-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            max-height: 120px;
            overflow-y: auto;
            padding: 8px;
            background: var(--bg-dark);
            border-radius: 8px;
            margin-bottom: 12px;
        }

        .palette-color-item {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            border: 2px solid transparent;
            cursor: pointer;
            position: relative;
        }

        .palette-color-item:hover {
            transform: scale(1.1);
        }

        .palette-color-item.selected {
            border-color: white;
        }

        .palette-color-item .remove-color {
            position: absolute;
            top: -6px;
            right: -6px;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent);
            color: white;
            font-size: 12px;
            line-height: 14px;
            text-align: center;
            display: none;
            cursor: pointer;
        }

        .palette-color-item:hover .remove-color {
            display: block;
        }

        .palette-actions {
            display: flex;
            gap: 8px;
        }

        .palette-actions button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
        }

        .add-color-btn {
            background: var(--bg-light);
            color: var(--text);
        }

        .add-color-btn:hover {
            background: var(--accent);
        }

        /* Tab Bar */
        .tab-bar {
            display: flex;
            align-items: center;
            background: var(--bg-dark);
            border-bottom: 1px solid var(--bg-light);
            padding: 4px 4px;
            min-height: 48px;
            gap: 8px;
            width: 100%;
            box-sizing: border-box;
        }

        .tabs-container {
            display: flex;
            flex-direction: row;
            flex-wrap: nowrap;
            align-items: center;
            flex: 1 1 0;
            min-width: 0;
            overflow-x: auto;
            overflow-y: hidden;
            gap: 8px;
            padding: 4px 8px;
            touch-action: pan-x;
        }

        .tabs-container::-webkit-scrollbar {
            height: 4px;
        }

        .tabs-container::-webkit-scrollbar-thumb {
            background: var(--bg-light);
            border-radius: 2px;
        }

        .tab {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 14px;
            background: var(--bg-medium);
            border: 2px solid var(--bg-light);
            border-radius: 8px 8px 0 0;
            color: var(--text-dim);
            font-size: 14px;
            cursor: pointer;
            white-space: nowrap;
            min-width: 100px;
            flex: 0 0 auto;
            box-sizing: border-box;
        }

        .tab:hover {
            background: var(--bg-light);
            border-color: var(--text-dim);
        }

        .tab.active {
            background: #9b59b6;
            border-color: #9b59b6;
            color: #ffffff;
        }

        .tab-name {
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100px;
        }

        .tab-close {
            width: 18px;
            height: 18px;
            border: none;
            background: transparent;
            color: var(--text-dim);
            font-size: 14px;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            line-height: 1;
        }

        .tab-close:hover {
            background: var(--accent);
            color: white;
        }

        .new-tab-btn {
            width: 28px;
            height: 28px;
            border: none;
            background: var(--bg-light);
            color: var(--text);
            font-size: 18px;
            cursor: pointer;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .new-tab-btn:hover {
            background: var(--accent);
        }
    </style>
</head>
<body>
    <!-- Top Bar -->
    <div class="top-bar">
        <div class="top-bar-left">
            <button class="menu-btn" id="menuBtn" title="Menu">‚ò∞</button>
            <span class="project-name" id="projectName">Untitled</span>
        </div>
        <div class="top-bar-right">
            <button class="action-btn" id="undoBtn" title="Undo (Ctrl+Z)">‚Ü©</button>
            <button class="action-btn" id="redoBtn" title="Redo (Ctrl+Y)">‚Ü™</button>
            <button class="action-btn" id="gridBtn" title="Toggle Grid (G)">‚ñ¶</button>
            <button class="action-btn" id="saveBtn" title="Export PNG">üíæ</button>
            <div class="sync-status" id="syncStatus" title="Cloud sync status">
                <span class="sync-icon" id="syncIcon">‚òÅ</span>
            </div>
            <button class="auth-btn" id="authBtn" title="Sign in to sync">
                <span class="auth-text" id="authText">Sign in</span>
            </button>
        </div>
    </div>

    <!-- Tab Bar -->
    <div class="tab-bar">
        <div class="tabs-container" id="tabsContainer"></div>
        <button class="new-tab-btn" id="newTabBtn" title="New Tab">+</button>
    </div>

    <!-- Main Canvas Area -->
    <div class="canvas-area">
        <!-- Desktop Side Tools -->
        <div class="side-tools">
            <button class="tool-btn active" data-tool="pencil" title="Pencil (P)"><canvas class="pixel-icon" data-icon="pencil"></canvas></button>
            <button class="tool-btn" data-tool="eraser" title="Eraser (E)"><canvas class="pixel-icon" data-icon="eraser"></canvas></button>
            <button class="tool-btn" data-tool="select" title="Select (M)"><canvas class="pixel-icon" data-icon="select"></canvas></button>
            <button class="tool-btn" data-tool="lasso" title="Lasso (S)"><canvas class="pixel-icon" data-icon="lasso"></canvas></button>
            <button class="tool-btn" data-tool="line" title="Line (L)"><canvas class="pixel-icon" data-icon="line"></canvas></button>
            <button class="tool-btn" data-tool="dither" title="Dither Gradient (G)"><canvas class="pixel-icon" data-icon="dither"></canvas></button>
            <button class="tool-btn" data-tool="rect" title="Rectangle (R)"><canvas class="pixel-icon" data-icon="rect"></canvas></button>
            <button class="tool-btn" data-tool="ellipse" title="Ellipse (O)"><canvas class="pixel-icon" data-icon="ellipse"></canvas></button>
            <button class="tool-btn" data-tool="fill" title="Fill Bucket (F)"><canvas class="pixel-icon" data-icon="fill"></canvas></button>
            <button class="tool-btn" data-tool="eyedropper" title="Eyedropper (I)"><canvas class="pixel-icon" data-icon="eyedropper"></canvas></button>
            <button class="tool-btn" data-tool="replace" title="Replace Color (C)"><canvas class="pixel-icon" data-icon="replace"></canvas></button>
        </div>

        <!-- Canvas Container -->
        <div class="canvas-container" id="canvasContainer">
            <div class="canvas-wrapper" id="canvasWrapper">
                <canvas id="mainCanvas"></canvas>
                <canvas id="gridCanvas"></canvas>
                <canvas id="previewCanvas"></canvas>
                <canvas id="selectionCanvas"></canvas>
                <div class="eraser-cursor" id="eraserCursor" style="display:none;"></div>
            </div>
            <div class="zoom-indicator" id="zoomIndicator">8x</div>
        </div>

        <!-- Selection Action Toolbar (outside canvas-container to avoid event capture) -->
        <div class="selection-toolbar" id="selectionToolbar" style="display:none;">
            <button class="sel-action" data-action="move" title="Move">‚úã</button>
            <button class="sel-action" data-action="copy" title="Copy">üìã</button>
            <button class="sel-action" data-action="cut" title="Cut">‚úÇÔ∏è</button>
            <button class="sel-action" data-action="delete" title="Delete">üóëÔ∏è</button>
            <button class="sel-action" data-action="fliph" title="Flip Horizontal">‚ÜîÔ∏è</button>
            <button class="sel-action" data-action="flipv" title="Flip Vertical">‚ÜïÔ∏è</button>
            <button class="sel-action" data-action="deselect" title="Deselect">‚úñÔ∏è</button>
        </div>

        <!-- Mobile Floating Undo/Redo -->
        <div class="mobile-undo-float">
            <button id="mobileUndoBtn" title="Undo">‚Ü©</button>
            <button id="mobileRedoBtn" title="Redo">‚Ü™</button>
        </div>

        <!-- Desktop Side Palette -->
        <div class="side-palette">
            <div class="palette-header">
                <h3>Colors</h3>
                <button class="action-btn" id="paletteGenBtn" title="Generate Palette">‚ú®</button>
            </div>
            <div class="current-colors">
                <div class="current-color" id="currentColor" style="background: #000000;"></div>
            </div>
            <!-- Dither gradient color picker (shown when dither tool active) -->
            <div class="dither-colors" id="ditherColors" style="display:none;">
                <div class="dither-label">Gradient Colors</div>
                <div class="dither-slots">
                    <div class="dither-slot active" id="ditherSlot1" data-slot="1" title="Start color">
                        <div class="dither-swatch" style="background:#000000;"></div>
                        <span>1</span>
                    </div>
                    <div class="dither-slot" id="ditherSlot2" data-slot="2" title="Middle color (optional)">
                        <div class="dither-swatch" style="background:transparent;"></div>
                        <span>2</span>
                    </div>
                    <div class="dither-slot" id="ditherSlot3" data-slot="3" title="End color">
                        <div class="dither-swatch" style="background:#ffffff;"></div>
                        <span>3</span>
                    </div>
                </div>
                <div class="dither-hint">Click slot, pick color from palette</div>
                <div class="dither-patterns">
                    <div class="dither-pattern-label">Pattern</div>
                    <div class="dither-pattern-btns">
                        <button class="dither-pattern-btn active" data-pattern="bayer" title="Bayer (smooth)">‚ñ¶</button>
                        <button class="dither-pattern-btn" data-pattern="checker" title="Checkerboard">‚ñ£</button>
                        <button class="dither-pattern-btn" data-pattern="hlines" title="Horizontal">‚â°</button>
                        <button class="dither-pattern-btn" data-pattern="vlines" title="Vertical">|||</button>
                        <button class="dither-pattern-btn" data-pattern="noise" title="Noise">‚ñë</button>
                    </div>
                </div>
            </div>
            <div class="palette-grid" id="paletteGrid"></div>
            <div class="palette-header">
                <h3>Palette</h3>
                <select id="paletteSelect" style="flex:1; margin-left: 8px;">
                    <option value="pico8">PICO-8</option>
                    <option value="gameboy">GameBoy</option>
                    <option value="endesga32">ENDESGA 32</option>
                    <option value="custom">Custom</option>
                </select>
            </div>
        </div>
    </div>

    <!-- Bottom Bar (Mobile) -->
    <div class="bottom-bar">
        <div class="color-row">
            <div class="mobile-current-color" id="mobileCurrentColor" style="background: #000000;"></div>
            <select id="mobileBrushSize" style="background:var(--surface);color:var(--text);border:1px solid var(--border);border-radius:4px;padding:4px;margin:0 8px;font-size:14px;">
                <option value="1">1px</option>
                <option value="2">2px</option>
                <option value="3">3px</option>
                <option value="4">4px</option>
                <option value="5">5px</option>
            </select>
            <div class="mobile-palette" id="mobilePalette"></div>
        </div>
        <div class="mobile-tools">
            <button class="tool-btn active" data-tool="pencil" title="Pencil"><canvas class="pixel-icon" data-icon="pencil"></canvas></button>
            <button class="tool-btn" data-tool="eraser" title="Eraser"><canvas class="pixel-icon" data-icon="eraser"></canvas></button>
            <button class="tool-btn" data-tool="select" title="Select"><canvas class="pixel-icon" data-icon="select"></canvas></button>
            <button class="tool-btn" data-tool="lasso" title="Lasso"><canvas class="pixel-icon" data-icon="lasso"></canvas></button>
            <button class="tool-btn" data-tool="line" title="Line"><canvas class="pixel-icon" data-icon="line"></canvas></button>
            <button class="tool-btn" data-tool="dither" title="Dither Gradient"><canvas class="pixel-icon" data-icon="dither"></canvas></button>
            <button class="tool-btn" data-tool="rect" title="Rectangle"><canvas class="pixel-icon" data-icon="rect"></canvas></button>
            <button class="tool-btn" data-tool="ellipse" title="Ellipse"><canvas class="pixel-icon" data-icon="ellipse"></canvas></button>
            <button class="tool-btn" data-tool="fill" title="Fill"><canvas class="pixel-icon" data-icon="fill"></canvas></button>
            <button class="tool-btn" data-tool="eyedropper" title="Eyedropper"><canvas class="pixel-icon" data-icon="eyedropper"></canvas></button>
            <button class="tool-btn" data-tool="replace" title="Replace"><canvas class="pixel-icon" data-icon="replace"></canvas></button>
            <button class="tool-btn layers-btn" id="layersBtn" title="Layers">üìë</button>
        </div>
        <div class="status-bar">
            <span id="statusTool">Tool: Pencil</span>
            <span id="statusSize">Size: 32x32</span>
            <span id="statusZoom">Zoom: 8x</span>
            <span id="statusPos">Pos: 0, 0</span>
            <span>Brush: <select id="brushSizeSelect" style="background:var(--surface);color:var(--text);border:1px solid var(--border);border-radius:4px;padding:2px;">
                <option value="1">1px</option>
                <option value="2">2px</option>
                <option value="3">3px</option>
                <option value="4">4px</option>
                <option value="5">5px</option>
            </select></span>
        </div>
    </div>

    <!-- Menu Modal -->
    <div class="modal-overlay" id="menuModal">
        <div class="modal">
            <h2>Menu</h2>
            <div class="form-group">
                <button class="btn btn-secondary" style="width:100%; margin-bottom: 8px;" id="newCanvasBtn">New Canvas</button>
                <button class="btn btn-secondary" style="width:100%; margin-bottom: 8px;" id="exportPngBtn">Export PNG</button>
                <button class="btn btn-secondary" style="width:100%; margin-bottom: 8px;" id="importImageBtn">Import Image</button>
                <button class="btn btn-secondary" style="width:100%; margin-bottom: 8px;" id="paletteGenMenuBtn">Palette Generator</button>
            </div>
            <div class="modal-buttons">
                <button class="btn btn-primary" id="closeMenuBtn">Close</button>
            </div>
        </div>
    </div>

    <!-- New Canvas Modal -->
    <div class="modal-overlay" id="newCanvasModal">
        <div class="modal">
            <h2>New Canvas</h2>
            <div class="form-group">
                <label>Width (pixels)</label>
                <input type="number" id="newWidth" value="32" min="8" max="256">
            </div>
            <div class="form-group">
                <label>Height (pixels)</label>
                <input type="number" id="newHeight" value="32" min="8" max="256">
            </div>
            <div class="form-group">
                <label>Preset</label>
                <select id="sizePreset">
                    <option value="">Custom</option>
                    <option value="8">8x8</option>
                    <option value="16">16x16</option>
                    <option value="32" selected>32x32</option>
                    <option value="64">64x64</option>
                    <option value="128">128x128</option>
                    <option value="256">256x256</option>
                </select>
            </div>
            <div class="modal-buttons">
                <button class="btn btn-secondary" id="cancelNewCanvas">Cancel</button>
                <button class="btn btn-primary" id="createNewCanvas">Create</button>
            </div>
        </div>
    </div>

    <!-- Replace Color Modal -->
    <div class="modal-overlay" id="replaceColorModal">
        <div class="modal" style="min-width: 300px;">
            <h2>Replace Color</h2>

            <div class="form-group">
                <label style="font-size: 16px; margin-bottom: 8px;">FROM (color to replace)</label>
                <div class="color-pick-row">
                    <div class="color-preview-large" id="replaceFromColor" style="background:#000;"></div>
                    <div class="color-pick-controls">
                        <input type="color" id="replaceFromInput" value="#000000">
                        <button class="pick-from-canvas-btn" id="pickFromBtn">Pick from canvas</button>
                    </div>
                </div>
            </div>

            <div class="form-group">
                <label style="font-size: 16px; margin-bottom: 8px;">TO (new color)</label>
                <div class="color-pick-row">
                    <div class="color-preview-large" id="replaceToColor" style="background:#ffffff;"></div>
                    <div class="color-pick-controls">
                        <input type="color" id="replaceToInput" value="#ffffff">
                        <button class="pick-from-canvas-btn" id="useCurrentBtn">Use current color</button>
                    </div>
                </div>
            </div>

            <div class="modal-buttons" style="margin-top: 20px;">
                <button class="btn btn-secondary" id="cancelReplace" style="padding: 14px 24px; font-size: 16px;">Cancel</button>
                <button class="btn btn-primary" id="doReplace" style="padding: 14px 24px; font-size: 16px;">Replace All</button>
            </div>
        </div>
    </div>

    <!-- Palette Generator Modal -->
    <div class="modal-overlay" id="paletteGenModal">
        <div class="modal" style="min-width: 340px; max-width: 95vw;">
            <h2>Palette Generator</h2>
            <div class="form-group">
                <label>Base Color</label>
                <input type="color" id="baseColor" value="#e94560" style="height: 40px;">
            </div>
            <div class="form-group">
                <label>Harmony Type</label>
                <select id="harmonyType">
                    <option value="monochromatic">Monochromatic</option>
                    <option value="complementary">Complementary</option>
                    <option value="analogous">Analogous</option>
                    <option value="triadic" selected>Triadic</option>
                    <option value="splitcomp">Split-Complementary</option>
                    <option value="tetradic">Tetradic</option>
                </select>
            </div>
            <div class="form-group">
                <label>Colors per Ramp: <span id="rampSizeVal">6</span></label>
                <input type="range" id="rampSize" min="3" max="9" value="6">
            </div>
            <div class="form-group">
                <label>Hue Shift: <span id="hueShiftVal">15</span>¬∞</label>
                <input type="range" id="hueShift" min="0" max="30" value="15">
            </div>
            <div class="form-group">
                <label>Temperature: <span id="tempShiftVal">0</span> <span style="color:var(--text-dim);font-size:12px;">(warm lights / cool darks)</span></label>
                <input type="range" id="tempShift" min="0" max="40" value="0">
            </div>
            <div class="form-group">
                <label>Click colors to select/deselect. Click row/column buttons to toggle whole rows/columns.</label>
                <div id="analogousAddTop" class="analogous-row-btn" style="display:none;">
                    <button class="btn btn-secondary" id="addRowTop">+ Add Row</button>
                    <button class="btn btn-secondary" id="removeRowTop" style="padding:4px 8px;">‚àí</button>
                </div>
                <div id="palettePreview" class="palette-gen-grid"></div>
                <div id="analogousAddBottom" class="analogous-row-btn" style="display:none;">
                    <button class="btn btn-secondary" id="addRowBottom">+ Add Row</button>
                    <button class="btn btn-secondary" id="removeRowBottom" style="padding:4px 8px;">‚àí</button>
                </div>
                <div class="palette-gen-actions">
                    <button id="selectAllColors">Select All</button>
                    <button id="deselectAllColors">Deselect All</button>
                    <button id="invertSelection">Invert</button>
                </div>
            </div>
            <div class="form-group" style="border-top: 1px solid var(--bg-light); padding-top: 12px; margin-top: 8px;">
                <label>Saved Palettes</label>
                <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    <select id="savedPaletteSelect" style="flex: 1; min-width: 120px; background: var(--bg-light); color: var(--text); border: 1px solid var(--bg-light); border-radius: 4px; padding: 6px;">
                        <option value="">-- Select --</option>
                    </select>
                    <button class="btn btn-secondary" id="loadSavedPalette" style="padding: 6px 12px;">Load</button>
                    <button class="btn btn-secondary" id="deleteSavedPalette" style="padding: 6px 12px;">üóëÔ∏è</button>
                </div>
                <div style="display: flex; gap: 8px; margin-top: 8px;">
                    <input type="text" id="savePaletteName" placeholder="Palette name..." style="flex: 1; background: var(--bg-light); color: var(--text); border: 1px solid var(--bg-light); border-radius: 4px; padding: 6px;">
                    <button class="btn btn-secondary" id="savePaletteBtn" style="padding: 6px 12px;">Save</button>
                </div>
            </div>
            <div class="modal-buttons" style="gap: 8px;">
                <button class="btn btn-secondary" id="downloadPalette" title="Download as .hex file">‚¨áÔ∏è Download</button>
                <button class="btn btn-secondary" id="cancelPaletteGen">Cancel</button>
                <button class="btn btn-primary" id="applyPalette">Apply Selected</button>
            </div>
        </div>
    </div>

    <!-- Layers Modal -->
    <div class="modal-overlay" id="layersModal">
        <div class="modal" style="max-width: 320px;">
            <h2>Layers</h2>
            <div class="layers-controls" style="display:flex;gap:8px;margin-bottom:12px;">
                <button class="btn btn-secondary" id="addLayerBtn" style="flex:1;">+ Add</button>
                <button class="btn btn-secondary" id="deleteLayerBtn" style="flex:1;">üóëÔ∏è Delete</button>
            </div>
            <div id="layersList" style="max-height:300px;overflow-y:auto;"></div>
            <div class="modal-buttons" style="margin-top:12px;">
                <button class="btn btn-primary" id="closeLayersBtn">Close</button>
            </div>
        </div>
    </div>

    <!-- Color Editor Modal -->
    <div class="modal-overlay" id="colorEditorModal">
        <div class="modal color-editor-modal">
            <h2>Color Editor</h2>

            <div class="color-editor-preview">
                <div class="color-editor-swatch" id="colorEditorSwatch"></div>
                <div class="color-editor-info">
                    <span>HEX</span>
                    <input type="text" id="colorEditorHex" placeholder="#000000">
                    <span style="margin-top:8px">RGB: <span id="colorEditorRgb">0, 0, 0</span></span>
                </div>
            </div>

            <div class="color-sliders">
                <div class="slider-row">
                    <span class="slider-label">Hue</span>
                    <input type="range" id="hueSlider" class="hue-slider" min="0" max="360" value="0">
                    <span class="slider-value" id="hueValue">0¬∞</span>
                </div>
                <div class="slider-row">
                    <span class="slider-label">Saturation</span>
                    <input type="range" id="satSlider" min="0" max="100" value="100">
                    <span class="slider-value" id="satValue">100%</span>
                </div>
                <div class="slider-row">
                    <span class="slider-label">Lightness</span>
                    <input type="range" id="lightSlider" min="0" max="100" value="50">
                    <span class="slider-value" id="lightValue">50%</span>
                </div>
            </div>

            <div class="palette-management">
                <h4>Palette Colors (tap to select, √ó to remove)</h4>
                <div class="palette-colors-list" id="paletteColorsList"></div>
                <div class="palette-actions">
                    <button class="add-color-btn" id="addToPaletteBtn">+ Add Current Color</button>
                </div>
            </div>

            <div class="modal-buttons">
                <button class="btn btn-secondary" id="cancelColorEditor">Cancel</button>
                <button class="btn btn-primary" id="applyColorEditor">Apply</button>
            </div>
        </div>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast"></div>
    <div class="debug-overlay" id="debugOverlay"></div>

    <script>
        // ===== STATE =====
        const state = {
            canvasWidth: 32,
            canvasHeight: 32,
            zoom: 8,
            panX: 0,
            panY: 0,
            currentTool: 'pencil',
            currentColor: '#000000',
            brushSize: 1,
            showGrid: true,
            undoStack: [],
            redoStack: [],
            maxHistory: 50,
            isDrawing: false,
            lastX: -1,
            lastY: -1,
            lineStartPoint: null, // For two-tap line mode
            ditherStartColor: null, // Color at start point for dither gradient
            // Dither gradient colors (3-color support)
            ditherColors: ['#000000', null, '#ffffff'], // [start, middle (optional), end]
            ditherActiveSlot: 1, // Which slot is selected (1, 2, or 3)
            ditherPattern: 'bayer', // 'bayer', 'checker', 'hlines', 'vlines', 'noise'
            palette: [],
            pinchStartDist: 0,
            pinchStartZoom: 1,
            pickingForReplace: false, // When picking color from canvas for replace
            generatedPalette: [], // Full generated palette
            selectedColors: new Set(), // Indices of selected colors
            paletteRampSize: 6, // Current ramp size for selection
            paletteNumRamps: 1, // Current number of ramps
            analogousCoolRows: 1, // Extra rows toward cool (blue)
            analogousWarmRows: 1, // Extra rows toward warm (yellow)
            // Selection state
            selection: {
                active: false,
                pixels: new Set(), // Set of "x,y" strings for selected pixels
                bounds: null, // {x, y, width, height}
                floating: false, // Is content lifted/floating?
                floatingData: null, // ImageData of floating content
                floatingOffset: {x: 0, y: 0}, // Offset from original position
            },
            clipboard: null, // ImageData for copy/paste
            lassoPixels: [], // Array of {x,y} for lasso drawing
            debugMode: false, // Toggle with 'D' key
            lassoStart: null, // Starting pixel of lasso
            // Layers
            layers: [], // Array of layer objects: {id, name, canvas, ctx, visible, opacity, locked}
            currentLayerIndex: 0,
            nextLayerId: 1,
            // Tabs
            tabs: [],           // Array of tab objects
            activeTabIndex: 0,  // Currently displayed tab
            nextTabId: 1,       // Counter for unique tab IDs
            tabLoading: false,  // Flag to prevent autoSave during async tab load
            // Cloud sync
            user: null,
            syncStatus: 'idle',
            lastSyncTime: null,
            syncDebounceTimer: null,
            realtimeChannel: null,
            lastSyncTimestamp: 0,  // When we last saved to cloud
        };

        // ===== SUPABASE =====
        const SUPABASE_URL = 'https://vwlbjjznvczfecjnrjen.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZ3bGJqanpudmN6ZmVjam5yamVuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njc5Nzc5OTIsImV4cCI6MjA4MzU1Mzk5Mn0.didh9h1rGEDEhzVlUBp7WhAxFMPsUTSvsuvIwa0aDro';
        let supabaseClient = null;

        // Initialize Supabase (SDK loaded synchronously in head)
        try {
            if (window.supabase) {
                // Use noOpLock to prevent auth lock deadlocks (Issue #1594)
                const noOpLock = async (name, acquireTimeout, fn) => await fn();
                supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
                    auth: { lock: noOpLock }
                });
                console.log('Supabase initialized with noOpLock');
            } else {
                console.error('Supabase SDK not loaded');
            }
        } catch (e) {
            console.error('Supabase init error:', e);
        }

        // Auth functions
        async function signInWithGoogle() {
            if (!supabaseClient) {
                showToast('Cloud sync loading...');
                return;
            }
            const { error } = await supabaseClient.auth.signInWithOAuth({
                provider: 'google',
                options: {
                    redirectTo: window.location.origin + window.location.pathname
                }
            });
            if (error) {
                console.error('Sign in error:', error);
                showToast('Sign in failed');
            }
        }

        async function signOut() {
            if (!supabaseClient) return;
            const { error } = await supabaseClient.auth.signOut();
            if (error) console.error('Sign out error:', error);
            state.user = null;
            updateAuthUI();
            showToast('Signed out');
        }

        function updateAuthUI() {
            const authBtn = document.getElementById('authBtn');
            const authText = document.getElementById('authText');
            const syncStatus = document.getElementById('syncStatus');
            if (!authBtn) return;

            if (state.user) {
                const name = state.user.user_metadata?.full_name || state.user.email?.split('@')[0] || 'User';
                authText.textContent = name;
                authBtn.classList.add('signed-in');
                syncStatus.classList.add('visible');
            } else {
                authText.textContent = 'Sign in';
                authBtn.classList.remove('signed-in');
                syncStatus.classList.remove('visible');
            }
        }

        function setupAuthListener() {
            if (!supabaseClient) return;
            // IMPORTANT: Don't use async callback - it breaks Supabase client (Discussion #40806)
            supabaseClient.auth.onAuthStateChange((event, session) => {
                console.log('Auth state:', event);
                state.user = session?.user || null;
                updateAuthUI();

                // Merge on sign-in or when loading page with existing session
                // Don't await - just fire and forget to avoid blocking
                if ((event === 'SIGNED_IN' || event === 'INITIAL_SESSION') && state.user) {
                    mergeWithCloud();
                    setupRealtimeSync();
                }
                if (event === 'SIGNED_OUT') {
                    // Unsubscribe from realtime
                    if (state.realtimeChannel) {
                        supabaseClient.removeChannel(state.realtimeChannel);
                        state.realtimeChannel = null;
                    }
                }
            });
        }

        function setupRealtimeSync() {
            if (!supabaseClient || !state.user || state.realtimeChannel) return;

            console.log('Setting up realtime sync...');
            state.realtimeChannel = supabaseClient
                .channel('projects-changes')
                .on('postgres_changes',
                    { event: '*', schema: 'public', table: 'projects', filter: `user_id=eq.${state.user.id}` },
                    (payload) => {
                        console.log('Realtime update:', payload.eventType, payload.new?.id?.slice(0,8));

                        if (payload.eventType === 'UPDATE' || payload.eventType === 'INSERT') {
                            const cloudProject = payload.new;
                            const localTab = state.tabs.find(t => t.id === cloudProject.id);

                            // Compare timestamps: accept if cloud is newer than our last sync
                            const cloudTime = new Date(cloudProject.updated_at).getTime();
                            const ourLastSync = state.lastSyncTimestamp || 0;

                            if (cloudTime <= ourLastSync) {
                                console.log('Ignoring older update (cloud:', cloudTime, 'ours:', ourLastSync, ')');
                                return;
                            }

                            console.log('Accepting newer update (cloud:', cloudTime, 'ours:', ourLastSync, ')');

                            if (localTab) {
                                // Update existing tab with cloud data
                                console.log('Applying remote update for', cloudProject.id.slice(0,8));
                                localTab.name = cloudProject.name;
                                localTab.canvasWidth = cloudProject.canvas_width;
                                localTab.canvasHeight = cloudProject.canvas_height;
                                localTab.layers = cloudProject.data?.layers || [];
                                localTab.currentLayerIndex = cloudProject.data?.currentLayerIndex || 0;
                                localTab.nextLayerId = cloudProject.data?.nextLayerId || 1;
                                localTab.palette = cloudProject.data?.palette || [...PALETTES.pico8];
                                localTab.currentColor = cloudProject.data?.currentColor || '#000000';
                                localTab.zoom = cloudProject.data?.zoom || 8;
                                localTab.panX = cloudProject.data?.panX || 0;
                                localTab.panY = cloudProject.data?.panY || 0;

                                // Reload if this is the active tab
                                const tabIndex = state.tabs.indexOf(localTab);
                                if (tabIndex === state.activeTabIndex) {
                                    loadTabState(tabIndex);
                                }
                                renderTabBar();
                            } else {
                                // New project from another device
                                console.log('Adding new project from remote:', cloudProject.id.slice(0,8));
                                const newTab = {
                                    id: cloudProject.id,
                                    name: cloudProject.name,
                                    canvasWidth: cloudProject.canvas_width,
                                    canvasHeight: cloudProject.canvas_height,
                                    layers: cloudProject.data?.layers || [],
                                    currentLayerIndex: cloudProject.data?.currentLayerIndex || 0,
                                    nextLayerId: cloudProject.data?.nextLayerId || 1,
                                    palette: cloudProject.data?.palette || [...PALETTES.pico8],
                                    currentColor: cloudProject.data?.currentColor || '#000000',
                                    undoStack: [],
                                    redoStack: [],
                                    zoom: cloudProject.data?.zoom || 8,
                                    panX: cloudProject.data?.panX || 0,
                                    panY: cloudProject.data?.panY || 0
                                };
                                state.tabs.push(newTab);
                                renderTabBar();
                            }
                        }
                    }
                )
                .subscribe((status) => {
                    console.log('Realtime subscription status:', status);
                });
        }

        // ===== CLOUD SYNC =====
        let lastSyncTrigger = 0;
        function debouncedCloudSync() {
            const now = Date.now();
            if (state.syncDebounceTimer) {
                clearTimeout(state.syncDebounceTimer);
            }

            // Force sync if it's been more than 5 seconds since first trigger
            if (!lastSyncTrigger) lastSyncTrigger = now;
            const timeSinceFirst = now - lastSyncTrigger;

            if (timeSinceFirst > 5000) {
                // Max wait exceeded, sync now
                lastSyncTrigger = 0;
                syncToCloud();
            } else {
                // Debounce for 1 second
                state.syncDebounceTimer = setTimeout(() => {
                    lastSyncTrigger = 0;
                    syncToCloud();
                }, 1000);
            }
        }

        function updateSyncStatus(status) {
            state.syncStatus = status;
            const syncStatus = document.getElementById('syncStatus');
            if (!syncStatus) return;

            syncStatus.classList.remove('syncing', 'synced', 'error');
            switch(status) {
                case 'syncing':
                    syncStatus.classList.add('syncing');
                    break;
                case 'synced':
                    syncStatus.classList.add('synced');
                    break;
                case 'error':
                    syncStatus.classList.add('error');
                    break;
            }
        }

        async function syncToCloud() {
            if (!state.user || !supabaseClient) {
                console.log('Sync skipped - no user or client');
                return;
            }

            // Don't sync while tab is loading - would save incomplete canvas data
            if (state.tabLoading) {
                console.log('Sync skipped - tab loading in progress');
                return;
            }

            console.log('Starting sync...');
            updateSyncStatus('syncing');
            try {
                // Save current tab state first
                if (state.tabs.length > 0) {
                    saveCurrentTabState();
                }

                // Save each tab as a project
                console.log('Saving', state.tabs.length, 'tabs...');
                for (let i = 0; i < state.tabs.length; i++) {
                    console.log('Saving tab', i, state.tabs[i].id);
                    await saveProjectToCloud(state.tabs[i]);
                    console.log('Tab', i, 'saved');
                }

                // Save workspace state
                console.log('Saving workspace...');
                await saveWorkspaceToCloud();
                console.log('Workspace saved');

                state.lastSyncTime = new Date();
                state.lastSyncTimestamp = Date.now();  // For comparing with incoming updates
                updateSyncStatus('synced');
                console.log('Synced to cloud', state.tabs.length, 'tabs, timestamp:', state.lastSyncTimestamp);
            } catch (error) {
                console.error('Sync error:', error);
                const errMsg = JSON.stringify(error, null, 2);
                navigator.clipboard.writeText(errMsg).catch(() => {});
                showToast('Sync error (copied)');
                updateSyncStatus('error');
            }
        }

        async function saveProjectToCloud(tab) {
            try {
                console.log('saveProjectToCloud called for:', tab.id, tab.name);

                // Ensure tab has a valid UUID (migrate old numeric IDs)
                if (typeof tab.id === 'number' || (typeof tab.id === 'string' && !tab.id.includes('-'))) {
                    tab.id = crypto.randomUUID();
                    console.log('Generated new UUID:', tab.id);
                }

                console.log('Building project data...');
                const projectData = {
                    id: tab.id,
                    user_id: state.user.id,
                    name: tab.name,
                    canvas_width: tab.canvasWidth,
                    canvas_height: tab.canvasHeight,
                    data: {
                        layers: tab.layers,
                        currentLayerIndex: tab.currentLayerIndex,
                        nextLayerId: tab.nextLayerId,
                        palette: tab.palette,
                        currentColor: tab.currentColor,
                        zoom: tab.zoom,
                        panX: tab.panX,
                        panY: tab.panY
                    },
                    updated_at: new Date().toISOString()
                };

                console.log('Upserting project:', tab.id, 'data size:', JSON.stringify(projectData).length);
                const { error } = await supabaseClient
                    .from('projects')
                    .upsert(projectData);

                console.log('Upsert done, error:', error);
                if (error) throw error;
            } catch (e) {
                console.error('saveProjectToCloud error:', e);
                throw e;
            }
        }

        async function saveWorkspaceToCloud() {
            const workspaceData = {
                user_id: state.user.id,
                open_project_ids: state.tabs.map(t => t.id),
                active_project_id: state.tabs[state.activeTabIndex]?.id || null,
                updated_at: new Date().toISOString()
            };

            const { error } = await supabaseClient
                .from('workspaces')
                .upsert(workspaceData, { onConflict: 'user_id' });

            if (error) throw error;
        }

        async function mergeWithCloud() {
            if (!state.user || !supabaseClient) return;

            try {
                // Get cloud projects for this user
                const { data: cloudProjects, error } = await supabaseClient
                    .from('projects')
                    .select('*')
                    .eq('user_id', state.user.id);

                if (error) throw error;

                console.log('Cloud projects:', cloudProjects?.length || 0);
                if (cloudProjects && cloudProjects.length > 0) {
                    // Build map of local tabs by ID
                    const localTabsById = {};
                    state.tabs.forEach(t => { localTabsById[String(t.id)] = t; });
                    console.log('Local tab IDs:', Object.keys(localTabsById));
                    console.log('Cloud project IDs:', cloudProjects.map(p => p.id));

                    // Merge cloud projects with local
                    for (const proj of cloudProjects) {
                        const cloudLayerSizes = proj.data?.layers?.map(l => l.image?.length || 0) || [];
                        console.log('Cloud proj', proj.id.slice(0,8), 'layers:', proj.data?.layers?.length, 'sizes:', cloudLayerSizes);

                        const existingTab = localTabsById[proj.id];
                        if (existingTab) {
                            // Update existing tab with cloud data (cloud wins for now)
                            console.log('Updating local tab with cloud data:', proj.id.slice(0,8));
                            existingTab.name = proj.name;
                            existingTab.canvasWidth = proj.canvas_width;
                            existingTab.canvasHeight = proj.canvas_height;
                            existingTab.layers = proj.data?.layers || [];
                            existingTab.currentLayerIndex = proj.data?.currentLayerIndex || 0;
                            existingTab.nextLayerId = proj.data?.nextLayerId || 1;
                            existingTab.palette = proj.data?.palette || [...PALETTES.pico8];
                            existingTab.currentColor = proj.data?.currentColor || '#000000';
                            existingTab.zoom = proj.data?.zoom || 8;
                            existingTab.panX = proj.data?.panX || 0;
                            existingTab.panY = proj.data?.panY || 0;
                        } else {
                            // Add new tab from cloud
                            console.log('Adding cloud tab:', proj.id);
                            const tab = {
                                id: proj.id,
                                name: proj.name,
                                canvasWidth: proj.canvas_width,
                                canvasHeight: proj.canvas_height,
                                layers: proj.data?.layers || [],
                                currentLayerIndex: proj.data?.currentLayerIndex || 0,
                                nextLayerId: proj.data?.nextLayerId || 1,
                                palette: proj.data?.palette || [...PALETTES.pico8],
                                currentColor: proj.data?.currentColor || '#000000',
                                undoStack: [],
                                redoStack: [],
                                zoom: proj.data?.zoom || 8,
                                panX: proj.data?.panX || 0,
                                panY: proj.data?.panY || 0
                            };
                            state.tabs.push(tab);
                        }
                    }

                    // Reload current tab to show updated data
                    loadTabState(state.activeTabIndex);
                    renderTabBar();
                    showToast('Synced with cloud');
                }

                // DON'T sync back immediately - images load async and we'd
                // overwrite cloud data with empty canvases. Let auto-save
                // handle syncing after user makes changes.

            } catch (error) {
                console.error('Merge error:', error);
                showToast('Sync failed');
            }
        }

        // ===== PALETTES =====
        const PALETTES = {
            pico8: [
                '#000000', '#1d2b53', '#7e2553', '#008751',
                '#ab5236', '#5f574f', '#c2c3c7', '#fff1e8',
                '#ff004d', '#ffa300', '#ffec27', '#00e436',
                '#29adff', '#83769c', '#ff77a8', '#ffccaa'
            ],
            gameboy: ['#0f380f', '#306230', '#8bac0f', '#9bbc0f'],
            endesga32: [
                '#be4a2f', '#d77643', '#ead4aa', '#e4a672',
                '#b86f50', '#733e39', '#3e2731', '#a22633',
                '#e43b44', '#f77622', '#feae34', '#fee761',
                '#63c74d', '#3e8948', '#265c42', '#193c3e',
                '#124e89', '#0099db', '#2ce8f5', '#ffffff',
                '#c0cbdc', '#8b9bb4', '#5a6988', '#3a4466',
                '#262b44', '#181425', '#ff0044', '#68386c',
                '#b55088', '#f6757a', '#e8b796', '#c28569'
            ],
            custom: ['#000000', '#ffffff']
        };

        // ===== DOM ELEMENTS =====
        const mainCanvas = document.getElementById('mainCanvas');
        const gridCanvas = document.getElementById('gridCanvas');
        const previewCanvas = document.getElementById('previewCanvas');
        const selectionCanvas = document.getElementById('selectionCanvas');
        const canvasWrapper = document.getElementById('canvasWrapper');
        const canvasContainer = document.getElementById('canvasContainer');
        const ctx = mainCanvas.getContext('2d');
        const gridCtx = gridCanvas.getContext('2d');
        const previewCtx = previewCanvas.getContext('2d');
        const selCtx = selectionCanvas.getContext('2d');

        // ===== LAYER MANAGEMENT =====
        function createLayer(name = null) {
            const canvas = document.createElement('canvas');
            canvas.width = state.canvasWidth;
            canvas.height = state.canvasHeight;
            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;

            const layer = {
                id: state.nextLayerId++,
                name: name || `Layer ${state.layers.length + 1}`,
                canvas: canvas,
                ctx: ctx,
                visible: true,
                opacity: 1,
                locked: false
            };
            return layer;
        }

        // Premium settings
        const FREE_LAYER_LIMIT = 2;
        // TODO: Set to false when auth is ready (currently true for development)
        const isPremium = () => true;

        function addLayer(insertAbove = true) {
            // Check layer limit for free users
            if (!isPremium() && state.layers.length >= FREE_LAYER_LIMIT) {
                showToast(`Free: ${FREE_LAYER_LIMIT} layers max. Upgrade for unlimited!`);
                return null;
            }

            const layer = createLayer();
            if (insertAbove) {
                state.layers.splice(state.currentLayerIndex + 1, 0, layer);
                state.currentLayerIndex++;
            } else {
                state.layers.push(layer);
                state.currentLayerIndex = state.layers.length - 1;
            }
            compositeAndRender();
            updateLayersPanel();
            return layer;
        }

        function deleteLayer(index) {
            if (state.layers.length <= 1) {
                showToast('Cannot delete only layer');
                return;
            }
            state.layers.splice(index, 1);
            if (state.currentLayerIndex >= state.layers.length) {
                state.currentLayerIndex = state.layers.length - 1;
            }
            compositeAndRender();
            updateLayersPanel();
        }

        function moveLayer(fromIndex, toIndex) {
            if (toIndex < 0 || toIndex >= state.layers.length) return;
            const [layer] = state.layers.splice(fromIndex, 1);
            state.layers.splice(toIndex, 0, layer);
            if (state.currentLayerIndex === fromIndex) {
                state.currentLayerIndex = toIndex;
            }
            compositeAndRender();
            updateLayersPanel();
        }

        function duplicateLayer(index) {
            const src = state.layers[index];
            const newLayer = createLayer(src.name + ' copy');
            newLayer.ctx.drawImage(src.canvas, 0, 0);
            newLayer.opacity = src.opacity;
            newLayer.visible = src.visible;
            state.layers.splice(index + 1, 0, newLayer);
            state.currentLayerIndex = index + 1;
            compositeAndRender();
            updateLayersPanel();
        }

        function mergeLayerDown(index) {
            if (index <= 0) return;
            const upper = state.layers[index];
            const lower = state.layers[index - 1];
            lower.ctx.globalAlpha = upper.opacity;
            lower.ctx.drawImage(upper.canvas, 0, 0);
            lower.ctx.globalAlpha = 1;
            state.layers.splice(index, 1);
            state.currentLayerIndex = index - 1;
            compositeAndRender();
            updateLayersPanel();
            saveState();
        }

        function getCurrentLayer() {
            return state.layers[state.currentLayerIndex];
        }

        function getCurrentCtx() {
            return state.layers[state.currentLayerIndex]?.ctx || ctx;
        }

        function compositeAndRender() {
            // Clear main canvas
            ctx.clearRect(0, 0, state.canvasWidth, state.canvasHeight);

            // Draw layers from bottom to top
            for (let i = 0; i < state.layers.length; i++) {
                const layer = state.layers[i];
                if (!layer.visible) continue;
                ctx.globalAlpha = layer.opacity;
                ctx.drawImage(layer.canvas, 0, 0);
            }
            ctx.globalAlpha = 1;
        }

        function flattenForExport() {
            // Create a temp canvas with all layers merged
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = state.canvasWidth;
            tempCanvas.height = state.canvasHeight;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.imageSmoothingEnabled = false;

            for (let i = 0; i < state.layers.length; i++) {
                const layer = state.layers[i];
                if (!layer.visible) continue;
                tempCtx.globalAlpha = layer.opacity;
                tempCtx.drawImage(layer.canvas, 0, 0);
            }
            tempCtx.globalAlpha = 1;
            return tempCanvas;
        }

        // ===== INITIALIZATION =====
        // ===== PIXEL ART ICONS =====
        function drawPixelIcons() {
            const icons = document.querySelectorAll('.pixel-icon');
            icons.forEach(canvas => {
                canvas.width = 16;
                canvas.height = 16;
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;
                const icon = canvas.dataset.icon;
                drawIcon(ctx, icon);
            });
        }

        function drawIcon(ctx, type) {
            const W = '#ffffff';  // White
            const G = '#888888';  // Gray
            const D = '#444444';  // Dark gray
            const P = '#ff69b4';  // Pink (eraser)
            const B = '#4a9eff';  // Blue
            const Y = '#ffcc00';  // Yellow
            const O = '#ff8800';  // Orange
            const R = '#ff4444';  // Red
            const _ = null;       // Transparent

            const iconData = {
                // Pencil - diagonal pencil
                pencil: [
                    [_,_,_,_,_,_,_,_,_,_,_,_,Y,Y,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,Y,Y,Y,Y,_],
                    [_,_,_,_,_,_,_,_,_,_,Y,Y,O,Y,Y,_],
                    [_,_,_,_,_,_,_,_,_,Y,Y,O,O,Y,_,_],
                    [_,_,_,_,_,_,_,_,Y,Y,O,O,Y,_,_,_],
                    [_,_,_,_,_,_,_,Y,Y,O,O,Y,_,_,_,_],
                    [_,_,_,_,_,_,Y,Y,O,O,Y,_,_,_,_,_],
                    [_,_,_,_,_,Y,Y,O,O,Y,_,_,_,_,_,_],
                    [_,_,_,_,Y,Y,O,O,Y,_,_,_,_,_,_,_],
                    [_,_,_,Y,Y,O,O,Y,_,_,_,_,_,_,_,_],
                    [_,_,Y,Y,O,O,Y,_,_,_,_,_,_,_,_,_],
                    [_,Y,Y,O,O,Y,_,_,_,_,_,_,_,_,_,_],
                    [_,D,D,O,Y,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,D,D,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,D,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                ],
                // Eraser - pink cylinder from above (ellipse)
                eraser: [
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,P,P,P,P,P,P,P,P,_,_,_,_],
                    [_,_,_,P,P,P,P,P,P,P,P,P,P,_,_,_],
                    [_,_,P,P,P,P,P,P,P,P,P,P,P,P,_,_],
                    [_,P,P,P,W,W,W,W,W,W,P,P,P,P,P,_],
                    [_,P,P,W,W,W,W,W,W,W,W,P,P,P,P,_],
                    [_,P,P,W,W,W,W,W,W,W,W,P,P,P,P,_],
                    [_,P,P,W,W,W,W,W,W,W,W,P,P,P,P,_],
                    [_,P,P,P,W,W,W,W,W,W,P,P,P,P,P,_],
                    [_,_,P,P,P,P,P,P,P,P,P,P,P,P,_,_],
                    [_,_,_,P,P,P,P,P,P,P,P,P,P,_,_,_],
                    [_,_,_,_,P,P,P,P,P,P,P,P,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                ],
                // Line - diagonal line
                line: [
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,W,W,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,W,W,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,W,W,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,W,W,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,W,W,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,W,W,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,W,W,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,W,W,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,W,W,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,W,W,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,W,W,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,W,W,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,W,W,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [W,W,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [W,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                ],
                // Dither gradient - checkerboard pattern fading
                dither: [
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,W,W,W,W,W,G,_,G,_,_,_,_,_,_,_],
                    [_,W,W,W,W,W,_,G,_,G,_,_,_,_,_,_],
                    [_,W,W,W,W,W,G,_,G,_,_,_,_,_,_,_],
                    [_,W,W,W,W,W,_,G,_,G,_,_,_,_,_,_],
                    [_,W,W,W,W,W,G,_,G,_,_,_,_,_,_,_],
                    [_,W,W,W,W,W,_,G,_,G,_,_,_,_,_,_],
                    [_,W,W,W,W,W,G,_,G,_,_,_,_,_,_,_],
                    [_,W,W,W,W,W,_,G,_,G,_,_,_,_,_,_],
                    [_,W,W,W,W,W,G,_,G,_,_,_,_,_,_,_],
                    [_,W,W,W,W,W,_,G,_,G,_,_,_,_,_,_],
                    [_,W,W,W,W,W,G,_,G,_,_,_,_,_,_,_],
                    [_,W,W,W,W,W,_,G,_,G,_,_,_,_,_,_],
                    [_,W,W,W,W,W,G,_,G,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                ],
                // Rectangle - square outline
                rect: [
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,W,W,W,W,W,W,W,W,W,W,W,W,_,_],
                    [_,_,W,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,_,W,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,_,W,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,_,W,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,_,W,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,_,W,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,_,W,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,_,W,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,_,W,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,_,W,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,_,W,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,_,W,W,W,W,W,W,W,W,W,W,W,W,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                ],
                // Ellipse - circle outline
                ellipse: [
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,W,W,W,W,W,W,_,_,_,_,_],
                    [_,_,_,W,W,_,_,_,_,_,_,W,W,_,_,_],
                    [_,_,W,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,_,W,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,W,_,_,_,_,_,_,_,_,_,_,_,_,W,_],
                    [_,W,_,_,_,_,_,_,_,_,_,_,_,_,W,_],
                    [_,W,_,_,_,_,_,_,_,_,_,_,_,_,W,_],
                    [_,W,_,_,_,_,_,_,_,_,_,_,_,_,W,_],
                    [_,W,_,_,_,_,_,_,_,_,_,_,_,_,W,_],
                    [_,W,_,_,_,_,_,_,_,_,_,_,_,_,W,_],
                    [_,_,W,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,_,W,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,_,_,W,W,_,_,_,_,_,_,W,W,_,_,_],
                    [_,_,_,_,_,W,W,W,W,W,W,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                ],
                // Fill bucket
                fill: [
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,W,W,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,W,_,_,W,_,_,_,_],
                    [_,_,_,_,_,_,_,W,_,_,_,_,W,_,_,_],
                    [_,_,_,_,_,_,W,_,_,_,_,_,W,_,_,_],
                    [_,_,_,_,_,W,_,_,_,_,_,_,W,_,_,_],
                    [_,_,_,_,W,_,_,_,_,_,_,W,_,_,_,_],
                    [_,_,_,W,G,_,_,_,_,_,W,_,_,_,_,_],
                    [_,_,W,G,G,G,_,_,_,W,_,_,_,_,_,_],
                    [_,W,G,G,G,G,G,_,W,_,_,_,_,_,_,_],
                    [_,W,G,G,G,G,G,G,W,_,_,_,_,_,_,_],
                    [_,_,W,G,G,G,G,W,B,B,_,_,_,_,_,_],
                    [_,_,_,W,G,G,W,B,B,B,B,_,_,_,_,_],
                    [_,_,_,_,W,W,_,B,B,B,B,B,_,_,_,_],
                    [_,_,_,_,_,_,_,_,B,B,B,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                ],
                // Eyedropper
                eyedropper: [
                    [_,_,_,_,_,_,_,_,_,_,_,W,W,W,_,_],
                    [_,_,_,_,_,_,_,_,_,_,W,W,W,W,W,_],
                    [_,_,_,_,_,_,_,_,_,_,W,W,W,W,W,_],
                    [_,_,_,_,_,_,_,_,_,W,W,W,W,W,_,_],
                    [_,_,_,_,_,_,_,_,W,W,W,W,W,_,_,_],
                    [_,_,_,_,_,_,_,W,G,W,W,W,_,_,_,_],
                    [_,_,_,_,_,_,W,G,G,W,W,_,_,_,_,_],
                    [_,_,_,_,_,W,G,G,G,W,_,_,_,_,_,_],
                    [_,_,_,_,W,G,G,G,W,_,_,_,_,_,_,_],
                    [_,_,_,W,G,G,G,W,_,_,_,_,_,_,_,_],
                    [_,_,W,G,G,G,W,_,_,_,_,_,_,_,_,_],
                    [_,W,G,G,G,W,_,_,_,_,_,_,_,_,_,_],
                    [_,W,G,G,W,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,W,W,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,W,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                ],
                // Replace - two overlapping squares with arrow
                replace: [
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,R,R,R,R,R,R,R,_,_,_,_,_,_,_,_],
                    [_,R,R,R,R,R,R,R,_,_,_,_,_,_,_,_],
                    [_,R,R,_,_,_,R,R,_,_,_,_,_,_,_,_],
                    [_,R,R,_,_,_,R,R,_,_,_,_,_,_,_,_],
                    [_,R,R,_,_,_,R,R,_,_,W,W,_,_,_,_],
                    [_,R,R,R,R,R,R,R,_,W,W,W,W,_,_,_],
                    [_,R,R,R,R,R,R,R,W,W,W,W,W,W,_,_],
                    [_,_,_,_,_,_,_,_,W,W,W,W,W,W,W,_],
                    [_,_,_,_,_,_,B,B,B,B,B,B,B,B,B,_],
                    [_,_,_,_,_,_,B,B,_,_,_,_,B,B,B,_],
                    [_,_,_,_,_,_,B,B,_,_,_,_,B,B,B,_],
                    [_,_,_,_,_,_,B,B,_,_,_,_,B,B,B,_],
                    [_,_,_,_,_,_,B,B,_,_,_,_,B,B,B,_],
                    [_,_,_,_,_,_,B,B,B,B,B,B,B,B,B,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                ],
                // Select - dashed rectangle marquee
                select: [
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,W,W,_,_,W,W,_,_,W,W,_,_,_,_],
                    [_,W,_,_,_,_,_,_,_,_,_,_,W,_,_,_],
                    [_,W,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,W,_,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,W,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,W,_,_,_,_,_,_,_,_,_,_,_,W,_,_],
                    [_,W,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,W,_,_,_],
                    [_,_,W,W,_,_,W,W,_,_,W,W,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                ],
                // Lasso - loop with rope tail
                lasso: [
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,W,W,W,W,_,_,_,_,_,_,_,_],
                    [_,_,_,W,W,_,_,W,W,_,_,_,_,_,_,_],
                    [_,_,_,W,_,_,_,_,W,_,_,_,_,_,_,_],
                    [_,_,_,W,_,_,_,_,W,_,_,_,_,_,_,_],
                    [_,_,_,W,W,_,_,W,W,_,_,_,_,_,_,_],
                    [_,_,_,_,W,W,W,W,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,W,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,W,_,W,W,W,_,_,_,_],
                    [_,_,_,_,_,_,_,W,W,W,_,W,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,W,W,W,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,W,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,W,W,W,W,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
                ],
            };

            const data = iconData[type];
            if (!data) return;

            for (let y = 0; y < 16; y++) {
                for (let x = 0; x < 16; x++) {
                    const color = data[y][x];
                    if (color) {
                        ctx.fillStyle = color;
                        ctx.fillRect(x, y, 1, 1);
                    }
                }
            }
        }

        function init() {
            drawPixelIcons();
            loadPalette('pico8');
            initCanvas(32, 32);
            setupEventListeners();
            setupAuthListener();
            updateUI();
            loadAutoSave();

            // If no tabs were loaded, create a default one
            if (state.tabs.length === 0) {
                const tab = createTabObject(32, 32, 'Untitled');
                tab.layers = state.layers.map(layer => ({
                    id: layer.id,
                    name: layer.name,
                    visible: layer.visible,
                    opacity: layer.opacity,
                    locked: layer.locked,
                    image: layer.canvas.toDataURL()
                }));
                tab.palette = [...state.palette];
                tab.currentColor = state.currentColor;
                state.tabs.push(tab);
                state.activeTabIndex = 0;
            }

            // Always render tab bar at the end of init
            renderTabBar();
            console.log('Tabs initialized:', state.tabs.length, 'tabs');
        }

        function initCanvas(width, height) {
            state.canvasWidth = width;
            state.canvasHeight = height;

            mainCanvas.width = width;
            mainCanvas.height = height;
            gridCanvas.width = width;
            gridCanvas.height = height;
            previewCanvas.width = width;
            previewCanvas.height = height;
            selectionCanvas.width = width;
            selectionCanvas.height = height;

            ctx.imageSmoothingEnabled = false;
            gridCtx.imageSmoothingEnabled = false;
            previewCtx.imageSmoothingEnabled = false;
            selCtx.imageSmoothingEnabled = false;

            // Clear canvas to transparent
            ctx.clearRect(0, 0, width, height);

            // Initialize layers if empty
            if (state.layers.length === 0) {
                state.layers = [createLayer('Background')];
                state.currentLayerIndex = 0;
            } else {
                // Resize existing layers
                state.layers.forEach(layer => {
                    layer.canvas.width = width;
                    layer.canvas.height = height;
                    layer.ctx.imageSmoothingEnabled = false;
                });
            }

            // Clear selection
            clearSelection();

            updateCanvasSize();
            drawGrid();
            updateLayersPanel();
            saveState();
        }

        function updateCanvasSize() {
            const displayWidth = state.canvasWidth * state.zoom;
            const displayHeight = state.canvasHeight * state.zoom;

            mainCanvas.style.width = displayWidth + 'px';
            mainCanvas.style.height = displayHeight + 'px';
            gridCanvas.style.width = displayWidth + 'px';
            gridCanvas.style.height = displayHeight + 'px';
            previewCanvas.style.width = displayWidth + 'px';
            previewCanvas.style.height = displayHeight + 'px';
            selectionCanvas.style.width = displayWidth + 'px';
            selectionCanvas.style.height = displayHeight + 'px';

            canvasWrapper.style.transform = `translate(${state.panX}px, ${state.panY}px)`;

            document.getElementById('zoomIndicator').textContent = state.zoom + 'x';
            document.getElementById('statusZoom').textContent = 'Zoom: ' + state.zoom + 'x';
            document.getElementById('statusSize').textContent = `Size: ${state.canvasWidth}x${state.canvasHeight}`;
        }

        // ===== GRID =====
        function drawGrid() {
            gridCtx.clearRect(0, 0, state.canvasWidth, state.canvasHeight);

            if (!state.showGrid || state.zoom < 4) return;

            gridCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            gridCtx.lineWidth = 1 / state.zoom;

            for (let x = 0; x <= state.canvasWidth; x++) {
                gridCtx.beginPath();
                gridCtx.moveTo(x, 0);
                gridCtx.lineTo(x, state.canvasHeight);
                gridCtx.stroke();
            }

            for (let y = 0; y <= state.canvasHeight; y++) {
                gridCtx.beginPath();
                gridCtx.moveTo(0, y);
                gridCtx.lineTo(state.canvasWidth, y);
                gridCtx.stroke();
            }
        }

        // ===== PALETTE =====
        function loadPalette(name) {
            state.palette = [...PALETTES[name]];
            state.currentColor = state.palette[0];
            renderPalette();
        }

        function renderPalette() {
            const grid = document.getElementById('paletteGrid');
            const mobile = document.getElementById('mobilePalette');

            grid.innerHTML = '';
            mobile.innerHTML = '';

            state.palette.forEach((color, i) => {
                // Desktop
                const div = document.createElement('div');
                div.className = 'palette-color' + (color === state.currentColor ? ' active' : '');
                div.style.background = color;
                div.onclick = () => selectColor(color);
                grid.appendChild(div);

                // Mobile
                const mDiv = document.createElement('div');
                mDiv.className = 'mobile-palette-color' + (color === state.currentColor ? ' active' : '');
                mDiv.style.background = color;
                mDiv.onclick = () => selectColor(color);
                mobile.appendChild(mDiv);
            });

            updateCurrentColor();
        }

        function selectColor(color) {
            state.currentColor = color;

            // If dither tool is active, update the selected dither slot
            if (state.currentTool === 'dither') {
                state.ditherColors[state.ditherActiveSlot - 1] = color;
                updateDitherUI();
            }

            renderPalette();
        }

        function updateCurrentColor() {
            document.getElementById('currentColor').style.background = state.currentColor;
            document.getElementById('mobileCurrentColor').style.background = state.currentColor;
        }

        // ===== DITHER COLOR UI =====
        function updateDitherUI() {
            const slots = document.querySelectorAll('.dither-slot');
            slots.forEach((slot, i) => {
                slot.classList.toggle('active', (i + 1) === state.ditherActiveSlot);
                const swatch = slot.querySelector('.dither-swatch');
                const color = state.ditherColors[i];
                if (color) {
                    swatch.style.background = color;
                } else {
                    swatch.style.background = 'transparent';
                }
            });
        }

        function selectDitherSlot(slotNum) {
            state.ditherActiveSlot = slotNum;
            updateDitherUI();
        }

        function clearDitherSlot(slotNum) {
            state.ditherColors[slotNum - 1] = null;
            updateDitherUI();
        }

        // ===== TOOLS =====
        function setTool(tool) {
            state.currentTool = tool;
            state.lineStartPoint = null;
            state.ditherStartColor = null;
            state.pickingForReplace = false;
            clearPreview();

            // Hide eraser cursor when switching tools
            document.getElementById('eraserCursor').style.display = 'none';

            // Show/hide dither color picker
            const ditherPanel = document.getElementById('ditherColors');
            if (ditherPanel) {
                ditherPanel.style.display = (tool === 'dither') ? 'block' : 'none';
            }

            // Update UI
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tool === tool);
            });
            document.getElementById('statusTool').textContent = 'Tool: ' + tool.charAt(0).toUpperCase() + tool.slice(1);

            // Show replace color modal if needed
            if (tool === 'replace') {
                document.getElementById('replaceColorModal').classList.add('active');
            }
        }

        // ===== DRAWING =====
        function setPixel(x, y, color) {
            if (x < 0 || x >= state.canvasWidth || y < 0 || y >= state.canvasHeight) return;
            const layer = getCurrentLayer();
            if (!layer || layer.locked) return;
            const layerCtx = layer.ctx;

            if (color === null || color === 'transparent') {
                layerCtx.clearRect(x, y, 1, 1);
            } else {
                layerCtx.fillStyle = color;
                layerCtx.fillRect(x, y, 1, 1);
            }
        }

        function setBrushPixel(cx, cy, color) {
            // Draw a square brush centered on cx, cy
            const size = state.brushSize;
            const offset = Math.floor(size / 2);
            for (let dy = 0; dy < size; dy++) {
                for (let dx = 0; dx < size; dx++) {
                    setPixel(cx - offset + dx, cy - offset + dy, color);
                }
            }
        }

        function getPixel(x, y, fromComposite = false) {
            if (x < 0 || x >= state.canvasWidth || y < 0 || y >= state.canvasHeight) return null;
            // Read from current layer or composite view
            const targetCtx = fromComposite ? ctx : (getCurrentLayer()?.ctx || ctx);
            const data = targetCtx.getImageData(x, y, 1, 1).data;
            if (data[3] === 0) return null;
            return '#' + [data[0], data[1], data[2]].map(v => v.toString(16).padStart(2, '0')).join('');
        }

        function bresenhamLine(x0, y0, x1, y1, callback) {
            x0 = Math.floor(x0);
            y0 = Math.floor(y0);
            x1 = Math.floor(x1);
            y1 = Math.floor(y1);

            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = x0 < x1 ? 1 : -1;
            const sy = y0 < y1 ? 1 : -1;
            let err = dx - dy;

            while (true) {
                callback(x0, y0);
                if (x0 === x1 && y0 === y1) break;
                const e2 = 2 * err;
                if (e2 > -dy) { err -= dy; x0 += sx; }
                if (e2 < dx) { err += dx; y0 += sy; }
            }
        }

        function bresenhamEllipse(cx, cy, rx, ry, callback) {
            // Split ellipse: right +1, bottom +1 to create 2-pixel wide/tall center
            let x = 0, y = ry;
            let d1 = (ry * ry) - (rx * rx * ry) + (0.25 * rx * rx);
            let dx = 2 * ry * ry * x;
            let dy = 2 * rx * rx * y;

            while (dx < dy) {
                // 4 quadrants: right+1, bottom+1
                callback(cx + x + 1, cy + y + 1);  // bottom-right
                callback(cx - x, cy + y + 1);       // bottom-left
                callback(cx + x + 1, cy - y);       // top-right
                callback(cx - x, cy - y);           // top-left

                if (d1 < 0) {
                    x++;
                    dx += 2 * ry * ry;
                    d1 += dx + ry * ry;
                } else {
                    x++;
                    y--;
                    dx += 2 * ry * ry;
                    dy -= 2 * rx * rx;
                    d1 += dx - dy + ry * ry;
                }
            }

            let d2 = ((ry * ry) * ((x + 0.5) * (x + 0.5))) +
                     ((rx * rx) * ((y - 1) * (y - 1))) -
                     (rx * rx * ry * ry);

            while (y >= 0) {
                // 4 quadrants: right+1, bottom+1
                callback(cx + x + 1, cy + y + 1);  // bottom-right
                callback(cx - x, cy + y + 1);       // bottom-left
                callback(cx + x + 1, cy - y);       // top-right
                callback(cx - x, cy - y);           // top-left

                if (d2 > 0) {
                    y--;
                    dy -= 2 * rx * rx;
                    d2 += rx * rx - dy;
                } else {
                    y--;
                    x++;
                    dx += 2 * ry * ry;
                    dy -= 2 * rx * rx;
                    d2 += dx - dy + rx * rx;
                }
            }
        }

        function floodFill(startX, startY, fillColor) {
            startX = Math.floor(startX);
            startY = Math.floor(startY);

            const layer = getCurrentLayer();
            if (!layer || layer.locked) return;
            const layerCtx = layer.ctx;

            const imageData = layerCtx.getImageData(0, 0, state.canvasWidth, state.canvasHeight);
            const data = imageData.data;
            const targetColor = getColorAt(data, startX, startY);
            const fillRgba = hexToRgba(fillColor);

            if (colorsMatch(targetColor, fillRgba)) return;

            const stack = [[startX, startY]];
            const visited = new Set();

            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const key = x + ',' + y;

                if (visited.has(key)) continue;
                if (x < 0 || x >= state.canvasWidth || y < 0 || y >= state.canvasHeight) continue;

                const currentColor = getColorAt(data, x, y);
                if (!colorsMatch(currentColor, targetColor)) continue;

                visited.add(key);
                setColorAt(data, x, y, fillRgba);

                stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
            }

            layerCtx.putImageData(imageData, 0, 0);
            compositeAndRender();
        }

        function getColorAt(data, x, y) {
            const i = (y * state.canvasWidth + x) * 4;
            return [data[i], data[i + 1], data[i + 2], data[i + 3]];
        }

        function setColorAt(data, x, y, rgba) {
            const i = (y * state.canvasWidth + x) * 4;
            data[i] = rgba[0];
            data[i + 1] = rgba[1];
            data[i + 2] = rgba[2];
            data[i + 3] = rgba[3];
        }

        function colorsMatch(c1, c2) {
            return c1[0] === c2[0] && c1[1] === c2[1] && c1[2] === c2[2] && c1[3] === c2[3];
        }

        function hexToRgba(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return [r, g, b, 255];
        }

        function replaceColor(fromColor, toColor) {
            const layer = getCurrentLayer();
            if (!layer || layer.locked) return;
            const layerCtx = layer.ctx;

            const imageData = layerCtx.getImageData(0, 0, state.canvasWidth, state.canvasHeight);
            const data = imageData.data;
            const fromRgba = hexToRgba(fromColor);
            const toRgba = hexToRgba(toColor);

            for (let i = 0; i < data.length; i += 4) {
                if (data[i] === fromRgba[0] && data[i + 1] === fromRgba[1] &&
                    data[i + 2] === fromRgba[2] && data[i + 3] === 255) {
                    data[i] = toRgba[0];
                    data[i + 1] = toRgba[1];
                    data[i + 2] = toRgba[2];
                    data[i + 3] = toRgba[3];
                }
            }

            layerCtx.putImageData(imageData, 0, 0);
            compositeAndRender();
        }

        // ===== PREVIEW LAYER =====
        function clearPreview() {
            previewCtx.clearRect(0, 0, state.canvasWidth, state.canvasHeight);
        }

        function drawBrushPreview(cx, cy) {
            clearPreview();
            const size = state.brushSize;
            const offset = Math.floor(size / 2);

            // Draw semi-transparent preview of brush area
            previewCtx.fillStyle = state.currentTool === 'eraser'
                ? 'rgba(255, 100, 100, 0.4)'
                : 'rgba(255, 255, 255, 0.4)';

            for (let dy = 0; dy < size; dy++) {
                for (let dx = 0; dx < size; dx++) {
                    const px = cx - offset + dx;
                    const py = cy - offset + dy;
                    if (px >= 0 && px < state.canvasWidth && py >= 0 && py < state.canvasHeight) {
                        previewCtx.fillRect(px, py, 1, 1);
                    }
                }
            }

            // Draw outline
            previewCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            previewCtx.lineWidth = 1 / state.zoom;
            previewCtx.strokeRect(
                cx - offset + 0.5 / state.zoom,
                cy - offset + 0.5 / state.zoom,
                size - 1 / state.zoom,
                size - 1 / state.zoom
            );
        }

        function drawPreviewLine(x0, y0, x1, y1, color) {
            clearPreview();
            previewCtx.fillStyle = color;
            bresenhamLine(x0, y0, x1, y1, (x, y) => {
                previewCtx.fillRect(x, y, 1, 1);
            });
        }

        // Get pixel color from composite view (for dither tool)
        function getPixelColor(x, y) {
            return getPixel(x, y, true);
        }

        // Dither gradient preview - show gradient direction line
        function drawPreviewDither(x0, y0, x1, y1) {
            clearPreview();
            const colors = state.ditherColors;

            // Draw a dithered line to show gradient direction
            const points = [];
            bresenhamLine(x0, y0, x1, y1, (x, y) => points.push({x, y}));

            if (points.length === 0) return;

            // Draw dithered preview line showing gradient direction
            points.forEach((p, i) => {
                const t = points.length > 1 ? i / (points.length - 1) : 0;
                const color = ditherPixel3(t, colors[0], colors[1], colors[2], p.x, p.y);
                previewCtx.fillStyle = color;
                previewCtx.fillRect(p.x, p.y, 1, 1);
            });

            // Draw start and end markers
            previewCtx.fillStyle = colors[0] || '#000';
            previewCtx.fillRect(x0 - 1, y0, 3, 1);
            previewCtx.fillRect(x0, y0 - 1, 1, 3);
            previewCtx.fillStyle = colors[2] || '#fff';
            previewCtx.fillRect(x1 - 1, y1, 3, 1);
            previewCtx.fillRect(x1, y1 - 1, 1, 3);
        }

        // Draw dithered gradient FILL between two points (like bucket but gradient)
        function drawDitherGradient(x0, y0, x1, y1) {
            const layer = getCurrentLayer();
            if (!layer) return;

            const colors = state.ditherColors;
            const layerCtx = layer.ctx;
            const imageData = layerCtx.getImageData(0, 0, state.canvasWidth, state.canvasHeight);
            const data = imageData.data;

            // Get the color at start point to determine what to fill
            const targetColor = getColorAt(data, x0, y0);

            // Calculate gradient direction and length
            const dx = x1 - x0;
            const dy = y1 - y0;
            const gradientLength = Math.sqrt(dx * dx + dy * dy);

            if (gradientLength === 0) {
                // Same point - just fill solid
                floodFill(x0, y0, colors[0]);
                return;
            }

            // Normalize direction
            const dirX = dx / gradientLength;
            const dirY = dy / gradientLength;

            // Flood fill with gradient
            const stack = [[x0, y0]];
            const visited = new Set();

            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const key = x + ',' + y;

                if (visited.has(key)) continue;
                if (x < 0 || x >= state.canvasWidth || y < 0 || y >= state.canvasHeight) continue;

                const currentColor = getColorAt(data, x, y);
                if (!colorsMatch(currentColor, targetColor)) continue;

                visited.add(key);

                // Calculate gradient position (how far along the gradient direction)
                const projX = x - x0;
                const projY = y - y0;
                const dist = projX * dirX + projY * dirY; // Dot product = projection
                const t = Math.max(0, Math.min(1, dist / gradientLength));

                // Apply dithering with 3 colors
                const color = ditherPixel3(t, colors[0], colors[1], colors[2], x, y);
                const rgba = hexToRgba(color);
                setColorAt(data, x, y, rgba);

                stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
            }

            layerCtx.putImageData(imageData, 0, 0);
            compositeAndRender();
        }

        // Calculate dithered color based on position and threshold (2 colors)
        function ditherPixel(t, color1, color2, x, y) {
            // Bayer 4x4 dither matrix (normalized to 0-1)
            const bayer = [
                [0/16, 8/16, 2/16, 10/16],
                [12/16, 4/16, 14/16, 6/16],
                [3/16, 11/16, 1/16, 9/16],
                [15/16, 7/16, 13/16, 5/16]
            ];

            const threshold = bayer[y % 4][x % 4];

            // If t is greater than threshold, use color2, else color1
            return t > threshold ? color2 : color1;
        }

        // Get dither threshold based on pattern type
        function getDitherThreshold(x, y, pattern) {
            switch(pattern) {
                case 'bayer':
                    // Bayer 4x4 ordered dither - smooth gradients
                    const bayer = [
                        [0/16, 8/16, 2/16, 10/16],
                        [12/16, 4/16, 14/16, 6/16],
                        [3/16, 11/16, 1/16, 9/16],
                        [15/16, 7/16, 13/16, 5/16]
                    ];
                    return bayer[y % 4][x % 4];
                case 'checker':
                    // Checkerboard pattern - classic 50% dither look
                    return (x + y) % 2 === 0 ? 0.25 : 0.75;
                case 'hlines':
                    // Horizontal lines - good for sky, metal
                    return y % 2 === 0 ? 0.25 : 0.75;
                case 'vlines':
                    // Vertical lines - good for rain, waterfalls
                    return x % 2 === 0 ? 0.25 : 0.75;
                case 'noise':
                    // Pseudo-random noise - organic textures
                    const n = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
                    return n - Math.floor(n);
                default:
                    return 0.5;
            }
        }

        // Calculate dithered color with 3 colors (start, middle optional, end)
        function ditherPixel3(t, color1, color2, color3, x, y) {
            const threshold = getDitherThreshold(x, y, state.ditherPattern);

            // If no middle color, just use 2-color dither
            if (!color2) {
                return t > threshold ? color3 : color1;
            }

            // 3-color gradient: split into two segments
            // 0.0-0.5: color1 -> color2
            // 0.5-1.0: color2 -> color3
            if (t < 0.5) {
                // First half: dither between color1 and color2
                const localT = t * 2; // Remap 0-0.5 to 0-1
                return localT > threshold ? color2 : color1;
            } else {
                // Second half: dither between color2 and color3
                const localT = (t - 0.5) * 2; // Remap 0.5-1 to 0-1
                return localT > threshold ? color3 : color2;
            }
        }

        function drawPreviewRect(x0, y0, x1, y1, color) {
            clearPreview();
            previewCtx.fillStyle = color;

            const minX = Math.min(x0, x1);
            const maxX = Math.max(x0, x1);
            const minY = Math.min(y0, y1);
            const maxY = Math.max(y0, y1);

            for (let x = minX; x <= maxX; x++) {
                previewCtx.fillRect(x, minY, 1, 1);
                previewCtx.fillRect(x, maxY, 1, 1);
            }
            for (let y = minY; y <= maxY; y++) {
                previewCtx.fillRect(minX, y, 1, 1);
                previewCtx.fillRect(maxX, y, 1, 1);
            }
        }

        function drawPreviewEllipse(x0, y0, x1, y1, color) {
            clearPreview();
            previewCtx.fillStyle = color;

            const cx = Math.floor((x0 + x1) / 2);
            const cy = Math.floor((y0 + y1) / 2);
            const rx = Math.floor(Math.abs(x1 - x0) / 2);
            const ry = Math.floor(Math.abs(y1 - y0) / 2);

            if (rx === 0 || ry === 0) {
                bresenhamLine(x0, y0, x1, y1, (x, y) => previewCtx.fillRect(x, y, 1, 1));
            } else {
                bresenhamEllipse(cx, cy, rx, ry, (x, y) => {
                    if (x >= 0 && x < state.canvasWidth && y >= 0 && y < state.canvasHeight) {
                        previewCtx.fillRect(x, y, 1, 1);
                    }
                });
            }
        }

        // ===== EVENT HANDLING =====
        function setupEventListeners() {
            // Tool buttons
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.onclick = () => setTool(btn.dataset.tool);
            });

            // Dither color slots
            document.querySelectorAll('.dither-slot').forEach(slot => {
                slot.onclick = () => selectDitherSlot(parseInt(slot.dataset.slot));
                // Double-click to clear middle slot
                slot.ondblclick = () => {
                    if (slot.dataset.slot === '2') {
                        clearDitherSlot(2);
                    }
                };
            });

            // Dither pattern buttons
            document.querySelectorAll('.dither-pattern-btn').forEach(btn => {
                btn.onclick = () => {
                    state.ditherPattern = btn.dataset.pattern;
                    // Update active state
                    document.querySelectorAll('.dither-pattern-btn').forEach(b => {
                        b.classList.toggle('active', b === btn);
                    });
                };
            });

            // Canvas events
            canvasContainer.addEventListener('mousedown', handlePointerStart);
            canvasContainer.addEventListener('mousemove', handlePointerMove);
            canvasContainer.addEventListener('mouseup', handlePointerEnd);
            canvasContainer.addEventListener('mouseleave', handlePointerEnd);
            canvasContainer.addEventListener('wheel', handleWheel, { passive: false });

            canvasContainer.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvasContainer.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvasContainer.addEventListener('touchend', handleTouchEnd, { passive: false });

            // Top bar actions
            document.getElementById('undoBtn').onclick = undo;
            document.getElementById('redoBtn').onclick = redo;
            document.getElementById('mobileUndoBtn').onclick = undo;
            document.getElementById('mobileRedoBtn').onclick = redo;
            document.getElementById('gridBtn').onclick = toggleGrid;
            document.getElementById('saveBtn').onclick = exportPNG;
            document.getElementById('menuBtn').onclick = () => document.getElementById('menuModal').classList.add('active');
            document.getElementById('authBtn').onclick = () => {
                if (state.user) {
                    signOut();
                } else {
                    signInWithGoogle();
                }
            };

            // Menu modal
            document.getElementById('closeMenuBtn').onclick = () => document.getElementById('menuModal').classList.remove('active');
            document.getElementById('newCanvasBtn').onclick = () => {
                document.getElementById('menuModal').classList.remove('active');
                document.getElementById('newCanvasModal').classList.add('active');
            };
            document.getElementById('exportPngBtn').onclick = () => {
                document.getElementById('menuModal').classList.remove('active');
                exportPNG();
            };
            document.getElementById('paletteGenMenuBtn').onclick = () => {
                document.getElementById('menuModal').classList.remove('active');
                showPaletteGenerator();
            };
            document.getElementById('importImageBtn').onclick = () => {
                document.getElementById('menuModal').classList.remove('active');
                importImage();
            };

            // New canvas modal
            document.getElementById('cancelNewCanvas').onclick = () => document.getElementById('newCanvasModal').classList.remove('active');
            document.getElementById('createNewCanvas').onclick = createNewCanvas;
            document.getElementById('sizePreset').onchange = (e) => {
                if (e.target.value) {
                    document.getElementById('newWidth').value = e.target.value;
                    document.getElementById('newHeight').value = e.target.value;
                }
            };

            // Replace color modal
            document.getElementById('cancelReplace').onclick = () => {
                document.getElementById('replaceColorModal').classList.remove('active');
                state.pickingForReplace = false;
                document.getElementById('pickFromBtn').classList.remove('active');
                setTool('pencil');
            };
            document.getElementById('doReplace').onclick = () => {
                const from = document.getElementById('replaceFromInput').value;
                const to = document.getElementById('replaceToInput').value;
                saveState();
                replaceColor(from, to);
                saveState();
                document.getElementById('replaceColorModal').classList.remove('active');
                state.pickingForReplace = false;
                setTool('pencil');
                showToast('Colors replaced!');
            };
            document.getElementById('replaceFromInput').oninput = (e) => {
                document.getElementById('replaceFromColor').style.background = e.target.value;
            };
            document.getElementById('replaceToInput').oninput = (e) => {
                document.getElementById('replaceToColor').style.background = e.target.value;
            };
            document.getElementById('pickFromBtn').onclick = () => {
                state.pickingForReplace = true;
                document.getElementById('pickFromBtn').classList.add('active');
                document.getElementById('replaceColorModal').classList.remove('active');
                showToast('Tap a color on the canvas');
            };
            document.getElementById('useCurrentBtn').onclick = () => {
                document.getElementById('replaceToInput').value = state.currentColor;
                document.getElementById('replaceToColor').style.background = state.currentColor;
            };

            // Palette generator modal
            document.getElementById('paletteGenBtn').onclick = showPaletteGenerator;
            document.getElementById('cancelPaletteGen').onclick = () => {
                document.getElementById('paletteGenModal').classList.remove('active');
                state.selectedColors.clear();
            };
            document.getElementById('applyPalette').onclick = applyGeneratedPalette;
            document.getElementById('baseColor').oninput = updatePalettePreview;
            document.getElementById('harmonyType').onchange = (e) => {
                // Show/hide analogous controls
                const isAnalogous = e.target.value === 'analogous';
                document.getElementById('analogousAddTop').style.display = isAnalogous ? 'flex' : 'none';
                document.getElementById('analogousAddBottom').style.display = isAnalogous ? 'flex' : 'none';
                updatePalettePreview();
            };

            // Analogous row controls (top = cool direction, bottom = warm direction)
            function updateAnalogousRows() {
                state.selectedColors.clear();
                updatePalettePreview();
            }

            document.getElementById('addRowTop').onclick = () => {
                if (state.analogousCoolRows < 5) {
                    state.analogousCoolRows++;
                    updateAnalogousRows();
                }
            };
            document.getElementById('removeRowTop').onclick = () => {
                if (state.analogousCoolRows > 0) {
                    state.analogousCoolRows--;
                    updateAnalogousRows();
                }
            };
            document.getElementById('addRowBottom').onclick = () => {
                if (state.analogousWarmRows < 5) {
                    state.analogousWarmRows++;
                    updateAnalogousRows();
                }
            };
            document.getElementById('removeRowBottom').onclick = () => {
                if (state.analogousWarmRows > 0) {
                    state.analogousWarmRows--;
                    updateAnalogousRows();
                }
            };

            document.getElementById('rampSize').oninput = (e) => {
                document.getElementById('rampSizeVal').textContent = e.target.value;
                state.selectedColors.clear(); // Reset selection when changing size
                updatePalettePreview();
            };
            document.getElementById('hueShift').oninput = (e) => {
                document.getElementById('hueShiftVal').textContent = e.target.value;
                updatePalettePreview();
            };
            document.getElementById('tempShift').oninput = (e) => {
                document.getElementById('tempShiftVal').textContent = e.target.value;
                updatePalettePreview();
            };
            document.getElementById('selectAllColors').onclick = selectAllColors;
            document.getElementById('deselectAllColors').onclick = deselectAllColors;
            document.getElementById('invertSelection').onclick = invertColorSelection;

            // Palette save/load/download
            document.getElementById('downloadPalette').onclick = downloadPalette;
            document.getElementById('savePaletteBtn').onclick = saveGeneratedPalette;
            document.getElementById('loadSavedPalette').onclick = loadSavedPalette;
            document.getElementById('deleteSavedPalette').onclick = deleteSavedPalette;
            loadSavedPalettesList();

            // Palette select
            document.getElementById('paletteSelect').onchange = (e) => loadPalette(e.target.value);

            // Brush size selects
            document.getElementById('brushSizeSelect').onchange = (e) => {
                state.brushSize = parseInt(e.target.value);
                document.getElementById('mobileBrushSize').value = e.target.value;
            };
            document.getElementById('mobileBrushSize').onchange = (e) => {
                state.brushSize = parseInt(e.target.value);
                document.getElementById('brushSizeSelect').value = e.target.value;
            };

            // Keyboard shortcuts
            document.addEventListener('keydown', handleKeyDown);

            // Window resize
            window.addEventListener('resize', updateCanvasSize);

            // Selection toolbar buttons - use event delegation for reliability
            document.getElementById('selectionToolbar').addEventListener('click', (e) => {
                const btn = e.target.closest('.sel-action');
                if (btn && btn.dataset.action) {
                    e.preventDefault();
                    e.stopPropagation();
                    selectionAction(btn.dataset.action);
                }
            });
            // Also handle touch for mobile
            document.getElementById('selectionToolbar').addEventListener('touchend', (e) => {
                const btn = e.target.closest('.sel-action');
                if (btn && btn.dataset.action) {
                    e.preventDefault();
                    e.stopPropagation();
                    selectionAction(btn.dataset.action);
                }
            });
        }

        function getCanvasCoords(e) {
            const rect = mainCanvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / state.zoom);
            const y = Math.floor((e.clientY - rect.top) / state.zoom);
            return { x, y };
        }

        function isModalOpen() {
            return document.querySelector('.modal-overlay.active') !== null;
        }

        function handlePointerStart(e) {
            if (e.button !== 0) return; // Only left click
            if (isModalOpen()) return; // Don't draw when modal is open

            const { x, y } = getCanvasCoords(e);
            state.isDrawing = true;

            handleToolStart(x, y);
        }

        function handlePointerMove(e) {
            const { x, y } = getCanvasCoords(e);

            // Update status
            document.getElementById('statusPos').textContent = `Pos: ${x}, ${y}`;

            // Update debug overlay
            updateDebugOverlay(e);

            // Update eraser cursor
            updateEraserCursor(e, x, y);

            if (!state.isDrawing) {
                // Preview for shape tools
                if (state.lineStartPoint && ['line', 'rect', 'ellipse'].includes(state.currentTool)) {
                    const start = state.lineStartPoint;
                    if (state.currentTool === 'line') {
                        drawPreviewLine(start.x, start.y, x, y, state.currentColor);
                    } else if (state.currentTool === 'rect') {
                        drawPreviewRect(start.x, start.y, x, y, state.currentColor);
                    } else if (state.currentTool === 'ellipse') {
                        drawPreviewEllipse(start.x, start.y, x, y, state.currentColor);
                    }
                } else if (['pencil', 'eraser'].includes(state.currentTool)) {
                    // Show brush preview
                    drawBrushPreview(x, y);
                } else {
                    clearPreview();
                }
                return;
            }

            handleToolMove(x, y);
        }

        function updateEraserCursor(e, gridX, gridY) {
            const cursor = document.getElementById('eraserCursor');
            if (state.currentTool !== 'eraser') {
                cursor.style.display = 'none';
                return;
            }

            cursor.style.display = 'block';
            cursor.style.width = state.zoom + 'px';
            cursor.style.height = state.zoom + 'px';
            cursor.style.left = (gridX * state.zoom) + 'px';
            cursor.style.top = (gridY * state.zoom) + 'px';
        }

        function handlePointerEnd(e) {
            // Clear brush preview when leaving canvas
            clearPreview();

            if (!state.isDrawing) return;
            state.isDrawing = false;

            const { x, y } = getCanvasCoords(e);
            handleToolEnd(x, y);
        }

        // Touch handling
        let touchState = {
            touches: [],
            isPinching: false,
            lastPinchDist: 0,
            lastPinchCenter: null,
            longPressTimer: null,
            longPressTriggered: false,
            drawDelayTimer: null,
            pendingDrawStart: null,
            smoothZoom: null,
            rafPending: false
        };

        function handleTouchStart(e) {
            // Don't handle canvas touches when modal is open
            if (isModalOpen()) return;

            e.preventDefault();

            // Clear any existing long press timer
            if (touchState.longPressTimer) {
                clearTimeout(touchState.longPressTimer);
                touchState.longPressTimer = null;
            }
            touchState.longPressTriggered = false;

            if (e.touches.length === 2) {
                // Start pinch zoom - cancel any pending draw
                if (touchState.drawDelayTimer) {
                    clearTimeout(touchState.drawDelayTimer);
                    touchState.drawDelayTimer = null;
                }
                touchState.isPinching = true;
                const dist = getTouchDistance(e.touches[0], e.touches[1]);
                touchState.lastPinchDist = dist;
                touchState.lastPinchCenter = getTouchCenter(e.touches[0], e.touches[1]);
                state.isDrawing = false;
                return;
            }

            if (e.touches.length === 1) {
                const touch = e.touches[0];
                const { x, y } = getCanvasCoords(touch);

                // Start long press timer for paste
                touchState.longPressTimer = setTimeout(() => {
                    if (state.clipboard) {
                        touchState.longPressTriggered = true;
                        state.isDrawing = false;
                        pasteClipboard();
                    }
                }, 500);

                // Delay draw start to allow for pinch gesture detection
                touchState.pendingDrawStart = { x, y };
                touchState.drawDelayTimer = setTimeout(() => {
                    if (!touchState.isPinching && touchState.pendingDrawStart) {
                        state.isDrawing = true;
                        handleToolStart(touchState.pendingDrawStart.x, touchState.pendingDrawStart.y);
                        touchState.pendingDrawStart = null;
                    }
                    touchState.drawDelayTimer = null;
                }, 60); // 60ms delay to detect second finger
            }
        }

        function handleTouchMove(e) {
            if (isModalOpen()) return;
            e.preventDefault();

            // Cancel long press on any movement
            if (touchState.longPressTimer) {
                clearTimeout(touchState.longPressTimer);
                touchState.longPressTimer = null;
            }

            if (e.touches.length === 2 && touchState.isPinching) {
                // Pinch zoom - smooth floating point zoom
                const dist = getTouchDistance(e.touches[0], e.touches[1]);
                const center = getTouchCenter(e.touches[0], e.touches[1]);

                const scale = dist / touchState.lastPinchDist;

                // Use floating point for smooth zoom, clamp to valid range
                if (!touchState.smoothZoom) touchState.smoothZoom = state.zoom;
                touchState.smoothZoom = Math.max(1, Math.min(32, touchState.smoothZoom * scale));

                // Apply zoom (will be used by transform)
                state.zoom = touchState.smoothZoom;

                // Pan with center offset
                if (touchState.lastPinchCenter) {
                    const dx = center.x - touchState.lastPinchCenter.x;
                    const dy = center.y - touchState.lastPinchCenter.y;
                    state.panX += dx;
                    state.panY += dy;
                }

                // Use requestAnimationFrame for smooth updates
                if (!touchState.rafPending) {
                    touchState.rafPending = true;
                    requestAnimationFrame(() => {
                        updateCanvasSize();
                        touchState.rafPending = false;
                    });
                }

                touchState.lastPinchDist = dist;
                touchState.lastPinchCenter = center;
                return;
            }

            if (e.touches.length === 1 && state.isDrawing) {
                const touch = e.touches[0];
                const { x, y } = getCanvasCoords(touch);
                document.getElementById('statusPos').textContent = `Pos: ${x}, ${y}`;
                handleToolMove(x, y);
            }
        }

        function handleTouchEnd(e) {
            if (isModalOpen()) return;
            e.preventDefault();

            // Clear long press timer
            if (touchState.longPressTimer) {
                clearTimeout(touchState.longPressTimer);
                touchState.longPressTimer = null;
            }

            // Clear draw delay timer
            if (touchState.drawDelayTimer) {
                clearTimeout(touchState.drawDelayTimer);
                touchState.drawDelayTimer = null;
            }

            // If there's a pending draw that never started (quick tap), execute it now
            const pendingTap = touchState.pendingDrawStart;
            touchState.pendingDrawStart = null;

            if (e.touches.length === 0) {
                // Finalize pinch zoom - round to nearest integer and redraw grid
                if (touchState.isPinching && touchState.smoothZoom) {
                    state.zoom = Math.round(touchState.smoothZoom);
                    touchState.smoothZoom = null;
                    updateCanvasSize();
                    drawGrid();
                }
                touchState.isPinching = false;

                // Skip normal handling if long press was triggered
                if (touchState.longPressTriggered) {
                    touchState.longPressTriggered = false;
                    state.isDrawing = false;
                    return;
                }

                // Handle quick tap - draw wasn't started yet but we have pending coords
                if (pendingTap && !state.isDrawing) {
                    handleToolStart(pendingTap.x, pendingTap.y);
                    handleToolEnd(pendingTap.x, pendingTap.y);
                    autoSave();
                    return;
                }

                if (state.isDrawing) {
                    state.isDrawing = false;
                    // Use last known position
                    handleToolEnd(state.lastX, state.lastY);
                }
            }
        }

        function getTouchDistance(t1, t2) {
            const dx = t2.clientX - t1.clientX;
            const dy = t2.clientY - t1.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function getTouchCenter(t1, t2) {
            return {
                x: (t1.clientX + t2.clientX) / 2,
                y: (t1.clientY + t2.clientY) / 2
            };
        }

        function handleWheel(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? -1 : 1;
            let newZoom = state.zoom + delta;
            newZoom = Math.max(1, Math.min(32, newZoom));

            if (newZoom !== state.zoom) {
                state.zoom = newZoom;
                updateCanvasSize();
                drawGrid();
            }
        }

        // ===== TOOL HANDLING =====
        function handleToolStart(x, y) {
            // Handle picking for replace color
            if (state.pickingForReplace) {
                const color = getPixel(x, y);
                if (color) {
                    document.getElementById('replaceFromInput').value = color;
                    document.getElementById('replaceFromColor').style.background = color;
                    showToast('Picked: ' + color);
                } else {
                    showToast('No color at that pixel');
                }
                state.pickingForReplace = false;
                document.getElementById('pickFromBtn').classList.remove('active');
                document.getElementById('replaceColorModal').classList.add('active');
                return;
            }

            state.lastX = x;
            state.lastY = y;

            switch (state.currentTool) {
                case 'pencil':
                    saveState();
                    setBrushPixel(x, y, state.currentColor);
                    compositeAndRender();
                    break;
                case 'eraser':
                    saveState();
                    setBrushPixel(x, y, null);
                    compositeAndRender();
                    break;
                case 'line':
                case 'rect':
                case 'ellipse':
                    if (!state.lineStartPoint) {
                        // First tap - set start point
                        state.lineStartPoint = { x, y };
                        showToast('Tap to set end point, or drag');
                    } else {
                        // Second tap - draw shape
                        saveState();
                        drawShape(state.lineStartPoint.x, state.lineStartPoint.y, x, y);
                        state.lineStartPoint = null;
                        clearPreview();
                    }
                    break;
                case 'dither':
                    if (!state.lineStartPoint) {
                        // First tap - set start point
                        state.lineStartPoint = { x, y };
                        showToast('Tap end point for gradient');
                    } else {
                        // Second tap - draw dither gradient using colors from UI
                        saveState();
                        drawDitherGradient(state.lineStartPoint.x, state.lineStartPoint.y, x, y);
                        state.lineStartPoint = null;
                        clearPreview();
                    }
                    break;
                case 'fill':
                    saveState();
                    floodFill(x, y, state.currentColor);
                    break;
                case 'eyedropper':
                    const color = getPixel(x, y);
                    if (color) {
                        selectColor(color);
                        showToast('Color: ' + color);
                    }
                    break;
                case 'select':
                    // If we have a floating selection, start dragging it
                    if (state.selection.floating) {
                        state.dragStartX = x;
                        state.dragStartY = y;
                        break;
                    }
                    // If there's an active selection, just deselect on tap
                    if (state.selection.active) {
                        clearSelection();
                        break;
                    }
                    // Two-tap selection like line tool
                    if (!state.lineStartPoint) {
                        state.lineStartPoint = { x, y };
                        showToast('Tap to set opposite corner, or drag');
                    } else {
                        setRectangularSelection(state.lineStartPoint.x, state.lineStartPoint.y, x, y);
                        state.lineStartPoint = null;
                        clearPreview();
                    }
                    break;
                case 'lasso':
                    // If we have a floating selection, commit it first
                    if (state.selection.floating) {
                        commitFloatingSelection();
                    }
                    // Start new lasso
                    clearSelection();
                    state.lassoStart = { x, y };
                    state.lassoPixels = [{ x, y }];
                    // Mark starting pixel
                    showLassoStart(x, y);
                    break;
            }
        }

        function handleToolMove(x, y) {
            if (x === state.lastX && y === state.lastY) return;

            switch (state.currentTool) {
                case 'pencil':
                    bresenhamLine(state.lastX, state.lastY, x, y, (px, py) => {
                        setBrushPixel(px, py, state.currentColor);
                    });
                    compositeAndRender();
                    break;
                case 'eraser':
                    bresenhamLine(state.lastX, state.lastY, x, y, (px, py) => {
                        setBrushPixel(px, py, null);
                    });
                    compositeAndRender();
                    break;
                case 'line':
                    if (state.lineStartPoint) {
                        drawPreviewLine(state.lineStartPoint.x, state.lineStartPoint.y, x, y, state.currentColor);
                    }
                    break;
                case 'dither':
                    if (state.lineStartPoint) {
                        // Preview the dither gradient
                        drawPreviewDither(state.lineStartPoint.x, state.lineStartPoint.y, x, y);
                    }
                    break;
                case 'rect':
                    if (state.lineStartPoint) {
                        drawPreviewRect(state.lineStartPoint.x, state.lineStartPoint.y, x, y, state.currentColor);
                    }
                    break;
                case 'ellipse':
                    if (state.lineStartPoint) {
                        drawPreviewEllipse(state.lineStartPoint.x, state.lineStartPoint.y, x, y, state.currentColor);
                    }
                    break;
                case 'select':
                    // Preview selection rectangle
                    if (state.lineStartPoint) {
                        drawPreviewSelection(state.lineStartPoint.x, state.lineStartPoint.y, x, y);
                    }
                    // Handle floating selection movement
                    if (state.selection.floating) {
                        const dx = x - state.lastX;
                        const dy = y - state.lastY;
                        moveFloatingSelection(dx, dy);
                    }
                    break;
                case 'lasso':
                    // Add pixel to lasso path using Bresenham for smooth line
                    if (state.lassoStart) {
                        bresenhamLine(state.lastX, state.lastY, x, y, (px, py) => {
                            // Only add if within canvas and not duplicate
                            if (px >= 0 && px < state.canvasWidth && py >= 0 && py < state.canvasHeight) {
                                const last = state.lassoPixels[state.lassoPixels.length - 1];
                                if (!last || last.x !== px || last.y !== py) {
                                    state.lassoPixels.push({ x: px, y: py });
                                }
                            }
                        });
                        drawLassoPreview();
                    }
                    break;
            }

            state.lastX = x;
            state.lastY = y;
        }

        function handleToolEnd(x, y) {
            // For drag-based shape tools
            if (['line', 'rect', 'ellipse'].includes(state.currentTool) && state.lineStartPoint) {
                // If we dragged (start != end), draw the shape
                if (state.lineStartPoint.x !== x || state.lineStartPoint.y !== y) {
                    saveState();
                    drawShape(state.lineStartPoint.x, state.lineStartPoint.y, x, y);
                    state.lineStartPoint = null;
                    clearPreview();
                }
            }

            // For dither gradient drag
            if (state.currentTool === 'dither' && state.lineStartPoint) {
                if (state.lineStartPoint.x !== x || state.lineStartPoint.y !== y) {
                    saveState();
                    drawDitherGradient(state.lineStartPoint.x, state.lineStartPoint.y, x, y);
                    state.lineStartPoint = null;
                    clearPreview();
                }
            }

            // For select tool drag (new selection)
            if (state.currentTool === 'select' && state.lineStartPoint) {
                if (state.lineStartPoint.x !== x || state.lineStartPoint.y !== y) {
                    setRectangularSelection(state.lineStartPoint.x, state.lineStartPoint.y, x, y);
                    state.lineStartPoint = null;
                    clearPreview();
                }
            }

            // For floating selection - commit on mouse/touch up
            if (state.currentTool === 'select' && state.selection.floating) {
                commitFloatingSelection();
            }

            // For lasso tool
            if (state.currentTool === 'lasso' && state.lassoStart && state.lassoPixels.length > 2) {
                // Check if we're close enough to the start to close the loop
                const start = state.lassoStart;
                const dist = Math.sqrt((x - start.x) ** 2 + (y - start.y) ** 2);

                // Only close if returning to start point
                if (dist <= 6) {
                    setLassoSelection(state.lassoPixels);
                } else {
                    showToast('Return to green start');
                }

                // Clear lasso state
                state.lassoStart = null;
                state.lassoPixels = [];
                hideLassoStart();
                clearPreview();
            }

            compositeAndRender();
            autoSave();
        }

        function drawShape(x0, y0, x1, y1) {
            switch (state.currentTool) {
                case 'line':
                    bresenhamLine(x0, y0, x1, y1, (x, y) => setPixel(x, y, state.currentColor));
                    break;
                case 'rect':
                    const minX = Math.min(x0, x1);
                    const maxX = Math.max(x0, x1);
                    const minY = Math.min(y0, y1);
                    const maxY = Math.max(y0, y1);

                    for (let x = minX; x <= maxX; x++) {
                        setPixel(x, minY, state.currentColor);
                        setPixel(x, maxY, state.currentColor);
                    }
                    for (let y = minY; y <= maxY; y++) {
                        setPixel(minX, y, state.currentColor);
                        setPixel(maxX, y, state.currentColor);
                    }
                    break;
                case 'ellipse':
                    const cx = Math.floor((x0 + x1) / 2);
                    const cy = Math.floor((y0 + y1) / 2);
                    const rx = Math.floor(Math.abs(x1 - x0) / 2);
                    const ry = Math.floor(Math.abs(y1 - y0) / 2);

                    if (rx === 0 || ry === 0) {
                        bresenhamLine(x0, y0, x1, y1, (x, y) => setPixel(x, y, state.currentColor));
                    } else {
                        bresenhamEllipse(cx, cy, rx, ry, (x, y) => setPixel(x, y, state.currentColor));
                    }
                    break;
            }
        }

        // ===== KEYBOARD SHORTCUTS =====
        function handleKeyDown(e) {
            // Ignore if typing in input
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

            const key = e.key.toLowerCase();

            if (e.ctrlKey || e.metaKey) {
                switch (key) {
                    case 'z':
                        e.preventDefault();
                        if (e.shiftKey) redo();
                        else undo();
                        break;
                    case 'y':
                        e.preventDefault();
                        redo();
                        break;
                    case 's':
                        e.preventDefault();
                        exportPNG();
                        break;
                    case 'a':
                        e.preventDefault();
                        selectAll();
                        break;
                    case 'c':
                        e.preventDefault();
                        if (state.selection.active) selectionAction('copy');
                        break;
                    case 'x':
                        e.preventDefault();
                        if (state.selection.active) selectionAction('cut');
                        break;
                    case 'v':
                        e.preventDefault();
                        pasteClipboard();
                        break;
                    case 'd':
                        e.preventDefault();
                        clearSelection();
                        break;
                }
                return;
            }

            switch (key) {
                case 'p': setTool('pencil'); break;
                case 'e': setTool('eraser'); break;
                case 'l': setTool('line'); break;
                case 'g': setTool('dither'); break;
                case 'r': setTool('rect'); break;
                case 'o': setTool('ellipse'); break;
                case 'f': setTool('fill'); break;
                case 'i': setTool('eyedropper'); break;
                case 'c': setTool('replace'); break;
                case 's': setTool('select'); break;
                case 'q': setTool('lasso'); break;
                case 'g': toggleGrid(); break;
                case '`': toggleDebug(); break;
                case '=':
                case '+':
                    state.zoom = Math.min(32, state.zoom + 1);
                    updateCanvasSize();
                    drawGrid();
                    break;
                case '-':
                    state.zoom = Math.max(1, state.zoom - 1);
                    updateCanvasSize();
                    drawGrid();
                    break;
                case 'escape':
                    state.lineStartPoint = null;
                    state.lassoStart = null;
                    state.lassoPixels = [];
                    hideLassoStart();
                    clearPreview();
                    if (state.selection.floating) {
                        commitFloatingSelection();
                    }
                    break;
                case 'delete':
                case 'backspace':
                    if (state.selection.active) {
                        e.preventDefault();
                        selectionAction('delete');
                    }
                    break;
            }
        }

        // ===== UNDO/REDO =====
        function saveState() {
            // Save current layer's state
            const layer = getCurrentLayer();
            if (!layer) return;

            const imageData = layer.ctx.getImageData(0, 0, state.canvasWidth, state.canvasHeight);
            const undoEntry = {
                layerIndex: state.currentLayerIndex,
                imageData: imageData
            };
            state.undoStack.push(undoEntry);
            if (state.undoStack.length > state.maxHistory) {
                state.undoStack.shift();
            }
            state.redoStack = [];
            updateUndoRedoButtons();
        }

        function undo() {
            if (state.undoStack.length <= 1) return;

            const currentEntry = state.undoStack.pop();
            state.redoStack.push(currentEntry);

            const prevEntry = state.undoStack[state.undoStack.length - 1];

            // Restore to the correct layer
            const targetLayer = state.layers[prevEntry.layerIndex];
            if (targetLayer) {
                targetLayer.ctx.putImageData(prevEntry.imageData, 0, 0);
            }

            compositeAndRender();
            updateUndoRedoButtons();
            updateLayersPanel();
            autoSave();
        }

        function redo() {
            if (state.redoStack.length === 0) return;

            const nextEntry = state.redoStack.pop();
            state.undoStack.push(nextEntry);

            // Restore to the correct layer
            const targetLayer = state.layers[nextEntry.layerIndex];
            if (targetLayer) {
                targetLayer.ctx.putImageData(nextEntry.imageData, 0, 0);
            }

            compositeAndRender();
            updateUndoRedoButtons();
            updateLayersPanel();
            autoSave();
        }

        // ===== DEBUG MODE =====
        function toggleDebug() {
            state.debugMode = !state.debugMode;
            const overlay = document.getElementById('debugOverlay');
            overlay.classList.toggle('show', state.debugMode);
            if (state.debugMode) {
                showToast('Debug ON (press ` to toggle)');
            }
        }

        function updateDebugOverlay(e) {
            if (!state.debugMode) return;

            const rect = mainCanvas.getBoundingClientRect();
            const offsetX = e.clientX - rect.left;
            const offsetY = e.clientY - rect.top;
            const calcX = Math.floor(offsetX / state.zoom);
            const calcY = Math.floor(offsetY / state.zoom);

            const overlay = document.getElementById('debugOverlay');
            overlay.textContent =
`Mouse: (${e.clientX.toFixed(1)}, ${e.clientY.toFixed(1)})
Rect:  (${rect.left.toFixed(1)}, ${rect.top.toFixed(1)})
       ${rect.width.toFixed(1)} x ${rect.height.toFixed(1)}
Offset: (${offsetX.toFixed(1)}, ${offsetY.toFixed(1)})
Zoom: ${state.zoom}
Pan: (${state.panX}, ${state.panY})
Calc: (${calcX}, ${calcY})
Canvas: ${state.canvasWidth}x${state.canvasHeight}`;
        }

        function updateUndoRedoButtons() {
            const canUndo = state.undoStack.length > 1;
            const canRedo = state.redoStack.length > 0;
            document.getElementById('undoBtn').disabled = !canUndo;
            document.getElementById('redoBtn').disabled = !canRedo;
            document.getElementById('mobileUndoBtn').disabled = !canUndo;
            document.getElementById('mobileRedoBtn').disabled = !canRedo;
        }

        // ===== GRID TOGGLE =====
        function toggleGrid() {
            state.showGrid = !state.showGrid;
            drawGrid();
            document.getElementById('gridBtn').style.color = state.showGrid ? 'var(--accent)' : 'var(--text)';
        }

        // ===== FILE OPERATIONS =====
        function exportPNG() {
            // Flatten all visible layers for export
            const exportCanvas = flattenForExport();
            exportCanvas.toBlob(async (blob) => {
                // Try Web Share API first (mobile-friendly)
                if (navigator.share && navigator.canShare) {
                    try {
                        const file = new File([blob], 'pixel-art.png', { type: 'image/png' });
                        if (navigator.canShare({ files: [file] })) {
                            await navigator.share({
                                files: [file],
                                title: 'Pixel Art'
                            });
                            showToast('Shared!');
                            return;
                        }
                    } catch (e) {
                        // Share cancelled or failed, fall through
                    }
                }

                // Fallback: open in new tab (long-press to save on mobile)
                const url = URL.createObjectURL(blob);
                const win = window.open(url, '_blank');
                if (!win) {
                    // Popup blocked, try direct download
                    const link = document.createElement('a');
                    link.download = 'pixel-art.png';
                    link.href = url;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                }
                showToast('PNG ready!');
                setTimeout(() => URL.revokeObjectURL(url), 60000);
            }, 'image/png');
        }

        function importImage() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const img = new Image();
                img.onload = () => {
                    // Resize canvas to match image (capped at 256)
                    const width = Math.min(img.width, 256);
                    const height = Math.min(img.height, 256);

                    state.undoStack = [];
                    state.redoStack = [];
                    state.layers = [];
                    state.currentLayerIndex = 0;
                    state.nextLayerId = 1;

                    state.canvasWidth = width;
                    state.canvasHeight = height;

                    mainCanvas.width = width;
                    mainCanvas.height = height;
                    gridCanvas.width = width;
                    gridCanvas.height = height;
                    previewCanvas.width = width;
                    previewCanvas.height = height;
                    selectionCanvas.width = width;
                    selectionCanvas.height = height;

                    ctx.imageSmoothingEnabled = false;
                    gridCtx.imageSmoothingEnabled = false;
                    previewCtx.imageSmoothingEnabled = false;
                    selCtx.imageSmoothingEnabled = false;

                    // Create layer and draw image
                    const layer = createLayer('Imported');
                    layer.ctx.imageSmoothingEnabled = false;
                    layer.ctx.drawImage(img, 0, 0, width, height);
                    state.layers.push(layer);

                    compositeAndRender();
                    updateCanvasSize();
                    drawGrid();
                    updateLayersPanel();
                    saveState();
                    autoSave();

                    showToast(`Imported ${width}x${height}`);
                    URL.revokeObjectURL(img.src);
                };
                img.src = URL.createObjectURL(file);
            };
            input.click();
        }

        function createNewCanvas() {
            const width = parseInt(document.getElementById('newWidth').value) || 32;
            const height = parseInt(document.getElementById('newHeight').value) || 32;

            // Create a new tab with the specified dimensions
            createNewTab(width, height);

            document.getElementById('newCanvasModal').classList.remove('active');
            showToast(`Created ${width}x${height} canvas`);
        }

        function autoSave() {
            // Don't save while tab is loading - images may not be fully loaded yet
            if (state.tabLoading) {
                console.log('AutoSave blocked - tab loading in progress');
                return;
            }
            try {
                // Save current tab state first
                if (state.tabs.length > 0) {
                    saveCurrentTabState();
                }

                // Save all tabs
                const tabsData = state.tabs.map(tab => ({
                    id: tab.id,
                    name: tab.name,
                    canvasWidth: tab.canvasWidth,
                    canvasHeight: tab.canvasHeight,
                    layers: tab.layers,
                    currentLayerIndex: tab.currentLayerIndex,
                    nextLayerId: tab.nextLayerId,
                    palette: tab.palette,
                    currentColor: tab.currentColor,
                    zoom: tab.zoom,
                    panX: tab.panX,
                    panY: tab.panY
                }));

                const data = {
                    version: 2, // Tab-based save format
                    tabs: tabsData,
                    activeTabIndex: state.activeTabIndex,
                    nextTabId: state.nextTabId
                };
                localStorage.setItem('pixelArtAutoSave', JSON.stringify(data));

                // Cloud sync if logged in
                if (state.user) {
                    console.log('Triggering cloud sync for user:', state.user.email);
                    debouncedCloudSync();
                }
            } catch (e) {
                console.warn('AutoSave failed:', e);
            }
        }

        function loadAutoSave() {
            try {
                const saved = localStorage.getItem('pixelArtAutoSave');
                if (saved) {
                    const data = JSON.parse(saved);

                    // Check for new tab-based format (version 2)
                    if (data.version === 2 && data.tabs && data.tabs.length > 0) {
                        // Load tabs
                        state.tabs = data.tabs.map(tabData => ({
                            id: tabData.id,
                            name: tabData.name,
                            canvasWidth: tabData.canvasWidth,
                            canvasHeight: tabData.canvasHeight,
                            layers: tabData.layers || [],
                            currentLayerIndex: tabData.currentLayerIndex || 0,
                            nextLayerId: tabData.nextLayerId || 1,
                            palette: tabData.palette || [...PALETTES.pico8],
                            currentColor: tabData.currentColor || '#000000',
                            undoStack: [],
                            redoStack: [],
                            zoom: tabData.zoom || 8,
                            panX: tabData.panX || 0,
                            panY: tabData.panY || 0
                        }));
                        state.activeTabIndex = data.activeTabIndex || 0;
                        state.nextTabId = data.nextTabId || state.tabs.length + 1;

                        // Load active tab
                        loadTabState(state.activeTabIndex);
                        renderTabBar();
                        return;
                    }

                    // Legacy format: convert to single tab
                    const tab = createTabObject(data.width, data.height, 'Untitled');
                    tab.layers = data.layers || [];
                    tab.currentLayerIndex = data.currentLayerIndex || 0;
                    tab.nextLayerId = data.nextLayerId || 1;
                    tab.palette = data.palette || [...PALETTES.pico8];
                    tab.zoom = data.zoom || 8;

                    // If no layers, create from legacy image
                    if (!tab.layers || tab.layers.length === 0) {
                        // Will be handled by loadTabState creating default layer
                    }

                    state.tabs = [tab];
                    state.activeTabIndex = 0;
                    state.nextTabId = 2;

                    loadTabState(0);
                    renderTabBar();
                }
            } catch (e) {
                console.warn('Load autosave failed:', e);
            }
        }

        // ===== PALETTE GENERATOR =====
        function showPaletteGenerator() {
            document.getElementById('paletteGenModal').classList.add('active');
            updatePalettePreview();
        }

        function updatePalettePreview() {
            const baseColor = document.getElementById('baseColor').value;
            const harmonyType = document.getElementById('harmonyType').value;
            const rampSize = parseInt(document.getElementById('rampSize').value);
            const hueShift = parseInt(document.getElementById('hueShift').value);
            const tempShift = parseInt(document.getElementById('tempShift').value);

            const palette = generatePalette(baseColor, harmonyType, rampSize, hueShift, tempShift);
            const oldLength = state.generatedPalette.length;
            state.generatedPalette = palette;
            state.paletteRampSize = rampSize;
            state.paletteNumRamps = palette.length / rampSize;

            // Reset selection if palette size changed (deselected by default)
            if (oldLength !== palette.length) {
                state.selectedColors.clear();
            }

            const preview = document.getElementById('palettePreview');
            preview.innerHTML = '';

            const numRamps = palette.length / rampSize;

            // Column selectors
            const colSelectors = document.createElement('div');
            colSelectors.className = 'palette-gen-col-selectors';
            for (let c = 0; c < rampSize; c++) {
                const colBtn = document.createElement('button');
                colBtn.className = 'palette-gen-col-select';
                colBtn.textContent = '‚Üï';
                colBtn.title = `Toggle column ${c + 1}`;
                colBtn.onclick = () => toggleColumn(c, rampSize, numRamps);
                colSelectors.appendChild(colBtn);
            }
            preview.appendChild(colSelectors);

            // Rows with row selectors
            for (let r = 0; r < numRamps; r++) {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'palette-gen-row';

                // Row selector button
                const rowBtn = document.createElement('button');
                rowBtn.className = 'palette-gen-row-select';
                rowBtn.textContent = '‚Üî';
                rowBtn.title = `Toggle row ${r + 1}`;
                rowBtn.onclick = () => toggleRow(r, rampSize);
                rowDiv.appendChild(rowBtn);

                // Colors in row
                const colorsDiv = document.createElement('div');
                colorsDiv.className = 'palette-gen-colors';

                for (let i = 0; i < rampSize; i++) {
                    const idx = r * rampSize + i;
                    const colorDiv = document.createElement('div');
                    colorDiv.className = 'palette-gen-color';
                    colorDiv.style.background = palette[idx];
                    colorDiv.dataset.idx = idx;

                    if (state.selectedColors.has(idx)) {
                        colorDiv.classList.add('selected');
                    } else {
                        colorDiv.classList.add('deselected');
                    }

                    colorDiv.onclick = () => toggleColorSelection(idx);
                    colorsDiv.appendChild(colorDiv);
                }

                rowDiv.appendChild(colorsDiv);
                preview.appendChild(rowDiv);
            }
        }

        function toggleColorSelection(idx) {
            if (state.selectedColors.has(idx)) {
                state.selectedColors.delete(idx);
            } else {
                state.selectedColors.add(idx);
            }
            updateColorSelectionUI();
        }

        function toggleRow(rowIdx, rampSize) {
            const startIdx = rowIdx * rampSize;
            const rowIndices = [];
            for (let i = 0; i < rampSize; i++) {
                rowIndices.push(startIdx + i);
            }

            // Check if all in row are selected
            const allSelected = rowIndices.every(idx => state.selectedColors.has(idx));

            if (allSelected) {
                // Deselect all in row
                rowIndices.forEach(idx => state.selectedColors.delete(idx));
            } else {
                // Select all in row
                rowIndices.forEach(idx => state.selectedColors.add(idx));
            }
            updateColorSelectionUI();
        }

        function toggleColumn(colIdx, rampSize, numRamps) {
            const colIndices = [];
            for (let r = 0; r < numRamps; r++) {
                colIndices.push(r * rampSize + colIdx);
            }

            // Check if all in column are selected
            const allSelected = colIndices.every(idx => state.selectedColors.has(idx));

            if (allSelected) {
                // Deselect all in column
                colIndices.forEach(idx => state.selectedColors.delete(idx));
            } else {
                // Select all in column
                colIndices.forEach(idx => state.selectedColors.add(idx));
            }
            updateColorSelectionUI();
        }

        function updateColorSelectionUI() {
            document.querySelectorAll('.palette-gen-color').forEach(div => {
                const idx = parseInt(div.dataset.idx);
                if (state.selectedColors.has(idx)) {
                    div.classList.add('selected');
                    div.classList.remove('deselected');
                } else {
                    div.classList.remove('selected');
                    div.classList.add('deselected');
                }
            });
        }

        function selectAllColors() {
            state.selectedColors = new Set(state.generatedPalette.map((_, i) => i));
            updateColorSelectionUI();
        }

        function deselectAllColors() {
            state.selectedColors.clear();
            updateColorSelectionUI();
        }

        function invertColorSelection() {
            const newSelection = new Set();
            state.generatedPalette.forEach((_, i) => {
                if (!state.selectedColors.has(i)) {
                    newSelection.add(i);
                }
            });
            state.selectedColors = newSelection;
            updateColorSelectionUI();
        }

        function generatePalette(baseHex, harmonyType, rampSize, hueShift, tempShift = 0) {
            const baseHsl = hexToHsl(baseHex);
            const palette = [];

            // Get harmony hues
            const hues = getHarmonyHues(baseHsl.h, harmonyType);

            // Generate ramp for each hue
            hues.forEach(hue => {
                const ramp = generateColorRamp(hue, baseHsl.s, rampSize, hueShift, tempShift);
                palette.push(...ramp);
            });

            return palette;
        }

        function getHarmonyHues(baseHue, type) {
            switch (type) {
                case 'monochromatic': return [baseHue];
                case 'complementary': return [baseHue, (baseHue + 180) % 360];
                case 'analogous': {
                    // Generate analogous hues based on state
                    const hues = [];
                    const step = 30; // degrees between analogous hues
                    // Add cool rows (toward blue, negative direction)
                    for (let i = state.analogousCoolRows; i >= 1; i--) {
                        hues.push((baseHue - step * i + 360) % 360);
                    }
                    // Add base hue
                    hues.push(baseHue);
                    // Add warm rows (toward yellow, positive direction)
                    for (let i = 1; i <= state.analogousWarmRows; i++) {
                        hues.push((baseHue + step * i) % 360);
                    }
                    return hues;
                }
                case 'triadic': return [baseHue, (baseHue + 120) % 360, (baseHue + 240) % 360];
                case 'splitcomp': return [baseHue, (baseHue + 150) % 360, (baseHue + 210) % 360];
                case 'tetradic': return [baseHue, (baseHue + 90) % 360, (baseHue + 180) % 360, (baseHue + 270) % 360];
                default: return [baseHue];
            }
        }

        function generateColorRamp(baseHue, baseSat, size, hueShiftAmount, tempShift = 0) {
            const ramp = [];
            const midpoint = Math.floor(size / 2);

            // Helper: shortest hue distance toward target
            function hueShiftToward(fromHue, targetHue, amount) {
                let diff = targetHue - fromHue;
                // Normalize to -180 to 180
                while (diff > 180) diff -= 360;
                while (diff < -180) diff += 360;
                return diff * amount;
            }

            for (let i = 0; i < size; i++) {
                const t = i / (size - 1); // 0 to 1
                const distFromMid = (i - midpoint) / midpoint; // -1 to 1

                // Base hue shift (existing behavior)
                let hueOffset = distFromMid * hueShiftAmount;
                if (distFromMid < 0) {
                    hueOffset = distFromMid * hueShiftAmount * 2;
                }

                // Temperature shift: lights toward yellow/orange, darks toward blue
                // t=0 is darkest, t=1 is lightest
                // Use a gentler curve (squared) and cap max shift at 30 degrees
                const tempAmount = tempShift / 40; // Normalize to 0-1.0
                const maxTempShift = 30; // Cap the maximum hue shift
                if (t < 0.5) {
                    // Dark colors - shift toward blue (220)
                    const darkness = Math.pow((0.5 - t) * 2, 1.5); // Gentler curve
                    const shift = hueShiftToward(baseHue, 220, darkness * tempAmount);
                    hueOffset += Math.max(-maxTempShift, Math.min(maxTempShift, shift));
                } else {
                    // Light colors - shift toward yellow/orange (40)
                    const bright = Math.pow((t - 0.5) * 2, 1.5); // Gentler curve
                    const shift = hueShiftToward(baseHue, 40, bright * tempAmount);
                    hueOffset += Math.max(-maxTempShift, Math.min(maxTempShift, shift));
                }

                const hue = (baseHue + hueOffset + 360) % 360;

                // Saturation: peaks in middle, lower at extremes
                const satFactor = 1 - Math.abs(distFromMid) * 0.5;
                const sat = Math.min(100, baseSat * satFactor);

                // Lightness: dark to light
                const lightness = 15 + t * 70;

                ramp.push(hslToHex(hue, sat, lightness));
            }

            return ramp;
        }

        function applyGeneratedPalette() {
            // Only apply selected colors
            const selectedPalette = [];
            state.generatedPalette.forEach((color, idx) => {
                if (state.selectedColors.has(idx)) {
                    selectedPalette.push(color);
                }
            });

            if (selectedPalette.length === 0) {
                showToast('No colors selected!');
                return;
            }

            state.palette = selectedPalette;
            state.currentColor = state.palette[0];
            renderPalette();

            document.getElementById('paletteSelect').value = 'custom';
            document.getElementById('paletteGenModal').classList.remove('active');
            showToast(`Applied ${selectedPalette.length} colors!`);

            // Reset selection for next time
            state.selectedColors.clear();
        }

        // ===== PALETTE SAVE/LOAD/DOWNLOAD =====
        function getSelectedPaletteColors() {
            const colors = [];
            state.generatedPalette.forEach((color, idx) => {
                if (state.selectedColors.has(idx)) {
                    colors.push(color);
                }
            });
            return colors.length > 0 ? colors : state.generatedPalette;
        }

        function downloadPalette() {
            const colors = getSelectedPaletteColors();
            if (colors.length === 0) {
                showToast('No colors to download!');
                return;
            }

            // Create .hex format (one hex per line, no #)
            const hexContent = colors.map(c => c.replace('#', '').toUpperCase()).join('\n');

            const blob = new Blob([hexContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'palette.hex';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showToast(`Downloaded ${colors.length} colors!`);
        }

        function getSavedPalettes() {
            try {
                return JSON.parse(localStorage.getItem('pixelArtSavedPalettes') || '{}');
            } catch {
                return {};
            }
        }

        function saveSavedPalettes(palettes) {
            localStorage.setItem('pixelArtSavedPalettes', JSON.stringify(palettes));
        }

        function loadSavedPalettesList() {
            const select = document.getElementById('savedPaletteSelect');
            const palettes = getSavedPalettes();

            select.innerHTML = '<option value="">-- Select --</option>';
            Object.keys(palettes).sort().forEach(name => {
                const opt = document.createElement('option');
                opt.value = name;
                opt.textContent = `${name} (${palettes[name].length})`;
                select.appendChild(opt);
            });
        }

        function saveGeneratedPalette() {
            const name = document.getElementById('savePaletteName').value.trim();
            if (!name) {
                showToast('Enter a palette name!');
                return;
            }

            const colors = getSelectedPaletteColors();
            if (colors.length === 0) {
                showToast('No colors to save!');
                return;
            }

            const palettes = getSavedPalettes();
            palettes[name] = colors;
            saveSavedPalettes(palettes);

            document.getElementById('savePaletteName').value = '';
            loadSavedPalettesList();
            showToast(`Saved "${name}" (${colors.length} colors)`);
        }

        function loadSavedPalette() {
            const name = document.getElementById('savedPaletteSelect').value;
            if (!name) {
                showToast('Select a palette first!');
                return;
            }

            const palettes = getSavedPalettes();
            const colors = palettes[name];
            if (!colors) {
                showToast('Palette not found!');
                return;
            }

            // Load into the current palette directly
            state.palette = colors;
            state.currentColor = state.palette[0];
            renderPalette();
            document.getElementById('paletteSelect').value = 'custom';
            document.getElementById('paletteGenModal').classList.remove('active');
            showToast(`Loaded "${name}" (${colors.length} colors)`);
        }

        function deleteSavedPalette() {
            const name = document.getElementById('savedPaletteSelect').value;
            if (!name) {
                showToast('Select a palette first!');
                return;
            }

            const palettes = getSavedPalettes();
            delete palettes[name];
            saveSavedPalettes(palettes);

            loadSavedPalettesList();
            showToast(`Deleted "${name}"`);
        }

        // ===== SELECTION FUNCTIONS =====
        function selectAll() {
            // Select entire canvas
            state.selection.pixels.clear();
            for (let y = 0; y < state.canvasHeight; y++) {
                for (let x = 0; x < state.canvasWidth; x++) {
                    state.selection.pixels.add(`${x},${y}`);
                }
            }
            state.selection.bounds = {x: 0, y: 0, width: state.canvasWidth, height: state.canvasHeight};
            state.selection.active = true;
            drawSelection();
            showSelectionToolbar();
            showToast('All selected');
        }

        function clearSelection() {
            state.selection.active = false;
            state.selection.pixels.clear();
            state.selection.bounds = null;
            state.selection.floating = false;
            state.selection.floatingData = null;
            state.selection.floatingOffset = {x: 0, y: 0};
            state.lassoPixels = [];
            state.lassoStart = null;
            selCtx.clearRect(0, 0, state.canvasWidth, state.canvasHeight);
            document.getElementById('selectionToolbar').style.display = 'none';
            // Remove lasso start indicator if exists
            const indicator = document.querySelector('.lasso-start');
            if (indicator) indicator.remove();
        }

        function setRectangularSelection(x1, y1, x2, y2) {
            const minX = Math.max(0, Math.min(x1, x2));
            const maxX = Math.min(state.canvasWidth - 1, Math.max(x1, x2));
            const minY = Math.max(0, Math.min(y1, y2));
            const maxY = Math.min(state.canvasHeight - 1, Math.max(y1, y2));

            state.selection.pixels.clear();
            for (let y = minY; y <= maxY; y++) {
                for (let x = minX; x <= maxX; x++) {
                    state.selection.pixels.add(`${x},${y}`);
                }
            }

            state.selection.bounds = {
                x: minX,
                y: minY,
                width: maxX - minX + 1,
                height: maxY - minY + 1
            };
            state.selection.active = true;
            drawSelection();
            showSelectionToolbar();
        }

        function setLassoSelection(boundaryPixels) {
            // Use inverse flood fill to find interior
            const width = state.canvasWidth;
            const height = state.canvasHeight;

            // Create temp bitmap: 0=unknown, 1=boundary, 2=outside
            const bitmap = new Uint8Array(width * height);

            // Mark boundary pixels
            const boundarySet = new Set();
            boundaryPixels.forEach(p => {
                if (p.x >= 0 && p.x < width && p.y >= 0 && p.y < height) {
                    bitmap[p.y * width + p.x] = 1;
                    boundarySet.add(`${p.x},${p.y}`);
                }
            });

            // Flood fill from edges to find "outside"
            const stack = [];
            // Add all edge pixels that aren't boundary
            for (let x = 0; x < width; x++) {
                if (bitmap[x] === 0) stack.push({x, y: 0});
                if (bitmap[(height-1) * width + x] === 0) stack.push({x, y: height-1});
            }
            for (let y = 0; y < height; y++) {
                if (bitmap[y * width] === 0) stack.push({x: 0, y});
                if (bitmap[y * width + width - 1] === 0) stack.push({x: width-1, y});
            }

            while (stack.length > 0) {
                const {x, y} = stack.pop();
                if (x < 0 || x >= width || y < 0 || y >= height) continue;
                const idx = y * width + x;
                if (bitmap[idx] !== 0) continue;
                bitmap[idx] = 2; // outside
                stack.push({x: x+1, y}, {x: x-1, y}, {x, y: y+1}, {x, y: y-1});
            }

            // Everything not outside and not boundary is inside
            state.selection.pixels.clear();
            let minX = width, minY = height, maxX = 0, maxY = 0;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    if (bitmap[idx] !== 2) { // boundary or inside
                        state.selection.pixels.add(`${x},${y}`);
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                    }
                }
            }

            if (state.selection.pixels.size > 0) {
                state.selection.bounds = {
                    x: minX,
                    y: minY,
                    width: maxX - minX + 1,
                    height: maxY - minY + 1
                };
                state.selection.active = true;
                drawSelection();
                showSelectionToolbar();
            } else {
                clearSelection();
                showToast('Selection too small');
            }
        }

        function drawSelection() {
            selCtx.clearRect(0, 0, state.canvasWidth, state.canvasHeight);
            if (!state.selection.active) return;

            // Draw selection with marching ants pattern
            const animOffset = Math.floor(Date.now() / 200) % 4;

            state.selection.pixels.forEach(key => {
                const [x, y] = key.split(',').map(Number);

                // Check if this pixel is on the edge of selection
                const neighbors = [
                    `${x-1},${y}`, `${x+1},${y}`, `${x},${y-1}`, `${x},${y+1}`
                ];

                const isEdge = neighbors.some(n => !state.selection.pixels.has(n));

                if (isEdge) {
                    // Draw dashed border effect
                    const patternPos = (x + y + animOffset) % 4;
                    selCtx.fillStyle = patternPos < 2 ? 'rgba(255,255,255,0.8)' : 'rgba(0,0,0,0.8)';
                    selCtx.fillRect(x, y, 1, 1);
                } else {
                    // Light tint for interior
                    selCtx.fillStyle = 'rgba(100,150,255,0.2)';
                    selCtx.fillRect(x, y, 1, 1);
                }
            });

            // Draw floating content if exists
            if (state.selection.floating && state.selection.floatingData) {
                const offX = state.selection.floatingOffset.x;
                const offY = state.selection.floatingOffset.y;
                // Draw on preview canvas instead
                previewCtx.clearRect(0, 0, state.canvasWidth, state.canvasHeight);
                previewCtx.putImageData(state.selection.floatingData,
                    state.selection.bounds.x + offX,
                    state.selection.bounds.y + offY);
            }
        }

        // Animate selection marching ants
        let selectionAnimFrame;
        function animateSelection() {
            if (state.selection.active) {
                drawSelection();
            }
            selectionAnimFrame = requestAnimationFrame(animateSelection);
        }

        function showSelectionToolbar() {
            document.getElementById('selectionToolbar').style.display = 'flex';
        }

        function hideSelectionToolbar() {
            document.getElementById('selectionToolbar').style.display = 'none';
        }

        function selectionAction(action) {
            if (!state.selection.active) return;

            const bounds = state.selection.bounds;

            switch (action) {
                case 'copy':
                case 'cut':
                    // Create masked clipboard with only selected pixels from current layer
                    const copyLayer = getCurrentLayer();
                    if (!copyLayer) break;
                    const copySrc = copyLayer.ctx.getImageData(bounds.x, bounds.y, bounds.width, bounds.height);
                    const copyMasked = new ImageData(bounds.width, bounds.height);
                    state.selection.pixels.forEach(key => {
                        const [px, py] = key.split(',').map(Number);
                        const lx = px - bounds.x;
                        const ly = py - bounds.y;
                        if (lx >= 0 && lx < bounds.width && ly >= 0 && ly < bounds.height) {
                            const idx = (ly * bounds.width + lx) * 4;
                            copyMasked.data[idx] = copySrc.data[idx];
                            copyMasked.data[idx + 1] = copySrc.data[idx + 1];
                            copyMasked.data[idx + 2] = copySrc.data[idx + 2];
                            copyMasked.data[idx + 3] = copySrc.data[idx + 3];
                        }
                    });
                    state.clipboard = copyMasked;

                    if (action === 'cut') {
                        saveState();
                        state.selection.pixels.forEach(key => {
                            const [x, y] = key.split(',').map(Number);
                            copyLayer.ctx.clearRect(x, y, 1, 1);
                        });
                        compositeAndRender();
                        showToast('Cut!');
                    } else {
                        showToast('Copied!');
                    }
                    clearSelection();
                    break;

                case 'delete':
                    const deleteLayer = getCurrentLayer();
                    if (!deleteLayer) break;
                    saveState();
                    state.selection.pixels.forEach(key => {
                        const [x, y] = key.split(',').map(Number);
                        deleteLayer.ctx.clearRect(x, y, 1, 1);
                    });
                    compositeAndRender();
                    showToast('Deleted!');
                    clearSelection();
                    break;

                case 'fliph':
                    flipSelection(true, false);
                    break;

                case 'flipv':
                    flipSelection(false, true);
                    break;

                case 'deselect':
                    clearSelection();
                    break;

                case 'move':
                    // Lift the pixels for moving
                    saveState();
                    state.selection.floating = true;
                    state.selection.floatingOffset = {x: 0, y: 0};

                    // Get current layer
                    const moveLayer = getCurrentLayer();
                    if (!moveLayer) break;

                    // Create masked ImageData with only selected pixels from layer
                    const srcData = moveLayer.ctx.getImageData(bounds.x, bounds.y, bounds.width, bounds.height);
                    const maskedData = new ImageData(bounds.width, bounds.height);

                    // Only copy pixels that are in the selection
                    state.selection.pixels.forEach(key => {
                        const [px, py] = key.split(',').map(Number);
                        const localX = px - bounds.x;
                        const localY = py - bounds.y;
                        if (localX >= 0 && localX < bounds.width && localY >= 0 && localY < bounds.height) {
                            const idx = (localY * bounds.width + localX) * 4;
                            maskedData.data[idx] = srcData.data[idx];
                            maskedData.data[idx + 1] = srcData.data[idx + 1];
                            maskedData.data[idx + 2] = srcData.data[idx + 2];
                            maskedData.data[idx + 3] = srcData.data[idx + 3];
                        }
                    });

                    state.selection.floatingData = maskedData;

                    // Clear only selected pixels from the LAYER (not composite)
                    state.selection.pixels.forEach(key => {
                        const [x, y] = key.split(',').map(Number);
                        moveLayer.ctx.clearRect(x, y, 1, 1);
                    });

                    // Update composite view
                    compositeAndRender();

                    // Draw floating selection on preview
                    previewCtx.putImageData(state.selection.floatingData, bounds.x, bounds.y);
                    // Switch to select tool for dragging
                    setTool('select');
                    showToast('Drag on canvas to move');
                    break;
            }
        }

        function flipSelection(horizontal, vertical) {
            if (!state.selection.active || !state.selection.bounds) return;

            const bounds = state.selection.bounds;
            saveState();

            // Handle floating selection - flip the floatingData directly
            if (state.selection.floating && state.selection.floatingData) {
                const srcData = state.selection.floatingData;
                const w = srcData.width;
                const h = srcData.height;
                const flippedData = new ImageData(w, h);

                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        const srcX = horizontal ? (w - 1 - x) : x;
                        const srcY = vertical ? (h - 1 - y) : y;
                        const srcIdx = (srcY * w + srcX) * 4;
                        const dstIdx = (y * w + x) * 4;
                        flippedData.data[dstIdx] = srcData.data[srcIdx];
                        flippedData.data[dstIdx + 1] = srcData.data[srcIdx + 1];
                        flippedData.data[dstIdx + 2] = srcData.data[srcIdx + 2];
                        flippedData.data[dstIdx + 3] = srcData.data[srcIdx + 3];
                    }
                }

                state.selection.floatingData = flippedData;

                // Update selection pixels set
                const newPixels = new Set();
                state.selection.pixels.forEach(key => {
                    const [px, py] = key.split(',').map(Number);
                    const lx = px - bounds.x;
                    const ly = py - bounds.y;
                    const newLx = horizontal ? (bounds.width - 1 - lx) : lx;
                    const newLy = vertical ? (bounds.height - 1 - ly) : ly;
                    newPixels.add(`${bounds.x + newLx},${bounds.y + newLy}`);
                });
                state.selection.pixels = newPixels;

                // Redraw on preview canvas
                previewCtx.clearRect(0, 0, state.canvasWidth, state.canvasHeight);
                previewCtx.putImageData(
                    flippedData,
                    bounds.x + state.selection.floatingOffset.x,
                    bounds.y + state.selection.floatingOffset.y
                );

                drawSelection();
                showToast(horizontal ? 'Flipped H!' : 'Flipped V!');
                return;
            }

            // Non-floating selection - flip on canvas directly
            const srcData = ctx.getImageData(bounds.x, bounds.y, bounds.width, bounds.height);

            // Create array to store flipped pixel data
            const flippedPixels = [];

            // For each selected pixel, calculate flipped position and store color
            state.selection.pixels.forEach(key => {
                const [px, py] = key.split(',').map(Number);
                const lx = px - bounds.x;
                const ly = py - bounds.y;

                // Get source color
                const srcIdx = (ly * bounds.width + lx) * 4;
                const r = srcData.data[srcIdx];
                const g = srcData.data[srcIdx + 1];
                const b = srcData.data[srcIdx + 2];
                const a = srcData.data[srcIdx + 3];

                // Calculate flipped position
                const newLx = horizontal ? (bounds.width - 1 - lx) : lx;
                const newLy = vertical ? (bounds.height - 1 - ly) : ly;
                const newPx = bounds.x + newLx;
                const newPy = bounds.y + newLy;

                flippedPixels.push({ox: px, oy: py, nx: newPx, ny: newPy, r, g, b, a});
            });

            // Clear original selected pixels
            state.selection.pixels.forEach(key => {
                const [x, y] = key.split(',').map(Number);
                ctx.clearRect(x, y, 1, 1);
            });

            // Draw flipped pixels and update selection set
            state.selection.pixels.clear();
            flippedPixels.forEach(p => {
                if (p.a > 0) {
                    ctx.fillStyle = `rgba(${p.r},${p.g},${p.b},${p.a/255})`;
                    ctx.fillRect(p.nx, p.ny, 1, 1);
                }
                state.selection.pixels.add(`${p.nx},${p.ny}`);
            });

            drawSelection();
            showToast(horizontal ? 'Flipped H!' : 'Flipped V!');
        }

        function pasteClipboard() {
            if (!state.clipboard) {
                showToast('Nothing to paste');
                return;
            }

            // Commit any existing floating selection first
            if (state.selection.floating) {
                commitFloatingSelection();
            }

            // Paste at center as floating selection (moveable)
            const x = Math.floor((state.canvasWidth - state.clipboard.width) / 2);
            const y = Math.floor((state.canvasHeight - state.clipboard.height) / 2);

            // Set up as floating selection
            state.selection.pixels.clear();
            for (let py = 0; py < state.clipboard.height; py++) {
                for (let px = 0; px < state.clipboard.width; px++) {
                    // Only add pixels that have alpha > 0
                    const idx = (py * state.clipboard.width + px) * 4;
                    if (state.clipboard.data[idx + 3] > 0) {
                        state.selection.pixels.add(`${x + px},${y + py}`);
                    }
                }
            }
            state.selection.bounds = {x, y, width: state.clipboard.width, height: state.clipboard.height};
            state.selection.active = true;
            state.selection.floating = true;
            state.selection.floatingData = state.clipboard;
            state.selection.floatingOffset = {x: 0, y: 0};

            // Draw on preview canvas (not main canvas yet)
            previewCtx.putImageData(state.clipboard, x, y);

            // Switch to select tool for dragging
            setTool('select');
            showSelectionToolbar();
            showToast('Drag to position, tap to place');
        }

        function commitFloatingSelection() {
            if (!state.selection.floating || !state.selection.floatingData) return;

            const bounds = state.selection.bounds;
            const offX = state.selection.floatingOffset.x;
            const offY = state.selection.floatingOffset.y;

            saveState();
            // Write to current layer - only non-transparent pixels (don't overwrite with empty)
            const layer = getCurrentLayer();
            if (layer) {
                const srcData = state.selection.floatingData;
                const destX = bounds.x + offX;
                const destY = bounds.y + offY;

                // Get destination data to blend with
                const destData = layer.ctx.getImageData(destX, destY, bounds.width, bounds.height);

                // Only copy non-transparent pixels
                for (let i = 0; i < srcData.data.length; i += 4) {
                    const alpha = srcData.data[i + 3];
                    if (alpha > 0) {
                        destData.data[i] = srcData.data[i];
                        destData.data[i + 1] = srcData.data[i + 1];
                        destData.data[i + 2] = srcData.data[i + 2];
                        destData.data[i + 3] = alpha;
                    }
                }

                layer.ctx.putImageData(destData, destX, destY);
            }
            previewCtx.clearRect(0, 0, state.canvasWidth, state.canvasHeight);
            clearSelection();
            compositeAndRender();
        }

        // ===== SELECTION HELPER FUNCTIONS =====
        function drawPreviewSelection(x0, y0, x1, y1) {
            previewCtx.clearRect(0, 0, state.canvasWidth, state.canvasHeight);
            const minX = Math.min(x0, x1);
            const maxX = Math.max(x0, x1);
            const minY = Math.min(y0, y1);
            const maxY = Math.max(y0, y1);

            // Draw dashed rectangle preview
            previewCtx.setLineDash([1, 1]);
            previewCtx.strokeStyle = '#fff';
            previewCtx.lineWidth = 1 / state.zoom;
            previewCtx.strokeRect(minX + 0.5, minY + 0.5, maxX - minX, maxY - minY);
            previewCtx.strokeStyle = '#000';
            previewCtx.lineDashOffset = 1;
            previewCtx.strokeRect(minX + 0.5, minY + 0.5, maxX - minX, maxY - minY);
            previewCtx.setLineDash([]);
            previewCtx.lineDashOffset = 0;
        }

        function showLassoStart(x, y) {
            // Show a visual indicator at the lasso start point
            hideLassoStart();
            const indicator = document.createElement('div');
            indicator.className = 'lasso-start';
            const rect = mainCanvas.getBoundingClientRect();
            indicator.style.left = (rect.left + x * state.zoom + state.zoom / 2) + 'px';
            indicator.style.top = (rect.top + y * state.zoom + state.zoom / 2) + 'px';
            document.body.appendChild(indicator);
        }

        function hideLassoStart() {
            const indicator = document.querySelector('.lasso-start');
            if (indicator) indicator.remove();
        }

        function drawLassoPreview() {
            previewCtx.clearRect(0, 0, state.canvasWidth, state.canvasHeight);
            if (state.lassoPixels.length < 2) return;

            // Draw the lasso path with alternating black/white
            state.lassoPixels.forEach((p, i) => {
                previewCtx.fillStyle = i % 2 === 0 ? 'rgba(0, 0, 0, 0.6)' : 'rgba(255, 255, 255, 0.6)';
                previewCtx.fillRect(p.x, p.y, 1, 1);
            });
        }

        function moveFloatingSelection(dx, dy) {
            if (!state.selection.floating || !state.selection.floatingData) return;

            state.selection.floatingOffset.x += dx;
            state.selection.floatingOffset.y += dy;

            // Draw on preview canvas
            previewCtx.clearRect(0, 0, state.canvasWidth, state.canvasHeight);
            previewCtx.putImageData(
                state.selection.floatingData,
                state.selection.bounds.x + state.selection.floatingOffset.x,
                state.selection.bounds.y + state.selection.floatingOffset.y
            );
        }

        // Start marching ants animation
        animateSelection();

        // ===== COLOR UTILITIES =====
        function hexToHsl(hex) {
            let r = parseInt(hex.slice(1, 3), 16) / 255;
            let g = parseInt(hex.slice(3, 5), 16) / 255;
            let b = parseInt(hex.slice(5, 7), 16) / 255;

            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }

            return { h: h * 360, s: s * 100, l: l * 100 };
        }

        function hslToHex(h, s, l) {
            s /= 100;
            l /= 100;

            const c = (1 - Math.abs(2 * l - 1)) * s;
            const x = c * (1 - Math.abs((h / 60) % 2 - 1));
            const m = l - c / 2;
            let r = 0, g = 0, b = 0;

            if (0 <= h && h < 60) { r = c; g = x; b = 0; }
            else if (60 <= h && h < 120) { r = x; g = c; b = 0; }
            else if (120 <= h && h < 180) { r = 0; g = c; b = x; }
            else if (180 <= h && h < 240) { r = 0; g = x; b = c; }
            else if (240 <= h && h < 300) { r = x; g = 0; b = c; }
            else if (300 <= h && h < 360) { r = c; g = 0; b = x; }

            r = Math.round((r + m) * 255);
            g = Math.round((g + m) * 255);
            b = Math.round((b + m) * 255);

            return '#' + [r, g, b].map(v => v.toString(16).padStart(2, '0')).join('');
        }

        // ===== UI HELPERS =====
        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 2000);
        }

        function updateUI() {
            updateUndoRedoButtons();
            document.getElementById('gridBtn').style.color = state.showGrid ? 'var(--accent)' : 'var(--text)';
        }

        // ===== COLOR EDITOR =====
        let colorEditorOriginalColor = null;
        let colorEditorCurrentHsl = { h: 0, s: 100, l: 50 };

        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return { r, g, b };
        }

        function openColorEditor() {
            colorEditorOriginalColor = state.currentColor;
            colorEditorCurrentHsl = hexToHsl(state.currentColor);

            updateColorEditorUI();
            renderPaletteColorsList();
            document.getElementById('colorEditorModal').classList.add('active');
        }

        function updateColorEditorUI() {
            const hex = hslToHex(colorEditorCurrentHsl.h, colorEditorCurrentHsl.s, colorEditorCurrentHsl.l);
            const rgb = hexToRgb(hex);

            document.getElementById('colorEditorSwatch').style.background = hex;
            document.getElementById('colorEditorHex').value = hex.toUpperCase();
            document.getElementById('colorEditorRgb').textContent = `${rgb.r}, ${rgb.g}, ${rgb.b}`;

            document.getElementById('hueSlider').value = colorEditorCurrentHsl.h;
            document.getElementById('satSlider').value = colorEditorCurrentHsl.s;
            document.getElementById('lightSlider').value = colorEditorCurrentHsl.l;

            document.getElementById('hueValue').textContent = Math.round(colorEditorCurrentHsl.h) + '¬∞';
            document.getElementById('satValue').textContent = Math.round(colorEditorCurrentHsl.s) + '%';
            document.getElementById('lightValue').textContent = Math.round(colorEditorCurrentHsl.l) + '%';

            // Update saturation slider background
            const satSlider = document.getElementById('satSlider');
            satSlider.style.background = `linear-gradient(to right,
                hsl(${colorEditorCurrentHsl.h}, 0%, ${colorEditorCurrentHsl.l}%),
                hsl(${colorEditorCurrentHsl.h}, 100%, ${colorEditorCurrentHsl.l}%))`;

            // Update lightness slider background
            const lightSlider = document.getElementById('lightSlider');
            lightSlider.style.background = `linear-gradient(to right,
                hsl(${colorEditorCurrentHsl.h}, ${colorEditorCurrentHsl.s}%, 0%),
                hsl(${colorEditorCurrentHsl.h}, ${colorEditorCurrentHsl.s}%, 50%),
                hsl(${colorEditorCurrentHsl.h}, ${colorEditorCurrentHsl.s}%, 100%))`;
        }

        function renderPaletteColorsList() {
            const list = document.getElementById('paletteColorsList');
            list.innerHTML = '';

            state.palette.forEach((color, i) => {
                const div = document.createElement('div');
                div.className = 'palette-color-item' + (color === state.currentColor ? ' selected' : '');
                div.style.background = color;

                // Click to select
                div.onclick = (e) => {
                    if (e.target.classList.contains('remove-color')) return;
                    colorEditorCurrentHsl = hexToHsl(color);
                    updateColorEditorUI();
                    renderPaletteColorsList();
                };

                // Remove button (only if more than 1 color)
                if (state.palette.length > 1) {
                    const removeBtn = document.createElement('span');
                    removeBtn.className = 'remove-color';
                    removeBtn.textContent = '√ó';
                    removeBtn.onclick = (e) => {
                        e.stopPropagation();
                        removeColorFromPalette(i);
                    };
                    div.appendChild(removeBtn);
                }

                list.appendChild(div);
            });
        }

        function removeColorFromPalette(index) {
            if (state.palette.length <= 1) return;

            const removedColor = state.palette[index];
            state.palette.splice(index, 1);

            // If we removed the current color, switch to first palette color
            if (removedColor === state.currentColor) {
                state.currentColor = state.palette[0];
                colorEditorCurrentHsl = hexToHsl(state.currentColor);
                updateColorEditorUI();
            }

            renderPaletteColorsList();
            renderPalette();
            document.getElementById('paletteSelect').value = 'custom';
        }

        function addColorToPalette() {
            const hex = hslToHex(colorEditorCurrentHsl.h, colorEditorCurrentHsl.s, colorEditorCurrentHsl.l);

            // Check if color already exists
            if (state.palette.includes(hex)) {
                showToast('Color already in palette');
                return;
            }

            state.palette.push(hex);
            renderPaletteColorsList();
            renderPalette();
            document.getElementById('paletteSelect').value = 'custom';
            showToast('Color added to palette');
        }

        function applyColorEditor() {
            const hex = hslToHex(colorEditorCurrentHsl.h, colorEditorCurrentHsl.s, colorEditorCurrentHsl.l);
            state.currentColor = hex;
            updateCurrentColor();
            document.getElementById('colorEditorModal').classList.remove('active');
        }

        function cancelColorEditor() {
            state.currentColor = colorEditorOriginalColor;
            updateCurrentColor();
            document.getElementById('colorEditorModal').classList.remove('active');
        }

        // Color editor event listeners
        document.getElementById('hueSlider').oninput = (e) => {
            colorEditorCurrentHsl.h = parseFloat(e.target.value);
            updateColorEditorUI();
        };

        document.getElementById('satSlider').oninput = (e) => {
            colorEditorCurrentHsl.s = parseFloat(e.target.value);
            updateColorEditorUI();
        };

        document.getElementById('lightSlider').oninput = (e) => {
            colorEditorCurrentHsl.l = parseFloat(e.target.value);
            updateColorEditorUI();
        };

        document.getElementById('colorEditorHex').onchange = (e) => {
            let hex = e.target.value.trim();
            if (!hex.startsWith('#')) hex = '#' + hex;
            if (/^#[0-9A-Fa-f]{6}$/.test(hex)) {
                colorEditorCurrentHsl = hexToHsl(hex);
                updateColorEditorUI();
            }
        };

        document.getElementById('addToPaletteBtn').onclick = addColorToPalette;
        document.getElementById('applyColorEditor').onclick = applyColorEditor;
        document.getElementById('cancelColorEditor').onclick = cancelColorEditor;

        // Click on current color buttons to open editor
        const currentColorBtn = document.getElementById('currentColor');
        const mobileCurrentColorBtn = document.getElementById('mobileCurrentColor');

        if (currentColorBtn) {
            currentColorBtn.addEventListener('click', openColorEditor);
            currentColorBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                openColorEditor();
            });
        }

        if (mobileCurrentColorBtn) {
            mobileCurrentColorBtn.addEventListener('click', openColorEditor);
            mobileCurrentColorBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                openColorEditor();
            });
        }

        // ===== LAYERS PANEL =====
        function updateLayersPanel() {
            const list = document.getElementById('layersList');
            if (!list) return;

            list.innerHTML = '';
            // Draw layers from top to bottom in the list
            for (let i = state.layers.length - 1; i >= 0; i--) {
                const layer = state.layers[i];
                const item = document.createElement('div');
                item.className = 'layer-item' + (i === state.currentLayerIndex ? ' active' : '');
                item.style.cssText = 'display:flex;align-items:center;gap:8px;padding:8px;margin-bottom:4px;background:var(--bg-light);border-radius:4px;cursor:pointer;border:2px solid ' + (i === state.currentLayerIndex ? 'var(--accent)' : 'transparent');

                // Visibility toggle
                const visBtn = document.createElement('button');
                visBtn.textContent = layer.visible ? 'üëÅÔ∏è' : 'üëÅÔ∏è‚Äçüó®Ô∏è';
                visBtn.style.cssText = 'background:none;border:none;font-size:16px;cursor:pointer;opacity:' + (layer.visible ? '1' : '0.4');
                visBtn.onclick = (e) => {
                    e.stopPropagation();
                    layer.visible = !layer.visible;
                    compositeAndRender();
                    updateLayersPanel();
                };

                // Layer preview thumbnail
                const thumb = document.createElement('canvas');
                thumb.width = 24;
                thumb.height = 24;
                thumb.style.cssText = 'border:1px solid var(--text-dim);background:repeating-conic-gradient(#808080 0% 25%, #404040 0% 50%) 50%/8px 8px;';
                const thumbCtx = thumb.getContext('2d');
                thumbCtx.imageSmoothingEnabled = false;
                thumbCtx.drawImage(layer.canvas, 0, 0, 24, 24);

                // Layer name
                const name = document.createElement('span');
                name.textContent = layer.name;
                name.style.cssText = 'flex:1;font-size:12px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;';

                // Opacity slider
                const opacity = document.createElement('input');
                opacity.type = 'range';
                opacity.min = '0';
                opacity.max = '100';
                opacity.value = Math.round(layer.opacity * 100);
                opacity.style.cssText = 'width:50px;';
                opacity.onclick = (e) => e.stopPropagation();
                opacity.oninput = (e) => {
                    layer.opacity = parseInt(e.target.value) / 100;
                    compositeAndRender();
                };

                // Move buttons
                const moveUp = document.createElement('button');
                moveUp.textContent = '‚Üë';
                moveUp.style.cssText = 'background:var(--bg-medium);border:none;color:var(--text);padding:2px 6px;border-radius:4px;cursor:pointer;';
                moveUp.onclick = (e) => { e.stopPropagation(); moveLayer(i, i + 1); };

                const moveDown = document.createElement('button');
                moveDown.textContent = '‚Üì';
                moveDown.style.cssText = 'background:var(--bg-medium);border:none;color:var(--text);padding:2px 6px;border-radius:4px;cursor:pointer;';
                moveDown.onclick = (e) => { e.stopPropagation(); moveLayer(i, i - 1); };

                item.onclick = () => {
                    state.currentLayerIndex = i;
                    updateLayersPanel();
                };

                item.appendChild(visBtn);
                item.appendChild(thumb);
                item.appendChild(name);
                item.appendChild(opacity);
                item.appendChild(moveUp);
                item.appendChild(moveDown);
                list.appendChild(item);
            }
        }

        // Layers modal events
        document.getElementById('layersBtn')?.addEventListener('click', () => {
            updateLayersPanel();
            document.getElementById('layersModal').classList.add('active');
        });
        document.getElementById('closeLayersBtn')?.addEventListener('click', () => {
            document.getElementById('layersModal').classList.remove('active');
        });
        document.getElementById('addLayerBtn')?.addEventListener('click', () => {
            addLayer();
            saveState();
        });
        document.getElementById('deleteLayerBtn')?.addEventListener('click', () => {
            deleteLayer(state.currentLayerIndex);
            saveState();
        });

        // ===== TABS =====
        function createTabObject(width = 32, height = 32, name = null) {
            const tabNum = state.nextTabId++;
            const tabId = crypto.randomUUID(); // UUID for cloud sync
            const tabName = name || `Untitled ${tabNum}`;

            return {
                id: tabId,
                name: tabName,
                canvasWidth: width,
                canvasHeight: height,
                layers: [], // Will store serialized layer data
                currentLayerIndex: 0,
                nextLayerId: 1,
                palette: [...PALETTES.pico8],
                currentColor: '#000000',
                undoStack: [],
                redoStack: [],
                zoom: 8,
                panX: 0,
                panY: 0
            };
        }

        function saveCurrentTabState() {
            if (state.tabs.length === 0) return;

            const tab = state.tabs[state.activeTabIndex];

            // DEBUG: Check if we have layers with content
            const layerInfo = state.layers.map(l => l.canvas.toDataURL().length).join(',');
            console.log('SAVE tab', state.activeTabIndex, '- layers:', state.layers.length, '- sizes:', layerInfo);
            tab.canvasWidth = state.canvasWidth;
            tab.canvasHeight = state.canvasHeight;
            tab.currentLayerIndex = state.currentLayerIndex;
            tab.nextLayerId = state.nextLayerId;
            tab.palette = [...state.palette];
            tab.currentColor = state.currentColor;
            tab.undoStack = state.undoStack.map(entry => ({
                layerIndex: entry.layerIndex,
                imageData: entry.imageData
            }));
            tab.redoStack = state.redoStack.map(entry => ({
                layerIndex: entry.layerIndex,
                imageData: entry.imageData
            }));
            tab.zoom = state.zoom;
            tab.panX = state.panX;
            tab.panY = state.panY;

            // Serialize layers (store image data as dataURLs)
            tab.layers = state.layers.map(layer => ({
                id: layer.id,
                name: layer.name,
                visible: layer.visible,
                opacity: layer.opacity,
                locked: layer.locked,
                image: layer.canvas.toDataURL()
            }));

            // Track when this device last modified this tab (for conflict resolution)
            tab.localUpdatedAt = Date.now();
        }

        function loadTabState(tabIndex) {
            const tab = state.tabs[tabIndex];

            // Block autoSave until all images are loaded
            state.tabLoading = true;

            // DEBUG: Check what we're loading
            const layerInfo = tab.layers ? tab.layers.map(l => l.image ? l.image.length : 0).join(',') : 'none';
            console.log('LOAD tab', tabIndex, '- layers:', tab.layers ? tab.layers.length : 0, '- sizes:', layerInfo);

            state.canvasWidth = tab.canvasWidth;
            state.canvasHeight = tab.canvasHeight;
            state.currentLayerIndex = tab.currentLayerIndex;
            state.nextLayerId = tab.nextLayerId;
            state.palette = [...tab.palette];
            state.currentColor = tab.currentColor;
            state.undoStack = tab.undoStack || [];
            state.redoStack = tab.redoStack || [];
            state.zoom = tab.zoom;
            state.panX = tab.panX;
            state.panY = tab.panY;

            // Resize canvases
            mainCanvas.width = state.canvasWidth;
            mainCanvas.height = state.canvasHeight;
            gridCanvas.width = state.canvasWidth;
            gridCanvas.height = state.canvasHeight;
            previewCanvas.width = state.canvasWidth;
            previewCanvas.height = state.canvasHeight;
            selectionCanvas.width = state.canvasWidth;
            selectionCanvas.height = state.canvasHeight;

            // Restore layers - with proper image load tracking
            state.layers = [];
            if (tab.layers && tab.layers.length > 0) {
                // Count how many images need to load
                const imagesToLoad = tab.layers.filter(l => l.image).length;
                let imagesLoaded = 0;

                tab.layers.forEach(layerData => {
                    const canvas = document.createElement('canvas');
                    canvas.width = state.canvasWidth;
                    canvas.height = state.canvasHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.imageSmoothingEnabled = false;

                    const layer = {
                        id: layerData.id,
                        name: layerData.name,
                        canvas: canvas,
                        ctx: ctx,
                        visible: layerData.visible,
                        opacity: layerData.opacity,
                        locked: layerData.locked
                    };

                    // Load image data
                    if (layerData.image) {
                        const img = new Image();
                        img.onload = () => {
                            ctx.drawImage(img, 0, 0);
                            compositeAndRender();
                            imagesLoaded++;
                            // Only autoSave when ALL images are loaded
                            if (imagesLoaded === imagesToLoad) {
                                console.log('All', imagesToLoad, 'images loaded for tab', tabIndex);
                                state.tabLoading = false;
                                setTimeout(() => autoSave(), 100);
                            }
                        };
                        img.src = layerData.image;
                    }

                    state.layers.push(layer);
                });

                // If no images to load, unblock immediately
                if (imagesToLoad === 0) {
                    state.tabLoading = false;
                }
            } else {
                // Create default layer if none exist
                const layer = createLayer('Layer 1');
                state.layers.push(layer);
                state.tabLoading = false;
            }

            // Update UI
            document.getElementById('projectName').textContent = tab.name;
            renderPalette();
            updateCurrentColor();
            updateUndoRedoButtons();
            updateCanvasSize();
            drawGrid();
            compositeAndRender();
        }

        function switchToTab(index) {
            if (index === state.activeTabIndex) return;
            if (index < 0 || index >= state.tabs.length) return;

            // Save current tab state
            saveCurrentTabState();

            // Switch to new tab
            state.activeTabIndex = index;
            loadTabState(index);

            // Update tab bar UI
            renderTabBar();
            // Note: Don't autoSave here - images are still loading async
            // AutoSave will happen on next user action
        }

        function createNewTab(width = 32, height = 32) {
            // Save current tab first
            if (state.tabs.length > 0) {
                saveCurrentTabState();
            }

            // Create new tab
            const tab = createTabObject(width, height);
            state.tabs.push(tab);
            state.activeTabIndex = state.tabs.length - 1;

            // Initialize canvas for new tab
            state.canvasWidth = width;
            state.canvasHeight = height;
            state.layers = [];
            state.currentLayerIndex = 0;
            state.nextLayerId = 1;
            state.undoStack = [];
            state.redoStack = [];
            state.palette = [...PALETTES.pico8];
            state.currentColor = state.palette[0];
            state.zoom = 8;
            state.panX = 0;
            state.panY = 0;

            // Resize canvases
            mainCanvas.width = width;
            mainCanvas.height = height;
            gridCanvas.width = width;
            gridCanvas.height = height;
            previewCanvas.width = width;
            previewCanvas.height = height;
            selectionCanvas.width = width;
            selectionCanvas.height = height;

            // Create first layer
            const layer = createLayer('Layer 1');
            state.layers.push(layer);

            // Update UI
            document.getElementById('projectName').textContent = tab.name;
            renderPalette();
            updateCurrentColor();
            updateUndoRedoButtons();
            updateCanvasSize();
            drawGrid();
            compositeAndRender();
            renderTabBar();
            autoSave();
        }

        function closeTab(index) {
            if (state.tabs.length <= 1) {
                showToast('Cannot close last tab');
                return;
            }

            // If closing active tab, switch first
            if (index === state.activeTabIndex) {
                const newIndex = index > 0 ? index - 1 : 0;
                saveCurrentTabState();
                state.tabs.splice(index, 1);
                state.activeTabIndex = Math.min(newIndex, state.tabs.length - 1);
                loadTabState(state.activeTabIndex);
            } else {
                state.tabs.splice(index, 1);
                // Adjust active index if needed
                if (state.activeTabIndex > index) {
                    state.activeTabIndex--;
                }
            }

            renderTabBar();
            autoSave();
        }

        function renderTabBar() {
            const container = document.getElementById('tabsContainer');
            if (!container) return;

            console.log('renderTabBar called, tabs:', state.tabs.length, 'active:', state.activeTabIndex);

            // Clear and rebuild
            container.innerHTML = '';

            state.tabs.forEach((tab, i) => {
                const tabEl = document.createElement('div');
                const isActive = i === state.activeTabIndex;
                tabEl.className = isActive ? 'tab active' : 'tab';
                tabEl.onclick = () => switchToTab(i);

                const nameSpan = document.createElement('span');
                nameSpan.className = 'tab-name';
                nameSpan.textContent = `${i + 1}. ${tab.name}`;

                const closeBtn = document.createElement('button');
                closeBtn.className = 'tab-close';
                closeBtn.textContent = '√ó';
                closeBtn.onclick = (e) => {
                    e.stopPropagation();
                    closeTab(i);
                };

                tabEl.appendChild(nameSpan);
                tabEl.appendChild(closeBtn);
                container.appendChild(tabEl);
            });

            // Force layout recalculation
            void container.offsetWidth;

            // Scroll active tab into view after a microtask
            requestAnimationFrame(() => {
                const activeTab = container.querySelector('.tab.active');
                if (activeTab) {
                    activeTab.scrollIntoView({ behavior: 'instant', inline: 'nearest', block: 'nearest' });
                }
            });
        }

        // Tab event handlers
        document.getElementById('newTabBtn').addEventListener('click', () => {
            createNewTab(32, 32);
        });

        // ===== START =====
        init();
    </script>
</body>
</html>
