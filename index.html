<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="description" content="Interactive neural network pathfinding demonstration">
    <link rel="manifest" href="manifest.json">
    <title>LOCOMOT.IO - Neural Train Pathfinding</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        html, body { width: 100%; height: 100%; overflow: hidden; touch-action: none; }
        body { background: #0a0610; font-family: 'Press Start 2P', monospace; display: flex; flex-direction: column; color: #fff; user-select: none; -webkit-user-select: none; }
        
        .leaderboard { position: absolute; top: 50px; right: 10px; background: rgba(10, 6, 16, 0.85); border: 1px solid #333; border-radius: 8px; padding: 10px; min-width: 120px; z-index: 20; pointer-events: none; }
        .leaderboard h3 { font-size: 8px; color: #888; margin-bottom: 8px; text-align: center; }
        .leaderboard-entry { display: flex; justify-content: space-between; align-items: center; font-size: 7px; padding: 3px 0; border-bottom: 1px solid #222; }
        .leaderboard-entry:last-child { border-bottom: none; }
        .leaderboard-entry.player { color: #0f0; }
        .leaderboard-entry.neural { color: #f0f; }
        .leaderboard-rank { color: #666; width: 16px; }
        .leaderboard-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; margin: 0 6px; }
        .leaderboard-score { color: #ff0; }
        
        .hud { display: flex; justify-content: space-between; padding: 10px 16px; background: linear-gradient(to bottom, #0a0610, #0a061000); font-size: 10px; position: absolute; top: 0; left: 0; right: 0; z-index: 10; pointer-events: none; }
        .hud-item { display: flex; align-items: center; gap: 6px; text-shadow: 0 0 10px currentColor; }
        .len-color { color: #0f0; }
        .wave-color { color: #5ff; }
        .score-color { color: #ff5; }
        
        .game-container { flex: 1; position: relative; overflow: hidden; }
        #gameCanvas { display: block; width: 100%; height: 100%; cursor: crosshair; }
        #gameCanvas.playing { cursor: none; }
        .touch-indicator { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); font-size: 7px; color: #333; pointer-events: none; text-align: center; }
        
        .overlay { position: absolute; inset: 0; background: rgba(5, 3, 10, 0.92); display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 24px; text-align: center; z-index: 100; }
        .overlay.hidden { display: none; }
        .overlay h2 { font-size: 20px; margin-bottom: 20px; }
        .overlay p { font-size: 8px; color: #888; margin-bottom: 8px; line-height: 2; }
        .start-screen h2 { color: #0f0; text-shadow: 0 0 30px #0f08; }
        .game-over-screen h2 { color: #f55; text-shadow: 0 0 30px #f558; }
        .pause-screen h2 { color: #5ff; text-shadow: 0 0 30px #5ff8; }
        .score-display { font-size: 14px; color: #ff5; margin: 20px 0; line-height: 2; }
        .start-btn { margin-top: 24px; padding: 18px 36px; font-family: 'Press Start 2P', monospace; font-size: 12px; background: #0f0; color: #000; border: none; border-radius: 8px; box-shadow: 0 0 30px #0f06; }
        .start-btn:active { background: #0c0; transform: scale(0.97); }
        .controls-help { display: flex; gap: 30px; margin-top: 24px; font-size: 7px; color: #666; }
        .control-item { text-align: center; }
        .control-item .icon { font-size: 20px; margin-bottom: 8px; color: #888; }
        .legend { display: flex; flex-wrap: wrap; justify-content: center; gap: 12px; margin-top: 16px; font-size: 6px; }
        .legend-item { display: flex; align-items: center; gap: 6px; color: #666; }
        .legend-color { width: 14px; height: 14px; border-radius: 4px; }
        .wave-announce { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 24px; color: #5ff; text-shadow: 0 0 30px #5ff; opacity: 0; z-index: 50; pointer-events: none; }
        .wave-announce.show { opacity: 1; }
        .pause-btn-fixed { position: absolute; top: 10px; right: 16px; width: 40px; height: 40px; background: transparent; border: 2px solid #333; border-radius: 8px; color: #555; font-size: 14px; z-index: 20; display: flex; align-items: center; justify-content: center; }
        .debug-btn-fixed { position: absolute; top: 10px; right: 66px; width: 40px; height: 40px; background: transparent; border: 2px solid #333; border-radius: 8px; color: #555; font-size: 14px; z-index: 20; display: flex; align-items: center; justify-content: center; }
        .kill-feed { position: absolute; bottom: 60px; left: 10px; font-size: 7px; z-index: 20; pointer-events: none; }
        .kill-feed-entry { background: rgba(0,0,0,0.7); padding: 4px 8px; margin: 2px 0; border-radius: 4px; opacity: 1; transition: opacity 0.5s; }
        .kill-feed-entry.fade { opacity: 0; }
        .invite-link { position: absolute; bottom: 10px; left: 10px; font-size: 6px; color: #666; z-index: 20; background: rgba(0,0,0,0.5); padding: 4px 8px; border-radius: 4px; }
        .invite-link span { color: #0f0; cursor: pointer; }
        .feedback-btn { position: absolute; bottom: 35px; left: 10px; font-size: 10px; color: #0f0; z-index: 100; background: rgba(0,0,0,0.8); padding: 8px 12px; border-radius: 4px; border: 1px solid #0f0; cursor: pointer; }
        .feedback-btn:hover { background: #0f0; color: #000; }
        .shake { animation: shake 0.3s ease-in-out; }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-10px) rotate(-1deg); } 75% { transform: translateX(10px) rotate(1deg); } }
    </style>
</head>
<body>
    <div class="hud">
        <div class="hud-item len-color"><span>‚óà</span><span id="snakeLen">2</span></div>
        <div class="hud-item wave-color"><span>‚óÜ</span><span>RANK <span id="waveNum">#?</span></span></div>
        <div class="hud-item score-color"><span>‚òÖ</span><span id="score">0</span></div>
        <div class="hud-item" style="color: #0fc;"><span>üëÅ</span><span id="patternHud">-</span></div>
    </div>
    
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        <div class="touch-indicator">MOBILE: SWIPE TO TURN ‚Ä¢ HOLD+DRAG TO AIM | DESKTOP: WASD/ARROWS ‚Ä¢ MOUSE TO AIM</div>
        <div class="leaderboard" id="leaderboard"><h3>üèÜ LEADERBOARD</h3><div id="leaderboardEntries"></div></div>
        <div class="wave-announce" id="waveAnnounce">WAVE 1</div>
        <button class="pause-btn-fixed" id="pauseBtn">‚ùö‚ùö</button>
        <button class="debug-btn-fixed" id="debugBtn">üêõ</button>
        <div class="kill-feed" id="killFeed"></div>
        <div class="invite-link">INVITE: <span id="inviteLink" onclick="copyInvite()">loading...</span></div>
        <button class="feedback-btn" onclick="submitIdea()">üí° SUBMIT IDEA</button>
        
        <div class="overlay start-screen" id="startScreen">
            <h2>LOCOMOT.IO</h2>
            <p style="color:#d4a017;">All aboard the pain train</p>
            <p>Build your train ‚Ä¢ Collect gun cars ‚Ä¢ Survive</p>
            <p style="color:#f0f;">üß† Neural Network AI Enemies!</p>
            <div style="margin: 15px 0;">
                <input type="text" id="usernameInput" placeholder="Enter your name..." maxlength="12"
                    style="font-family: 'Press Start 2P'; font-size: 10px; padding: 10px; border: 2px solid #0f0; background: #111; color: #0f0; text-align: center; width: 200px;">
            </div>
            <div class="controls-help">
                <div class="control-item"><div class="icon">üéÆ</div><div>WASD/ARROWS<br>to turn</div></div>
                <div class="control-item"><div class="icon">üñ±Ô∏è</div><div>MOUSE<br>to aim</div></div>
                <div class="control-item"><div class="icon">üëã</div><div>SWIPE<br>mobile</div></div>
            </div>
            <div class="legend">
                <div class="legend-item"><div class="legend-color" style="background:#f0f;"></div> NEURAL AI</div>
                <div class="legend-item"><div class="legend-color" style="background:#f55;"></div> HUNTER</div>
                <div class="legend-item"><div class="legend-color" style="background:#ff0;"></div> ALPHA</div>
                <div class="legend-item"><div class="legend-color" style="background:#4f4;"></div> HEALTH</div>
            </div>
            <button class="start-btn" id="startBtn">ALL ABOARD</button>
        </div>
        
        <div class="overlay pause-screen hidden" id="pauseScreen">
            <h2>PAUSED</h2>
            <button class="start-btn" id="resumeBtn">RESUME</button>
        </div>
        
        <div class="overlay game-over-screen hidden" id="gameOverScreen">
            <h2>GAME OVER</h2>
            <div style="margin: 10px 0;">
                <input type="text" id="usernameInputDeath" placeholder="Change name..." maxlength="12"
                    style="font-family: 'Press Start 2P'; font-size: 8px; padding: 8px; border: 2px solid #f55; background: #111; color: #f55; text-align: center; width: 180px;">
            </div>
            <div class="score-display">SCORE: <span id="finalScore">0</span><br>BEST RANK: <span id="finalWave">#?</span><br>MAX LENGTH: <span id="finalLength">2</span></div>
            <div id="deathReasonBox" style="font-size: 8px; color: #f55; margin: 10px 0; padding: 10px; background: #200; border-radius: 4px; max-width: 280px;">CAUSE: <span id="deathReasonText">Unknown</span></div>
            <div id="patternStatsBox" style="font-size: 8px; color: #0fc; margin: 10px 0; padding: 10px; background: #021; border: 1px solid #0fc; border-radius: 4px; max-width: 280px;">
                <div style="color: #fff; margin-bottom: 5px;">üëÅ I OBSERVED YOUR PATTERNS:</div>
                <div id="patternStatsText">Loading...</div>
            </div>
            <div id="godelStatsBox" style="font-size: 8px; color: #f0f; margin: 10px 0; padding: 10px; background: #201; border: 1px solid #f0f; border-radius: 4px; max-width: 280px;">
                <div style="color: #fff; margin-bottom: 5px;">üß† NEURAL TRAINS LEARNED:</div>
                <div id="godelStatsText">Loading...</div>
            </div>
            <button class="start-btn" id="restartBtn">TRY AGAIN</button>
            <button class="start-btn" id="uploadCollectiveBtn" style="background: #0a6; margin-top: 10px; font-size: 9px;">üß† UPLOAD TO COLLECTIVE</button>
            <button class="start-btn" id="copyDeathBtn" style="background: #5af; margin-top: 10px; font-size: 9px;">üìã COPY DEBUG</button>
        </div>
    </div>

    <script id="brainData" type="application/json">
{"net.0.weight": [[-0.14063696563243866, 0.1554080694913864, 0.33258190751075745, -0.05950263515114784, 0.07368038594722748, 0.15392644703388214, 0.254254549741745, -0.0026402133516967297, 0.35466840863227844, -0.11527003347873688, 0.04515760391950607, 0.0940709114074707, 0.1011018231511116, 0.12395468354225159, 0.2568212151527405, 0.11883559823036194, 0.06264950335025787, 0.16766932606697083, -0.1592254489660263, 0.06044108420610428, 0.1854584664106369, 0.1617480367422104, -0.09249279648065567, -0.06366704404354095, 0.04144633561372757, 0.16719770431518555, -0.12747134268283844, -0.08107393980026245, -0.1391468048095703, -0.18318945169448853, -0.08749950677156448, -0.13245588541030884, -0.27727487683296204, -0.032401420176029205, 0.04950784146785736, -0.17902645468711853, 0.11061938852071762, 0.06192208454012871, -0.10664715617895126, 0.09256124496459961, -0.08249879628419876, -0.16023245453834534, -0.1775246113538742, 0.08501669019460678, 0.09781190007925034, 0.06446867436170578, -0.01856422796845436, 0.00579884834587574], [0.3822864592075348, 0.024469343945384026, 0.16389918327331543, -0.05708747357130051, -0.011093171313405037, 0.03841596096754074, -0.20222178101539612, 0.28851228952407837, 0.04384523257613182, -0.0977720394730568, 0.09929252415895462, 0.004998733755201101, -0.20641879737377167, 0.4038090109825134, -0.0800616517663002, 0.0709560438990593, -0.0825544223189354, 0.128355011343956, -0.1120510920882225, -0.010687132366001606, 0.14171786606311798, 8.33296071505174e-05, 0.0035315959248691797, -0.010825488716363907, 0.0279148668050766, 0.15046150982379913, 0.12550470232963562, -0.063209667801857, -0.08445102721452713, 0.027926264330744743, 0.05723285302519798, 0.05099168419837952, -0.053724247962236404, -0.088096484541893, -0.1164882704615593, 0.051807254552841187, 0.32005903124809265, -0.03240866959095001, 0.05305470898747444, -0.12314436584711075, 0.03714849799871445, -0.1026078462600708, 0.19802390038967133, -0.13029156625270844, 0.03899097070097923, -0.0021321524400264025, -0.09039179980754852, -0.1186724379658699], [-0.37160125374794006, -0.03176451474428177, 0.20239941775798798, 0.04303830862045288, 0.156075581908226, 0.1006050780415535, 0.21466869115829468, -0.01074427179992199, 0.3021071255207062, -0.16624516248703003, 0.0386219248175621, 0.18208318948745728, 0.0762629434466362, -0.01280977763235569, -0.012778396718204021, 0.04272594675421715, 0.03274737298488617, 0.14480562508106232, -0.05240456014871597, -0.036424409598112106, 0.10867121815681458, 0.1243191659450531, -0.10856552422046661, -0.02898583374917507, -0.09771212935447693, 0.06764979660511017, -0.12302990257740021, 0.1123540922999382, 0.05500221997499466, 0.0187330674380064, -0.11716580390930176, -0.04284727945923805, -0.04962078481912613, -0.047202493995428085, 0.020135411992669106, -0.11611051857471466, 0.2526383101940155, 0.042478784918785095, -0.1672905534505844, 0.14221107959747314, -0.11425194144248962, 0.07031593471765518, -0.15040823817253113, -0.03913629427552223, 0.15492087602615356, -0.01129953470081091, 0.1238645389676094, 0.037304140627384186], [0.3713681995868683, -0.03171579912304878, -0.16745543479919434, 0.08771663904190063, -0.0785929262638092, -0.16160571575164795, -0.15720245242118835, 0.026053955778479576, -0.05233646556735039, 0.05843227729201317, -0.027458567172288895, -0.03485832363367081, 0.06243043392896652, 0.14990080893039703, 0.0943278968334198, 0.12328160554170609, 0.1031455248594284, 0.025235934183001518, 0.10825075209140778, 0.1118319034576416, 0.006065820809453726, 0.029222046956419945, 0.035250723361968994, 0.178286612033844, 0.04408501088619232, 0.0357246994972229, 0.20074111223220825, 0.1372925490140915, -0.10078541934490204, 0.0026408361736685038, 0.2738354504108429, 0.1832071840763092, 0.17695152759552002, 0.05237073451280594, -6.920877058291808e-05, 0.08857329189777374, -0.21982689201831818, -0.03183142840862274, 0.017757562920451164, -0.04469098150730133, 0.04082315042614937, 0.18911175429821014, 0.306803435087204, 0.06771301478147507, -0.07131537795066833, 0.1261860579252243, -0.13886317610740662, -0.09986262768507004], [0.5054964423179626, -0.054411713033914566, -0.07975498586893082, -0.07676024734973907, -0.12978823482990265, -0.03714465722441673, 0.022973516955971718, -0.03254306688904762, 0.04893353581428528, -0.08477700501680374, 0.02470223233103752, -0.08084719628095627, 0.08770909160375595, -0.1272931545972824, 0.08695922046899796, 0.004130881279706955, -0.12425500154495239, -0.18462620675563812, 0.16731472313404083, 0.0639062449336052, 0.034510236233472824, -0.09439128637313843, 0.10495968163013458, -0.004723989870399237, -0.08913388848304749, 0.015418879687786102, 0.025983339175581932, 0.03626003861427307, -0.08859975636005402, -0.04985632374882698, 0.17414912581443787, -0.04956866428256035, 0.17758898437023163, 0.11965886503458023, 0.16647018492221832, 0.05080466344952583, -0.31912070512771606, 0.000523689086548984, 0.1363627165555954, 0.11147848516702652, 0.2291157990694046, 0.08793987333774567, 0.3124767541885376, -0.11604378372430801, 0.13401851058006287, 0.041380852460861206, -0.11784765124320984, -0.13999073207378387], [-0.07465814054012299, -0.07998150587081909, -0.11453980952501297, 0.1313413828611374, 0.09316570311784744, -0.06605558097362518, 0.21918447315692902, 0.012782929465174675, -0.061692193150520325, 0.016504500061273575, -0.12240195274353027, -0.10607298463582993, 0.22223269939422607, -0.17535057663917542, -0.09207218885421753, -0.17197388410568237, -0.15349021553993225, -0.17468136548995972, 0.1202535480260849, 0.04018336161971092, -0.0740681141614914, 0.053486477583646774, -0.10324036329984665, -0.04415307566523552, 0.1599196195602417, -0.015233433805406094, 0.10325754433870316, 0.15117451548576355, -0.10299499332904816, -0.03974582999944687, 0.04290824756026268, 0.10583415627479553, 0.01616738922894001, 0.0933486595749855, -0.038334086537361145, 0.2994458079338074, -0.20250271260738373, 0.3399067223072052, 0.11457619071006775, 0.16411352157592773, 0.07863321900367737, 0.1645977944135666, -0.028744488954544067, 0.24672739207744598, -0.13272607326507568, 0.020211664959788322, 0.0882471352815628, 0.22107015550136566], [-0.018803343176841736, 0.2353779375553131, 0.29228243231773376, 0.06746707856655121, 0.03945336490869522, 0.07484991103410721, 0.00266975536942482, 0.10191038995981216, 0.11251650750637054, -0.14144310355186462, 0.20335564017295837, 0.0574180968105793, -0.1340968757867813, 0.08545864373445511, 0.1967073231935501, 0.013616401702165604, 0.18126483261585236, 0.2704203724861145, -0.09197773784399033, 0.023122737184166908, 0.23536744713783264, -0.02524619735777378, 0.0865200087428093, 0.16662472486495972, -0.13428263366222382, 0.15752780437469482, -0.10497894138097763, -0.12071535736322403, -0.05568143352866173, -0.10938766598701477, 0.04957043007016182, -0.08002451807260513, -0.09637569636106491, -0.009135603904724121, -0.19003553688526154, -0.08665277063846588, 0.41783013939857483, 0.002346138469874859, -0.09059187024831772, -0.13774517178535461, -0.19027039408683777, -0.2026260644197464, -0.017053447663784027, -0.11263210326433182, 0.05134861543774605, 0.12978126108646393, 0.039025161415338516, -0.09259762614965439], [0.39090731739997864, -0.003286287421360612, 0.09664078056812286, -0.04758821800351143, -0.17062629759311676, -0.09479836374521255, -0.21658660471439362, -0.10230784118175507, -0.035638466477394104, -0.10735391825437546, 0.0484452024102211, 0.050599291920661926, -0.28463834524154663, 0.07581585645675659, -0.053380999714136124, 0.006748842541128397, -0.08310188353061676, 0.039903972297906876, 0.01933065988123417, -0.058158788830041885, -0.03630703315138817, -0.02092582732439041, -0.041734371334314346, 0.051068324595689774, 0.10963183641433716, 0.00498092919588089, 0.07395798712968826, 0.15281012654304504, 0.042733095586299896, -0.020922012627124786, -0.05872562900185585, 0.0718880444765091, -0.08758483827114105, 0.02601405419409275, 0.12129455804824829, -0.0553918220102787, -0.004425638820976019, 0.054012466222047806, 0.16223733127117157, 0.04824439808726311, -0.10075198858976364, -0.006823425181210041, 0.2767772078514099, -0.07651947438716888, 0.022905383259058, 0.012229759246110916, -0.04732096567749977, -0.14494173228740692], [0.10574368387460709, -0.10127604007720947, -0.10026513040065765, 0.04262040555477142, -0.07775498926639557, -0.11232031136751175, -0.09753607213497162, 0.020996952429413795, -0.0523848794400692, 0.11474458128213882, 0.019662417471408844, -0.05945109948515892, -0.06458486616611481, 0.039823904633522034, -0.10452371835708618, 0.14224570989608765, -0.0994967445731163, -0.09870170801877975, -0.13409270346164703, 0.04755944758653641, 0.07033220678567886, -0.09586060792207718, -0.012869235128164291, 0.01518751960247755, 0.02700030617415905, -0.12614984810352325, 0.0029470582958310843, -0.04295217990875244, -0.010757668875157833, -0.08092054724693298, 0.06943752616643906, -0.14358988404273987, -0.027917927131056786, -0.006082747131586075, 0.033593837171792984, -0.027156302705407143, -0.021487895399332047, 0.05093676596879959, 0.10242126882076263, 0.12759356200695038, 0.033524513244628906, 0.0968795120716095, -0.14348204433918, -0.007690975908190012, -0.04512613266706467, 0.027944466099143028, -0.11658866703510284, -0.13990448415279388], [0.21855495870113373, 0.09738211333751678, 0.1777864396572113, -0.09148810803890228, 0.09479966014623642, -0.017289023846387863, -0.22455453872680664, 0.20911414921283722, 0.29477155208587646, 0.03984789177775383, 0.027742955833673477, 0.1156608909368515, -0.014876754023134708, 0.34115058183670044, 0.31841111183166504, 0.15117716789245605, 0.07191161811351776, 0.1168615072965622, -0.11868336796760559, 0.15603652596473694, 0.15169578790664673, 0.054200056940317154, -0.05207712575793266, 0.2739390432834625, -0.00852002203464508, 0.10588636249303818, 0.10624635964632034, -0.12434844672679901, 0.058659907430410385, 0.05227891728281975, 0.05641603469848633, -0.01529478095471859, -0.04513883218169212, 0.1863393485546112, -0.1441177874803543, -0.08699557930231094, 0.23445524275302887, -0.17170555889606476, -0.10089968144893646, -0.10979750007390976, -0.0104724932461977, -0.1128387600183487, 0.21127228438854218, -0.08369419723749161, -0.04853954538702965, 0.14525152742862701, -0.11933637410402298, -0.169651061296463], [-0.08980076014995575, 0.1722276508808136, 0.056394148617982864, 0.06692676991224289, -0.03870466351509094, -0.009748552925884724, -0.09467680752277374, 0.09003999829292297, 0.32516470551490784, -0.01801506243646145, 0.06190173700451851, 0.18450337648391724, -0.020107844844460487, 0.24254894256591797, 0.21697282791137695, 0.10823582857847214, 0.18289166688919067, 0.08014179766178131, -0.01620526611804962, 0.12771077454090118, 0.1923399120569229, -0.05988464504480362, 0.09912252426147461, 0.21152028441429138, -0.04954810068011284, 0.19546885788440704, -0.06725713610649109, -0.10995958000421524, -0.06879765540361404, -0.006178954150527716, 0.02073248289525509, -0.029795018956065178, -0.0843430683016777, 0.014221323654055595, -0.028788086026906967, -0.15730461478233337, 0.21275494992733002, -0.10151822865009308, -0.01287186611443758, -0.1088828295469284, -0.04658706113696098, -0.19902223348617554, -0.006458601914346218, -0.06984440237283707, 0.12655074894428253, 0.09867992252111435, -0.08264658600091934, 0.010700175538659096], [0.006116420030593872, 0.1713758409023285, 0.18009832501411438, 0.0256375540047884, -0.027282839640975, 0.04522547870874405, 0.03455903008580208, 0.16324496269226074, 0.43545857071876526, -0.1188114583492279, 0.11333559453487396, 0.163143590092659, -0.1632000207901001, 0.1005677580833435, 0.32483381032943726, 0.12596046924591064, 0.23581403493881226, 0.16055233776569366, 0.06024584919214249, 0.07359084486961365, 0.2636318802833557, 0.09760446846485138, -0.06781043857336044, -0.03461487963795662, -0.16198650002479553, 0.062408871948719025, -0.08429927378892899, -0.06733286380767822, -0.04076496511697769, 0.03968315199017525, -0.09879399836063385, -0.0032914013136178255, -0.19263407588005066, 0.10128893703222275, -0.04144132882356644, -0.11050672829151154, 0.2582207918167114, -0.25262683629989624, -0.09746380150318146, -0.03316231817007065, -0.21978667378425598, -0.08559154719114304, -0.09368610382080078, 0.03301765397191048, 0.24301999807357788, -0.016401825472712517, 0.12872454524040222, 0.011546368710696697], [0.24150687456130981, -0.03153521567583084, 0.01930057257413864, 0.14133386313915253, 0.017965901643037796, -0.168792262673378, -0.06790564209222794, 0.33434557914733887, 0.07791170477867126, 0.0931408628821373, -0.016868211328983307, 0.10602642595767975, -0.1428583711385727, 0.1863662153482437, 0.23491139709949493, 0.09676826000213623, -0.03985722362995148, 0.025888729840517044, -0.011985762976109982, 0.21760739386081696, 0.2894105017185211, 0.19562619924545288, 0.15064020454883575, -0.005851115565747023, 0.0508907251060009, 0.141140416264534, 0.0371972918510437, -0.008920090273022652, -0.14088955521583557, -0.15100929141044617, 0.27476295828819275, -0.049409832805395126, 0.13516569137573242, -0.02911277487874031, -0.04093687981367111, -0.05332907661795616, 0.3198646903038025, -0.021382978186011314, 0.026364121586084366, 0.10190271586179733, 0.05504823476076126, -0.17617227137088776, 0.1777551919221878, -0.02010500617325306, 0.14292627573013306, 0.1880437135696411, -0.10100997984409332, -0.08007517457008362], [-0.23801270127296448, 0.07073348015546799, 0.003683276241645217, -0.03120712749660015, 0.04884582385420799, 0.17102746665477753, 0.14787450432777405, -0.12598364055156708, -0.1861751526594162, 0.1121622696518898, -0.12949760258197784, -0.08980631083250046, 0.1494397521018982, -0.1219877302646637, -0.07444949448108673, -0.18769033253192902, -0.21955172717571259, -0.1468295156955719, 0.035489752888679504, -0.0458989180624485, -0.10878841578960419, -0.12029110640287399, 0.11349201947450638, 0.007430251222103834, -0.015570311807096004, 0.02902894839644432, -0.04659043624997139, -0.019848579540848732, -0.019819434732198715, 0.1598019301891327, 0.08525127172470093, 0.12155162543058395, 0.22873719036579132, -0.13094718754291534, -0.057348135858774185, 0.052139054983854294, -0.22997502982616425, 0.019131677225232124, 0.14843735098838806, -0.001671709236688912, 0.19906124472618103, 0.11267533153295517, -0.23007796704769135, 0.22934122383594513, -0.14131245017051697, 0.0815577432513237, -0.020412875339388847, 0.19816306233406067], [0.3076809048652649, -0.015180683694779873, -0.24632802605628967, 0.09993236511945724, 0.010284923017024994, 0.061745576560497284, 0.07618649303913116, 0.0030144404154270887, -0.11558939516544342, 0.005810240283608437, -0.1908319890499115, -0.15392529964447021, 0.13132189214229584, 0.14093086123466492, -0.18849273025989532, -0.018035758286714554, 0.04303887113928795, -0.17301557958126068, 0.1562073975801468, -0.031631950289011, 0.10780518501996994, 0.004136963281780481, 0.016335390508174896, 0.023054784163832664, 0.14385876059532166, 0.18793299794197083, 0.23571664094924927, 0.1853296160697937, 0.12525056302547455, 0.19720859825611115, 0.22310814261436462, 0.12804946303367615, 0.17891825735569, -0.03826718404889107, 0.13692627847194672, 0.13138405978679657, -0.04367528110742569, 0.21126572787761688, 0.07958601415157318, 0.20860931277275085, 0.183546245098114, 0.2721090614795685, 0.17310288548469543, 0.1855391561985016, -0.041820213198661804, -0.026415333151817322, -0.007864960469305515, -0.04291537031531334], [0.3868856132030487, -0.18155956268310547, -0.13094162940979004, 0.051731836050748825, 0.024399766698479652, -0.08055128902196884, 0.10843058675527573, 0.13716106116771698, -0.1077720895409584, -0.05929785594344139, -0.16635467112064362, -0.030813047662377357, 0.3474266827106476, -0.06213561072945595, 0.04663272947072983, 0.11676939576864243, -0.058453723788261414, 0.04395835101604462, 0.25217750668525696, -0.05196388438344002, 0.09861139953136444, 0.02390185371041298, -0.07446615397930145, -0.06629001349210739, 0.022292014211416245, 0.01886679045855999, 0.09972609579563141, -0.07204733788967133, 0.019248254597187042, 0.03292781114578247, 0.2903324365615845, 0.06576758623123169, 0.2822735607624054, -0.08455037325620651, -0.04693686589598656, 0.23871976137161255, -0.2251969426870346, 0.3317016661167145, 0.18152348697185516, -0.060789838433265686, 0.07341758161783218, 0.05114983767271042, 0.1274396926164627, 0.2437734752893448, -0.1404723823070526, -0.058506276458501816, -0.1193762868642807, 0.0552060604095459], [-0.027851935476064682, 0.0036375075578689575, -0.049050334841012955, 0.11604499071836472, -0.001263011828996241, 0.045799337327480316, 0.2737113833427429, -0.10038482397794724, -0.2502836287021637, -0.0016220769612118602, 0.03937646001577377, -0.1262715756893158, 0.28237274289131165, -0.20331886410713196, -0.10985537618398666, -0.10071847587823868, -0.01595192775130272, -0.12161032110452652, 0.05584435909986496, 0.03369263932108879, 0.1649073362350464, -0.14292554557323456, 0.11175918579101562, -0.010464165359735489, 0.140874445438385, 0.022718820720911026, 0.2504652738571167, 0.13580499589443207, -0.010593900457024574, 0.14658060669898987, 0.05947888642549515, 0.15142808854579926, 0.2008035033941269, -0.015011456795036793, 0.14679646492004395, 0.277397483587265, -0.1881953477859497, 0.3869549334049225, 0.04916919767856598, 0.11117115616798401, 0.13636000454425812, 0.14480113983154297, -0.05585208535194397, 0.19172264635562897, 0.08246396481990814, -0.030507788062095642, -0.03920714929699898, 0.1484350711107254], [0.29234394431114197, -0.019436493515968323, -0.0772516056895256, 0.12644954025745392, -0.02340680919587612, -0.11823876947164536, 0.1444798856973648, -0.040631189942359924, -0.0556403212249279, 0.10179837793111801, 0.01898263208568096, -0.10168863087892532, 0.17902575433254242, -0.20223908126354218, 0.11911211907863617, -0.06464193016290665, 0.04451246187090874, -0.10323279350996017, 0.18939396739006042, 0.08291734755039215, 0.01860971935093403, -0.07449344545602798, 0.1624273955821991, -0.11855196207761765, 0.08394108712673187, -0.03872757777571678, 0.18639066815376282, -0.09069462865591049, -0.09747705608606339, 0.150619238615036, 0.1949775367975235, 0.10092434287071228, 0.04002666473388672, 0.06866192072629929, 0.20515094697475433, 0.0994720607995987, -0.14882458746433258, 0.1860693097114563, -0.04585817828774452, 0.18300007283687592, 0.07212936133146286, 0.2795841693878174, -0.09487246721982956, 0.008331320248544216, -0.033521443605422974, 0.020231960341334343, -0.025701669976115227, 0.013431990519165993], [0.06086667999625206, 0.1539357453584671, 0.2919943928718567, -0.07981209456920624, 0.036154985427856445, 0.07176916301250458, 0.16396395862102509, 0.061963245272636414, 0.3822619318962097, 0.05754251033067703, 0.2140776813030243, 0.1450556218624115, -0.06298152357339859, 0.0688336044549942, 0.3973452150821686, 0.06353823095560074, 0.11689075827598572, 0.07674805819988251, -0.07261084020137787, 0.18336527049541473, 0.3932454586029053, 0.05408478155732155, -0.07492604851722717, 0.07826372981071472, -0.046478644013404846, 0.2200305461883545, -0.0498516708612442, 0.06316743046045303, -0.12960445880889893, 0.0019903273787349463, -0.059409353882074356, -0.06899064779281616, 0.06426214426755905, 0.11349471658468246, -0.0013804794289171696, -0.059972140938043594, 0.19978825747966766, 0.21957257390022278, -0.008416857570409775, -0.1551043540239334, -0.1093849465250969, -0.23433168232440948, -0.01759517937898636, 0.042575426399707794, 0.11314523965120316, 0.13573680818080902, -0.07169131934642792, 0.10569426417350769], [0.3234458565711975, 0.0046068839728832245, 0.2551591694355011, 0.10533876717090607, 0.15439443290233612, 0.0820804163813591, -0.1805335283279419, 0.046634774655103683, 0.22626568377017975, -0.059509579092264175, 0.11608807742595673, 0.18501491844654083, -0.08312011510133743, 0.20158320665359497, 0.040382325649261475, 0.06422997266054153, -0.0501435250043869, 0.32569384574890137, -0.10613299161195755, 0.12370853871107101, 0.13033607602119446, 0.03031693398952484, 0.1351889669895172, -0.0035677554551512003, -0.030789343640208244, -0.015921700745821, -0.134939506649971, -0.09329898655414581, -0.12053575366735458, 0.08157172054052353, 0.055418603122234344, 0.049579985439777374, 0.023210100829601288, 0.16509868204593658, 0.07307776808738708, -0.006073569413274527, 0.1842585802078247, -0.029286008328199387, 0.18128496408462524, -0.1298816055059433, -0.13483455777168274, -0.008293503895401955, 0.25697341561317444, -0.03740953281521797, 0.14193524420261383, 0.15694452822208405, 0.0036838643718510866, -0.12086127698421478], [-0.39157354831695557, 0.30604666471481323, 0.3188183605670929, -0.025630058720707893, 0.10429518669843674, 0.3363245129585266, 0.0834103673696518, 0.04926616698503494, 0.3822201192378998, -0.09107837826013565, 0.1349191516637802, 0.21597731113433838, 0.0328797847032547, -0.07105664163827896, 0.22716684639453888, 0.13351701200008392, -0.044945769011974335, 0.10649894177913666, 0.018660498782992363, 0.036751601845026016, 0.023469336330890656, 0.1327744573354721, 7.342381286434829e-05, -0.09027311950922012, -0.12077594548463821, 0.09201855212450027, 0.01401098445057869, 0.10067667812108994, 0.10915650427341461, -0.019022924825549126, -0.025679701939225197, -0.006572095677256584, -0.046604618430137634, -0.12485304474830627, 0.05378298461437225, -0.1897207647562027, 0.16002584993839264, -0.09200918674468994, -0.07222779840230942, -0.09499797970056534, -0.1306612640619278, -0.06627795100212097, -0.23325374722480774, 0.09719552844762802, 0.24505193531513214, -0.12768730521202087, -0.03700212389230728, 0.07285158336162567], [0.20972256362438202, -0.08508744090795517, -0.1367371678352356, -0.09679553657770157, -0.009750955738127232, -0.05123757943511009, -0.00926794484257698, -0.009950301609933376, -0.26856932044029236, 0.10355038940906525, -0.050121888518333435, -0.03800316900014877, 0.271807998418808, 0.17642438411712646, -0.12037219107151031, -0.13091933727264404, -0.1445361077785492, -0.016420923173427582, 0.1818060576915741, 0.07297027856111526, -0.043580107390880585, -0.02104657143354416, 0.02069910056889057, 0.044912535697221756, 0.16877961158752441, 0.12334958463907242, 0.2850590646266937, 0.08085314184427261, 0.03510676696896553, -0.03989321365952492, 0.31787997484207153, 0.13438400626182556, 0.18785874545574188, -0.07197942584753036, 0.051773689687252045, 0.1465730369091034, -0.09143875539302826, 0.25880298018455505, 0.16889214515686035, 0.010683857835829258, 0.07912483811378479, 0.052913445979356766, 0.29575347900390625, 0.18776875734329224, -0.07387953251600266, 0.17340558767318726, -0.07695150375366211, -0.005584352649748325], [0.2765845060348511, -0.1524980366230011, -0.07410725206136703, 0.10485833138227463, -0.10689157992601395, -0.10105559974908829, 0.3297196328639984, 0.04922688007354736, 0.05966034531593323, 0.1438092589378357, -0.03488531336188316, -0.09668191522359848, 0.020898958668112755, 0.03036726452410221, 0.056382764130830765, 0.11984805762767792, 0.039796456694602966, 0.043609507381916046, -0.06962010264396667, 0.06962494552135468, -0.0005001742974855006, -0.05607311427593231, -0.061354540288448334, -0.043499983847141266, 0.1187637597322464, 0.012018054723739624, 0.17148007452487946, 0.08259625732898712, -0.041184160858392715, 0.10649577528238297, 0.024182744324207306, -0.07354417443275452, -0.10632984340190887, 0.13049082458019257, 0.010599064640700817, -0.013994619250297546, -0.12892967462539673, -0.03250422328710556, -0.13312877714633942, -0.05237960070371628, 0.012913203798234463, 0.15652063488960266, 0.0466124527156353, -0.03218132257461548, 0.11408154666423798, 0.17870241403579712, 0.07401645183563232, 0.08433576673269272], [0.3274201452732086, 0.03345789760351181, -0.20380710065364838, -0.009885981678962708, -0.013055192306637764, -0.08313629776239395, -0.11189183592796326, 0.13065896928310394, -0.1800425499677658, 0.18175679445266724, -0.07076103240251541, -0.09763055294752121, 0.00047945388359948993, 0.10912473499774933, 0.003994311206042767, 0.10579556226730347, -0.0774654969573021, -0.15560109913349152, 0.22769960761070251, 0.07171888649463654, 0.16580049693584442, 0.038555435836315155, 0.13981549441814423, 0.10031748563051224, 0.01785464398562908, 0.03363218158483505, 0.2077169269323349, 0.03313469514250755, 0.09140485525131226, 0.19411571323871613, 0.26869234442710876, 0.23000174760818481, 0.13303573429584503, 0.09833922982215881, -0.019192105159163475, 0.16477543115615845, -0.2242460548877716, 0.14639337360858917, 0.051937006413936615, 0.17349527776241302, -0.0073516820557415485, 0.26268693804740906, 0.28381192684173584, 0.02502300590276718, -0.02314971387386322, 0.031246881932020187, -0.10702479630708694, -0.03322102501988411], [0.2823260426521301, -0.05454515665769577, 0.1378800868988037, 0.10224203765392303, -0.18700937926769257, -0.19682994484901428, -0.3155197203159332, 0.0973367691040039, -0.014192004688084126, -0.009179229848086834, 0.07822835445404053, -0.06924900412559509, 0.0060803452506661415, 0.3851716220378876, 0.14635254442691803, 0.1567700207233429, 0.019912777468562126, 0.07339179515838623, 0.00511524360626936, 0.1874483972787857, 0.20854507386684418, 0.203679159283638, 0.14010624587535858, 0.10650566220283508, 0.03014899417757988, 0.16296474635601044, -0.06491440534591675, -0.05308464914560318, -0.08763016015291214, -0.08030238002538681, 0.2989271879196167, 0.035712625831365585, -0.04342830181121826, -0.07730164378881454, -0.024795789271593094, 0.07495329529047012, 0.2667667269706726, -0.1207653284072876, 0.17503011226654053, -0.10479773581027985, -0.03250109776854515, -0.13911306858062744, 0.14782440662384033, -0.018879219889640808, -0.03249508515000343, 0.03421716392040253, 0.05191713199019432, -0.1631823182106018], [-0.29151415824890137, 0.05491248145699501, 0.3198866844177246, -0.06710988283157349, -0.0011196199338883162, 0.33312779664993286, 0.12043803930282593, -0.026422962546348572, 0.24315126240253448, -0.10717888176441193, 0.17820444703102112, 0.21038538217544556, 0.10650523751974106, 0.09200198948383331, 0.11682171374559402, -0.005286395084112883, -0.0812394842505455, 0.025635115802288055, 0.05874110385775566, -0.13462893664836884, 0.0854516252875328, -0.03424078971147537, 0.1034775823354721, 0.05725804343819618, -0.1665814071893692, 0.12410573661327362, -0.0901232659816742, 0.03376547619700432, 0.07468395680189133, -0.10090335458517075, -0.005405338481068611, -0.1073090136051178, -0.01582162268459797, -0.01589341089129448, 0.042962152510881424, -0.0361236110329628, 0.18805153667926788, -0.02220202051103115, -0.00408655172213912, 0.13211151957511902, -0.09463460743427277, -0.05677890405058861, -0.2618485689163208, -0.0018800513353198767, 0.0847247838973999, -0.065238818526268, 0.18348313868045807, 0.04786233976483345], [0.12780527770519257, 0.08513079583644867, -0.14214393496513367, 0.12681086361408234, -0.17568232119083405, 0.015357978641986847, 0.022871708497405052, 0.08164312690496445, -0.15900017321109772, 0.1748480498790741, -0.1329144388437271, -0.1824142187833786, 0.16613031923770905, -0.12375083565711975, -0.08747134357690811, -0.05248392000794411, -0.02926614135503769, -0.15981042385101318, 0.25152671337127686, -0.0013576156925410032, -0.04531291127204895, -0.02658907137811184, -0.04463685303926468, 0.07752086222171783, 0.24154043197631836, 0.17424625158309937, 0.3674694299697876, 0.1519053429365158, 0.15305349230766296, 0.12705892324447632, 0.253492146730423, 0.03399977460503578, 0.12271571159362793, 0.12384799122810364, 0.05004560947418213, 0.25759679079055786, -0.2967190146446228, 0.30317968130111694, 0.018272288143634796, 0.07999829947948456, 0.11222077161073685, 0.06519538164138794, 0.1068321019411087, 0.17795012891292572, -0.05854890123009682, -0.1149679645895958, -0.0724610760807991, -0.039783917367458344], [0.3471119999885559, -0.2211933135986328, -0.07045792788267136, -0.060386236757040024, -0.056691113859415054, -0.02723858319222927, -0.07613400369882584, 0.030177749693393707, -0.1338680535554886, 0.13011573255062103, 0.0006455554394051433, -0.06160660833120346, -0.09928350150585175, 0.14343328773975372, -0.03392383083701134, 0.08360837399959564, -0.046606555581092834, -0.03437148779630661, 0.029510922729969025, -0.00015209273260552436, -0.04910975322127342, 0.045235056430101395, -0.06540820002555847, 0.001740761217661202, 0.023509638383984566, 0.11657203733921051, -0.02425234764814377, 0.07942427694797516, -0.03532390668988228, -0.05151789262890816, 0.21618258953094482, 0.013078264892101288, 0.22267594933509827, -0.03772132843732834, 0.16501180827617645, 0.013675438240170479, -0.1968427449464798, 0.13478778302669525, 0.058045774698257446, 0.011527656577527523, 0.22767217457294464, -0.0006645392277278006, 0.06703174859285355, -0.1627889722585678, 0.17474669218063354, -0.051362935453653336, -0.06726650893688202, -0.06258181482553482], [0.23040170967578888, -0.08728142827749252, 0.181227445602417, -0.10148914158344269, -0.01982954889535904, 0.029214709997177124, -0.03762643411755562, 0.15828962624073029, 0.31713399291038513, -0.03521735221147537, 0.17188376188278198, 0.21457073092460632, -0.06991712749004364, 0.34018170833587646, 0.11147457361221313, -0.03296256810426712, 0.2611105442047119, 0.21400709450244904, -0.07235576957464218, 0.16992852091789246, 0.25507670640945435, 0.060910627245903015, 0.055141888558864594, 0.07520078122615814, -0.07594530284404755, 0.11837633699178696, 0.12567992508411407, 0.08265303075313568, 0.08854827284812927, -0.07640840113162994, -0.06463722139596939, 0.02272072248160839, -0.12136711180210114, -0.09935800731182098, -0.13866223394870758, -0.12750305235385895, 0.3190733790397644, -0.16864138841629028, 0.02172570489346981, -0.08611032366752625, 0.029062140733003616, -0.05266163870692253, 0.15069645643234253, 0.045313142240047455, 0.06060124933719635, 0.16648341715335846, 0.02006884291768074, -0.061991214752197266], [-0.13234692811965942, 0.18598879873752594, 0.2838982939720154, 0.06620889157056808, 0.04782455414533615, -0.02505841664969921, -0.043223004788160324, 0.06567629426717758, 0.27553120255470276, 0.027282031252980232, -0.007255507167428732, 0.2638460397720337, 0.0884677991271019, 0.15139269828796387, 0.23327912390232086, 0.040924426168203354, 0.23879645764827728, 0.3084179162979126, 0.06690524518489838, 0.15637964010238647, 0.24600134789943695, 0.17509199678897858, -0.0939972847700119, 0.053334563970565796, -0.0617118775844574, 0.1515887975692749, -0.1398000568151474, -0.013996408320963383, 0.0709465742111206, -0.11817429214715958, -0.11673033237457275, -0.027221594005823135, -0.18386678397655487, 0.017151666805148125, -0.0967504233121872, -0.24629420042037964, 0.10100986808538437, -0.09616720676422119, -0.13417977094650269, -0.20669177174568176, -0.007541477680206299, -0.19858524203300476, -0.09780923277139664, 0.06083245947957039, 0.1544143408536911, 0.11085142195224762, -0.08704270422458649, 0.05008672550320625], [0.2832932472229004, -0.006714070215821266, -0.2953055799007416, 0.05587072670459747, 0.016231661662459373, -0.2408466935157776, -0.18456707894802094, 0.130093514919281, -0.23696395754814148, 0.15508270263671875, -0.1700359433889389, -0.2430519163608551, -0.05247721076011658, 0.09427261352539062, -0.1313578188419342, -0.08432769775390625, 0.04954679682850838, -0.11012161523103714, -0.028470154851675034, 0.1239238828420639, 0.027567986398935318, 0.041766196489334106, -0.11237810552120209, 0.02155875600874424, 0.22123992443084717, 0.0897211953997612, 0.348681777715683, 0.06686154752969742, 0.04036588966846466, 0.12343213707208633, 0.2933606803417206, 0.1713007241487503, 0.18253539502620697, -0.03184674680233002, -0.059854522347450256, 0.21029731631278992, -0.2599430978298187, 0.16424696147441864, 0.202204167842865, -0.04777384549379349, 0.11126907169818878, 0.15847039222717285, 0.3308505117893219, 0.14556899666786194, -0.11911439895629883, -0.010401535779237747, -0.02134869620203972, -0.02291484735906124], [0.3396710455417633, -0.10261266678571701, -0.1817818135023117, 0.09410112351179123, -0.19439812004566193, -0.11123308539390564, 0.1244475394487381, 0.07713250070810318, -0.11609207093715668, -0.03793239966034889, 0.06716863065958023, -0.04843398183584213, 0.171909362077713, 0.1394234597682953, 0.054887715727090836, 0.037167176604270935, 0.051904503256082535, 0.008076642639935017, 0.07132787257432938, -0.020449461415410042, 0.05962193384766579, 0.08437349647283554, 0.03477345034480095, 0.15649569034576416, 0.08775951713323593, 0.16584616899490356, 0.2166305035352707, 0.00953950360417366, 0.02331041544675827, 0.18665708601474762, 0.24165785312652588, 0.11648773401975632, 0.2546454071998596, 0.12304773181676865, 0.1907876878976822, 0.23945824801921844, -0.29365432262420654, 0.365104615688324, 0.255930095911026, 0.11977241933345795, 0.138946533203125, 0.09630711376667023, 0.19963975250720978, 0.2190529853105545, -0.08804673701524734, 0.09340263158082962, -0.17048054933547974, -0.04963454231619835], [0.4214729964733124, -0.2478504180908203, -0.17723791301250458, -0.02100696787238121, -0.02038218267261982, -0.1721467226743698, -0.17882858216762543, 0.10410986840724945, -0.14031951129436493, 0.02410450391471386, 0.020365215837955475, -0.1158996969461441, 0.1325063705444336, 0.0724419355392456, -0.012819464318454266, 0.11901473999023438, -0.010711072944104671, -0.021177247166633606, -0.05845421552658081, 0.12135085463523865, -0.012881177477538586, 0.08577721565961838, -0.03968266397714615, 0.16173255443572998, -0.04132770374417305, 0.016573257744312286, 0.12718848884105682, -0.046605344861745834, -0.0764472708106041, 0.191873237490654, 0.25527167320251465, 0.18682247400283813, 0.04751390963792801, 0.0741928219795227, 0.06944779306650162, 0.11721709370613098, -0.14684797823429108, 0.02608102187514305, 0.0065195607021451, 0.01795499213039875, 0.035961732268333435, 0.12770728766918182, 0.14036697149276733, 0.11475758254528046, -0.14292670786380768, 0.1041049212217331, -0.017562953755259514, 0.11095298826694489], [-0.31722205877304077, 0.06466250121593475, 0.12911993265151978, -0.06410901993513107, 0.04162200167775154, 0.03466666862368584, 0.034065213054418564, 0.27136117219924927, 0.18757960200309753, -0.06319455057382584, 0.0310952290892601, 0.29355525970458984, 0.008872037753462791, 0.1713295876979828, 0.29138973355293274, 0.07076171040534973, 0.2801916003227234, 0.30781856179237366, 0.0018008470069617033, 0.04360863193869591, 0.3050183653831482, -0.006918798200786114, -0.12233081459999084, 0.16252540051937103, -0.01166627835482359, 0.0892709493637085, -0.003710433840751648, -0.07404913008213043, 0.10012725740671158, -0.0003817730175796896, -0.0546749122440815, -0.09626119583845139, -0.17736180126667023, -0.09880880266427994, -0.16845403611660004, -0.01100205723196268, 0.3278621435165405, -0.15336449444293976, -0.034973662346601486, -0.08216973394155502, -0.01318286545574665, -0.17272844910621643, -0.019201895222067833, -0.04902986064553261, 0.05264206975698471, 0.12273693829774857, 0.06797212362289429, -0.0534152053296566], [-0.19579680263996124, 0.0991063043475151, 0.18804170191287994, 0.005302274599671364, 0.13114027678966522, 0.16408111155033112, 0.022379081696271896, -0.0747281014919281, 0.29315096139907837, 0.04032113775610924, 0.1233890950679779, 0.2637201249599457, -0.21948890388011932, 0.06436078995466232, 0.09415894001722336, -0.020851686596870422, -0.08225992321968079, 0.07906731963157654, 0.044091686606407166, 0.11232125014066696, 0.08342007547616959, -0.09148764610290527, -0.08838751167058945, -0.03630537912249565, 0.030791906639933586, -0.011016914620995522, -0.10300517827272415, 0.009813046082854271, -0.09693986177444458, -0.09896036237478256, -0.22122694551944733, -0.05618569627404213, -0.1913095861673355, -0.04029328376054764, 0.004381575621664524, -0.23180662095546722, 0.17737378180027008, -0.08770637959241867, 0.04228731244802475, 0.09614399820566177, -0.09045971930027008, -0.1729721575975418, -0.03315485268831253, 0.09411808848381042, 0.1620364487171173, 0.007959061302244663, -0.017217107117176056, 0.09900776296854019], [-0.3302744925022125, 0.057718679308891296, -0.20696492493152618, 0.14641280472278595, -0.0934140682220459, -0.0604478158056736, 0.02028133161365986, -0.08923006802797318, -0.09354991465806961, 0.19023948907852173, 0.04242238774895668, -0.06185764819383621, 0.07297705113887787, -0.20688582956790924, -0.2738863229751587, -0.09320241212844849, 0.02232413738965988, -0.21828506886959076, -0.04478173702955246, -0.12048561125993729, -0.21049703657627106, -0.09666498750448227, -0.025534693151712418, 0.051172658801078796, -0.10427810996770859, 0.16381999850273132, 0.11236194521188736, 0.15335124731063843, 0.14023658633232117, 0.11753451079130173, 0.021139441058039665, -0.0326937697827816, 0.25838524103164673, -0.1703902930021286, 0.23129165172576904, 0.18376491963863373, -0.059356361627578735, 0.3339847922325134, 0.10964786261320114, 0.05306022986769676, 0.13231423497200012, 0.04370658099651337, -0.04417979344725609, 0.24696952104568481, -0.025248108431696892, -0.058200620114803314, -0.1266135573387146, 0.07808522135019302], [0.2078850269317627, 0.09459084272384644, 0.2570675015449524, 0.10994967073202133, 0.0435953214764595, 0.12887807190418243, -0.22682975232601166, 0.03798641264438629, 0.18655292689800262, -0.12659138441085815, 0.13152125477790833, 0.1146046370267868, -0.1624201536178589, 0.07817502319812775, 0.1354803591966629, -0.044418815523386, 0.08466646075248718, 0.2227081060409546, -0.016087926924228668, 0.21286296844482422, 0.04955046996474266, -0.009406122379004955, -0.030627213418483734, 0.09208071231842041, 0.0458214096724987, -0.011646691709756851, -0.14011694490909576, 0.12399610131978989, -0.10436396300792694, 0.05701373517513275, -0.10319167375564575, 0.0445360504090786, -0.05817149952054024, 0.008355730213224888, 0.03700748085975647, -0.06591281294822693, 0.3251141905784607, -0.09680984914302826, -0.11026517301797867, -0.09172707051038742, -0.1755843162536621, -0.2529725134372711, 0.14527826011180878, -0.058996520936489105, 0.08741242438554764, 0.050030604004859924, 0.036898598074913025, -0.05052141472697258], [0.25359803438186646, -0.04081479832530022, -0.22459781169891357, -0.10748052597045898, -0.0006992073613218963, -0.014801411889493465, 0.06571119278669357, 0.16510283946990967, -0.08620110154151917, 0.04437322914600372, 0.019847987219691277, -0.2248850017786026, 0.22990195453166962, 0.1265985369682312, -0.053044356405735016, 0.07500453293323517, 0.16391006112098694, -0.11138036847114563, 0.0020476088393479586, 0.1853126734495163, 0.16983461380004883, -0.09832900017499924, 0.17109864950180054, 0.12243610620498657, 0.07396641373634338, 0.07423979789018631, 0.35623952746391296, -0.06224815174937248, 0.13187631964683533, -0.04449697956442833, 0.1268720179796219, 0.22812238335609436, 0.229619100689888, -0.04631742462515831, 0.05315211042761803, 0.19563928246498108, -0.13061147928237915, 0.09965094178915024, 0.15892380475997925, 0.14166724681854248, 0.07058464735746384, 0.14068901538848877, 0.20195409655570984, 0.15165311098098755, -0.06731610000133514, -0.029668442904949188, -0.015933025628328323, 0.06412357091903687], [-0.16106249392032623, 0.04227609559893608, -0.2608281075954437, -0.0797748863697052, 0.0952434316277504, -0.11799962818622589, 0.1977902501821518, -0.04035777226090431, -0.13936257362365723, 0.03403911367058754, 0.02503780648112297, -0.23400817811489105, 0.21539205312728882, -0.20768079161643982, -0.043533314019441605, -0.09299539774656296, -0.16541196405887604, -0.2615221440792084, 0.19887642562389374, -0.12096991389989853, -0.1025770902633667, 0.06946014612913132, -0.08701366931200027, -0.05801020562648773, 0.0927686095237732, 0.03514911234378815, 0.0688854455947876, -0.05696482956409454, -0.06481800973415375, 0.040173619985580444, 0.021093733608722687, 0.20165486633777618, 0.1525827944278717, 0.003950737416744232, -0.0006909440853632987, 0.1525537520647049, -0.15144135057926178, 0.27667564153671265, 0.20999997854232788, 0.08095478266477585, 0.2883474826812744, 0.29726144671440125, -0.08925402909517288, 0.13222628831863403, -0.18886831402778625, 0.025139013305306435, 0.013134531676769257, 0.015858149155974388], [0.3193622827529907, 0.01978696696460247, 0.02589009515941143, -0.03847354277968407, 0.03541997820138931, -0.03509754315018654, -0.22360540926456451, 0.0037226143758744, -0.09087954461574554, 0.07836908847093582, 0.004128746688365936, 0.04208637401461601, -0.2142028659582138, 0.3815824091434479, 0.09843894094228745, -0.05403641238808632, 0.003418114734813571, 0.239983931183815, 0.074226513504982, -0.008771066553890705, 0.10435467958450317, 0.1812153458595276, 0.03372382000088692, 0.2871590256690979, 0.014899526722729206, -0.07133902609348297, -0.08429116755723953, -0.05625980347394943, -0.0342780239880085, -0.13576820492744446, 0.040728531777858734, 0.016784792765975, 0.05565502494573593, 0.03696548938751221, -0.07598961889743805, 0.1110687404870987, 0.24998608231544495, 0.01795564591884613, 0.13382814824581146, -0.06671040505170822, -0.07183100283145905, -0.016748791560530663, 0.37520894408226013, -0.18370048701763153, 0.11523473262786865, 0.1302952766418457, 0.06751004606485367, -0.1816241294145584], [0.046265192329883575, 0.08935269713401794, 0.22197701036930084, 0.14047299325466156, 0.003282553516328335, 0.023640872910618782, 0.09973148256540298, 0.1835445612668991, 0.28894785046577454, -0.05478847026824951, 0.13695019483566284, 0.08564777672290802, -0.06684114038944244, 0.07223232090473175, 0.3602558672428131, 0.1544211357831955, 0.22845374047756195, 0.23975755274295807, 0.11186712980270386, 0.18954002857208252, 0.3172549307346344, 0.1898973137140274, 0.0010636921506375074, -0.026182085275650024, -0.15132586658000946, 0.1989213228225708, -0.09108218550682068, 0.01744728535413742, 0.08395083993673325, -0.12098431587219238, -0.15370959043502808, -0.09171735495328903, -0.026775304228067398, 0.08154260367155075, -0.09181608259677887, -0.2518593370914459, 0.180931955575943, -0.1544814258813858, -0.19006799161434174, 0.0395178496837616, -0.2366509884595871, -0.2759552597999573, 0.017802264541387558, -0.0873299092054367, 0.25708693265914917, 0.12302141636610031, 0.04004577547311783, -0.21677394211292267], [0.24251943826675415, 0.038438860327005386, 0.20130710303783417, 0.11935395002365112, -0.06501979380846024, 0.08250096440315247, 0.06862224638462067, -0.0020790547132492065, 0.3273216187953949, -0.11877933889627457, 0.14393824338912964, 0.22364942729473114, -0.20813652873039246, 0.22616250813007355, 0.08843793720006943, 0.024296659976243973, 0.25779107213020325, 0.10866096615791321, 0.07631535083055496, 0.15116825699806213, 0.14171651005744934, 0.011160781607031822, 0.10126013308763504, -0.015825511887669563, 0.09565024822950363, 0.07410617917776108, -0.22622506320476532, -0.14807026088237762, 0.09061958640813828, -0.042557138949632645, 0.0547289177775383, -0.033240024000406265, -0.07250335812568665, 0.1745316982269287, -0.20035775005817413, -0.22933202981948853, 0.33384591341018677, -0.0069907899014651775, 0.02957863174378872, -0.19937047362327576, -0.12353355437517166, -0.20646680891513824, 0.19221477210521698, -0.1502937227487564, 0.3318498432636261, 0.15728574991226196, 0.09729169309139252, -0.1218172237277031], [-0.0999506339430809, 0.026477685198187828, -0.025249585509300232, 0.024120287969708443, 0.1328163892030716, 0.17218489944934845, 0.3561810255050659, 0.024154242128133774, -0.03991514444351196, 0.0381636805832386, 0.0038207729812711477, -0.1051531583070755, 0.32620927691459656, 0.007153586950153112, 0.11506573855876923, -0.1401338279247284, -0.03228142112493515, 0.017935331910848618, 0.16875994205474854, -0.14274908602237701, 0.03547677397727966, 0.009028199128806591, 0.0545540452003479, -0.07649803906679153, 0.10164200514554977, -0.025016535073518753, 0.16625219583511353, 0.13004370033740997, 0.04533541202545166, 0.17068462073802948, 0.2043456882238388, 0.15241551399230957, 0.2581222951412201, -0.032844118773937225, 0.14080899953842163, 0.08582614362239838, -0.07572389394044876, 0.35903358459472656, 0.3127788305282593, 0.2203899472951889, 0.19531971216201782, 0.24824467301368713, -0.07593521475791931, 0.29323849081993103, 0.03238283097743988, 0.1525743007659912, 0.08032697439193726, 0.1351940780878067], [-0.2616017162799835, 0.28253114223480225, 0.30524373054504395, 0.06101265549659729, 0.040411923080682755, -0.0033823936246335506, 0.074981190264225, 0.017559075728058815, 0.30474141240119934, -0.14966262876987457, 0.1617680788040161, 0.0974518433213234, -0.16634432971477509, 0.04863373190164566, 0.27047351002693176, 0.15739217400550842, 0.2085006684064865, 0.25141799449920654, -0.10485810041427612, 0.15810756385326385, 0.13889645040035248, -0.05599487945437431, -0.011753903701901436, -0.006321541499346495, 0.0801638811826706, 0.047288522124290466, -0.022430486977100372, -0.08334171772003174, 0.036638639867305756, -0.16662496328353882, -0.1848970502614975, -0.05214504525065422, -0.10420394688844681, -0.031227124854922295, -0.09866174310445786, -0.19249393045902252, 0.2487126737833023, -0.11489847302436829, 0.00901793409138918, -0.019297940656542778, -0.025268223136663437, -0.26447656750679016, -0.09747183322906494, -0.02826661616563797, 0.19722498953342438, -0.08861272782087326, 0.1090768426656723, 0.009853141382336617], [-0.05739307403564453, -0.00787552259862423, -0.06571131944656372, 0.002211866434663534, 0.09102915227413177, -0.13679176568984985, 0.15466280281543732, -0.16588249802589417, -0.18384051322937012, 0.09302150458097458, -0.04311194643378258, -0.15476468205451965, 0.1280127465724945, -0.17302735149860382, -0.02351185865700245, -0.169895201921463, 0.0201838631182909, -0.2390683889389038, 0.06960650533437729, 0.012681539170444012, -0.050173863768577576, -0.14163705706596375, 0.12696205079555511, 0.0790720209479332, 0.17938244342803955, 0.17071621119976044, 0.3005763292312622, -0.05730821564793587, 0.005306682549417019, 0.1548491269350052, 0.050104960799217224, 0.01695176213979721, 0.14552336931228638, -0.013867681846022606, 0.22755439579486847, 0.12075943499803543, -0.3422543406486511, 0.32199057936668396, 0.12055598944425583, 0.0868506133556366, 0.24581824243068695, 0.12696120142936707, -0.0252213217318058, 0.35555946826934814, -0.19057556986808777, -0.10196288675069809, 0.12656734883785248, 0.17243893444538116], [0.130861297249794, 0.05380100756883621, -0.04448845610022545, 0.028073837980628014, -0.05623370781540871, -0.07901694625616074, 0.22124908864498138, -0.1321905255317688, -0.05214736610651016, 0.14524425566196442, 0.010135962627828121, -0.11550159007310867, 0.21020689606666565, -0.25463372468948364, -0.06065089628100395, 0.09613970667123795, 0.0064306361600756645, -0.07818986475467682, 0.11032926291227341, 0.09156498312950134, 0.024743465706706047, 0.09262323379516602, -0.14213261008262634, -0.04752497002482414, -0.02733009308576584, 0.017140217125415802, 0.28575971722602844, 0.17135672271251678, -0.04708050563931465, 0.031052762642502785, 0.12460033595561981, 0.07313666492700577, 0.19575883448123932, -0.07489010691642761, 0.0378422848880291, 0.2785033583641052, -0.20207223296165466, 0.14673063158988953, 0.13331061601638794, 0.15121036767959595, 0.24284231662750244, 0.2798991799354553, -0.1593526154756546, 0.3277919888496399, -0.026847856119275093, 0.054206982254981995, -0.0111590176820755, 0.05550721660256386], [0.5063174962997437, -0.16989432275295258, 0.10873611271381378, 0.05323305353522301, -0.08223511278629303, 0.00028595776529982686, -0.05470970645546913, -0.04692980647087097, 0.10329815745353699, 0.1111358255147934, 0.06950228661298752, -0.009310415014624596, -0.18597547709941864, 0.10172457993030548, 0.036180734634399414, 0.01799659989774227, 0.059171076864004135, -0.01719013787806034, -0.08435554057359695, -0.03961119055747986, 0.13844901323318481, 0.07487424463033676, 0.11325276643037796, 0.08711706101894379, 0.08950795978307724, -0.036132022738456726, -0.1564861387014389, -0.010257704183459282, -0.03081185184419155, 0.022694604471325874, 0.1734919399023056, 0.03346732258796692, 0.1408408284187317, -0.030316472053527832, 0.1455000340938568, 0.10123628377914429, -0.13315187394618988, 0.0977640375494957, 0.11680492013692856, 0.09425141662359238, -0.1325976550579071, 0.11042624711990356, 0.16197702288627625, -0.09941466152667999, 0.03226231411099434, -0.029376281425356865, -0.14730042219161987, -0.12510178983211517], [0.18072214722633362, -0.06090380996465683, -0.14920786023139954, -0.1133359894156456, -0.03965064510703087, -0.06488298624753952, 0.12752550840377808, -0.037318356335163116, -0.15856274962425232, 0.20459604263305664, -0.08975572884082794, -0.12607526779174805, 0.2125348597764969, -0.17795099318027496, -0.054230570793151855, -0.06621747463941574, -0.10502427071332932, -0.13176865875720978, -0.02031998708844185, 0.0013455277075991035, 0.20093439519405365, -0.02577533759176731, 0.165835440158844, -0.02795262262225151, -0.03627270087599754, -0.024506203830242157, 0.22043941915035248, -0.00887876097112894, -0.08962755650281906, 0.04258768633008003, 0.10737907886505127, -0.04729880392551422, 0.3003028333187103, -0.032091233879327774, -0.0252529289573431, 0.2616753876209259, -0.28655171394348145, 0.3324975371360779, 0.07199046015739441, 0.1655917465686798, -0.03603646531701088, 0.17861132323741913, 0.07969646900892258, 0.2229689210653305, -0.013311032205820084, 0.06328632682561874, 0.03657126426696777, -0.006093338131904602], [0.1200314313173294, -0.16165031492710114, -0.22912463545799255, 0.01399208139628172, -0.14898237586021423, -0.20569704473018646, -0.10203813761472702, 0.070226289331913, -0.1556878238916397, 0.08124681562185287, -0.0734708309173584, -0.24128374457359314, -0.014650875702500343, -0.07427943497896194, -0.050888542085886, 0.011133076623082161, -0.0734458863735199, 0.034541770815849304, -0.024916792288422585, 0.08127569407224655, 0.050646379590034485, -0.045161765068769455, -0.04397626221179962, 0.09610762447118759, 0.21267302334308624, 0.16343531012535095, 0.2734484076499939, 0.1880638748407364, -0.054926805198192596, 0.05780749395489693, 0.16472193598747253, 0.18378379940986633, 0.1489398181438446, -0.13353805243968964, 0.1269548535346985, 0.23879499733448029, -0.2446802705526352, 0.10997619479894638, 0.1605992466211319, 0.02466745860874653, 0.17929019033908844, 0.19132164120674133, 0.1599278599023819, 0.06714446097612381, -0.045919228345155716, 0.13391967117786407, -0.002970473375171423, 0.011347850784659386], [0.029508503153920174, -0.14286349713802338, -0.026932338252663612, 0.013484344817698002, 0.10011419653892517, -0.00779239134863019, 0.13979925215244293, 0.016937386244535446, -0.13684377074241638, 0.06475120037794113, -0.06062423065304756, 0.01639162003993988, 0.1941886842250824, 0.020979898050427437, -0.0948762372136116, 0.026929941028356552, -0.1012294664978981, 0.048371508717536926, 0.11759152263402939, 0.0006798601243644953, -0.00969354435801506, -0.07486294955015182, -0.0366855263710022, -0.04118742793798447, -0.025642968714237213, 0.11208193749189377, 0.14926545321941376, 0.0001343268813798204, -0.08429114520549774, 0.20937560498714447, 0.27730807662010193, 0.19943317770957947, 0.07197685539722443, -0.0632677897810936, 0.07261504977941513, 0.2976054847240448, -0.07066349685192108, 0.1416677087545395, 0.04689280316233635, 0.12959274649620056, 0.07664719969034195, 0.2677980363368988, 0.13557776808738708, 0.27434468269348145, -0.14477775990962982, 0.07450306415557861, 0.002788911107927561, 0.02984349988400936], [-0.2151467651128769, 0.2305210828781128, 0.04402129724621773, -0.11322938650846481, 0.08640286326408386, 0.013460622169077396, -0.08580619841814041, 0.2462465912103653, 0.1525448113679886, 0.019611597061157227, 0.10169482231140137, 0.25091204047203064, -0.09009566158056259, 0.27823489904403687, -0.11673219501972198, 0.010656850412487984, 0.0524991936981678, 0.34950628876686096, 0.09546422213315964, 0.022464491426944733, -0.050790946930646896, 0.16985049843788147, -0.00823113601654768, 0.13663248717784882, 0.1330418735742569, 0.03813762962818146, -0.049249351024627686, -0.03694596886634827, -0.08788993209600449, 0.12851715087890625, -0.03659600391983986, -0.07447874546051025, -0.0582064613699913, -0.08240579813718796, 0.08498231321573257, -0.2085149735212326, 0.40205514430999756, -0.20964358747005463, 0.07754325121641159, -0.0033782506361603737, -0.14319489896297455, -0.1459549367427826, 0.003743504174053669, 0.06819049268960953, 0.13908322155475616, -0.03437289223074913, 0.0939745381474495, 0.05322848632931709], [0.39569878578186035, -0.16206799447536469, -0.09196101129055023, -0.07579576969146729, -0.17179609835147858, -0.08993899077177048, -0.13804525136947632, 0.09761737287044525, 0.1941133588552475, -0.04345672205090523, 0.11609207093715668, -0.0853051096200943, -0.14290544390678406, 0.35206300020217896, 0.2057020217180252, 0.1952049881219864, -0.08100051432847977, 0.0863594263792038, -0.032924335449934006, 0.2807536721229553, 0.06683182716369629, -0.004407311789691448, 0.19109700620174408, 0.021476278081536293, 0.059727367013692856, 0.0039051203057169914, -0.018527206033468246, 0.12524212896823883, -0.06845572590827942, 0.11705123633146286, 0.20524132251739502, 0.16131214797496796, -0.018404856324195862, -0.14497731626033783, 0.08179166167974472, 0.20853327214717865, -0.01855832152068615, -0.03209974244236946, 0.021431894972920418, -0.02314487099647522, 0.12847955524921417, -0.08730800449848175, 0.32942867279052734, 0.0981624647974968, 0.06567985564470291, 0.13036897778511047, -0.09874364733695984, -0.0599200464785099], [0.07277935743331909, -0.07533412426710129, 0.13529706001281738, -0.1173386350274086, -0.048179492354393005, -0.04308430850505829, -0.3178462088108063, 0.14049524068832397, -0.0552629679441452, 0.07499398291110992, 0.15804454684257507, 0.20469866693019867, -0.3742500841617584, 0.08877503871917725, 0.009450012817978859, -0.021098904311656952, 0.11304451525211334, 0.3249491751194, -0.23197345435619354, -0.03006572835147381, 0.00482004601508379, 0.04365703463554382, -0.09485932439565659, 0.16575172543525696, -0.003506922163069248, 0.02181847207248211, 0.10572633147239685, -0.058234311640262604, -0.0025549582205712795, 0.09689708799123764, 0.026603909209370613, 0.28292620182037354, 0.06517160683870316, 0.027631869539618492, 0.04980597272515297, 0.040667466819286346, 0.497781366109848, -0.044289108365774155, 0.08844874799251556, -0.14251184463500977, -0.05543527379631996, -0.24514546990394592, 0.31504252552986145, 0.08638150990009308, 0.15049785375595093, 0.12971098721027374, -0.09968139976263046, -0.20060591399669647], [0.34470072388648987, -0.020222170278429985, -0.28753119707107544, -0.07668478786945343, -0.014057298190891743, -0.12197837978601456, -0.12946364283561707, -0.07486075162887573, -0.0678311139345169, 0.15875323116779327, 0.051433075219392776, -0.03514915332198143, -0.04017452523112297, 0.16965557634830475, -0.19508394598960876, -0.0422123558819294, -0.11777666211128235, -0.10928252339363098, 0.018867425620555878, 0.12969356775283813, -0.0781983956694603, -0.11843637377023697, 0.17253410816192627, 0.13293130695819855, 0.04869164153933525, 0.1687101423740387, 0.09490051865577698, -0.06361102312803268, -0.07757949084043503, 0.10672793537378311, 0.26559925079345703, 0.19627313315868378, 0.12820333242416382, 0.005115058273077011, 0.06570175290107727, 0.18426935374736786, -0.2872844934463501, 0.016461510211229324, 0.06866490095853806, -0.08700541406869888, 0.03598621487617493, 0.016257120296359062, 0.2595061659812927, 0.031397297978401184, -0.05637238919734955, 0.13806010782718658, -0.10328231006860733, -0.10384142398834229], [-0.09481601417064667, 0.3329475522041321, 0.05150381848216057, 0.15673445165157318, 0.050538741052150726, 0.18767601251602173, 0.07483316212892532, 0.2134234607219696, 0.07200468331575394, -0.12869764864444733, -0.058055296540260315, 0.1623942255973816, -0.09236116707324982, 0.04148136451840401, 0.1905013620853424, 0.03724975138902664, 0.19122308492660522, 0.188751220703125, -0.017307914793491364, 0.11470968276262283, -0.11148330569267273, -0.03905961290001869, -0.06623244285583496, -0.15215210616588593, -0.11438468843698502, -0.0325915664434433, 0.1005931943655014, 0.1294434517621994, 0.02693447843194008, -0.09679994732141495, -0.09859653562307358, 0.07680557668209076, -0.08508673310279846, -0.04439597204327583, 0.010616322979331017, -0.12993577122688293, 0.47193366289138794, -0.019629215821623802, 0.08138716965913773, 0.08943823724985123, -0.12491550296545029, -0.14064349234104156, -0.12045678496360779, 0.32500821352005005, 0.06648824363946915, -0.13713790476322174, 0.07067841291427612, 0.12825791537761688], [0.19695937633514404, 0.03189597651362419, -0.25418907403945923, -0.026321306824684143, -0.1482938826084137, -0.06004015728831291, 0.10842005163431168, 0.04491830989718437, -0.17902934551239014, 0.18285910785198212, -0.026538854464888573, -0.044062744826078415, 0.33633720874786377, -0.0203228909522295, -0.15325720608234406, 0.013499409891664982, 0.03835529461503029, -0.22972844541072845, 0.11558602750301361, 0.0657457560300827, 0.10159415006637573, -0.07384195178747177, 0.06677524745464325, -0.09674257785081863, -0.06209121644496918, 0.005716896150261164, 0.1981692612171173, 0.1598791480064392, -0.0768902525305748, 0.17938441038131714, 0.21542653441429138, 0.17119567096233368, 0.17771010100841522, -0.04330182075500488, 0.025161053985357285, 0.024669552221894264, -0.2578495144844055, 0.38429075479507446, 0.03378703445196152, -0.04590893164277077, 0.049250368028879166, 0.12293791025876999, -0.05835368484258652, 0.31720611453056335, -0.03312204033136368, 0.029670722782611847, -0.13508813083171844, -0.03865962475538254], [0.3549829125404358, 0.014777951873838902, -0.05364598333835602, 0.02441241778433323, -0.08943264931440353, -0.15547707676887512, -0.21455831825733185, 0.025113940238952637, -0.2287997603416443, 0.1651524305343628, -0.11105959117412567, -0.1866023987531662, 0.02056770585477352, 0.003191567026078701, -0.09978488087654114, -0.0323270820081234, 0.06938207149505615, 0.07653068006038666, 0.2226543128490448, 0.1556844860315323, -0.04037678614258766, -0.1433861404657364, 0.06458791345357895, 0.07737204432487488, 0.23596151173114777, 0.025822877883911133, 0.23932510614395142, -0.013228814117610455, -0.07379882037639618, 0.0764879658818245, 0.06512130796909332, 0.17812740802764893, 0.19965511560440063, -0.07374483346939087, -0.058993395417928696, 0.08344133198261261, -0.248397096991539, 0.04429073631763458, 0.09382308274507523, 0.0600639171898365, 0.14876028895378113, 0.2203264683485031, 0.32645052671432495, -0.09908170998096466, -0.26617422699928284, -0.05328001454472542, 0.07209284603595734, -0.06739950180053711], [-0.4681682884693146, 0.28481540083885193, 0.28806111216545105, 0.10379508882761002, 0.15349586308002472, 0.2600701153278351, 0.12510259449481964, 0.047967348247766495, 0.2523098289966583, -0.08237873017787933, 0.07135545462369919, 0.1547934114933014, 0.13025729358196259, 0.048956241458654404, 0.028672335669398308, -0.07257767766714096, 0.02915751002728939, 0.04329826682806015, -0.06317710876464844, -0.07816257327795029, -0.023994455114006996, -0.10250326246023178, -0.14999234676361084, -0.05369039997458458, 0.04592882841825485, 0.08294171094894409, 0.010293119587004185, -0.02649441920220852, 0.018354836851358414, 0.07888814061880112, -0.11103082448244095, -0.058520376682281494, -0.08567867428064346, 0.1367635726928711, 0.05068042874336243, -0.1263308972120285, 0.20041179656982422, -0.03137706592679024, -0.03702148050069809, -0.007775495760142803, -0.08124390244483948, -0.1923825442790985, -0.27628007531166077, 0.11456584185361862, 0.1337563395500183, 0.015225465409457684, 0.07051455229520798, 0.03566525876522064], [0.3806328773498535, -0.2070610374212265, 0.12244538962841034, -0.03168252855539322, -0.12237247824668884, -0.18003082275390625, -0.24703280627727509, 0.2575451731681824, 0.02619057148694992, 0.09786652028560638, 0.02676747553050518, 0.07696664333343506, -0.208778977394104, 0.1438438445329666, 0.06644316762685776, 0.1146312803030014, -0.012198870070278645, 0.28764525055885315, -0.10698381811380386, 0.2338847517967224, -0.02495572529733181, -0.0056641120463609695, 0.17481458187103271, 0.1460721343755722, 0.13344290852546692, -0.004463954363018274, 0.09110935777425766, -0.06735868006944656, -0.030806060880422592, -0.03925243392586708, 0.11799338459968567, 0.005472647957503796, 0.018055913969874382, 0.014328218065202236, 0.06953402608633041, 0.0791635811328888, 0.1750868707895279, -0.021297389641404152, 0.08930154144763947, -0.007800248451530933, -0.08297932893037796, -0.014987467788159847, 0.2327273190021515, 0.10491543263196945, -0.014145084656774998, 0.15686561167240143, 0.003955953288823366, -0.20802074670791626], [0.2254975289106369, -0.03275221213698387, -0.1708761602640152, 0.06906300783157349, -0.19375869631767273, -0.2363574504852295, -0.13152477145195007, -0.023765021935105324, -0.028178861364722252, 0.20134767889976501, -0.14136208593845367, -0.016173414885997772, -0.04051649942994118, 0.14122459292411804, -0.1277778297662735, -0.13304680585861206, 0.08774593472480774, 0.051053375005722046, 0.056091420352458954, 0.017173482105135918, 0.11361183971166611, -0.06164456158876419, 0.01147887296974659, 0.19365401566028595, 0.1865636706352234, -0.02642945572733879, 0.19896847009658813, -0.017476806417107582, 0.01577502302825451, 0.16614827513694763, 0.2817588150501251, 0.18607519567012787, 0.30218952894210815, 0.08672482520341873, 0.03912454843521118, 0.2779102921485901, -0.17099545896053314, 0.10838328301906586, 0.057916443794965744, 0.048877205699682236, 0.1016245111823082, 0.06198524683713913, 0.22758693993091583, -0.11247801780700684, -0.18181224167346954, -0.03599253669381142, 0.0449233241379261, 0.05559961497783661], [0.027006790041923523, 0.07639310508966446, -0.281080037355423, 0.07383444905281067, 0.07070893794298172, 0.07549813389778137, 0.023332912474870682, -0.057391490787267685, -0.10606911033391953, -0.05861217528581619, -0.07428478449583054, -0.08253990113735199, 0.15397734940052032, -0.18046993017196655, -0.2845819592475891, -0.140665665268898, -0.1203780397772789, -0.27543550729751587, 0.12360096722841263, -0.07222512364387512, 0.03519561141729355, -0.1716870814561844, -0.026012279093265533, -0.12034790962934494, 0.0039714607410132885, 0.11568230390548706, 0.1970294713973999, 0.07425756007432938, 0.026549866423010826, -0.04929537698626518, 0.16441120207309723, 0.22110524773597717, 0.09978281706571579, 0.030418382957577705, 0.08521389961242676, 0.08133633434772491, -0.1758379191160202, 0.19117380678653717, 0.03102613240480423, 0.08432105928659439, 0.06263436377048492, 0.32514065504074097, 0.10163234919309616, 0.30066677927970886, -0.1553668975830078, -0.13253915309906006, -0.0443522185087204, 0.09435699135065079], [0.3143383264541626, 0.0836300328373909, -0.06637473404407501, -0.04130661115050316, -0.0902363732457161, -0.06731486320495605, -0.1469699591398239, 0.062014807015657425, 0.16648705303668976, -0.015399105846881866, -0.054777152836322784, 0.03999164327979088, -0.20224504172801971, 0.3988402485847473, 0.06907662004232407, 0.13183262944221497, 0.09613995999097824, 0.30006104707717896, -0.002081748330965638, 0.12958447635173798, 0.053547363728284836, 0.1494518369436264, -0.0368402823805809, 0.19734176993370056, 0.1687309890985489, 0.05689850077033043, 0.19573338329792023, 0.027681546285748482, 0.008321816101670265, 0.09130242466926575, 0.28710711002349854, -0.051966577768325806, 0.04052941873669624, -0.06454108655452728, -0.10829883813858032, 0.06693542748689651, 0.15741662681102753, -0.07244562357664108, 0.04358568787574768, -0.007238921709358692, -0.08212209492921829, 0.046359557658433914, 0.2087111473083496, -0.19621440768241882, 0.12423256039619446, 0.1511785238981247, -0.16439233720302582, -0.11095914244651794], [0.20927225053310394, -0.04176073521375656, -0.15528757870197296, -0.03148441016674042, 0.06822879612445831, -0.02782233990728855, 0.2590692639350891, -0.11906815320253372, -0.16019828617572784, 0.16313786804676056, -0.11910450458526611, -0.13064244389533997, 0.17195914685726166, 0.03823293000459671, 0.0657181516289711, -0.01773425191640854, -0.08979228883981705, -0.12491630762815475, 0.034916624426841736, 0.018216483294963837, 0.07508523017168045, -0.061776891350746155, 0.09805238246917725, -0.10371959209442139, 0.19837993383407593, -0.05272059887647629, 0.17913947999477386, 0.17890407145023346, -0.04472830146551132, 0.19091592729091644, 0.07741589099168777, 0.1537860929965973, 0.06296833604574203, 0.06385601311922073, -0.03831099346280098, 0.2554210424423218, -0.2725965976715088, 0.3193124234676361, -0.045343946665525436, -0.043518971651792526, 0.14761199057102203, 0.08501584827899933, -0.08573805540800095, 0.18771372735500336, -0.09645351022481918, 0.03432654216885567, -0.10140879452228546, 0.18784701824188232], [-0.28991225361824036, 0.015655431896448135, 0.3401806354522705, 0.05856975540518761, -0.05167786404490471, 0.13355706632137299, -0.07532809674739838, 0.23319311439990997, 0.3062349557876587, -0.017234208062291145, -0.011924449354410172, 0.22279652953147888, -0.1545243114233017, 0.252066433429718, 0.13432082533836365, 0.06606801599264145, 0.04000217467546463, 0.16340935230255127, 0.1046898141503334, 0.12317092716693878, 0.24836969375610352, 0.11013350635766983, 0.12497561424970627, -0.07090814411640167, -0.10150660574436188, 0.1376790851354599, -0.16162854433059692, -0.08392481505870819, -0.1316712200641632, -0.10025724768638611, -0.13068252801895142, -0.018318230286240578, -0.16742351651191711, 0.03527733311057091, 0.04612771049141884, -0.10746036469936371, 0.31668663024902344, -0.15525925159454346, -0.20547370612621307, -0.0796385407447815, -0.20035819709300995, -0.18839050829410553, -0.12236598879098892, 0.1559603214263916, 0.27357953786849976, -0.05844440311193466, 0.10324883460998535, 0.01046814676374197]], "net.0.bias": [0.11116653680801392, -0.10097065567970276, 0.09167977422475815, -0.03220845386385918, 0.05651938170194626, 0.14226122200489044, 0.1588541716337204, 0.07387339323759079, -0.10911766439676285, -0.003979465924203396, 0.026502378284931183, 0.06873496621847153, -0.06454478949308395, 0.15753747522830963, 0.11981222778558731, 0.09814300388097763, 0.11770890653133392, 0.08806689828634262, 0.19422203302383423, 0.03280612453818321, 0.09076085686683655, -0.0068750628270208836, 0.06447412073612213, -0.014964376576244831, 0.06093369051814079, 0.08049023896455765, 0.04873019456863403, -0.08146245032548904, 0.1444055587053299, 0.18064485490322113, 0.12294366210699081, 0.19246888160705566, 0.006016670260578394, -0.013463500887155533, 0.14938008785247803, 0.09419214725494385, 0.05729372054338455, 0.1429775208234787, 0.21427397429943085, 0.1363687813282013, 0.21390685439109802, 0.08916594088077545, 0.016931137070059776, 0.11391694098711014, 0.024547386914491653, 0.0860603079199791, 0.05583672598004341, 0.16161544620990753, 0.013368864543735981, -0.084864042699337, 0.02308669686317444, -0.0031924128998070955, 0.05762983113527298, -0.08262878656387329, -0.05821940675377846, 0.06127596274018288, 0.0330510139465332, 0.16167794167995453, 0.07831437885761261, 0.11046817153692245, 0.07565014809370041, 0.05373036116361618, 0.1453099548816681, 0.15481959283351898], "net.2.weight": [[-0.0458877868950367, -0.20100541412830353, -0.11677268147468567, 0.1619691401720047, 0.33069971203804016, 0.3738144338130951, -0.10108721256256104, -0.08413136005401611, 0.0737694725394249, -0.10474955290555954, -0.14278936386108398, -0.22088858485221863, -0.05512838065624237, 0.17293985188007355, 0.10686274617910385, 0.3591766059398651, 0.27350175380706787, 0.16863100230693817, -0.005113438703119755, 0.011394419707357883, -0.005519260186702013, 0.31933945417404175, 0.1002553328871727, 0.11780215799808502, -0.06386277824640274, -0.17521443963050842, 0.167086660861969, 0.14323672652244568, -0.0391530804336071, -0.04154669865965843, 0.3109121322631836, 0.194241002202034, 0.11226854473352432, -0.06858623772859573, -0.11551311612129211, 0.2756739556789398, -0.06404056400060654, 0.0822916179895401, 0.2986198663711548, -0.21309217810630798, -0.06869906932115555, 0.06499680876731873, 0.3296809792518616, -0.015672938898205757, 0.2579580843448639, 0.26950573921203613, 0.06638230383396149, 0.33714696764945984, 0.22989943623542786, 0.15854698419570923, -0.4334280788898468, -0.032262153923511505, -0.21441689133644104, 0.2912866175174713, -0.23380956053733826, 0.21514230966567993, 0.2915957570075989, -0.1917565017938614, -0.0645551085472107, 0.22829866409301758, 0.21241627633571625, -0.009711546823382378, 0.33246734738349915, -0.03864522650837898], [-0.008830825798213482, 0.23295827209949493, -0.3005511462688446, 0.35845234990119934, 0.3603985607624054, -0.05385685712099075, 0.09899517893791199, 0.11139389872550964, -0.07406298816204071, 0.13882984220981598, -0.0019811985548585653, 0.0390787236392498, 0.13007834553718567, -0.09891562908887863, 0.09292278438806534, 0.21102949976921082, 0.023088885471224785, 0.014560187235474586, 0.01534597110003233, 0.08487911522388458, -0.16356641054153442, 0.08321426808834076, 0.14240466058254242, 0.21460528671741486, 0.13726332783699036, -0.3174431324005127, 0.15160804986953735, 0.38935738801956177, 0.08983130753040314, 0.00791856274008751, 0.0026851948350667953, 0.11193382740020752, 0.06824620068073273, -0.05126173421740532, -0.1256202757358551, -0.06662993878126144, 0.11719949543476105, 0.11058720201253891, -0.0036437695380300283, 0.2194705605506897, -0.035740118473768234, -0.05122334882616997, 0.10455566644668579, -0.012594114057719707, 0.11395483464002609, 0.14725907146930695, 0.41242825984954834, 0.1465757191181183, 0.0882074236869812, 0.1825728714466095, -0.05217950418591499, 0.1831449419260025, 0.11321999132633209, 0.12422288954257965, -0.40052956342697144, 0.16385604441165924, 0.25768327713012695, -0.2792729139328003, 0.11890353262424469, 0.014447377063333988, 0.03968953341245651, 0.21068470180034637, -0.011059107258915901, 0.03453344851732254], [-0.026085779070854187, 0.5088884830474854, -0.20165632665157318, 0.018285060301423073, 0.04335537925362587, -0.2331976294517517, 0.16474752128124237, 0.189591184258461, -0.0896659642457962, 0.12018229812383652, 0.16220508515834808, 0.09351058304309845, 0.2393801510334015, -0.06141652539372444, 0.03810987249016762, 0.0238723773509264, -0.09520620852708817, -0.12847109138965607, 0.16995130479335785, 0.2001328468322754, -0.12663789093494415, 0.13241241872310638, -0.07117270678281784, 0.1186213567852974, 0.06406150013208389, -0.011783440597355366, 0.05962815880775452, 0.28978779911994934, 0.2170436680316925, 0.01575339399278164, 0.01571688801050186, 0.05993428826332092, 0.18833333253860474, 0.1653766632080078, 0.06779614835977554, -0.07606065273284912, 0.0900854542851448, 0.018003733828663826, -0.08284862339496613, 0.32673323154449463, 0.06565976142883301, 0.05494900047779083, -0.11579962074756622, 0.12077604979276657, -0.244439035654068, -0.1498071402311325, 0.21873629093170166, -0.22971436381340027, -0.1246890053153038, 0.06352674961090088, 0.29006001353263855, 0.3000584542751312, 0.30292946100234985, 0.12243065983057022, 0.0656966120004654, -0.10240598767995834, 0.19892671704292297, -0.012235670350492, 0.16337300837039948, 0.08855058997869492, -0.11114232987165451, 0.25786375999450684, 0.013728581368923187, 0.0516202375292778], [0.08745913207530975, 0.09486660361289978, 0.08732414245605469, 0.016157671809196472, -0.0860261619091034, 0.11875210702419281, -0.10531175136566162, 0.0036431849002838135, -0.11560346186161041, 0.01757153868675232, 0.01591336727142334, 0.027818068861961365, 0.09431366622447968, 0.10383155941963196, -0.08690690994262695, -0.07397709786891937, -0.08457544445991516, -0.10515989363193512, -0.04544903337955475, -0.09016025066375732, 0.05472669005393982, 0.06291131675243378, 0.05139559507369995, 0.0856904536485672, -0.09962676465511322, -0.010424897074699402, -0.01952292025089264, -0.011768907308578491, -0.062379926443099976, -0.12174716591835022, 0.07135540246963501, -0.11957648396492004, 0.09090098738670349, -0.05244837701320648, 0.009906336665153503, 0.0414096862077713, 0.09117469191551208, -0.050687432289123535, -0.11254039406776428, 0.01120804250240326, 0.08814497292041779, -0.07627400755882263, 0.020739033818244934, 0.06716853380203247, 0.11868816614151001, 0.1123860627412796, 0.06782595813274384, 0.018547385931015015, -0.1140861064195633, -0.017982974648475647, -0.09112441539764404, -0.057197973132133484, -0.08057902753353119, -0.02820083498954773, -0.06004200875759125, -0.026625603437423706, -0.11095812916755676, 0.05771118402481079, -0.018805846571922302, -0.04909956455230713, -0.11189177632331848, -0.0892016589641571, -0.036627158522605896, -0.013500377535820007], [-0.03729793429374695, -0.47732576727867126, -0.02446826733648777, -0.01891683042049408, 0.23176836967468262, 0.2774127125740051, -0.03723328560590744, -0.12181413173675537, -0.06453368812799454, -0.03399678319692612, -0.09225982427597046, -0.004414109047502279, 0.10245577991008759, 0.1917257308959961, 0.0397174097597599, 0.04147559031844139, 0.35755622386932373, 0.17463372647762299, 0.13573436439037323, -0.19151651859283447, -0.03813784196972847, 0.025378841906785965, 0.21479035913944244, -0.01035750936716795, 0.05333034694194794, 0.10825035721063614, 0.10245344787836075, -0.1688288152217865, -0.04932783916592598, -0.09807389229536057, 0.20514215528964996, 0.16701367497444153, -0.0006963033229112625, -0.05193406715989113, -0.11817485839128494, 0.2718270719051361, 0.09785611182451248, 0.19488711655139923, 0.2163066416978836, -0.1564042568206787, -0.10084179788827896, -0.09148313850164413, 0.2698339819908142, 0.06298729032278061, 0.2549438178539276, 0.2901117205619812, -0.18816152215003967, 0.17406252026557922, 0.11243987828493118, 0.18761798739433289, -0.3643428087234497, -0.022404581308364868, -0.380728542804718, -0.02136211469769478, -0.2563207745552063, 0.2509121000766754, 0.1056506410241127, 0.10011910647153854, -0.050216205418109894, 0.17066292464733124, 0.2027229368686676, 0.03286494314670563, 0.06720133125782013, -0.12187334150075912], [0.19654443860054016, 0.3507409691810608, 0.0065843514166772366, 0.2046687752008438, -0.04496864974498749, -0.24816370010375977, 0.13027755916118622, 0.10113198310136795, -0.09260725229978561, 0.31994664669036865, 0.15992988646030426, 0.292345255613327, 0.22677640616893768, -0.09245225042104721, -0.050700556486845016, 0.0533403716981411, -0.22610165178775787, -0.05117630586028099, 0.1916343718767166, 0.14108611643314362, 0.13559238612651825, -0.021914321929216385, -0.07832102477550507, 0.00561873521655798, 0.038584187626838684, 0.0837348997592926, 0.009400729089975357, 0.29420602321624756, 0.17047905921936035, 0.05614204332232475, 0.16771860420703888, 0.06565995514392853, 0.0515277236700058, 0.30764269828796387, 0.004406049847602844, -0.09922636300325394, 0.18736031651496887, 0.12453041225671768, -0.17641645669937134, 0.2590184211730957, 0.18648971617221832, 0.051299404352903366, -0.17424936592578888, -0.036310046911239624, -0.001278325216844678, -0.2343311458826065, 0.2015155404806137, -0.20859704911708832, -0.039361272007226944, -0.09806891530752182, 0.3324330151081085, 0.31157827377319336, 0.2832767963409424, -0.02444574050605297, 0.0717901885509491, -0.16794051229953766, 0.008826236240565777, -0.08835854381322861, 0.07372701168060303, 0.06991304457187653, -0.1766262799501419, 0.15635235607624054, 0.021934829652309418, 0.19429931044578552], [0.21640238165855408, 0.2488318532705307, 0.1640990972518921, -0.1561172902584076, -0.2971346378326416, -0.2037198394536972, 0.2205958217382431, 0.028574926778674126, -0.0014365436509251595, 0.15409746766090393, 0.07164621353149414, 0.32538360357284546, 0.20864830911159515, -0.16170038282871246, 0.03600899875164032, -0.010312550701200962, -0.23522216081619263, -0.2412416785955429, 0.19966867566108704, 0.10013987869024277, 0.1885930746793747, -0.04533390700817108, -0.11889433115720749, -0.1408231109380722, 0.15034763514995575, 0.09713932126760483, -0.030887695029377937, -0.20073382556438446, 0.2512836456298828, 0.24083863198757172, -0.07832499593496323, 0.10203512012958527, -0.11173664778470993, 0.2574240267276764, 0.13192082941532135, -0.1446988582611084, 0.23796549439430237, -0.07688349485397339, -0.06970121711492538, 0.11675997823476791, 0.27396905422210693, 0.24138875305652618, -0.004772416781634092, 0.26790595054626465, -0.09048116952180862, -0.043279703706502914, -0.2814556062221527, -0.2729588747024536, -0.11934521049261093, -0.11076832562685013, 0.45531246066093445, 0.12505532801151276, 0.35701629519462585, -0.14927436411380768, 0.37601491808891296, -0.11901088804006577, -0.178595632314682, 0.0943143218755722, 0.04389023035764694, -0.10708103328943253, -0.07369853556156158, 0.057451099157333374, -0.10205598920583725, 0.07513578236103058], [0.13640861213207245, -0.24835814535617828, 0.3262256979942322, -0.21406757831573486, -0.36269688606262207, 0.1914619356393814, 0.1553313136100769, -0.17280371487140656, 0.006292014382779598, -0.051068976521492004, 0.16048675775527954, 0.13843773305416107, -0.050999242812395096, 0.21060813963413239, 0.1646469235420227, 0.03017914853990078, 0.027621852234005928, -0.050037629902362823, 0.09812571853399277, -0.0970124751329422, 0.3173365294933319, 0.013085132464766502, 0.012025694362819195, -0.021169643849134445, -0.05356481298804283, 0.16349883377552032, -0.01032567210495472, -0.15609107911586761, 0.03189235180616379, 0.17146047949790955, -0.054231803864240646, -0.03789367154240608, -0.04857870563864708, 0.2341143935918808, 0.16352479159832, 0.07787223905324936, -0.10954960435628891, 0.024832362309098244, 0.13400179147720337, -0.23754286766052246, -0.04571358859539032, 0.06358250230550766, 0.012423497624695301, 0.13166038691997528, 0.04889611154794693, 0.043529074639081955, -0.1985352486371994, 0.11282122135162354, -0.06375369429588318, -0.07268840074539185, 0.24023784697055817, -0.22379127144813538, 0.07197606563568115, -0.07632013410329819, 0.32100775837898254, 0.006096705328673124, -0.13427169620990753, 0.24652327597141266, -0.06843393296003342, -0.12506739795207977, 0.04000205919146538, 0.033585324883461, -0.037063196301460266, 0.03401808813214302], [-0.06577806919813156, -0.033873945474624634, 0.058371298015117645, -0.11831208318471909, -0.07589223980903625, -0.10446199029684067, -0.10367260128259659, 0.04012016952037811, -0.10654033720493317, 0.03239012882113457, 0.028691107407212257, 0.04987906292080879, 0.012647095136344433, 0.10333506762981415, -0.051867976784706116, 0.1103963628411293, 0.11651407182216644, -0.038255639374256134, -0.016328176483511925, 0.05195741727948189, 0.010058132000267506, 0.08887892961502075, 0.11785370111465454, 0.11632981151342392, -0.052837081253528595, 0.08897428214550018, -0.12830838561058044, 0.04106074199080467, -0.025008024647831917, -0.021196646615862846, -0.03544967994093895, -0.046655137091875076, 0.06754780560731888, 0.07167865335941315, -0.07250223308801651, -0.005936925765126944, -0.06049145758152008, -0.030410127714276314, -0.04813582822680473, 0.10578474402427673, -0.017383908852934837, 0.08213262259960175, 0.024172209203243256, 0.04057417809963226, 0.029192952439188957, -0.020523397251963615, 0.045903757214546204, -0.07367837429046631, 0.000892647251021117, 0.010978731326758862, -0.09928423911333084, -0.013219035230576992, -0.025456320494413376, -0.12255413085222244, 0.12090107798576355, 0.006798150017857552, 0.04497896879911423, 0.028768396005034447, 0.017915301024913788, 0.09640736132860184, -0.06791847199201584, -0.06501835584640503, 0.030558938160538673, 0.007554047275334597], [-0.18122509121894836, 0.10091099888086319, -0.2999884784221649, 0.1243932843208313, 0.3929717242717743, 0.03444128483533859, -0.0653185024857521, 0.1595994532108307, -0.08752679079771042, 0.03341411054134369, -0.0603565089404583, -0.15230107307434082, 0.1651049107313156, -0.06663378328084946, 0.16511783003807068, 0.07591148465871811, 0.24098333716392517, 0.23657409846782684, -0.021891362965106964, -0.012859098613262177, -0.1725943386554718, 0.24850130081176758, 0.19377437233924866, 0.2597416639328003, -0.0637451633810997, -0.2604486644268036, 0.14994114637374878, 0.25498539209365845, -0.010903676971793175, 0.10592074692249298, 0.2564888894557953, 0.04201916232705116, 0.25270113348960876, -0.24228166043758392, -0.004833504091948271, 0.0008344011730514467, 0.06237775459885597, 0.21880373358726501, 0.07615365833044052, 0.0832282155752182, 0.03926553577184677, -0.11973676830530167, 0.19486476480960846, -0.040212828665971756, 0.041753627359867096, 0.07429860532283783, 0.20638440549373627, 0.2701285779476166, 0.2069937139749527, 0.21728354692459106, -0.31501471996307373, 0.1448877453804016, -0.020552700385451317, 0.26135700941085815, -0.37833309173583984, 0.2072792649269104, 0.22290731966495514, -0.35865840315818787, 0.17339211702346802, 0.22621354460716248, -0.0067436289973556995, 0.11776410788297653, 0.15951783955097198, -0.1465626358985901], [-0.05701295658946037, 0.000974020455032587, 0.07280077785253525, 0.07096556574106216, 0.05175243690609932, 0.11582819372415543, 0.015783239156007767, -0.07761825621128082, 0.11989659070968628, -0.0582474023103714, 0.04364641755819321, 0.011549388989806175, -0.09198691695928574, 0.03371599316596985, -0.05869702994823456, 0.09480080008506775, -0.08383502811193466, 0.06796945631504059, 0.10783654451370239, -0.052294593304395676, -0.12169958651065826, -0.08362361788749695, -0.03911096602678299, -0.09595806896686554, -0.12490888684988022, -0.06293205171823502, -0.010490957647562027, -0.045718420296907425, 0.041553035378456116, -0.010996339842677116, -0.08103116601705551, -0.03219000995159149, 0.044831860810518265, -0.07523036003112793, -0.0554036870598793, -0.07494621723890305, 0.08872124552726746, -0.05736337974667549, -0.03351529315114021, -0.0763806477189064, -0.017416534945368767, 0.013977209106087685, 0.0902741327881813, -0.010260590352118015, 0.053507186472415924, 0.02367362193763256, 0.09827812016010284, 0.005291285924613476, -0.011149892583489418, 0.07546354830265045, 0.048509471118450165, -0.08468220382928848, -0.1082208901643753, 0.0025005904026329517, 0.05268057435750961, -0.11904526501893997, -0.035758089274168015, 0.10328921675682068, -0.0778987929224968, 0.06718704849481583, 0.05106020346283913, -0.05448947101831436, -0.06013651192188263, 0.03582973778247833], [-0.10189997404813766, 0.2843281030654907, -0.21720820665359497, 0.3067888617515564, 0.4006267786026001, 0.041052624583244324, -0.1038191169500351, 0.35392695665359497, -0.01774074137210846, 0.26864662766456604, 0.11379154771566391, 0.09462139755487442, 0.2350887656211853, -0.1459607183933258, -0.05895112827420235, 0.08606382459402084, -0.08457689732313156, -0.030071593821048737, 0.1225869208574295, 0.26789459586143494, -0.3601660430431366, 0.07609854638576508, 0.08156149089336395, 0.05548756942152977, 0.21695908904075623, -0.2898995578289032, -0.08328066021203995, 0.36964914202690125, 0.07641167938709259, 0.1005268543958664, 0.05644842982292175, -0.010851875878870487, 0.22201666235923767, -0.1439836174249649, -0.04774744436144829, -0.022044159471988678, -0.027934029698371887, 0.12354632467031479, -0.0002550995268393308, 0.2616286873817444, 0.13154278695583344, 0.17831236124038696, -0.0022378352005034685, -0.042469631880521774, -0.08304042369127274, 0.060508664697408676, 0.2937334477901459, 0.04098903015255928, 0.13977301120758057, -0.028755193576216698, -0.007918142713606358, 0.37250322103500366, 0.17463046312332153, 0.19142019748687744, -0.10190770030021667, -0.019613176584243774, 0.04566655680537224, -0.26855435967445374, 0.257241427898407, 0.1413157433271408, -0.02441360242664814, 0.245278000831604, 0.035642243921756744, -0.08346866816282272], [-0.1625528633594513, -0.32196247577667236, -0.09815477579832077, 0.19970904290676117, 0.24468395113945007, 0.186086967587471, -0.05742296576499939, 0.005130006931722164, -0.05817228928208351, -0.1640685349702835, 0.002449664054438472, -0.19769863784313202, 0.03770304471254349, 0.2377152144908905, 0.08802254498004913, 0.2924630641937256, 0.2446267306804657, 0.14641627669334412, 0.04139028489589691, 0.04223356395959854, -0.2083551585674286, 0.23054683208465576, 0.2841186225414276, 0.32173511385917664, -0.08130239695310593, -0.05647866800427437, 0.2003912478685379, 0.2889185845851898, 0.053716178983449936, 0.0473000630736351, 0.17589177191257477, 0.24951712787151337, 0.22403669357299805, -0.2592443823814392, -0.08630437403917313, 0.16824501752853394, -0.14756450057029724, 0.1923588514328003, 0.14355230331420898, 0.0036328632850199938, -0.06177441403269768, -0.005485834553837776, 0.3560953736305237, -0.2160201519727707, 0.2149437516927719, 0.20911505818367004, 0.2240079641342163, 0.22797532379627228, 0.05719267576932907, 0.08643413335084915, -0.25107675790786743, 0.1196344718337059, -0.16261379420757294, 0.28376632928848267, -0.1959795206785202, 0.297637939453125, 0.18123780190944672, -0.19475725293159485, -0.06611432880163193, 0.21017146110534668, 0.17027994990348816, -0.10390453785657883, 0.27384859323501587, -0.04515803977847099], [0.09259729087352753, 0.3447929620742798, -0.04931391775608063, 0.17903219163417816, -0.06080612912774086, -0.17807772755622864, 0.034604512155056, 0.11933539807796478, -0.029598409309983253, 0.21910707652568817, 0.1913340538740158, 0.25265997648239136, 0.2053373008966446, -0.031098702922463417, -0.1303144246339798, -0.21355454623699188, -0.18618042767047882, 0.0004046014801133424, 0.14998169243335724, 0.11720103770494461, -0.04528896138072014, -0.01079675555229187, -0.09807693958282471, -0.13390301167964935, 0.036042530089616776, 0.09269969165325165, -0.1041288822889328, 0.28161531686782837, 0.20966245234012604, 0.011626378633081913, -0.027936389669775963, 0.024408310651779175, -0.001895581604912877, 0.2904317378997803, -0.010597692802548409, -0.09307657182216644, 0.08500328660011292, 0.1120685562491417, -0.06279188394546509, 0.44122040271759033, 0.018496353179216385, 0.09963154792785645, -0.09688562899827957, -0.0006856914260424674, -0.08671031892299652, -0.20451247692108154, 0.19587622582912445, -0.2096039056777954, -0.10977505147457123, -0.10400716215372086, 0.47086766362190247, 0.338678240776062, 0.39502668380737305, 0.13679614663124084, 0.23323288559913635, -0.04025236517190933, 0.013169907964766026, 0.0865277349948883, 0.2804650068283081, 0.04610421508550644, -0.0012174475705251098, 0.24067439138889313, -0.05581500008702278, 0.12875516712665558], [0.2244974672794342, 0.3748956024646759, 0.07769537717103958, -0.0726388469338417, -0.29976797103881836, -0.19057925045490265, 0.0701451301574707, -0.008277630433440208, 0.03091513365507126, 0.24616682529449463, 0.2528463304042816, 0.09039429575204849, 0.08827775716781616, -0.0026512902695685625, -0.023987295106053352, -0.250437468290329, -0.08575250208377838, -0.07950714975595474, 0.1718897670507431, 0.2114415317773819, 0.17700783908367157, -0.08947784453630447, -0.2227761298418045, 0.025185078382492065, 0.08733503520488739, -0.002505867974832654, -0.05597182735800743, -0.14026804268360138, 0.23389822244644165, 0.24875952303409576, 0.049106843769550323, -0.036975570023059845, -0.11825332790613174, 0.18224063515663147, 0.17242620885372162, 0.01634867675602436, 0.1320418417453766, 0.10709848254919052, -0.19444763660430908, 0.2762303650379181, 0.22097082436084747, 0.19097645580768585, -0.20789264142513275, 0.15223102271556854, -0.22378486394882202, -0.23945452272891998, 0.025583801791071892, -0.21362337470054626, -0.12149110436439514, -0.10550634562969208, 0.3075162172317505, 0.2520938217639923, 0.3509504199028015, 0.03021528571844101, 0.36793506145477295, -0.07972694933414459, -0.061686623841524124, 0.12052168697118759, 0.2528543174266815, -0.12298465520143509, -0.13060401380062103, 0.2443174570798874, -0.19014738500118256, 0.2689674198627472], [0.08372598141431808, -0.24056200683116913, 0.21785633265972137, -0.15690423548221588, -0.15056465566158295, 0.11802643537521362, 0.11118872463703156, -0.12758749723434448, -0.07378576695919037, -0.12534798681735992, 0.10573269426822662, 0.05532960593700409, -0.15381738543510437, 0.13995344936847687, -0.061851851642131805, 0.09739875048398972, 0.13641434907913208, -0.11026650667190552, 0.017090534791350365, -0.09865500777959824, 0.30726972222328186, 0.06984606385231018, -0.03576674312353134, -0.12648871541023254, -0.06255799531936646, 0.17638978362083435, 0.1421518325805664, -0.3213762044906616, 0.051874566823244095, -0.011854217387735844, -0.05865499749779701, 0.09256963431835175, -0.17607542872428894, 0.014471285045146942, 0.0665208250284195, 0.11690212041139603, -0.022208696231245995, 0.08163503557443619, 0.08753027021884918, -0.12907147407531738, 0.052419718354940414, -0.0785122737288475, 0.19361622631549835, 0.1331477165222168, 0.0920003205537796, 0.10685434192419052, -0.40527480840682983, 0.01844131387770176, 0.08546667546033859, 0.15742526948451996, 0.0359298400580883, -0.2350730299949646, -0.19090785086154938, -0.056383777409791946, 0.24266214668750763, -0.06020662561058998, -0.04504888877272606, 0.20113828778266907, -0.08902152627706528, 0.004984618164598942, -0.03516095131635666, 0.025668837130069733, 0.13251180946826935, 0.08983297646045685], [0.02876635454595089, -0.11832725256681442, -0.14128562808036804, 0.15429916977882385, 0.24346765875816345, 0.3277251422405243, -0.03846773877739906, 0.05486300215125084, -0.09009258449077606, -0.06780705600976944, 0.01411996129900217, -0.07110156863927841, 0.12475193291902542, 0.11725958436727524, 0.24808621406555176, 0.24368338286876678, 0.23899881541728973, 0.2711838483810425, 0.14465783536434174, -0.07495247572660446, -0.14893484115600586, 0.18853412568569183, 0.2567064166069031, 0.24616825580596924, -0.12217260152101517, -0.14763829112052917, 0.08579014241695404, 0.09880342334508896, -0.12705841660499573, 0.09039231389760971, 0.07925575226545334, 0.20497757196426392, 0.06040554493665695, 0.04866097867488861, 0.03785557299852371, 0.06606203317642212, 0.07216569036245346, 0.12983089685440063, 0.12569642066955566, -0.20962262153625488, -0.10600592941045761, -0.0076780677773058414, 0.33345791697502136, -0.051739294081926346, 0.24616973102092743, 0.32014596462249756, 0.24277625977993011, 0.3625416159629822, 0.06036585569381714, 0.14700603485107422, -0.23934149742126465, 0.04280012845993042, -0.43261587619781494, 0.1576816737651825, -0.16099633276462555, 0.27442944049835205, 0.11223713308572769, -0.25525474548339844, 0.07902924716472626, 0.1266627460718155, 0.15945002436637878, -0.15892978012561798, 0.060632552951574326, -0.1085616946220398], [0.17826470732688904, -0.30332517623901367, 0.28184640407562256, -0.18381628394126892, -0.07526455819606781, 0.08925040811300278, -0.0029102519620209932, -0.3629482686519623, 0.09565234184265137, -0.000703051860909909, 0.158416748046875, 0.08352786302566528, 0.11822246015071869, 0.0616191141307354, 0.016732055693864822, -0.007837962359189987, 0.15441159904003143, 0.014681180007755756, 0.09652429819107056, -0.08550182729959488, 0.22451001405715942, -0.09188167005777359, 0.04665909707546234, -0.0949782207608223, 0.023476911708712578, 0.13317465782165527, -0.047633204609155655, -0.30660954117774963, -0.044711943715810776, -0.03591438755393028, -0.13664408028125763, 0.08232801407575607, -0.004110564012080431, 0.14207947254180908, 0.15506263077259064, -0.03826749697327614, 0.15278400480747223, -0.0709540992975235, -0.03467482328414917, -0.06664026528596878, 0.038142722100019455, -0.03212306275963783, 0.14848516881465912, 0.20479533076286316, 0.16595515608787537, 0.12860728800296783, -0.13603392243385315, 0.12969402968883514, -0.055497702211141586, 0.07759520411491394, 0.09809800237417221, 0.01841559074819088, -0.1413852572441101, -0.17952755093574524, 0.1522415578365326, 0.08815032243728638, -0.10626228898763657, 0.2613131105899811, -0.10847003012895584, -0.006827882491052151, 0.041430648416280746, 0.15629078447818756, -0.07144619524478912, 0.008801763877272606], [-0.08281710743904114, 0.31726908683776855, -0.2373970001935959, 0.18977734446525574, 0.1340762972831726, -0.19852009415626526, -0.05921962857246399, 0.14087465405464172, 0.01277167908847332, 0.20608319342136383, 0.03402912616729736, 0.07364257425069809, 0.10864704847335815, -0.1796465665102005, -0.018925242125988007, 0.09818283468484879, -0.15225501358509064, -0.07524736225605011, 0.023036286234855652, 0.1827782839536667, -0.1440533995628357, 0.11442676186561584, -0.06312678754329681, 0.14023543894290924, 0.24234502017498016, -0.24025307595729828, -0.03194742277264595, 0.30693498253822327, 0.13212840259075165, 0.08871708810329437, 0.14217786490917206, -0.03767155110836029, 0.09243640303611755, 0.13249118626117706, 0.012751491740345955, -0.21440280973911285, 0.10768648982048035, -0.02258928306400776, -0.10103588551282883, 0.20872585475444794, 0.13245785236358643, 0.21120688319206238, -0.17797963321208954, 0.037164945155382156, -0.10751698911190033, -0.17626173794269562, 0.2259911298751831, 0.05865909531712532, 0.05178117752075195, 0.0880148857831955, 0.11826711893081665, 0.26469647884368896, 0.1716109812259674, 0.032232340425252914, -0.09553594887256622, 0.06621186435222626, 0.04409448802471161, -0.28244951367378235, 0.22295425832271576, 0.14905346930027008, 0.058024611324071884, 0.2477061003446579, 0.010081611573696136, 0.007720951922237873], [-0.14311449229717255, 0.1427130252122879, -0.3329377770423889, 0.1339833289384842, 0.42768803238868713, 0.09915754944086075, -0.0011444422416388988, 0.2648944556713104, -0.029829533770680428, 0.03237707540392876, 0.06892967224121094, -0.008976008743047714, 0.22818966209888458, -0.09254849702119827, 0.09118489176034927, -0.014716925099492073, -0.10347604006528854, 0.18429699540138245, 0.1261594593524933, 0.19103379547595978, -0.26477986574172974, 0.1918189376592636, 0.14247548580169678, 0.27477893233299255, 0.1701875776052475, -0.07533812522888184, 0.003759590210393071, 0.38191723823547363, 0.047300245612859726, 0.021217091009020805, 0.15489304065704346, 0.10204234719276428, 0.18156984448432922, -0.09357950836420059, -0.11401785910129547, -0.13265815377235413, -0.022625254467129707, 0.029814712703227997, -0.0038262682501226664, 0.22217150032520294, -0.07531001418828964, -0.023644354194402695, -0.047538742423057556, 0.04088086634874344, 0.03752221167087555, 0.04849833622574806, 0.364418625831604, 0.12918433547019958, 0.02781788818538189, 0.04831027239561081, -0.02704879455268383, 0.3324403166770935, -0.03967391699552536, 0.24428194761276245, -0.4090255796909332, 0.07482555508613586, 0.2459895759820938, -0.23850570619106293, 0.16210564970970154, 0.11137177050113678, -0.007012085523456335, 0.1574295610189438, 0.16622394323349, 0.10367157310247421], [-0.09266413748264313, 0.3193507492542267, -0.12145739793777466, 0.13208569586277008, 0.27108466625213623, -0.02004850283265114, -0.03947757929563522, 0.23974798619747162, -0.11641325801610947, 0.21091875433921814, 0.07584050297737122, 0.022087793797254562, 0.05273545905947685, -0.08427577465772629, 0.07461921125650406, 0.1261865496635437, -0.08388400077819824, 0.16453826427459717, 0.07523130625486374, 0.033838704228401184, -0.24998751282691956, 0.21166114509105682, -0.008261028677225113, 0.14004310965538025, 0.12959639728069305, -0.29847145080566406, 0.08484654128551483, 0.2243581861257553, 0.02861090935766697, -0.009721246547996998, 0.1728639453649521, -0.029966728761792183, 0.21383729577064514, 0.022036753594875336, -0.11987721174955368, -0.13221076130867004, 0.05106044188141823, 0.1849033385515213, -0.014639855362474918, 0.256778359413147, 0.11170972138643265, 0.15133348107337952, -0.023870786651968956, -0.12197147309780121, 0.031932611018419266, 0.10493280738592148, 0.23558145761489868, -0.054086167365312576, 0.137618288397789, 0.10334749519824982, -0.2660385072231293, 0.35832539200782776, 0.005992294289171696, 0.23048333823680878, -0.21068641543388367, 0.11835090816020966, 0.22979211807250977, -0.3039114773273468, 0.2603972554206848, 0.19121037423610687, 0.009161623194813728, 0.03364001214504242, 0.031405407935380936, -0.078123539686203], [0.03752627223730087, 0.08348828554153442, -0.036064814776182175, 0.08485040813684464, 0.05544091761112213, -0.010568022727966309, -0.10138002038002014, 0.044900789856910706, -0.10238751769065857, 0.09063674509525299, -0.008408625610172749, 0.09872797131538391, -0.11465603113174438, 0.020392470061779022, 0.04044436290860176, -0.04875345900654793, 0.10885855555534363, -0.1154155284166336, 0.0005374823813326657, 0.0001630329352337867, -0.10851341485977173, 0.002217157743871212, -0.004248708486557007, 0.06513550132513046, -0.07427631318569183, 0.09964284300804138, 0.019322415813803673, -0.09749488532543182, -0.02979433350265026, 0.026470152661204338, -0.11200447380542755, -0.024715295061469078, -0.055186256766319275, -0.08783266693353653, -0.10301892459392548, 0.009885580278933048, 0.015508592128753662, -0.09731612354516983, 0.019027581438422203, 0.01687730848789215, 0.019028710201382637, 0.025095902383327484, -0.11442799866199493, -0.10521667450666428, -0.021052896976470947, -0.06421822309494019, -0.10906100273132324, 0.0995493084192276, -0.11107082664966583, -0.006990790367126465, 0.10318019241094589, -0.049939900636672974, 0.03935663402080536, 0.025410281494259834, -0.10735209286212921, 0.013275280594825745, 0.0697353184223175, 0.08145899325609207, -0.002547740936279297, 0.0575110949575901, 0.05888902023434639, -0.06569087505340576, -0.10944661498069763, 0.08268409967422485], [-0.005530077964067459, -0.14713208377361298, -0.00964456144720316, 0.20103804767131805, 0.3364863991737366, 0.17739902436733246, -0.05892932787537575, 0.23533077538013458, 0.051820993423461914, -0.08491899818181992, 0.0916217789053917, -0.07757718861103058, -0.08200787752866745, -0.07048192620277405, 0.07116930186748505, 0.18255822360515594, 0.21815596520900726, 0.24077650904655457, 0.0568469874560833, 0.021662482991814613, -0.17780382931232452, 0.1488126814365387, 0.22133176028728485, 0.06114274263381958, 0.015797685831785202, -0.022857563570141792, 0.16122549772262573, 0.23343759775161743, -0.03962809592485428, -0.08463706821203232, 0.03741264343261719, -0.0016411782708019018, 0.09437344968318939, -0.2019234448671341, -0.021587731316685677, 0.038789089769124985, 0.004053015261888504, 0.08751429617404938, 0.09441934525966644, 0.08234012871980667, -0.020067371428012848, 0.10009212046861649, 0.18071846663951874, 0.026863345876336098, 0.1572970300912857, 0.1950138807296753, 0.24530057609081268, 0.22991491854190826, 0.1514529287815094, -0.036423537880182266, -0.10481087863445282, 0.14505444467067719, -0.17449162900447845, 0.07876612991094589, -0.14830224215984344, 0.11005166172981262, 0.17923851311206818, -0.04030521959066391, 0.10355763137340546, -0.0010785586200654507, 0.0023207440972328186, -0.072758749127388, 0.11319474130868912, -0.1124422550201416], [0.06595489382743835, -0.1376400738954544, 0.26473161578178406, -0.17724160850048065, 0.023458460345864296, 0.02246660366654396, 0.10898132622241974, -0.2892112731933594, 0.12137750536203384, -0.07648032158613205, 0.03118768334388733, -0.02739044465124607, -0.07766098529100418, 0.09612832218408585, -0.013962388969957829, -0.13168849050998688, 0.11761805415153503, -0.0932343378663063, 0.09925868362188339, -0.1098351925611496, 0.31562745571136475, -0.0259806290268898, 0.14485394954681396, -0.17214326560497284, 0.013613433577120304, 0.17083320021629333, 0.11806478351354599, -0.11911503225564957, 0.0871257558465004, 0.021487964317202568, -0.057187967002391815, 0.09414280205965042, -0.1977674812078476, 0.1865275800228119, 0.07437548041343689, 0.044995829463005066, 0.12867946922779083, 0.0604545958340168, 0.018671231344342232, -0.06705022603273392, -0.0835769772529602, 0.011247808113694191, 0.1410641372203827, 0.008879008702933788, 0.0940965861082077, 0.08367600291967392, -0.1953679770231247, 0.14711198210716248, 0.00983548816293478, 0.024171974509954453, 0.20868879556655884, -0.18804560601711273, -0.01806112565100193, -0.0123945577070117, 0.08908076584339142, 0.09145810455083847, -0.19671767950057983, 0.25212839245796204, -0.020929720252752304, -0.1566314548254013, 0.06089053303003311, -0.14445607364177704, 0.036836691200733185, 0.09601618349552155], [0.025563975796103477, 0.3997737169265747, -0.24730165302753448, 0.252411812543869, 0.3007661700248718, 0.0685582384467125, 0.10309195518493652, 0.37572816014289856, -0.10164089500904083, 0.0683063268661499, -0.04098006337881088, -0.03120729885995388, 0.027091586962342262, -0.03395119309425354, -0.11752492934465408, -0.004502052906900644, -0.11886431276798248, 0.07439529150724411, -0.04757704213261604, 0.22385573387145996, -0.2694603502750397, 0.11748699098825455, 0.03961541876196861, -0.005817784462124109, 0.16321541368961334, -0.22098392248153687, 0.09363791346549988, 0.37646445631980896, 0.10418201237916946, 0.06689326465129852, 0.042776502668857574, 0.06940587610006332, 0.24838778376579285, -0.15265271067619324, 0.1383201777935028, -0.015548555180430412, 0.0072710695676505566, 0.05553789809346199, -0.17274677753448486, 0.30551761388778687, -0.07462425529956818, 0.13233180344104767, -0.11935844272375107, 0.04712711647152901, 0.0337948240339756, 0.07836952805519104, 0.274480938911438, 0.022411445155739784, 0.11425892263650894, 0.011832554824650288, 0.046959854662418365, 0.19123245775699615, 0.19795992970466614, 0.1972913146018982, -0.15800775587558746, -0.09688091278076172, 0.10899460315704346, -0.22950850427150726, 0.18636539578437805, 0.04237262159585953, -0.12660978734493256, 0.23723885416984558, -0.05707617476582527, -0.012672873213887215], [0.0037054666317999363, -0.15789076685905457, -0.16262325644493103, 0.1582701951265335, 0.4124312102794647, 0.23045842349529266, -0.10865383595228195, -0.02952704392373562, -0.04278606176376343, -0.1904115229845047, -0.1271888017654419, -0.26044392585754395, -0.09259965270757675, 0.1716412603855133, 0.24946579337120056, 0.2647988498210907, 0.2587057054042816, 0.2548065483570099, 0.013159708119928837, -0.017545470967888832, -0.21038596332073212, 0.10058143734931946, 0.15346775949001312, 0.19774246215820312, 0.06988446414470673, -0.16639484465122223, 0.031147334724664688, 0.29625359177589417, 0.07900460809469223, -0.14342918992042542, 0.22442026436328888, 0.20353484153747559, 0.2647933065891266, -0.19393765926361084, -0.021362608298659325, 0.020069556310772896, -0.08144504576921463, 0.2022159993648529, 0.20716609060764313, -0.08170653879642487, -0.015912678092718124, -0.031948357820510864, 0.17508074641227722, -0.058990225195884705, 0.3432527482509613, 0.26574814319610596, 0.12325264513492584, 0.3466505706310272, 0.23073218762874603, 0.0039431010372936726, -0.2646019458770752, 0.1942276805639267, -0.3746967017650604, 0.21798495948314667, -0.14412228763103485, 0.2603089511394501, 0.06885532289743423, -0.13397528231143951, -0.12744741141796112, 0.15775956213474274, 0.13759450614452362, 0.04737741872668266, 0.0800783708691597, -0.1487739533185959], [0.12651874125003815, -0.09487741440534592, 0.21452397108078003, -0.1815558820962906, -0.28436875343322754, 0.1470162570476532, -0.05325336009263992, -0.133379265666008, 0.010793492197990417, -0.04422569274902344, -0.0398094542324543, 0.1240224838256836, 0.04057773947715759, 0.21012450754642487, -0.021336210891604424, 0.04194805026054382, 0.2500310242176056, 0.006132492795586586, 0.19655397534370422, -0.004727096762508154, 0.33190637826919556, 0.07775615900754929, -0.09450393915176392, -0.08325580507516861, 0.056558918207883835, 0.1455308496952057, 0.12882940471172333, -0.1913936734199524, -0.08749833703041077, 0.16916929185390472, -0.11004635691642761, 0.02404290810227394, -0.1395023912191391, 0.16939327120780945, 0.11432719230651855, 0.20312564074993134, -0.08153374493122101, -0.0296042338013649, 0.16017816960811615, -0.27766913175582886, 0.02376854233443737, 0.029224831610918045, 0.23042339086532593, 0.004772948566824198, 0.24500639736652374, 0.08463814854621887, -0.4033013582229614, 0.10473737120628357, -0.05363049358129501, 0.1701599806547165, 0.10336882621049881, -0.24632084369659424, -0.21161191165447235, -0.01682560332119465, 0.10032916814088821, 0.046557649970054626, -0.0898701474070549, 0.37264010310173035, -0.0893656462430954, -0.08746317028999329, 0.1056601032614708, -0.16820098459720612, 0.047725554555654526, 0.10467727482318878], [0.056037046015262604, 0.00965129490941763, 0.19543804228305817, -0.2732737362384796, -0.4041089117527008, 0.034827884286642075, 0.06030223146080971, -0.18006189167499542, -0.0008364439127035439, -0.0666867271065712, 0.12662386894226074, 0.1751929074525833, 0.11887285858392715, -0.03610759973526001, 0.06485579162836075, -0.04247421398758888, 0.08140381425619125, -0.1010294035077095, 0.12058990448713303, 0.011617646552622318, 0.2092587798833847, 0.06366686522960663, -0.04820645600557327, -0.16535845398902893, 0.025965994223952293, 0.3523646593093872, 0.1730295866727829, -0.32699501514434814, -0.0066889747977256775, 0.10153990983963013, 0.05240795761346817, -0.09753527492284775, -0.08385037630796432, 0.050575993955135345, 0.08076627552509308, 0.22495602071285248, -0.041882868856191635, -0.03336000815033913, -0.04013901576399803, -0.046833258122205734, 0.14148950576782227, 0.08826350420713425, -0.0006204617093317211, 0.20937129855155945, 0.09657090902328491, -0.04994034022092819, -0.38196712732315063, -0.1252707540988922, -0.038619786500930786, -0.05101067200303078, 0.23514819145202637, -0.146852046251297, 0.040945760905742645, -0.06204002723097801, 0.36814698576927185, -0.026644686236977577, -0.12306944280862808, 0.3904803693294525, -0.14198030531406403, 0.02438410371541977, -0.041390277445316315, -0.0807000994682312, 0.08678240329027176, 0.23277156054973602], [0.16780729591846466, -0.21471165120601654, 0.06871426105499268, -0.1312798708677292, -0.1893843114376068, 0.2361356019973755, -0.04128793999552727, -0.44165951013565063, -0.1122555285692215, -0.12617889046669006, 0.10461798310279846, -0.004629223141819239, 0.09058978408575058, 0.08899345248937607, -0.032915033400058746, -0.009797081351280212, 0.2074943333864212, 0.09461212903261185, 0.08047519624233246, -0.06433144211769104, 0.2110627144575119, 0.10566446930170059, 0.1657499372959137, 0.04774332419037819, -0.012616564519703388, 0.09650452435016632, 0.09303254634141922, -0.21618713438510895, -0.0999101921916008, 0.07500488311052322, 0.09392357617616653, 0.0727706030011177, -0.08120989054441452, 4.719390744867269e-06, -0.03972497209906578, 0.2113349288702011, -0.10431540757417679, 0.10643626749515533, 0.18459552526474, -0.25151321291923523, 0.009001882746815681, -0.10437843203544617, 0.06486710160970688, 0.018198087811470032, 0.2549852132797241, 0.16587483882904053, -0.3234718143939972, 0.16761134564876556, 0.09031827747821808, 0.016119541600346565, -0.11155861616134644, -0.07961323857307434, -0.2551768124103546, 0.0941087156534195, 0.07156773656606674, 0.1980835646390915, -0.12653642892837524, 0.13928815722465515, 0.02328014001250267, -0.07315327227115631, -0.021071288734674454, -0.2100524753332138, 0.10872995853424072, 0.13016772270202637], [0.1619924008846283, 0.41354063153266907, -0.0766206681728363, -0.019941087812185287, -0.05815299227833748, -0.1981598287820816, 0.08657776564359665, 0.21017207205295563, 0.11615107208490372, 0.18111620843410492, 0.15713286399841309, 0.2889477610588074, 0.2502059042453766, -0.08002768456935883, -0.04220324382185936, -0.12069070339202881, -0.14095066487789154, -0.07546453922986984, 0.21830689907073975, 0.09670185297727585, 0.15469515323638916, -0.08807806670665741, -0.183904767036438, 0.10864898562431335, 0.062043990939855576, 0.07905373722314835, -0.11941445618867874, 0.09095458686351776, 0.2538969814777374, 0.15293309092521667, 0.054534781724214554, -0.05461381375789642, -0.07099683582782745, 0.1716831624507904, 0.21583698689937592, -0.15829846262931824, 0.06158751994371414, 0.07928119599819183, 0.024831293150782585, 0.23679497838020325, 0.19849975407123566, 0.1467277854681015, -0.20785771310329437, 0.08003132790327072, -0.24487459659576416, -0.1619255542755127, 0.05778130888938904, -0.22517777979373932, 0.022446930408477783, -0.04578947275876999, 0.33243033289909363, 0.3516624867916107, 0.41690319776535034, 0.028415493667125702, 0.2862403988838196, -0.12903298437595367, 0.13676905632019043, -0.042186252772808075, 0.09052596986293793, 0.10987450182437897, -0.02488778345286846, 0.26620134711265564, -0.19439198076725006, 0.24203896522521973], [0.190420001745224, 0.236429363489151, 0.21288113296031952, -0.07341042160987854, -0.31463146209716797, -0.21118220686912537, 0.1837271749973297, -0.03955094888806343, 0.11674848198890686, 0.3049262762069702, 0.02821451798081398, 0.28094759583473206, 0.039624717086553574, -0.12505538761615753, -0.049022089689970016, -0.06278813630342484, -0.2780836522579193, -0.13086837530136108, 0.06706495583057404, 0.26113054156303406, 0.21884271502494812, 0.009250476025044918, -0.07767042517662048, -0.1648426651954651, 0.0967814028263092, 0.163065105676651, -0.020557483658194542, -0.08910350501537323, 0.04492778331041336, 0.1282138079404831, -0.12275771051645279, -0.07323963940143585, -0.22355897724628448, 0.36511343717575073, 0.09265928715467453, -0.1638450026512146, 0.09152969717979431, 0.08318599313497543, -0.15348896384239197, 0.16134138405323029, 0.2341018170118332, 0.18475638329982758, -0.14840412139892578, 0.19192886352539062, -0.07335565984249115, -0.06691738218069077, -0.07584352791309357, -0.12190839648246765, 0.04390806704759598, -0.03784354776144028, 0.44356200098991394, 0.03653852641582489, 0.291740745306015, 0.047669507563114166, 0.36878934502601624, -0.08156436681747437, -0.09020072966814041, 0.12655481696128845, 0.1957198530435562, -0.13359573483467102, -0.16854269802570343, 0.026386527344584465, -0.11984893679618835, 0.1925233006477356], [0.08965988457202911, -0.22120238840579987, 0.027752704918384552, 0.1663302779197693, 0.30989912152290344, 0.42963922023773193, 0.07236966490745544, -0.026667065918445587, 0.09603933990001678, -0.2433655709028244, 0.013780745677649975, -0.16907945275306702, -0.010477361269295216, 0.2095191925764084, 0.24189630150794983, 0.1467745155096054, 0.25520309805870056, 0.16379190981388092, 0.03976493701338768, -0.08461897820234299, -0.04797280207276344, 0.23196865618228912, 0.10483969748020172, 0.16880549490451813, 0.0516444593667984, 0.009866045787930489, 0.10444794595241547, 0.05792415887117386, -0.09490249305963516, -0.07202650606632233, 0.10846775025129318, 0.18870705366134644, 0.22258207201957703, -0.14283441007137299, -0.0921911671757698, 0.20995299518108368, -0.1131681352853775, 0.0810440257191658, 0.1742914915084839, -0.3243982791900635, 0.032651059329509735, -0.07677219808101654, 0.19696380198001862, -0.08274707943201065, 0.34235286712646484, 0.23587578535079956, -0.037309665232896805, 0.34405526518821716, 0.17238295078277588, 0.24497680366039276, -0.3825450539588928, -0.09491696953773499, -0.34545087814331055, 0.010088400915265083, -0.23936007916927338, 0.3327919840812683, 0.20797082781791687, -0.044033922255039215, -0.044306203722953796, 0.13666276633739471, 0.27836158871650696, -0.06720062345266342, 0.22772257030010223, -0.001654548686929047]], "net.2.bias": [0.036271560937166214, 0.13454362750053406, 0.0011402470991015434, -0.09085409343242645, 0.04672953486442566, -0.02492322213947773, -0.022693926468491554, 0.04712566360831261, -0.13234294950962067, 0.05553330481052399, -0.1181383952498436, 0.07117369025945663, 0.006444750819355249, 0.15235765278339386, 0.022624017670750618, 0.07577025890350342, -0.07768171280622482, 0.13747932016849518, 0.08858254551887512, -0.02151041105389595, 0.12052243202924728, -0.11390125751495361, -0.08685974776744843, 0.1069210097193718, -0.013252981007099152, 0.07571719586849213, 0.10852455347776413, 0.04819157347083092, 0.034285254776477814, -0.03334571048617363, 0.14385229349136353, -0.024874890223145485], "net.4.weight": [[-0.3113206624984741, -0.21440984308719635, 0.09850306808948517, -0.07457781583070755, -0.21060052514076233, 0.2051030695438385, 0.3914623558521271, 0.14951160550117493, -0.06319458037614822, -0.30549877882003784, -0.15499812364578247, 0.07886853814125061, -0.3596583902835846, 0.11133671551942825, 0.3286053538322449, 0.0348043218255043, -0.30554208159446716, -0.09697389602661133, 0.08365503698587418, -0.201412171125412, -0.22626252472400665, 0.03439192473888397, -0.29722175002098083, -0.010189258493483067, 0.07455625385046005, -0.1622980684041977, 0.09331011772155762, 0.3380093574523926, -0.033986896276474, 0.19311629235744476, 0.31403979659080505, -0.28420954942703247], [0.07367116212844849, 0.27918869256973267, 0.14723916351795197, -0.08594399690628052, -0.03747712820768356, 0.06604894995689392, -0.24451759457588196, -0.3859589993953705, -0.03806540369987488, 0.2270965725183487, 0.07283550500869751, 0.26495590806007385, 0.1882932186126709, 0.011428234167397022, -0.08225511759519577, -0.273654967546463, 0.1466098129749298, -0.23666247725486755, 0.31648215651512146, 0.19239860773086548, 0.16084636747837067, -0.01548546552658081, 0.21774737536907196, -0.1803182065486908, 0.31011223793029785, 0.23427744209766388, -0.38910919427871704, -0.3067973554134369, -0.09045388549566269, 0.0356053002178669, -0.03537629917263985, 0.03998724743723869], [0.1840619593858719, -0.16310542821884155, -0.31658604741096497, -0.018931541591882706, 0.23916710913181305, -0.34201332926750183, -0.27732717990875244, 0.1768064945936203, 0.1505160927772522, -0.05662531778216362, 0.011530314572155476, -0.03709473833441734, 0.20194587111473083, -0.18658863008022308, -0.3035006821155548, 0.19391664862632751, 0.23013292253017426, 0.26344728469848633, -0.2493700236082077, -0.21002636849880219, -0.23196887969970703, -0.0181528739631176, 0.06867802888154984, 0.08398398756980896, -0.11246126890182495, 0.21971607208251953, 0.3147263526916504, 0.21145495772361755, 0.30364468693733215, -0.1877993643283844, -0.10459127277135849, 0.30512136220932007]], "net.4.bias": [0.006048767361789942, -0.12244439870119095, -0.13774198293685913]}
    </script>

    <script>
        // ==================== NEURAL NETWORK ====================
        const BRAIN = JSON.parse(document.getElementById('brainData').textContent);
        
        // Simple neural network forward pass
        class NeuralNetwork {
            constructor(weights) {
                this.w0 = weights['net.0.weight'];
                this.b0 = weights['net.0.bias'];
                this.w2 = weights['net.2.weight'];
                this.b2 = weights['net.2.bias'];
                this.w4 = weights['net.4.weight'];
                this.b4 = weights['net.4.bias'];
            }
            
            relu(x) { return Math.max(0, x); }
            
            forward(input) {
                // Layer 0: 48 -> 64
                let h1 = new Array(64).fill(0);
                for (let i = 0; i < 64; i++) {
                    let sum = this.b0[i];
                    for (let j = 0; j < 48; j++) {
                        sum += input[j] * this.w0[i][j];
                    }
                    h1[i] = this.relu(sum);
                }
                
                // Layer 2: 64 -> 32
                let h2 = new Array(32).fill(0);
                for (let i = 0; i < 32; i++) {
                    let sum = this.b2[i];
                    for (let j = 0; j < 64; j++) {
                        sum += h1[j] * this.w2[i][j];
                    }
                    h2[i] = this.relu(sum);
                }
                
                // Layer 4: 32 -> 3 (output)
                let output = new Array(3).fill(0);
                for (let i = 0; i < 3; i++) {
                    let sum = this.b4[i];
                    for (let j = 0; j < 32; j++) {
                        sum += h2[j] * this.w4[i][j];
                    }
                    output[i] = sum;
                }
                
                return output;
            }
            
            decide(input) {
                const output = this.forward(input);
                // 0=left, 1=straight, 2=right
                let maxIdx = 0;
                for (let i = 1; i < 3; i++) {
                    if (output[i] > output[maxIdx]) maxIdx = i;
                }
                return maxIdx;
            }
        }
        
        const neuralBrain = new NeuralNetwork(BRAIN);

        // ==================== RULE ENGINE (G√∂del Layer) ====================
        class RuleEngine {
            constructor() {
                this.rules = [];
                this.pendingCredits = []; // Track which rules influenced recent decisions
                this.stateHistory = {};   // Track recent states per snake for death analysis
                this.deathPatterns = {};  // Count death patterns to find common causes
                this.ruleIdCounter = 0;
                this.tick = 0;
                this.rulesGenerated = 0;
                this.load();
            }

            // Record state before each decision (for death analysis)
            recordState(snakeId, state, chosenAction) {
                if (!this.stateHistory[snakeId]) this.stateHistory[snakeId] = [];
                this.stateHistory[snakeId].push({ state: {...state}, action: chosenAction, tick: this.tick });
                // Keep only last 10 states
                if (this.stateHistory[snakeId].length > 10) this.stateHistory[snakeId].shift();
            }

            // Analyze death and potentially generate a new rule
            analyzeDeathAndGenerateRule(snakeId) {
                const history = this.stateHistory[snakeId];
                if (!history || history.length < 2) return;

                // Look at the last few states before death
                const lastState = history[history.length - 1];
                const state = lastState.state;
                const fatalAction = lastState.action; // 0=left, 1=straight, 2=right

                // Create a "death signature" from key state features
                const signature = this.createSignature(state, fatalAction);

                // Count this death pattern
                this.deathPatterns[signature] = (this.deathPatterns[signature] || 0) + 1;

                // If we've seen this pattern 3+ times, generate a rule
                if (this.deathPatterns[signature] >= 3) {
                    // Check if we already have a similar rule
                    const existingRule = this.rules.find(r =>
                        r.source === 'death_pattern' &&
                        JSON.stringify(r.trigger.conditions) === JSON.stringify(state)
                    );

                    if (!existingRule && this.rules.length < 50) { // Cap at 50 rules
                        // Create rule to avoid the fatal action
                        const bias = [0, 0, 0];
                        bias[fatalAction] = -1.5; // Strongly discourage the fatal action
                        // Slightly encourage alternatives
                        bias[(fatalAction + 1) % 3] = 0.3;
                        bias[(fatalAction + 2) % 3] = 0.3;

                        // Simplify state to key features only
                        const keyConditions = {};
                        if (state.wallAhead) keyConditions.wallAhead = true;
                        if (state.wallLeft) keyConditions.wallLeft = true;
                        if (state.wallRight) keyConditions.wallRight = true;
                        if (state.bodyAhead) keyConditions.bodyAhead = true;
                        if (state.bodyLeft) keyConditions.bodyLeft = true;
                        if (state.bodyRight) keyConditions.bodyRight = true;
                        if (state.enemyAhead) keyConditions.enemyAhead = true;

                        if (Object.keys(keyConditions).length > 0) {
                            const newRule = this.createRule(
                                { type: 'state', conditions: keyConditions },
                                { bias },
                                'death_pattern'
                            );
                            newRule.stats.confidence = 0.35; // Start with low confidence
                            this.rulesGenerated++;
                            console.log(`[G√ñDEL] Generated rule from ${this.deathPatterns[signature]} deaths:`, keyConditions, '‚Üí avoid action', fatalAction);

                            // Reset this pattern count
                            this.deathPatterns[signature] = 0;
                        }
                    }
                }

                // Clear history for dead snake
                delete this.stateHistory[snakeId];
            }

            createSignature(state, action) {
                const parts = [];
                if (state.wallAhead) parts.push('wA');
                if (state.wallLeft) parts.push('wL');
                if (state.wallRight) parts.push('wR');
                if (state.bodyAhead) parts.push('bA');
                if (state.bodyLeft) parts.push('bL');
                if (state.bodyRight) parts.push('bR');
                if (state.enemyAhead) parts.push('eA');
                parts.push(`a${action}`);
                return parts.join('_') || 'clear_a' + action;
            }

            createRule(trigger, action, source = 'manual') {
                const rule = {
                    id: `rule_${this.ruleIdCounter++}`,
                    trigger: trigger,      // { type: 'state', conditions: {...} }
                    action: action,        // { bias: [left, straight, right] }
                    stats: { applied: 0, successes: 0, failures: 0, confidence: 0.5 },
                    source: source,
                    createdAt: Date.now(),
                    active: true
                };
                this.rules.push(rule);
                return rule;
            }

            matchesTrigger(trigger, state) {
                if (trigger.type === 'state') {
                    for (const [key, value] of Object.entries(trigger.conditions)) {
                        if (typeof value === 'boolean') {
                            if (!!state[key] !== value) return false;
                        } else if (typeof value === 'object') {
                            if (value.min !== undefined && state[key] < value.min) return false;
                            if (value.max !== undefined && state[key] > value.max) return false;
                        } else {
                            if (state[key] !== value) return false;
                        }
                    }
                    return true;
                }
                return false;
            }

            applyRules(neuralOutput, gameState, snakeId) {
                let modified = [...neuralOutput];
                let appliedRuleIds = [];

                for (const rule of this.rules) {
                    if (!rule.active) continue;
                    if (this.matchesTrigger(rule.trigger, gameState)) {
                        for (let i = 0; i < 3; i++) {
                            modified[i] += rule.action.bias[i] * rule.stats.confidence;
                        }
                        appliedRuleIds.push(rule.id);
                        rule.stats.applied++;
                    }
                }

                if (appliedRuleIds.length > 0) {
                    this.pendingCredits.push({ snakeId, ruleIds: appliedRuleIds, tick: this.tick });
                    if (this.pendingCredits.length > 200) this.pendingCredits = this.pendingCredits.slice(-100);
                }

                return modified;
            }

            onOutcome(snakeId, outcome) {
                const rewards = { death: -1, ate_food: 0.3, got_kill: 1.0, survived_30: 0.1 };
                const reward = rewards[outcome] || 0;
                const recent = this.pendingCredits.filter(p => p.snakeId === snakeId && this.tick - p.tick < 30);

                for (const credit of recent) {
                    for (const ruleId of credit.ruleIds) {
                        const rule = this.rules.find(r => r.id === ruleId);
                        if (!rule) continue;
                        if (reward > 0) rule.stats.successes++;
                        else rule.stats.failures++;
                        const total = rule.stats.successes + rule.stats.failures;
                        if (total > 0) rule.stats.confidence = 0.3 + 0.7 * (rule.stats.successes / total);
                    }
                }

                if (outcome === 'death') {
                    this.pendingCredits = this.pendingCredits.filter(p => p.snakeId !== snakeId);
                }
            }

            pruneRules() {
                const before = this.rules.length;
                this.rules = this.rules.filter(rule => {
                    if (rule.stats.applied < 10) return true;
                    if (rule.stats.confidence < 0.25) return false;
                    return true;
                });
                if (this.rules.length < before) console.log(`[G√ñDEL] Pruned ${before - this.rules.length} weak rules`);
            }

            update() {
                this.tick++;
                if (this.tick % 500 === 0) { this.pruneRules(); this.save(); }
            }

            save() {
                localStorage.setItem('locomotio_rules', JSON.stringify({
                    rules: this.rules, ruleIdCounter: this.ruleIdCounter, savedAt: Date.now()
                }));
            }

            load() {
                try {
                    const saved = localStorage.getItem('locomotio_rules');
                    if (saved) {
                        const data = JSON.parse(saved);
                        this.rules = data.rules || [];
                        this.ruleIdCounter = data.ruleIdCounter || 0;
                        console.log(`[G√ñDEL] Loaded ${this.rules.length} rules`);
                    }
                } catch (e) { console.log('[G√ñDEL] No saved rules'); }
            }

            getStats() {
                const learned = this.rules.filter(r => r.source === 'death_pattern').length;
                return {
                    total: this.rules.length,
                    active: this.rules.filter(r => r.active).length,
                    learned: learned,
                    generated: this.rulesGenerated,
                    avgConf: this.rules.length > 0
                        ? (this.rules.reduce((s, r) => s + r.stats.confidence, 0) / this.rules.length).toFixed(2) : 0,
                    patterns: Object.keys(this.deathPatterns).length
                };
            }
        }

        const ruleEngine = new RuleEngine();

        // Starter rules if none exist
        if (ruleEngine.rules.length === 0) {
            ruleEngine.createRule({ type: 'state', conditions: { wallAhead: true } }, { bias: [-0.5, -2.0, -0.5] }, 'manual');
            ruleEngine.createRule({ type: 'state', conditions: { bodyLeft: true } }, { bias: [-1.5, 0, 0.3] }, 'manual');
            ruleEngine.createRule({ type: 'state', conditions: { bodyRight: true } }, { bias: [0.3, 0, -1.5] }, 'manual');
            ruleEngine.createRule({ type: 'state', conditions: { foodAhead: true } }, { bias: [0, 0.8, 0] }, 'manual');
            ruleEngine.createRule({ type: 'state', conditions: { foodLeft: true, foodAhead: false } }, { bias: [0.6, 0, 0] }, 'manual');
            ruleEngine.createRule({ type: 'state', conditions: { foodRight: true, foodAhead: false } }, { bias: [0, 0, 0.6] }, 'manual');
            ruleEngine.createRule({ type: 'state', conditions: { enemyAhead: true } }, { bias: [0, 0.5, 0] }, 'manual');
            console.log('[G√ñDEL] Created 7 starter rules');
            ruleEngine.save();
        }

        // ==================== MULTIPLAYER ====================
        // Player username
        let playerName = localStorage.getItem('locomot_username') || 'Train' + Math.floor(Math.random() * 999);

        const Multiplayer = {
            username: playerName,
            socket: null,
            connected: false,
            playerId: null,
            roomId: null,
            otherPlayers: new Map(), // id -> player state
            serverUrl: 'locomot-io.savecharlie.partykit.dev',

            connect(roomId = 'main') {
                this.roomId = roomId;
                try {
                    // Use PartySocket for reconnection handling
                    this.socket = new WebSocket(`wss://${this.serverUrl}/party/${roomId}`);

                    this.socket.onopen = () => {
                        console.log('[MP] Connected to room:', roomId);
                        this.connected = true;
                        this.showStatus('Connected!');
                        // Send username to server
                        if (this.username) {
                            this.send({ type: 'name', name: this.username });
                        }
                    };

                    this.socket.onmessage = (event) => {
                        this.handleMessage(JSON.parse(event.data));
                    };

                    this.socket.onclose = () => {
                        console.log('[MP] Disconnected');
                        this.connected = false;
                        this.showStatus('Disconnected');
                        // Try reconnect after 2s
                        setTimeout(() => this.connect(roomId), 2000);
                    };

                    this.socket.onerror = (e) => {
                        console.log('[MP] Error:', e);
                    };
                } catch (e) {
                    console.log('[MP] Connection failed:', e);
                }
            },

            handleMessage(data) {
                switch (data.type) {
                    case 'init':
                        this.playerId = data.playerId;
                        console.log('[MP] Assigned ID:', this.playerId);
                        // Initialize other players
                        for (const p of data.players) {
                            if (p.id !== this.playerId) {
                                this.otherPlayers.set(p.id, p);
                            }
                        }
                        break;

                    case 'player_joined':
                        console.log('[MP] Player joined:', data.player.name);
                        this.otherPlayers.set(data.player.id, data.player);
                        this.showStatus(`${data.player.name} joined!`);
                        break;

                    case 'player_left':
                        const left = this.otherPlayers.get(data.playerId);
                        this.otherPlayers.delete(data.playerId);
                        if (left) this.showStatus(`${left.name} left`);
                        break;

                    case 'state':
                        // Update all other players
                        for (const p of data.players) {
                            if (p.id !== this.playerId) {
                                this.otherPlayers.set(p.id, p);
                            }
                        }
                        break;
                    
                    case 'hit':
                        // We got hit by another player!
                        if (data.targetId === this.playerId && snake.length > 1) {
                            // Damage a random segment
                            const segIdx = 1 + Math.floor(Math.random() * (snake.length - 1));
                            if (snake[segIdx]) {
                                snake[segIdx].hp -= data.damage;
                                haptic('medium');
                                // Flash red
                                const seg = snake[segIdx];
                                for (let j = 0; j < 5; j++) {
                                    particles.push({ x: seg.x * GRID, y: seg.y * GRID, vx: (Math.random()-0.5)*3, vy: (Math.random()-0.5)*3, life: 10, color: '#f00' });
                                }
                            }
                        }
                        break;
                }
            },

            send(data) {
                if (this.socket && this.connected) {
                    this.socket.send(JSON.stringify(data));
                }
            },

            // Send our position to server
            sendUpdate(x, y, segments, score) {
                this.send({
                    type: 'update',
                    x, y,
                    segments: segments.map(s => ({ x: s.x, y: s.y })),
                    score
                });
            },

            // Send direction change
            sendMove(dir) {
                this.send({ type: 'move', dir });
            },

            setUsername(name) {
                name = name.trim().slice(0, 12) || 'Train' + Math.floor(Math.random() * 999);
                this.username = name;
                playerName = name;
                localStorage.setItem('locomot_username', name);
                this.send({ type: 'name', name });
            },

            showStatus(msg) {
                const el = document.getElementById('waveAnnounce');
                if (el) {
                    el.textContent = msg;
                    el.classList.add('show');
                    setTimeout(() => el.classList.remove('show'), 1500);
                }
            },

            // Draw other players
            drawOtherPlayers(ctx) {
                for (const player of this.otherPlayers.values()) {
                    if (!player.segments || player.segments.length === 0) continue;

                    // Draw segments
                    for (let i = player.segments.length - 1; i >= 0; i--) {
                        const seg = player.segments[i];
                        const isHead = i === 0;

                        ctx.fillStyle = isHead ? player.color : this.dimColor(player.color);
                        ctx.fillRect(seg.x * 12, seg.y * 12, 12, 12);

                        // Outline
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(seg.x * 12, seg.y * 12, 12, 12);
                    }

                    // Name tag
                    const head = player.segments[0];
                    ctx.fillStyle = '#fff';
                    ctx.font = '8px "Press Start 2P"';
                    ctx.textAlign = 'center';
                    ctx.fillText(player.name, head.x * 12 + 6, head.y * 12 - 5);
                }
            },

            dimColor(color) {
                // Dim color for body segments
                const r = parseInt(color.slice(1, 3), 16) * 0.6;
                const g = parseInt(color.slice(3, 5), 16) * 0.6;
                const b = parseInt(color.slice(5, 7), 16) * 0.6;
                return `rgb(${r},${g},${b})`;
            }
        };

        // Auto-connect to multiplayer
        const urlParams = new URLSearchParams(window.location.search);
        const roomParam = urlParams.get('room') || 'main';
        // Connect when game starts
        setTimeout(() => Multiplayer.connect(roomParam), 1000);
        
        // === KILL FEED ===
        const killFeed = {
            entries: [],
            add(killer, victim, method = '') {
                const entry = document.createElement('div');
                entry.className = 'kill-feed-entry';
                entry.innerHTML = `<span style="color:#f55">${killer}</span> üî´ <span style="color:#5ff">${victim}</span>`;
                document.getElementById('killFeed').prepend(entry);
                this.entries.push(entry);
                // Fade out after 4s
                setTimeout(() => entry.classList.add('fade'), 4000);
                setTimeout(() => entry.remove(), 4500);
                // Keep max 5
                if (this.entries.length > 5) {
                    const old = this.entries.shift();
                    old.remove();
                }
            }
        };
        
        // === INVITE LINK ===
        function updateInviteLink() {
            const room = roomParam || 'main';
            const link = 'locomot.io?room=' + room;
            document.getElementById('inviteLink').textContent = link;
        }
        function copyInvite() {
            const room = roomParam || 'main';
            const link = 'https://locomot.io?room=' + room;
            navigator.clipboard.writeText(link).then(() => {
                document.getElementById('inviteLink').textContent = 'COPIED!';
                setTimeout(updateInviteLink, 1500);
            });
        }
        setTimeout(updateInviteLink, 100);
        
        // === IDEA SUBMISSION ===
        function submitIdea() {
            const idea = prompt('Got an idea for LOCOMOT.IO? Share it!');
            if (idea && idea.trim()) {
                const subject = encodeURIComponent('LOCOMOT.IO Idea');
                const body = encodeURIComponent('IDEA: ' + idea + '\n\n---\nSent from locomot.io');
                window.open('mailto:savecharlie@gmail.com?subject=' + subject + '&body=' + body);
            }
        }
        
        // === SCREEN SHAKE ===
        function screenShake() {
            document.body.classList.add('shake');
            setTimeout(() => document.body.classList.remove('shake'), 300);
        }
        
        // === SOUND EFFECTS ===
        const sounds = {
            ctx: null,
            init() {
                if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            },
            play(type) {
                this.init();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                
                if (type === 'shoot') {
                    osc.frequency.value = 200;
                    osc.type = 'square';
                    gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                    gain.gain.exponentialDecayTo && gain.gain.exponentialDecayTo(0.01, this.ctx.currentTime + 0.1);
                    osc.start(); osc.stop(this.ctx.currentTime + 0.05);
                } else if (type === 'pickup') {
                    osc.frequency.value = 600;
                    osc.type = 'sine';
                    gain.gain.setValueAtTime(0.15, this.ctx.currentTime);
                    osc.start(); osc.stop(this.ctx.currentTime + 0.1);
                } else if (type === 'hit') {
                    osc.frequency.value = 150;
                    osc.type = 'sawtooth';
                    gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                    osc.start(); osc.stop(this.ctx.currentTime + 0.15);
                } else if (type === 'death') {
                    osc.frequency.value = 100;
                    osc.type = 'sawtooth';
                    gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(30, this.ctx.currentTime + 0.5);
                    osc.start(); osc.stop(this.ctx.currentTime + 0.5);
                } else if (type === 'powerup') {
                    osc.frequency.value = 400;
                    osc.type = 'sine';
                    gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(800, this.ctx.currentTime + 0.2);
                    osc.start(); osc.stop(this.ctx.currentTime + 0.2);
                }
            }
        };

        // ==================== GAME CODE ====================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
        resize();
        window.addEventListener('resize', resize);
        
        const GRID = 12;
        const WORLD_COLS = 300;
        const WORLD_ROWS = 200;
        const WORLD_WIDTH = WORLD_COLS * GRID;
        const WORLD_HEIGHT = WORLD_ROWS * GRID;
        
        let cameraX = 0, cameraY = 0, targetCameraX = 0, targetCameraY = 0;
        let cameraZoom = 2, targetZoom = 2; // Start zoomed in
        let gameState = 'start';
        let score = 0, wave = 1, lastTime = 0, moveTimer = 0, MOVE_INTERVAL = 70; // Faster!
        let aimAngle = 0, isAiming = false;
        let mouseX = 0, mouseY = 0, isMouseAiming = false;
        let trainFrame = 0; // For wheel animation
        
        const DIR = { UP: {x:0,y:-1}, DOWN: {x:0,y:1}, LEFT: {x:-1,y:0}, RIGHT: {x:1,y:0} };
        const GUNS = {
            HEAD: { color: '#0f0', fireRate: 200, damage: 12, range: 200 },
            MACHINEGUN: { color: '#f80', fireRate: 80, damage: 5, range: 180 },
            SHOTGUN: { color: '#f55', fireRate: 350, damage: 8, range: 150, spread: 0.4, pellets: 5 },
            CANNON: { color: '#5af', fireRate: 600, damage: 35, range: 250, size: 8 },
            PULSE: { color: '#f0f', fireRate: 500, damage: 15, range: 80, aoe: true }
        };
        const GUN_NAMES = ['MACHINEGUN', 'SHOTGUN', 'CANNON', 'PULSE'];

        // TRAIN PALETTE - warm industrial 8-bit colors
        const TRAIN = {
            black: '#1a1a2e',
            dark_metal: '#4a4a5c',
            metal: '#7a7a8c',
            light_metal: '#b0b0bc',
            rust: '#8b4513',
            rust_light: '#cd853f',
            red: '#c0392b',
            red_light: '#e74c3c',
            gold: '#d4a017',
            gold_light: '#ffd700',
            smoke: '#555566',
            smoke_light: '#888899',
            window: '#87ceeb',
            window_dark: '#5f9ea0',
            green: '#27ae60',
            green_light: '#2ecc71'
        };

        // Smoke puffs from locomotive
        let smokePuffs = [];

        function drawLocomotive(ctx, x, y, size, direction, frame) {
            // CHUNKY BLOCKY DESIGN - reads at any distance
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(Math.atan2(direction.y, direction.x));

            const s = size * 0.5;

            // Main body - big red block
            ctx.fillStyle = TRAIN.red;
            ctx.fillRect(-s, -s*0.7, s*1.8, s*1.4);

            // Cabin (taller back section)
            ctx.fillStyle = TRAIN.red_light;
            ctx.fillRect(-s*1.1, -s, s*0.5, s*2);

            // Smokestack - obvious block on top
            ctx.fillStyle = TRAIN.dark_metal;
            ctx.fillRect(s*0.2, -s*1.2, s*0.4, s*0.5);

            // Headlight - bright yellow/gold
            ctx.fillStyle = (frame % 16 < 8) ? '#fff' : TRAIN.gold_light;
            ctx.fillRect(s*0.7, -s*0.2, s*0.3, s*0.4);

            // Cow catcher - front wedge
            ctx.fillStyle = TRAIN.dark_metal;
            ctx.fillRect(s*0.8, -s*0.5, s*0.3, s*1);

            // Thick black outline for readability
            ctx.strokeStyle = TRAIN.black;
            ctx.lineWidth = 2;
            ctx.strokeRect(-s*1.1, -s, s*2.2, s*2);

            // Wheels - simple black rectangles at edges
            ctx.fillStyle = TRAIN.black;
            ctx.fillRect(-s*0.8, s*0.5, s*0.4, s*0.3);
            ctx.fillRect(s*0.2, s*0.5, s*0.4, s*0.3);
            ctx.fillRect(-s*0.8, -s*0.8, s*0.4, s*0.3);
            ctx.fillRect(s*0.2, -s*0.8, s*0.4, s*0.3);

            ctx.restore();
        }

        function drawBoxcar(ctx, x, y, size, direction, gunType, frame, hp, maxHp) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(Math.atan2(direction.y, direction.x));

            const s = size * 0.5;

            // Determine car color based on gun type
            let carColor = TRAIN.rust;
            if (gunType) {
                if (gunType.color === '#f80') carColor = '#f80';      // Machinegun - orange
                else if (gunType.color === '#f55') carColor = '#e44'; // Shotgun - red
                else if (gunType.color === '#5af') carColor = '#5af'; // Cannon - blue
                else if (gunType.color === '#f0f') carColor = '#f0f'; // Pulse - purple
            }

            // Damage flash
            if (hp < maxHp * 0.25 && Math.sin(frame * 0.5) > 0) carColor = '#600';
            else if (hp < maxHp * 0.5 && Math.sin(frame * 0.3) > 0.5) carColor = '#880';

            // Simple boxcar - just a rectangle
            ctx.fillStyle = carColor;
            ctx.fillRect(-s*0.8, -s*0.6, s*1.6, s*1.2);

            // Thick black outline
            ctx.strokeStyle = TRAIN.black;
            ctx.lineWidth = 2;
            ctx.strokeRect(-s*0.8, -s*0.6, s*1.6, s*1.2);

            // Gun turret - bright colored square on top
            if (gunType) {
                ctx.fillStyle = '#fff';
                ctx.fillRect(-s*0.2, -s*0.2, s*0.4, s*0.4);
                ctx.fillStyle = gunType.color;
                ctx.fillRect(-s*0.15, -s*0.15, s*0.3, s*0.3);
            }

            // Wheels - black rectangles
            ctx.fillStyle = TRAIN.black;
            ctx.fillRect(-s*0.6, s*0.4, s*0.3, s*0.25);
            ctx.fillRect(s*0.3, s*0.4, s*0.3, s*0.25);
            ctx.fillRect(-s*0.6, -s*0.65, s*0.3, s*0.25);
            ctx.fillRect(s*0.3, -s*0.65, s*0.3, s*0.25);

            ctx.restore();
        }

        function drawCaboose(ctx, x, y, size, direction, frame) {
            const s = size / 12;
            ctx.save();
            ctx.translate(x, y);

            let angle = Math.atan2(direction.y, direction.x);
            ctx.rotate(angle);

            // CABOOSE BODY (bright red!)
            ctx.fillStyle = TRAIN.red_light;
            ctx.fillRect(-5*s, -4*s, 10*s, 8*s);
            ctx.strokeStyle = TRAIN.black;
            ctx.lineWidth = s;
            ctx.strokeRect(-5*s, -4*s, 10*s, 8*s);

            // CUPOLA (raised section)
            ctx.fillStyle = TRAIN.red;
            ctx.fillRect(-3*s, -6*s, 6*s, 3*s);
            ctx.strokeRect(-3*s, -6*s, 6*s, 3*s);

            // Cupola windows
            ctx.fillStyle = TRAIN.window;
            ctx.fillRect(-2*s, -5*s, 4*s, 2*s);

            // Side windows
            ctx.fillRect(-4*s, -2*s, 3*s, 3*s);
            ctx.fillRect(1*s, -2*s, 3*s, 3*s);

            // LANTERN (blinking!)
            const lanternBlink = Math.sin(frame * 0.4) > 0;
            ctx.fillStyle = lanternBlink ? TRAIN.gold_light : TRAIN.gold;
            ctx.fillRect(-6*s, -3*s, 2*s, 3*s);
            ctx.strokeStyle = TRAIN.gold;
            ctx.strokeRect(-6*s, -3*s, 2*s, 3*s);

            // Railing
            ctx.strokeStyle = TRAIN.gold;
            ctx.lineWidth = s * 0.8;
            ctx.beginPath();
            ctx.moveTo(-5*s, 4*s);
            ctx.lineTo(-7*s, 4*s);
            ctx.lineTo(-7*s, -4*s);
            ctx.lineTo(-5*s, -4*s);
            ctx.stroke();

            // WHEELS
            const wheelOffset = (frame % 4) * (Math.PI / 2);
            for (let wy of [-3, 3]) {
                ctx.fillStyle = TRAIN.dark_metal;
                ctx.beginPath();
                ctx.arc(0, wy*s, 2*s, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        function spawnSmoke(x, y, direction) {
            // Spawn cloud puff behind the smokestack
            const offsetX = -direction.x * 10;
            const offsetY = -direction.y * 10;
            // Spawn a cluster of overlapping circles for cloud effect
            for (let i = 0; i < 3; i++) {
                smokePuffs.push({
                    x: x + offsetX + (Math.random() - 0.5) * 6,
                    y: y + offsetY + (Math.random() - 0.5) * 6,
                    vx: -direction.x * 0.3 + (Math.random() - 0.5) * 0.8,
                    vy: -0.8 - Math.random() * 0.4,
                    size: 4 + Math.random() * 3,
                    life: 50 + Math.random() * 20,
                    maxLife: 50
                });
            }
        }

        function updateSmoke() {
            for (let i = smokePuffs.length - 1; i >= 0; i--) {
                const p = smokePuffs[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy *= 0.98; // Slow down rise
                p.vx *= 0.98;
                p.size += 0.3; // Grow as it dissipates
                p.life--;
                if (p.life <= 0) smokePuffs.splice(i, 1);
            }
            // Limit total puffs
            if (smokePuffs.length > 100) smokePuffs.splice(0, 20);
        }

        function drawSmoke(ctx) {
            for (const p of smokePuffs) {
                const alpha = (p.life / p.maxLife) * 0.6;
                // Lighter gray that fades
                const gray = 150 + (1 - p.life / p.maxLife) * 80;
                ctx.fillStyle = `rgba(${gray}, ${gray}, ${gray + 10}, ${alpha})`;
                // BLOCKY squares instead of circles
                const sz = Math.floor(p.size);
                ctx.fillRect(Math.floor(p.x) - sz/2, Math.floor(p.y) - sz/2, sz, sz);
            }
        }

        let snake = [], dir = DIR.RIGHT, nextDir = DIR.RIGHT;
        let dirQueue = []; // Queue for fast direction changes
        let enemies = [], projectiles = [], enemyProjectiles = [], pickups = [], particles = [];
        let waveEnemies = 0, waveKills = 0, spawnTimer = 0, waveDelay = 0;
        let bestRank = 999, maxLength = 2;
        let invincibleTimer = 0; // 30 seconds of spawn protection
        let speedTimer = 0; // Speed boost duration
        let magnetTimer = 0; // Magnet pull duration
        const BASE_MOVE_INTERVAL = 80; // Normal move speed (ms)
        
        // Power-up types
        const POWERUPS = {
            SPEED: { name: 'SPEED', color: '#0ff', icon: 'üöÄ', duration: 10000 },
            SHIELD: { name: 'SHIELD', color: '#ff0', icon: 'üõ°Ô∏è', duration: 15000 },
            MAGNET: { name: 'MAGNET', color: '#f0f', icon: 'üß≤', duration: 12000 }
        };
        let deathReason = ''; // Track what killed the player
        let deathDebugInfo = null; // Full debug info at death

        // === PATTERN TRACKER - Real-time player behavior learning ===
        const patternTracker = {
            leftTurns: 0,
            rightTurns: 0,
            straightMoves: 0,
            turnsNearThreat: [],
            fleeDistances: [],
            recentTurns: [],
            lastTurnTime: 0,

            reset() {
                // Only reset session data, keep cumulative totals
                this.recentTurns = [];
                this.lastTurnTime = 0;
                this.turnsNearThreat = [];
                // Note: leftTurns, rightTurns, fleeDistances persist across games!
            },

            fullReset() {
                // Full reset - only when explicitly requested
                this.leftTurns = 0;
                this.rightTurns = 0;
                this.straightMoves = 0;
                this.turnsNearThreat = [];
                this.fleeDistances = [];
                this.recentTurns = [];
                this.lastTurnTime = 0;
            },

            recordTurn(oldDir, newDir, threatDist) {
                const turnDir = this.getTurnDirection(oldDir, newDir);
                if (turnDir === 0) { this.straightMoves++; return; }

                if (turnDir < 0) this.leftTurns++;
                else this.rightTurns++;

                if (threatDist < 10) {
                    this.turnsNearThreat.push({ dist: threatDist, turnDir });
                    if (threatDist < 5) this.fleeDistances.push(threatDist);
                }

                this.recentTurns.push(turnDir);
                if (this.recentTurns.length > 10) this.recentTurns.shift();

                if ((this.leftTurns + this.rightTurns) % 12 === 0) {
                    showPatternFlash('adapting');
                }
            },

            getTurnDirection(oldDir, newDir) {
                if (oldDir === DIR.UP) return newDir === DIR.LEFT ? -1 : newDir === DIR.RIGHT ? 1 : 0;
                if (oldDir === DIR.DOWN) return newDir === DIR.RIGHT ? -1 : newDir === DIR.LEFT ? 1 : 0;
                if (oldDir === DIR.LEFT) return newDir === DIR.DOWN ? -1 : newDir === DIR.UP ? 1 : 0;
                if (oldDir === DIR.RIGHT) return newDir === DIR.UP ? -1 : newDir === DIR.DOWN ? 1 : 0;
                return 0;
            },

            predictTurn() {
                const total = this.leftTurns + this.rightTurns;
                if (total < 5) return null;
                const leftBias = this.leftTurns / total;
                let recentBias = 0.5;
                if (this.recentTurns.length >= 3) {
                    recentBias = this.recentTurns.filter(t => t < 0).length / this.recentTurns.length;
                }
                const finalBias = (leftBias * 0.3) + (recentBias * 0.7);
                return { predictedDir: finalBias > 0.5 ? -1 : 1, confidence: Math.abs(finalBias - 0.5) * 2 };
            },

            getFleeDistance() {
                if (this.fleeDistances.length < 3) return 5;
                return this.fleeDistances.reduce((a,b) => a+b, 0) / this.fleeDistances.length;
            },

            getStats() {
                const turns = this.leftTurns + this.rightTurns;
                return {
                    leftBias: turns > 0 ? Math.round((this.leftTurns / turns) * 100) : 50,
                    totalTurns: turns,
                    fleeDistance: this.getFleeDistance().toFixed(1),
                    threatReactions: this.turnsNearThreat.length
                };
            },

            // Save patterns to localStorage
            save() {
                const data = {
                    leftTurns: this.leftTurns,
                    rightTurns: this.rightTurns,
                    straightMoves: this.straightMoves,
                    fleeDistances: this.fleeDistances.slice(-50), // Keep last 50
                    savedAt: Date.now()
                };
                localStorage.setItem('locomotio_patterns', JSON.stringify(data));
            },

            // Load patterns from localStorage
            load() {
                try {
                    const saved = localStorage.getItem('locomotio_patterns');
                    if (saved) {
                        const data = JSON.parse(saved);
                        this.leftTurns = data.leftTurns || 0;
                        this.rightTurns = data.rightTurns || 0;
                        this.straightMoves = data.straightMoves || 0;
                        this.fleeDistances = data.fleeDistances || [];
                        console.log('Loaded pattern data:', this.getStats());
                    }
                } catch (e) { console.log('No saved patterns'); }
            },

            // Get data for collective upload
            getCollectiveData() {
                return {
                    patterns: this.getStats(),
                    fleeDistances: this.fleeDistances,
                    timestamp: Date.now(),
                    version: 'v1'
                };
            }
        };

        let patternFlashTimer = 0, patternFlashType = '';
        function showPatternFlash(type) { patternFlashType = type; patternFlashTimer = 90; }
        function drawPatternFlash(ctx) {
            if (patternFlashTimer <= 0) return;
            patternFlashTimer--;
            const alpha = Math.min(1, patternFlashTimer / 30);
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.font = '10px "Press Start 2P"';
            ctx.textAlign = 'center';
            if (patternFlashType === 'adapting') {
                ctx.fillStyle = `rgba(0, 255, 200, ${alpha})`;
                ctx.fillText('ADAPTING...', canvas.width / 2, 70);
            } else if (patternFlashType === 'detected') {
                ctx.fillStyle = `rgba(255, 100, 100, ${alpha})`;
                ctx.fillText('PATTERN DETECTED', canvas.width / 2, 70);
            }
            ctx.restore();
        }

        function haptic(style = 'light') {
            if (!navigator.vibrate) return;
            switch(style) {
                case 'light': navigator.vibrate(10); break;
                case 'medium': navigator.vibrate(25); break;
                case 'heavy': navigator.vibrate(50); break;
                case 'double': navigator.vibrate([20, 30, 20]); break;
                case 'death': navigator.vibrate([50, 50, 100, 50, 200]); break;
            }
        }
        
        // Vision system for neural network - matches training exactly
        // LOOKAHEAD AI - Simulate future moves to predict outcomes
        function simulateLookahead(headX, headY, currentDir, segments, allEnemies, allPickups, playerSnake, depth = 4) {
            const scores = [0, 0, 0]; // left, straight, right
            const directions = [turnLeft(currentDir), currentDir, turnRight(currentDir)];
            
            for (let d = 0; d < 3; d++) {
                let simX = headX;
                let simY = headY;
                let simDir = directions[d];
                let simSegments = segments.map(s => ({x: s.x, y: s.y}));
                let alive = true;
                let foodCollected = 0;
                let score = 0;
                
                // Simulate several steps ahead
                for (let step = 0; step < depth && alive; step++) {
                    // Move in current direction
                    simX += simDir.x;
                    simY += simDir.y;
                    
                    // Wrap around world
                    if (simX < 0) simX = WORLD_COLS - 1;
                    if (simX >= WORLD_COLS) simX = 0;
                    if (simY < 0) simY = WORLD_ROWS - 1;
                    if (simY >= WORLD_ROWS) simY = 0;
                    
                    // Check self collision
                    for (const seg of simSegments) {
                        if (seg.x === simX && seg.y === simY) {
                            alive = false;
                            score -= 100; // Death is very bad
                            break;
                        }
                    }
                    
                    if (!alive) break;
                    
                    // Check collision with other enemies
                    for (const enemy of allEnemies) {
                        if (!enemy.segments) continue;
                        for (const seg of enemy.segments) {
                            if (seg.x === simX && seg.y === simY) {
                                // Collision - bad if they're bigger
                                if (enemy.segments.length >= simSegments.length) {
                                    alive = false;
                                    score -= 80;
                                } else {
                                    score += 30; // Could eat them!
                                }
                                break;
                            }
                        }
                        if (!alive) break;
                    }
                    
                    if (!alive) break;
                    
                    // Check collision with player
                    if (playerSnake && playerSnake.length > 0) {
                        for (let i = 0; i < playerSnake.length; i++) {
                            const seg = playerSnake[i];
                            if (seg.x === simX && seg.y === simY) {
                                if (i === 0) {
                                    // Head collision - depends on size
                                    if (playerSnake.length >= simSegments.length) {
                                        alive = false;
                                        score -= 90;
                                    } else {
                                        score += 50; // Kill player!
                                    }
                                } else {
                                    alive = false;
                                    score -= 70;
                                }
                                break;
                            }
                        }
                    }
                    
                    if (!alive) break;
                    
                    // Check for nearby food (bonus for paths near food)
                    for (const pickup of allPickups) {
                        const px = Math.floor(pickup.x / GRID);
                        const py = Math.floor(pickup.y / GRID);
                        const dist = Math.abs(simX - px) + Math.abs(simY - py);
                        if (dist === 0) {
                            foodCollected++;
                            score += 20;
                        } else if (dist < 3) {
                            score += 5 / dist; // Closer food = better
                        }
                    }
                    
                    // Update simulated segments (move forward)
                    simSegments.unshift({x: simX, y: simY});
                    if (foodCollected === 0) simSegments.pop();
                    
                    // Slight preference for going straight (more predictable)
                    if (d === 1) score += 0.5;
                    
                    // After first step, continue straight for simulation
                    // (simplification - real tree search would branch)
                }
                
                // Bonus for staying alive
                if (alive) score += 10;
                
                scores[d] = score;
            }
            
            return scores; // [leftScore, straightScore, rightScore]
        }

        function getVision(headX, headY, currentDir, segments, allEnemies, allPickups, playerSnake) {
            // 8 directions relative to heading (matches training order)
            const angles = [0, Math.PI/4, Math.PI/2, 3*Math.PI/4, Math.PI, -3*Math.PI/4, -Math.PI/2, -Math.PI/4];
            const RAY_DIST = 25; // Match training ray distance

            // Heading angles (matches training: UP=-œÄ/2, DOWN=œÄ/2, LEFT=œÄ, RIGHT=0)
            let headingAngle = 0;
            if (currentDir === DIR.UP) headingAngle = -Math.PI/2;
            else if (currentDir === DIR.DOWN) headingAngle = Math.PI/2;
            else if (currentDir === DIR.LEFT) headingAngle = Math.PI;
            else if (currentDir === DIR.RIGHT) headingAngle = 0;

            const myLength = segments.length;

            // 8 directions √ó 6 values = 48 inputs
            // Order: [food, self_body, wall, smaller_head, bigger_head, enemy_body]
            const input = new Array(48).fill(0);

            for (let i = 0; i < 8; i++) {
                const angle = headingAngle + angles[i];
                const dx = Math.round(Math.cos(angle));
                const dy = Math.round(Math.sin(angle));

                let foodDist = 0, selfDanger = 0, wallDist = 0;
                let enemySmallerDist = 0, enemyBiggerDist = 0, enemyBodyDist = 0;

                // Cast ray - NO WRAPPING (walls are solid obstacles)
                for (let dist = 1; dist <= RAY_DIST; dist++) {
                    const checkX = headX + dx * dist;
                    const checkY = headY + dy * dist;

                    // Bounds check - out of world = wall, stop ray
                    if (checkX < 0 || checkX >= WORLD_COLS || checkY < 0 || checkY >= WORLD_ROWS) {
                        if (wallDist === 0) wallDist = 1 / dist;
                        break;
                    }

                    // Wall proximity (2-cell buffer like training)
                    if (wallDist === 0) {
                        if (checkX <= 1 || checkX >= WORLD_COLS-2 || checkY <= 1 || checkY >= WORLD_ROWS-2) {
                            wallDist = 1 / dist;
                        }
                    }

                    // Self collision (skip head)
                    if (selfDanger === 0) {
                        for (let s = 1; s < segments.length; s++) {
                            if (segments[s].x === checkX && segments[s].y === checkY) {
                                selfDanger = 1 / dist;
                                break;
                            }
                        }
                    }

                    // Other snakes
                    const allSnakes = [...allEnemies];
                    if (playerSnake && playerSnake.length > 0) {
                        allSnakes.push({ segments: playerSnake, isPlayer: true });
                    }

                    for (const other of allSnakes) {
                        const otherSegs = other.segments || other;
                        if (!otherSegs || otherSegs.length === 0) continue;
                        if (otherSegs === segments) continue;

                        const otherLength = otherSegs.length;

                        for (let s = 0; s < otherSegs.length; s++) {
                            const seg = otherSegs[s];
                            if (seg.x === checkX && seg.y === checkY) {
                                if (s === 0) {
                                    // Head - check size
                                    if (otherLength < myLength && enemySmallerDist === 0) {
                                        enemySmallerDist = 1 / dist;
                                    } else if (otherLength >= myLength && enemyBiggerDist === 0) {
                                        enemyBiggerDist = 1 / dist;
                                    }
                                } else if (enemyBodyDist === 0) {
                                    enemyBodyDist = 1 / dist;
                                }
                                break;
                            }
                        }
                    }

                    // Food (all pickups)
                    if (foodDist === 0) {
                        for (const p of allPickups) {
                            const px = Math.floor(p.x / GRID);
                            const py = Math.floor(p.y / GRID);
                            if (px === checkX && py === checkY) {
                                foodDist = 1 / dist;
                                break;
                            }
                        }
                    }
                }

                // Store: [food, self, wall, smaller, bigger, body]
                input[i * 6 + 0] = foodDist;
                input[i * 6 + 1] = selfDanger;
                input[i * 6 + 2] = wallDist;
                input[i * 6 + 3] = enemySmallerDist;
                input[i * 6 + 4] = enemyBiggerDist;
                input[i * 6 + 5] = enemyBodyDist;
            }

            return input;
        }
        
        function turnLeft(d) {
            if (d === DIR.UP) return DIR.LEFT;
            if (d === DIR.LEFT) return DIR.DOWN;
            if (d === DIR.DOWN) return DIR.RIGHT;
            return DIR.UP;
        }
        
        function turnRight(d) {
            if (d === DIR.UP) return DIR.RIGHT;
            if (d === DIR.RIGHT) return DIR.DOWN;
            if (d === DIR.DOWN) return DIR.LEFT;
            return DIR.UP;
        }
        
        // Spawn an established enemy at a specific location (for pre-population)
        function spawnEstablishedEnemy(x, y, length, isAlpha = false) {
            const dirs = [DIR.UP, DIR.DOWN, DIR.LEFT, DIR.RIGHT];
            const startDir = dirs[Math.floor(Math.random() * dirs.length)];
            
            const isNeural = Math.random() < 0.5;
            let color, personality;
            
            if (isNeural) {
                color = '#f0f';
                personality = { aggression: 0.5, greed: 0.5, caution: 0.5, neural: true };
            } else {
                const personalities = [
                    { aggression: 0.8, greed: 0.3, caution: 0.2 },
                    { aggression: 0.2, greed: 0.9, caution: 0.4 },
                    { aggression: 0.5, greed: 0.5, caution: 0.7 },
                    { aggression: 0.9, greed: 0.1, caution: 0.1 },
                ];
                personality = personalities[Math.floor(Math.random() * personalities.length)];
                
                if (isAlpha) color = '#ff0'; // Alpha predators are gold
                else if (personality.aggression > 0.7) color = '#f55';
                else if (personality.greed > 0.7) color = '#ff0';
                else if (personality.caution > 0.5) color = '#5af';
                else color = '#f80';
            }
            
            const baseHp = 20 + wave * 5;
            const segments = [];
            
            // Build snake body following a path (not just straight line)
            let curX = x, curY = y, curDir = startDir;
            for (let i = 0; i < length; i++) {
                segments.push({
                    x: curX, y: curY,
                    hp: i === 0 ? Infinity : baseHp,
                    maxHp: i === 0 ? Infinity : baseHp,
                    type: i === 0 ? GUNS.HEAD : GUNS[GUN_NAMES[Math.floor(Math.random() * GUN_NAMES.length)]],
                    lastFired: 0
                });
                // Move backwards from head, occasionally turning
                if (i > 0 && Math.random() < 0.3) {
                    curDir = dirs[Math.floor(Math.random() * dirs.length)];
                }
                curX = (curX - curDir.x + WORLD_COLS) % WORLD_COLS;
                curY = (curY - curDir.y + WORLD_ROWS) % WORLD_ROWS;
            }
            
            enemies.push({
                segments, dir: startDir, nextDir: startDir, color,
                baseSpeed: 8 + wave * 0.5, damage: 10 + wave * 2,
                moveTimer: Math.random() * 500, // Stagger movement
                lastFired: 0, fireRate: 1200 - wave * 40,
                score: 10 * length, personality,
                targetPos: null, avoidPos: null, lastDecision: 0,
                decisionInterval: 300 + Math.random() * 200
            });
        }
        
        function simulateWorld(ticks) {
            // Run the world simulation for a while before player joins
            for (let t = 0; t < ticks; t++) {
                // Update enemies (simplified - just movement)
                for (const e of enemies) {
                    if (!e.segments || e.segments.length === 0) continue;
                    
                    e.moveTimer += 16; // ~60fps
                    const myLen = e.segments.length;
                    const speedMultiplier = 1 / (1 + (myLen - 1) * 0.05);
                    const actualSpeed = e.baseSpeed * speedMultiplier;
                    const moveInterval = 150 / actualSpeed * 10;
                    
                    if (e.moveTimer >= moveInterval) {
                        e.moveTimer = 0;
                        
                        const head = e.segments[0];
                        let newDir = e.dir;
                        
                        // Simple AI for simulation
                        if (Math.random() < 0.1) {
                            const dirs = [turnLeft(e.dir), e.dir, turnRight(e.dir)];
                            newDir = dirs[Math.floor(Math.random() * dirs.length)];
                        }
                        
                        // Go towards nearest pickup
                        if (pickups.length > 0 && Math.random() < 0.5) {
                            let nearestDist = Infinity, nearestPickup = null;
                            for (const p of pickups) {
                                const px = Math.floor(p.x / GRID), py = Math.floor(p.y / GRID);
                                const dist = Math.abs(head.x - px) + Math.abs(head.y - py);
                                if (dist < nearestDist) { nearestDist = dist; nearestPickup = p; }
                            }
                            if (nearestPickup && nearestDist < 30) {
                                const px = Math.floor(nearestPickup.x / GRID);
                                const py = Math.floor(nearestPickup.y / GRID);
                                const dx = px - head.x, dy = py - head.y;
                                if (Math.abs(dx) > Math.abs(dy)) newDir = dx > 0 ? DIR.RIGHT : DIR.LEFT;
                                else if (Math.abs(dy) > 0) newDir = dy > 0 ? DIR.DOWN : DIR.UP;
                            }
                        }
                        
                        // Don't reverse
                        if (newDir.x === -e.dir.x && newDir.y === -e.dir.y) newDir = e.dir;
                        e.dir = newDir;
                        
                        // Move
                        const prevPositions = e.segments.map(s => ({ x: s.x, y: s.y }));
                        head.x = (head.x + e.dir.x + WORLD_COLS) % WORLD_COLS;
                        head.y = (head.y + e.dir.y + WORLD_ROWS) % WORLD_ROWS;
                        for (let j = 1; j < e.segments.length; j++) {
                            e.segments[j].x = prevPositions[j - 1].x;
                            e.segments[j].y = prevPositions[j - 1].y;
                        }
                        
                        // Pickup collection
                        for (let pi = pickups.length - 1; pi >= 0; pi--) {
                            const p = pickups[pi];
                            const px = Math.floor(p.x / GRID), py = Math.floor(p.y / GRID);
                            if (head.x === px && head.y === py && !p.isHealth) {
                                const tail = e.segments[e.segments.length - 1];
                                e.segments.push({ 
                                    x: tail.x, y: tail.y, 
                                    hp: 20 + wave * 5, maxHp: 20 + wave * 5, 
                                    type: p.type, lastFired: 0 
                                });
                                pickups.splice(pi, 1);
                            }
                        }
                    }
                }
                
                // Spawn new pickups occasionally
                if (t % 60 === 0 && pickups.length < 20) {
                    const px = Math.floor(Math.random() * WORLD_COLS) * GRID + GRID/2;
                    const py = Math.floor(Math.random() * WORLD_ROWS) * GRID + GRID/2;
                    pickups.push({
                        x: px, y: py,
                        type: GUNS[GUN_NAMES[Math.floor(Math.random() * GUN_NAMES.length)]],
                        isHealth: false, bob: Math.random() * Math.PI * 2
                    });
                }
                // Spawn power-ups rarely
                if (t % 300 === 0 && pickups.filter(p => p.isPowerup).length < 3) {
                    const px = Math.floor(Math.random() * WORLD_COLS) * GRID + GRID/2;
                    const py = Math.floor(Math.random() * WORLD_ROWS) * GRID + GRID/2;
                    const powerupTypes = Object.values(POWERUPS);
                    const powerup = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];
                    pickups.push({
                        x: px, y: py,
                        type: powerup,
                        isPowerup: true,
                        bob: Math.random() * Math.PI * 2
                    });
                }
            }
        }
        
        function init() {
            score = 0; wave = 3; // Start at wave 3 - world is already established
            enemies = []; projectiles = []; enemyProjectiles = []; pickups = []; particles = [];
            waveEnemies = 0; waveKills = 0; spawnTimer = 0; waveDelay = 0;
            bestRank = 999; maxLength = 4; // Reset tracking
            invincibleTimer = 10000; // 10 seconds of spawn protection
            speedTimer = 0; magnetTimer = 0; // Reset power-up timers
            patternTracker.reset(); // Reset pattern tracking for new game
            
            // Scatter pickups around the world first
            for (let i = 0; i < 200; i++) {
                const px = Math.floor(Math.random() * WORLD_COLS) * GRID + GRID/2;
                const py = Math.floor(Math.random() * WORLD_ROWS) * GRID + GRID/2;
                pickups.push({
                    x: px, y: py,
                    type: GUNS[GUN_NAMES[Math.floor(Math.random() * GUN_NAMES.length)]],
                    isHealth: Math.random() < 0.15,
                    healAmount: 40,
                    bob: Math.random() * Math.PI * 2
                });
            }
            
            // Spawn initial power-ups
            const powerupTypes = Object.values(POWERUPS);
            for (let i = 0; i < 5; i++) {
                const px = Math.floor(Math.random() * WORLD_COLS) * GRID + GRID/2;
                const py = Math.floor(Math.random() * WORLD_ROWS) * GRID + GRID/2;
                pickups.push({
                    x: px, y: py,
                    type: powerupTypes[Math.floor(Math.random() * powerupTypes.length)],
                    isPowerup: true,
                    bob: Math.random() * Math.PI * 2
                });
            }
            
            // Spawn established enemies across the map
            // Alpha predators (big snakes, 12-25 segments) - fewer of them
            for (let i = 0; i < 6; i++) {
                const x = Math.floor(Math.random() * (WORLD_COLS - 20)) + 10;
                const y = Math.floor(Math.random() * (WORLD_ROWS - 20)) + 10;
                spawnEstablishedEnemy(x, y, 12 + Math.floor(Math.random() * 14), true);
            }
            
            // Medium snakes (5-11 segments) - fewer
            for (let i = 0; i < 20; i++) {
                const x = Math.floor(Math.random() * (WORLD_COLS - 10)) + 5;
                const y = Math.floor(Math.random() * (WORLD_ROWS - 10)) + 5;
                spawnEstablishedEnemy(x, y, 5 + Math.floor(Math.random() * 7));
            }
            
            // Small snakes (2-5 segments) - your peers
            for (let i = 0; i < 50; i++) {
                const x = Math.floor(Math.random() * (WORLD_COLS - 6)) + 3;
                const y = Math.floor(Math.random() * (WORLD_ROWS - 6)) + 3;
                spawnEstablishedEnemy(x, y, 2 + Math.floor(Math.random() * 4));
            }
            
            // Simulate the world for a bit so snakes have moved around
            simulateWorld(600);
            
            // Find a safe spawn location for player (away from big snakes)
            let spawnX, spawnY, attempts = 0;
            do {
                spawnX = Math.floor(Math.random() * (WORLD_COLS - 10)) + 5;
                spawnY = Math.floor(Math.random() * (WORLD_ROWS - 10)) + 5;
                attempts++;
                
                // Check distance from all enemies
                let safe = true;
                for (const e of enemies) {
                    if (e.segments.length === 0) continue;
                    const head = e.segments[0];
                    const dist = Math.abs(head.x - spawnX) + Math.abs(head.y - spawnY);
                    // Stay far away from big snakes
                    if (e.segments.length > 5 && dist < 30) safe = false;
                    // Decent distance from any snake
                    if (dist < 15) safe = false;
                }
                if (safe || attempts > 100) break;
            } while (true);
            
            // Player starts small but tough - head + 3 segments with boosted HP
            snake = [
                { x: spawnX, y: spawnY, type: GUNS.HEAD, hp: Infinity, maxHp: Infinity, lastFired: 0 },
                { x: spawnX - 1, y: spawnY, type: GUNS.MACHINEGUN, hp: 300, maxHp: 300, lastFired: 0 },
                { x: spawnX - 2, y: spawnY, type: GUNS.SHOTGUN, hp: 300, maxHp: 300, lastFired: 0 },
                { x: spawnX - 3, y: spawnY, type: GUNS.CANNON, hp: 300, maxHp: 300, lastFired: 0 }
            ];
            
            dir = DIR.RIGHT; nextDir = DIR.RIGHT;
            aimAngle = 0; isAiming = true;
            
            cameraZoom = 2; targetZoom = 2; // Start zoomed in
            cameraX = spawnX * GRID - canvas.width / 2 / cameraZoom;
            cameraY = spawnY * GRID - canvas.height / 2 / cameraZoom;
            dirQueue = []; // Clear direction queue
            
            updateHUD(); updateLeaderboard(); announceSpawn();
        }
        
        function announceSpawn() {
            const el = document.getElementById('waveAnnounce');
            el.textContent = 'üõ°Ô∏è 45s SHIELD';
            el.classList.add('show');
            waveDelay = 1500;
            haptic('medium');
            setTimeout(() => el.classList.remove('show'), 1500);
        }
        
        function announceWave() {
            const el = document.getElementById('waveAnnounce');
            el.textContent = `WAVE ${wave}`;
            el.classList.add('show');
            waveDelay = 2000;
            haptic('medium');
            setTimeout(() => el.classList.remove('show'), 1500);
        }

        function respawn() {
            // Death effects
            screenShake();
            // sounds disabled
            
            // Capture debug info at death
            const otherPlayersDebug = [];
            if (Multiplayer.connected) {
                for (const [pid, op] of Multiplayer.otherPlayers) {
                    otherPlayersDebug.push({
                        id: pid,
                        name: op.name,
                        segments: op.segments ? op.segments.length : 0,
                        head: op.segments && op.segments[0] ? op.segments[0] : null,
                        color: op.color
                    });
                }
            }
            
            deathDebugInfo = {
                timestamp: new Date().toISOString(),
                reason: deathReason,
                myPosition: snake[0] ? { x: snake[0].x, y: snake[0].y } : null,
                myLength: snake.length,
                myScore: score,
                multiplayer: {
                    connected: Multiplayer.connected,
                    playerId: Multiplayer.playerId,
                    roomId: Multiplayer.roomId,
                    otherPlayers: otherPlayersDebug
                },
                nearbyEnemies: enemies.filter(e => {
                    if (!e.segments || !snake[0]) return false;
                    const dist = Math.abs(e.segments[0].x - snake[0].x) + Math.abs(e.segments[0].y - snake[0].y);
                    return dist < 15;
                }).map(e => ({
                    len: e.segments.length,
                    head: e.segments[0],
                    personality: e.personality?.neural ? 'neural' : 'basic'
                }))
            };
            console.log('DEATH DEBUG:', deathDebugInfo);
            
            // Show death screen with learning stats
            patternTracker.save();
            ruleEngine.save();

            // Update game over screen stats
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalWave').textContent = '#' + (enemies.filter(e => e.segments.length >= snake.length).length + 1);
            document.getElementById('finalLength').textContent = maxLength;
            document.getElementById('deathReasonText').textContent = deathReason || 'Unknown';

            // Pattern stats
            const pStats = patternTracker.getStats();
            document.getElementById('patternStatsText').innerHTML =
                `Turn bias: ${pStats.leftBias}% left<br>` +
                `Flee distance: ${pStats.fleeDistance} tiles`;

            // G√∂del learning stats
            const gStats = ruleEngine.getStats();
            let godelText = `${gStats.total} rules active (${gStats.learned} learned from deaths)<br>`;
            godelText += `Avg confidence: ${(gStats.avgConf * 100).toFixed(0)}%<br>`;
            godelText += `Death patterns tracked: ${gStats.patterns}`;

            // Show recently generated rules
            const recentRules = ruleEngine.rules.filter(r => r.source === 'death_pattern').slice(-3);
            if (recentRules.length > 0) {
                godelText += `<br><br>Recent learnings:`;
                for (const rule of recentRules) {
                    const conditions = Object.keys(rule.trigger.conditions).join(', ');
                    const avoid = rule.action.bias[0] < -1 ? 'left' : rule.action.bias[2] < -1 ? 'right' : 'straight';
                    godelText += `<br>‚Ä¢ "${conditions}" ‚Üí avoid ${avoid}`;
                }
            }
            document.getElementById('godelStatsText').innerHTML = godelText;

            // Show game over screen
            gameState = 'dead';
            canvas.classList.remove('playing');
            document.getElementById('gameOverScreen').classList.remove('hidden');
        }

        function doRespawn() {
            document.getElementById('gameOverScreen').classList.add('hidden');

            // Find safe spawn location
            let spawnX, spawnY, attempts = 0;
            do {
                spawnX = Math.floor(Math.random() * (WORLD_COLS - 10)) + 5;
                spawnY = Math.floor(Math.random() * (WORLD_ROWS - 10)) + 5;
                attempts++;

                let safe = true;
                for (const e of enemies) {
                    if (e.segments.length === 0) continue;
                    const head = e.segments[0];
                    const dist = Math.abs(head.x - spawnX) + Math.abs(head.y - spawnY);
                    if (e.segments.length > 5 && dist < 30) safe = false;
                    if (dist < 15) safe = false;
                }
                if (safe || attempts > 100) break;
            } while (true);

            // Fresh start with new train
            snake = [
                { x: spawnX, y: spawnY, type: GUNS.HEAD, hp: Infinity, maxHp: Infinity, lastFired: 0 },
                { x: spawnX - 1, y: spawnY, type: GUNS.MACHINEGUN, hp: 300, maxHp: 300, lastFired: 0 },
                { x: spawnX - 2, y: spawnY, type: GUNS.SHOTGUN, hp: 300, maxHp: 300, lastFired: 0 },
                { x: spawnX - 3, y: spawnY, type: GUNS.CANNON, hp: 300, maxHp: 300, lastFired: 0 }
            ];

            dir = DIR.RIGHT; nextDir = DIR.RIGHT;
            aimAngle = 0; isAiming = true;
            invincibleTimer = 5000; // 5s spawn protection

            cameraZoom = 2; targetZoom = 2;
            cameraX = spawnX * GRID - canvas.width / 2 / cameraZoom;
            cameraY = spawnY * GRID - canvas.height / 2 / cameraZoom;
            dirQueue = [];

            // Reset score on death (io game style)
            score = 0;
            maxLength = 4;
            deathReason = '';
            deathDebugInfo = null;

            gameState = 'playing';
            canvas.classList.add('playing');

            const el = document.getElementById('waveAnnounce');
            el.textContent = 'üõ°Ô∏è RESPAWNING...';
            el.classList.add('show');
            haptic('medium');
            setTimeout(() => el.classList.remove('show'), 1500);
        }

        function spawnEnemy() {
            const edge = Math.floor(Math.random() * 4);
            let x, y, startDir;
            
            switch (edge) {
                case 0: x = 0; y = Math.floor(Math.random() * WORLD_ROWS); startDir = DIR.RIGHT; break;
                case 1: x = WORLD_COLS - 1; y = Math.floor(Math.random() * WORLD_ROWS); startDir = DIR.LEFT; break;
                case 2: x = Math.floor(Math.random() * WORLD_COLS); y = 0; startDir = DIR.DOWN; break;
                case 3: x = Math.floor(Math.random() * WORLD_COLS); y = WORLD_ROWS - 1; startDir = DIR.UP; break;
            }
            
            let trainLength = 2;
            if (wave >= 2 && Math.random() > 0.6) trainLength = 3;
            if (wave >= 4 && Math.random() > 0.7) trainLength = 4;
            if (wave >= 6 && Math.random() > 0.8) trainLength = 5;
            
            // 50% chance to be neural AI, rest are personality-based
            const isNeural = Math.random() < 0.5;
            
            let color, personality;
            if (isNeural) {
                color = '#f0f'; // Magenta for neural AI
                personality = { aggression: 0.5, greed: 0.5, caution: 0.5, neural: true };
            } else {
                const personalities = [
                    { aggression: 0.8, greed: 0.3, caution: 0.2 },
                    { aggression: 0.2, greed: 0.9, caution: 0.4 },
                    { aggression: 0.5, greed: 0.5, caution: 0.7 },
                    { aggression: 0.9, greed: 0.1, caution: 0.1 },
                ];
                personality = personalities[Math.floor(Math.random() * personalities.length)];
                
                if (personality.aggression > 0.7) color = '#f55';
                else if (personality.greed > 0.7) color = '#ff0';
                else if (personality.caution > 0.5) color = '#5af';
                else color = '#f80';
            }
            
            const baseHp = 20 + wave * 5;
            const segments = [];
            for (let i = 0; i < trainLength; i++) {
                let gunType = i === 0 ? GUNS.HEAD : GUNS[GUN_NAMES[Math.floor(Math.random() * GUN_NAMES.length)]];
                const segX = (x - startDir.x * i + WORLD_COLS) % WORLD_COLS;
                const segY = (y - startDir.y * i + WORLD_ROWS) % WORLD_ROWS;
                segments.push({
                    x: segX, y: segY,
                    hp: i === 0 ? Infinity : baseHp,
                    maxHp: i === 0 ? Infinity : baseHp,
                    type: gunType, lastFired: 0
                });
            }
            
            enemies.push({
                segments, dir: startDir, nextDir: startDir, color,
                baseSpeed: 8 + wave * 0.5, damage: 10 + wave * 2,
                moveTimer: 0, lastFired: 0, fireRate: 1200 - wave * 40,
                score: 10 * trainLength, personality,
                targetPos: null, avoidPos: null, lastDecision: 0,
                decisionInterval: 300 + Math.random() * 200
            });
        }
        
        function updateSnake() {
            // Consume from direction queue for responsive controls
            if (dirQueue.length > 0) {
                const newDir = dirQueue.shift();
                // Extra check to prevent 180 turns
                if (!(dir.x === -newDir.x && dir.y === -newDir.y)) {
                    dir = newDir;
                    nextDir = newDir;
                }
            } else {
                dir = nextDir;
            }
            const head = snake[0];
            const newX = head.x + dir.x;
            const newY = head.y + dir.y;
            const wrappedX = (newX + WORLD_COLS) % WORLD_COLS;
            const wrappedY = (newY + WORLD_ROWS) % WORLD_ROWS;
            
            for (let i = 1; i < snake.length; i++) {
                if (snake[i].x === wrappedX && snake[i].y === wrappedY) {
                    snake[0].hp = 0;
                    deathReason = 'Self collision - ran into own body';
                    return true;
                }
            }
            
            const prevPositions = snake.map(s => ({ x: s.x, y: s.y }));
            snake[0].x = wrappedX;
            snake[0].y = wrappedY;
            
            for (let i = 1; i < snake.length; i++) {
                snake[i].x = prevPositions[i - 1].x;
                snake[i].y = prevPositions[i - 1].y;
            }
            
            const headPx = wrappedX * GRID + GRID / 2;
            const headPy = wrappedY * GRID + GRID / 2;
            
            for (let i = pickups.length - 1; i >= 0; i--) {
                const p = pickups[i];
                const dist = Math.sqrt((p.x - headPx) ** 2 + (p.y - headPy) ** 2);
                
                if (dist < GRID) {
                    if (p.isPowerup) {
                        // Collect power-up!
                        if (p.type.name === 'SPEED') {
                            speedTimer = p.type.duration;
                        } else if (p.type.name === 'SHIELD') {
                            invincibleTimer = Math.max(invincibleTimer, p.type.duration);
                        } else if (p.type.name === 'MAGNET') {
                            magnetTimer = p.type.duration;
                        }
                        haptic('heavy');
                        // sounds disabled
                        // Big flashy particles
                        for (let j = 0; j < 20; j++) {
                            particles.push({ x: p.x, y: p.y, vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8, life: 40, color: p.type.color });
                        }
                        pickups.splice(i, 1);
                        continue;
                    } else if (p.isHealth) {
                        let mostDamaged = null, lowestHp = Infinity;
                        for (let j = 1; j < snake.length; j++) {
                            if (snake[j].hp < snake[j].maxHp && snake[j].hp < lowestHp) {
                                lowestHp = snake[j].hp;
                                mostDamaged = snake[j];
                            }
                        }
                        if (mostDamaged) {
                            mostDamaged.hp = Math.min(mostDamaged.maxHp, mostDamaged.hp + p.healAmount);
                            haptic('double');
                            for (let j = 0; j < 8; j++) {
                                particles.push({ x: p.x, y: p.y, vx: (Math.random() - 0.5) * 4, vy: (Math.random() - 0.5) * 4, life: 25, color: '#4f4' });
                            }
                        }
                    } else {
                        const tailPos = prevPositions[prevPositions.length - 1];
                        snake.push({ x: tailPos.x, y: tailPos.y, type: p.type, hp: 200, maxHp: 200, lastFired: 0 });
                        haptic('double');
                        // sounds disabled
                        score += 50;
                        for (let j = 0; j < 12; j++) {
                            particles.push({ x: p.x, y: p.y, vx: (Math.random() - 0.5) * 6, vy: (Math.random() - 0.5) * 6, life: 30, color: p.type.color });
                        }
                    }
                    pickups.splice(i, 1);
                }
            }

            // Send position to multiplayer server
            if (Multiplayer.connected) {
                Multiplayer.sendUpdate(snake[0].x, snake[0].y, snake, score);
                
                // PVP COLLISION DETECTION
                for (const [playerId, otherPlayer] of Multiplayer.otherPlayers) {
                    if (!otherPlayer.segments || otherPlayer.segments.length === 0) continue;
                    
                    const otherHead = otherPlayer.segments[0];
                    const myLen = snake.length;
                    const theirLen = otherPlayer.segments.length;
                    
                    // Check head vs other player's body (with 1-tile tolerance for lag)
                    for (let i = 0; i < otherPlayer.segments.length; i++) {
                        const seg = otherPlayer.segments[i];
                        const dx = Math.abs(wrappedX - seg.x);
                        const dy = Math.abs(wrappedY - seg.y);
                        
                        // Exact collision or within 1 tile (lag compensation)
                        if (dx <= 1 && dy <= 1 && dx + dy <= 1) {
                            // Collision detected
                            
                            if (i === 0) {
                                // Head-to-head collision!
                                if (myLen > theirLen) {
                                    // We win!
                                    score += theirLen * 100;
                                    haptic('heavy');
                                    // sounds disabled
                                    killFeed.add(playerName, otherPlayer.name);
                                    for (let j = 0; j < 20; j++) {
                                        particles.push({ x: seg.x * GRID, y: seg.y * GRID, vx: (Math.random()-0.5)*8, vy: (Math.random()-0.5)*8, life: 40, color: otherPlayer.color });
                                    }
                                    Multiplayer.send({ type: 'kill', targetId: playerId });
                                } else if (myLen < theirLen) {
                                    // We die!
                                    deathReason = 'Killed by ' + otherPlayer.name + ' (head-on, ' + theirLen + ' vs ' + myLen + ')';
                                    return true;
                                }
                                // Equal size = both survive
                            } else {
                                // Hit their body - we die!
                                deathReason = 'Ran into ' + otherPlayer.name + "'s body (seg " + i + ')';
                                return true;
                            }
                        }
                    }
                }
                
                
            }

            return false;
        }

        function updateEnemies(dt) {
            const playerHead = snake[0];
            const playerLen = snake.length;
            
            // Track which player segments have been damaged this frame (prevent stacking)
            const playerSegmentsDamagedThisFrame = new Set();
            
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                if (!e.segments || e.segments.length === 0) { enemies.splice(i, 1); continue; }
                
                const head = e.segments[0];
                const myLen = e.segments.length;
                const speedMultiplier = 1 / (1 + (myLen - 1) * 0.05); // Reduced penalty
                const actualSpeed = e.baseSpeed * speedMultiplier;
                
                e.moveTimer += dt;
                const moveInterval = 150 / actualSpeed * 10; // Fixed formula - lower = faster
                
                if (e.moveTimer >= moveInterval) {
                    e.moveTimer = 0;
                    
                    let newDir = e.dir;
                    
                    // NEURAL NETWORK AI + RULE ENGINE
                    if (e.personality.neural) {
                        const vision = getVision(head.x, head.y, e.dir, e.segments, enemies.filter(oe => oe !== e), pickups, snake);

                        // Extract gameState from vision for rule matching
                        // Vision: 8 directions √ó 6 values [food, self, wall, smaller_head, bigger_head, enemy_body]
                        // Dir 0=ahead, 2=right, 6=left
                        // Find leader (biggest snake) direction
                        let leaderDir = null;
                        let maxLen = e.segments.length;
                        for (const other of enemies) {
                            if (other !== e && other.segments && other.segments.length > maxLen) {
                                maxLen = other.segments.length;
                                const dx = other.segments[0].x - head.x;
                                const dy = other.segments[0].y - head.y;
                                leaderDir = { dx, dy, len: other.segments.length };
                            }
                        }
                        // Check player too
                        if (snake.length > maxLen) {
                            maxLen = snake.length;
                            const dx = snake[0].x - head.x;
                            const dy = snake[0].y - head.y;
                            leaderDir = { dx, dy, len: snake.length };
                        }
                        
                        // Calculate leader direction relative to our heading
                        let leaderAhead = false, leaderLeft = false, leaderRight = false;
                        if (leaderDir) {
                            const { dx, dy } = leaderDir;
                            if (e.dir === DIR.UP) { leaderAhead = dy < 0; leaderLeft = dx < 0; leaderRight = dx > 0; }
                            else if (e.dir === DIR.DOWN) { leaderAhead = dy > 0; leaderLeft = dx > 0; leaderRight = dx < 0; }
                            else if (e.dir === DIR.LEFT) { leaderAhead = dx < 0; leaderLeft = dy > 0; leaderRight = dy < 0; }
                            else { leaderAhead = dx > 0; leaderLeft = dy < 0; leaderRight = dy > 0; }
                        }
                        
                        const gameState = {
                            foodAhead: vision[0] > 0,
                            foodLeft: vision[36] > 0,
                            foodRight: vision[12] > 0,
                            wallAhead: vision[2] > 0.3,
                            wallLeft: vision[38] > 0.3,
                            wallRight: vision[14] > 0.3,
                            bodyAhead: vision[1] > 0,
                            bodyLeft: vision[37] > 0,
                            bodyRight: vision[13] > 0,
                            enemyAhead: vision[5] > 0 || vision[3] > 0 || vision[4] > 0,
                            enemyLeft: vision[41] > 0 || vision[39] > 0 || vision[40] > 0,
                            enemyRight: vision[17] > 0 || vision[15] > 0 || vision[16] > 0,
                            enemyCloser: vision[3] > vision[4],
                            leaderAhead,
                            leaderLeft, 
                            leaderRight,
                            iAmBigger: leaderDir ? e.segments.length > leaderDir.len : true
                        };

                        // Get raw neural output
                        let output = neuralBrain.forward(vision);

                        // Apply rules (G√∂del layer)
                        output = ruleEngine.applyRules(output, gameState, e.id);

                        // LOOKAHEAD: Simulate future moves to avoid bad outcomes
                        const lookaheadScores = simulateLookahead(
                            head.x, head.y, e.dir, e.segments,
                            enemies.filter(oe => oe !== e), pickups, snake, 5
                        );
                        
                        // Combine neural output with lookahead (lookahead can veto bad moves)
                        // Normalize neural output to 0-1 range
                        const maxNeural = Math.max(output[0], output[1], output[2]);
                        const minNeural = Math.min(output[0], output[1], output[2]);
                        const range = maxNeural - minNeural || 1;
                        const neuralNorm = output.map(v => (v - minNeural) / range);
                        
                        // If lookahead predicts death (very negative), heavily penalize
                        for (let i = 0; i < 3; i++) {
                            if (lookaheadScores[i] < -50) {
                                output[i] -= 100; // Veto this direction
                            } else {
                                // Add lookahead bonus scaled by neural confidence
                                output[i] += lookaheadScores[i] * 0.1;
                            }
                        }

                        // LEADER HUNTING: Bias toward the biggest snake (if we're bigger, hunt; if smaller, maybe flee)
                        if (gameState.leaderAhead || gameState.leaderLeft || gameState.leaderRight) {
                            const huntBias = gameState.iAmBigger ? 2 : -1; // Hunt if bigger, slight avoid if smaller
                            if (gameState.leaderAhead) output[1] += huntBias;
                            if (gameState.leaderLeft) output[0] += huntBias;
                            if (gameState.leaderRight) output[2] += huntBias;
                        }

                        // Make decision from modified output
                        let decision = 1; // default straight
                        if (output[0] > output[1] && output[0] > output[2]) decision = 0;
                        else if (output[2] > output[1] && output[2] > output[0]) decision = 2;

                        // Record state for death analysis (G√∂del learning)
                        ruleEngine.recordState(e.id, gameState, decision);

                        if (decision === 0) newDir = turnLeft(e.dir);
                        else if (decision === 2) newDir = turnRight(e.dir);
                        // decision === 1 means go straight

                        // PATTERN PREDICTION: Override when near player
                        const distToPlayer = Math.abs(head.x - playerHead.x) + Math.abs(head.y - playerHead.y);
                        if (distToPlayer < 8 && distToPlayer > 2) {
                            const prediction = patternTracker.predictTurn();
                            if (prediction && prediction.confidence > 0.3) {
                                // Predict where player will be based on their turn bias
                                const playerDir = dir;
                                let predictedPos = { x: playerHead.x, y: playerHead.y };

                                // If player tends to turn left, anticipate that
                                if (prediction.predictedDir < 0) {
                                    const leftDir = turnLeft(playerDir);
                                    predictedPos.x += leftDir.x * 3;
                                    predictedPos.y += leftDir.y * 3;
                                } else {
                                    const rightDir = turnRight(playerDir);
                                    predictedPos.x += rightDir.x * 3;
                                    predictedPos.y += rightDir.y * 3;
                                }

                                // Move toward predicted position
                                const dx = predictedPos.x - head.x;
                                const dy = predictedPos.y - head.y;

                                if (Math.abs(dx) > Math.abs(dy)) {
                                    const wantDir = dx > 0 ? DIR.RIGHT : DIR.LEFT;
                                    if (!(wantDir.x === -e.dir.x && wantDir.y === -e.dir.y)) {
                                        newDir = wantDir;
                                        // Flash pattern detected occasionally
                                        if (Math.random() < 0.08) showPatternFlash('detected');
                                    }
                                } else {
                                    const wantDir = dy > 0 ? DIR.DOWN : DIR.UP;
                                    if (!(wantDir.x === -e.dir.x && wantDir.y === -e.dir.y)) {
                                        newDir = wantDir;
                                        if (Math.random() < 0.08) showPatternFlash('detected');
                                    }
                                }
                            }
                        }
                    } else {
                        // Original personality-based AI
                        let targetX = playerHead.x, targetY = playerHead.y;
                        const p = e.personality;
                        
                        if (p.greed > 0.5 && pickups.length > 0) {
                            let nearestDist = Infinity;
                            for (const pickup of pickups) {
                                const px = Math.floor(pickup.x / GRID);
                                const py = Math.floor(pickup.y / GRID);
                                const dist = Math.abs(head.x - px) + Math.abs(head.y - py);
                                if (dist < nearestDist && dist < 30) {
                                    nearestDist = dist;
                                    targetX = px; targetY = py;
                                }
                            }
                        }
                        
                        if (p.aggression > 0.7) {
                            for (const other of enemies) {
                                if (other === e || other.segments.length === 0) continue;
                                if (myLen > other.segments.length) {
                                    const dist = Math.abs(head.x - other.segments[0].x) + Math.abs(head.y - other.segments[0].y);
                                    if (dist < 20) { targetX = other.segments[0].x; targetY = other.segments[0].y; break; }
                                }
                            }
                        }
                        
                        if (p.caution > 0.5 && myLen < playerLen) {
                            const dist = Math.abs(head.x - playerHead.x) + Math.abs(head.y - playerHead.y);
                            if (dist < 15) {
                                targetX = head.x + (head.x - playerHead.x) * 2;
                                targetY = head.y + (head.y - playerHead.y) * 2;
                            }
                        }
                        
                        const dx = targetX - head.x, dy = targetY - head.y;
                        if (Math.abs(dx) > Math.abs(dy)) newDir = dx > 0 ? DIR.RIGHT : DIR.LEFT;
                        else if (Math.abs(dy) > 0) newDir = dy > 0 ? DIR.DOWN : DIR.UP;
                    }
                    
                    // Don't reverse
                    if (newDir.x === -e.dir.x && newDir.y === -e.dir.y) newDir = e.dir;
                    
                    // Collision avoidance
                    const nextX = (head.x + newDir.x + WORLD_COLS) % WORLD_COLS;
                    const nextY = (head.y + newDir.y + WORLD_ROWS) % WORLD_ROWS;
                    let willCollide = false;
                    
                    for (let j = 1; j < e.segments.length; j++) {
                        if (e.segments[j].x === nextX && e.segments[j].y === nextY) { willCollide = true; break; }
                    }
                    
                    if (willCollide) {
                        const dirs = [DIR.UP, DIR.DOWN, DIR.LEFT, DIR.RIGHT];
                        for (const tryDir of dirs) {
                            if (tryDir.x === -e.dir.x && tryDir.y === -e.dir.y) continue;
                            const tryX = (head.x + tryDir.x + WORLD_COLS) % WORLD_COLS;
                            const tryY = (head.y + tryDir.y + WORLD_ROWS) % WORLD_ROWS;
                            let safe = true;
                            for (let j = 1; j < e.segments.length; j++) {
                                if (e.segments[j].x === tryX && e.segments[j].y === tryY) { safe = false; break; }
                            }
                            if (safe) { newDir = tryDir; break; }
                        }
                    }
                    
                    e.dir = newDir;
                    
                    // Move
                    const prevPositions = e.segments.map(s => ({ x: s.x, y: s.y }));
                    head.x = (head.x + e.dir.x + WORLD_COLS) % WORLD_COLS;
                    head.y = (head.y + e.dir.y + WORLD_ROWS) % WORLD_ROWS;
                    for (let j = 1; j < e.segments.length; j++) {
                        e.segments[j].x = prevPositions[j - 1].x;
                        e.segments[j].y = prevPositions[j - 1].y;
                    }
                    
                    // Pickup collection
                    for (let pi = pickups.length - 1; pi >= 0; pi--) {
                        const p = pickups[pi];
                        const px = Math.floor(p.x / GRID), py = Math.floor(p.y / GRID);
                        if (head.x === px && head.y === py) {
                            if (!p.isHealth) {
                                const tail = e.segments[e.segments.length - 1];
                                e.segments.push({ x: tail.x, y: tail.y, hp: 20 + wave * 5, maxHp: 20 + wave * 5, type: p.type, lastFired: 0 });
                            }
                            pickups.splice(pi, 1);
                            ruleEngine.onOutcome(e.id, 'ate_food'); // Credit rules for eating
                            for (let j = 0; j < 6; j++) {
                                particles.push({ x: head.x * GRID + GRID/2, y: head.y * GRID + GRID/2, vx: (Math.random()-0.5)*4, vy: (Math.random()-0.5)*4, life: 20, color: e.color });
                            }
                        }
                    }
                }
                
                // Shooting - find best target (player or other enemies)
                const now = performance.now();
                let targetX = null, targetY = null, targetDist = Infinity;
                
                // Check player distance
                const playerDist = Math.abs(head.x - playerHead.x) + Math.abs(head.y - playerHead.y);
                if (playerDist < 25) {
                    targetX = playerHead.x;
                    targetY = playerHead.y;
                    targetDist = playerDist;
                }
                
                // Check other enemies - prioritize smaller ones or threats
                for (const other of enemies) {
                    if (other === e || !other.segments || other.segments.length === 0) continue;
                    const otherHead = other.segments[0];
                    const dist = Math.abs(head.x - otherHead.x) + Math.abs(head.y - otherHead.y);
                    
                    // Engage if: close enough AND (we're bigger OR they're a threat)
                    if (dist < 20) {
                        const dominated = e.segments.length > other.segments.length;
                        const threatened = other.segments.length > e.segments.length && dist < 12;
                        
                        if ((dominated || threatened) && dist < targetDist) {
                            targetX = otherHead.x;
                            targetY = otherHead.y;
                            targetDist = dist;
                        }
                    }
                }
                
                // Fire at target if we have one
                if (targetX !== null) {
                    for (let si = 0; si < e.segments.length; si++) {
                        const seg = e.segments[si];
                        if (!seg.type) continue;
                        if (seg.lastFired === undefined) seg.lastFired = 0;
                        const type = seg.type;
                        if (now - seg.lastFired < type.fireRate) continue;
                        seg.lastFired = now;
                        
                        const sx = seg.x * GRID + GRID/2, sy = seg.y * GRID + GRID/2;
                        const tx = targetX * GRID + GRID/2, ty = targetY * GRID + GRID/2;
                        const angle = Math.atan2(ty - sy, tx - sx);
                        
                        if (si === 0) { e.aimAngle = angle; e.aimX = sx; e.aimY = sy; }
                        
                        if (type.aoe) {
                            // AOE damages player (if not invincible) and other enemies
                            if (invincibleTimer <= 0) {
                                for (const ps of snake) {
                                    const psx = ps.x * GRID + GRID/2, psy = ps.y * GRID + GRID/2;
                                    const dist = Math.sqrt((psx - sx)**2 + (psy - sy)**2);
                                    if (dist < type.range) ps.hp -= type.damage;
                                }
                            }
                            for (const other of enemies) {
                                if (other === e || !other.segments) continue;
                                for (const oseg of other.segments) {
                                    const osx = oseg.x * GRID + GRID/2, osy = oseg.y * GRID + GRID/2;
                                    const dist = Math.sqrt((osx - sx)**2 + (osy - sy)**2);
                                    if (dist < type.range) oseg.hp -= type.damage;
                                }
                            }
                            particles.push({ x: sx, y: sy, vx: 0, vy: 0, life: 15, color: type.color, isAoe: true, radius: 10 });
                        } else if (type.spread) {
                            for (let p = 0; p < type.pellets; p++) {
                                const spread = (Math.random() - 0.5) * type.spread * 2;
                                const a = angle + spread;
                                enemyProjectiles.push({ x: sx, y: sy, vx: Math.cos(a)*5, vy: Math.sin(a)*5, damage: type.damage, size: 3, color: type.color, life: 300, owner: e });
                            }
                        } else {
                            const size = type.size || 4;
                            enemyProjectiles.push({ x: sx, y: sy, vx: Math.cos(angle)*5, vy: Math.sin(angle)*5, damage: type.damage, size, color: type.color, life: 400, owner: e });
                        }
                    }
                }
                
                // Collisions - skip fatal ones during invincibility or grace period
                // Grace: for 500ms after shield drops, head collisions just push through
                if (head.x === playerHead.x && head.y === playerHead.y) {
                    // If player only has head (no body), any collision is instant death
                    if (playerLen <= 1 && invincibleTimer <= 0) {
                        deathReason = 'Head-only collision - no protection!';
                        return true;
                    }
                    if (invincibleTimer > -2000) {
                        // During invincibility or 2 second grace period, just pass through
                        // But deal significant damage to the enemy for touching us
                        if (e.segments.length > 1) e.segments[1].hp -= 50;
                    } else if (myLen > playerLen + 6) {
                        // Only instant death if enemy is MUCH bigger (7+ segments more)
                        deathReason = `Head collision with MUCH bigger enemy (${myLen} vs ${playerLen} segments)`;
                        console.log('DEATH: Enemy much bigger', { myLen, playerLen, invincibleTimer });
                        return true;
                    } else if (myLen > playerLen) {
                        // Bigger but not by much - take heavy damage instead of instant death
                        for (let si = 1; si < snake.length && si < 3; si++) {
                            snake[si].hp -= 50;
                        }
                        haptic('heavy');
                    } else if (myLen < playerLen) {
                        for (const seg of e.segments) {
                            pickups.push({ x: seg.x*GRID+GRID/2, y: seg.y*GRID+GRID/2, type: GUNS[GUN_NAMES[Math.floor(Math.random()*GUN_NAMES.length)]], isHealth: false, bob: Math.random()*Math.PI*2 });
                            score += 15; waveKills++;
                        }
                        e.segments = [];
                        haptic('medium');
                    } else {
                        // Equal size - both take damage, neither dies instantly
                        for (let si = 1; si < snake.length && si < 2; si++) {
                            snake[si].hp -= 30;
                        }
                        for (let si = 1; si < e.segments.length && si < 2; si++) {
                            e.segments[si].hp -= 30;
                        }
                    }
                }
                
                // Enemy vs enemy collisions
                for (const other of enemies) {
                    if (other === e || !other.segments || other.segments.length === 0) continue;
                    if (e.segments.length === 0) break;
                    const otherHead = other.segments[0];
                    if (head.x === otherHead.x && head.y === otherHead.y) {
                        const otherLen = other.segments.length;
                        if (myLen > otherLen) {
                            for (const seg of other.segments) { pickups.push({ x: seg.x*GRID+GRID/2, y: seg.y*GRID+GRID/2, type: GUNS[GUN_NAMES[Math.floor(Math.random()*GUN_NAMES.length)]], isHealth: false, bob: Math.random()*Math.PI*2 }); waveKills++; }
                            ruleEngine.onOutcome(other.id, 'death');
                            ruleEngine.analyzeDeathAndGenerateRule(other.id);
                            ruleEngine.onOutcome(e.id, 'got_kill');
                            other.segments = [];
                        } else if (myLen < otherLen) {
                            for (const seg of e.segments) { pickups.push({ x: seg.x*GRID+GRID/2, y: seg.y*GRID+GRID/2, type: GUNS[GUN_NAMES[Math.floor(Math.random()*GUN_NAMES.length)]], isHealth: false, bob: Math.random()*Math.PI*2 }); waveKills++; }
                            ruleEngine.onOutcome(e.id, 'death');
                            ruleEngine.analyzeDeathAndGenerateRule(e.id);
                            ruleEngine.onOutcome(other.id, 'got_kill');
                            e.segments = [];
                        } else {
                            for (const seg of e.segments) { pickups.push({ x: seg.x*GRID+GRID/2, y: seg.y*GRID+GRID/2, type: GUNS[GUN_NAMES[Math.floor(Math.random()*GUN_NAMES.length)]], isHealth: false, bob: Math.random()*Math.PI*2 }); waveKills++; }
                            for (const seg of other.segments) { pickups.push({ x: seg.x*GRID+GRID/2, y: seg.y*GRID+GRID/2, type: GUNS[GUN_NAMES[Math.floor(Math.random()*GUN_NAMES.length)]], isHealth: false, bob: Math.random()*Math.PI*2 }); waveKills++; }
                            ruleEngine.onOutcome(e.id, 'death');
                            ruleEngine.analyzeDeathAndGenerateRule(e.id);
                            ruleEngine.onOutcome(other.id, 'death');
                            ruleEngine.analyzeDeathAndGenerateRule(other.id);
                            e.segments = [];
                            other.segments = [];
                        }
                    }
                }

                // Self collision
                for (let j = 1; j < e.segments.length; j++) {
                    if (head.x === e.segments[j].x && head.y === e.segments[j].y) {
                        for (const seg of e.segments) { pickups.push({ x: seg.x*GRID+GRID/2, y: seg.y*GRID+GRID/2, type: GUNS[GUN_NAMES[Math.floor(Math.random()*GUN_NAMES.length)]], isHealth: false, bob: Math.random()*Math.PI*2 }); waveKills++; }
                        ruleEngine.onOutcome(e.id, 'death');
                        ruleEngine.analyzeDeathAndGenerateRule(e.id);
                        e.segments = [];
                        break;
                    }
                }
                
                // Body collisions with player - limit damage per frame globally
                for (let si = 0; si < e.segments.length; si++) {
                    const seg = e.segments[si];
                    for (let j = 0; j < snake.length; j++) {
                        const ps = snake[j];
                        if (seg.x === ps.x && seg.y === ps.y) {
                            if (si === 0 && j > 0) { seg.hp -= 50; haptic('medium'); }
                            else if (si > 0 && j === 0) seg.hp = 0;
                            else if (si > 0 && j > 0) { 
                                seg.hp -= 30; 
                                // Only damage each player segment once per frame total (not per enemy)
                                // Reduced damage during grace period
                                if (invincibleTimer <= 0 && !playerSegmentsDamagedThisFrame.has(j)) { 
                                    const dmg = invincibleTimer > -2000 ? e.damage * 0.3 : e.damage;
                                    ps.hp -= dmg; 
                                    playerSegmentsDamagedThisFrame.add(j);
                                    haptic('heavy'); 
                                }
                            }
                        }
                    }
                }
                
                // Remove dead segments
                for (let j = e.segments.length - 1; j >= 0; j--) {
                    if (e.segments[j].hp <= 0) {
                        const seg = e.segments[j];
                        score += 10; waveKills++;
                        let totalHp = 0, maxTotalHp = 0;
                        for (let k = 1; k < snake.length; k++) { totalHp += snake[k].hp; maxTotalHp += snake[k].maxHp; }
                        const healthPct = maxTotalHp > 0 ? totalHp / maxTotalHp : 1;
                        let dropHealth = healthPct < 0.4 ? Math.random() < 0.8 : Math.random() > healthPct;
                        if (healthPct >= 0.95) dropHealth = false;
                        
                        if (dropHealth) {
                            pickups.push({ x: seg.x*GRID+GRID/2, y: seg.y*GRID+GRID/2, type: { color: '#4f4', name: 'HEALTH' }, isHealth: true, healAmount: 40, bob: Math.random()*Math.PI*2 });
                        } else {
                            pickups.push({ x: seg.x*GRID+GRID/2, y: seg.y*GRID+GRID/2, type: GUNS[GUN_NAMES[Math.floor(Math.random()*GUN_NAMES.length)]], isHealth: false, bob: Math.random()*Math.PI*2 });
                        }
                        for (let k = 0; k < 8; k++) { particles.push({ x: seg.x*GRID+GRID/2, y: seg.y*GRID+GRID/2, vx: (Math.random()-0.5)*6, vy: (Math.random()-0.5)*6, life: 25, color: e.color }); }
                        e.segments.splice(j);
                        break;
                    }
                }
                
                if (e.segments.length === 0) enemies.splice(i, 1);
            }
            
            const playerSpeedMultiplier = 1 / (1 + (playerLen - 3) * 0.1);
            const speedBoost = speedTimer > 0 ? 1.8 : 1; // 80% faster with speed power-up
            MOVE_INTERVAL = 120 / playerSpeedMultiplier / speedBoost;
            
            // Passive health regen for player segments (2 HP per 100ms = 20 HP/sec)
            for (let i = 1; i < snake.length; i++) {
                const seg = snake[i];
                if (seg.hp < seg.maxHp) {
                    seg.hp = Math.min(seg.maxHp, seg.hp + dt * 0.02);
                }
            }
            
            // Passive health regen for enemy segments (slower - 5 HP/sec)
            for (const e of enemies) {
                if (!e.segments) continue;
                for (let i = 1; i < e.segments.length; i++) {
                    const seg = e.segments[i];
                    if (seg.hp < seg.maxHp) {
                        seg.hp = Math.min(seg.maxHp, seg.hp + dt * 0.005);
                    }
                }
            }
            
            for (let i = snake.length - 1; i >= 1; i--) {
                if (snake[i].hp <= 0) {
                    const seg = snake[i];
                    for (let j = 0; j < 10; j++) { particles.push({ x: seg.x*GRID+GRID/2, y: seg.y*GRID+GRID/2, vx: (Math.random()-0.5)*5, vy: (Math.random()-0.5)*5, life: 30, color: seg.type.color }); }
                    snake.splice(i);
                    haptic('heavy');
                    break;
                }
            }
            
            return snake.length <= 1;
        }
        
        function updateEnemyProjectiles(dt) {
            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const p = enemyProjectiles[i];
                p.x += p.vx * dt * 0.2; p.y += p.vy * dt * 0.2; p.life -= dt;
                
                // Check hit on player (skip if invincible, reduced damage during grace)
                if (invincibleTimer <= 0) {
                    for (const seg of snake) {
                        const sx = seg.x * GRID + GRID/2, sy = seg.y * GRID + GRID/2;
                        const dist = Math.sqrt((p.x - sx)**2 + (p.y - sy)**2);
                        if (dist < p.size + GRID/2) {
                            // Reduced damage during 2 second grace period
                            const dmg = invincibleTimer > -2000 ? p.damage * 0.3 : p.damage;
                            seg.hp -= dmg; p.life = 0; haptic('medium');
                            particles.push({ x: p.x, y: p.y, vx: 0, vy: 0, life: 10, color: '#f00' });
                            break;
                        }
                    }
                }
                
                // Check hit on other enemies (not the owner)
                if (p.life > 0) {
                    for (const e of enemies) {
                        if (e === p.owner || !e.segments) continue;
                        for (const seg of e.segments) {
                            const sx = seg.x * GRID + GRID/2, sy = seg.y * GRID + GRID/2;
                            const dist = Math.sqrt((p.x - sx)**2 + (p.y - sy)**2);
                            if (dist < p.size + GRID/2) {
                                seg.hp -= p.damage; p.life = 0;
                                particles.push({ x: p.x, y: p.y, vx: 0, vy: 0, life: 10, color: '#ff0' });
                                break;
                            }
                        }
                        if (p.life <= 0) break;
                    }
                }
                
                if (p.life <= 0) enemyProjectiles.splice(i, 1);
            }
        }
        
        function updateProjectiles(dt) {
            // Combine enemies + other players into one target list
            const allTargets = [...enemies];
            if (Multiplayer.connected) {
                for (const [playerId, op] of Multiplayer.otherPlayers) {
                    if (op.segments && op.segments.length > 0) {
                        allTargets.push({
                            segments: op.segments.map(s => ({ x: s.x, y: s.y, hp: 999, maxHp: 999 })),
                            color: op.color,
                            isPlayer: true,
                            playerId: playerId
                        });
                    }
                }
            }
            
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.x += p.vx * dt * 0.25; p.y += p.vy * dt * 0.25; p.life -= dt;
                
                // Hit any target (enemies or players)
                outer: for (const e of allTargets) {
                    if (!e.segments) continue;
                    for (const seg of e.segments) {
                        const sx = seg.x * GRID + GRID/2, sy = seg.y * GRID + GRID/2;
                        const dist = Math.sqrt((p.x - sx)**2 + (p.y - sy)**2);
                        if (dist < GRID/2 + p.size) {
                            p.life = 0;
                            particles.push({ x: p.x, y: p.y, vx: (Math.random()-0.5)*2, vy: (Math.random()-0.5)*2, life: 10, color: e.color || '#fff' });
                            
                            if (e.isPlayer) {
                                // Hit another player
                                score += 10;
                                haptic('light');
                                // sounds disabled
                                Multiplayer.send({ type: 'hit', targetId: e.playerId, damage: p.damage });
                            } else {
                                // Hit enemy AI
                                seg.hp -= p.damage;
                                // sounds disabled
                            }
                            break outer;
                        }
                    }
                }
                
                if (p.life <= 0) projectiles.splice(i, 1);
            }
        }
        
        function fireGuns(time) {
            if (!isAiming) return;
            let fired = false;
            for (let i = 0; i < snake.length; i++) {
                const seg = snake[i], type = seg.type;
                if (time - seg.lastFired < type.fireRate) continue;
                seg.lastFired = time;
                const cx = seg.x * GRID + GRID/2, cy = seg.y * GRID + GRID/2;
                if (type.aoe) {
                    for (const e of enemies) {
                        for (const seg of e.segments) {
                            const sx = seg.x * GRID + GRID/2, sy = seg.y * GRID + GRID/2;
                            const dist = Math.sqrt((sx - cx)**2 + (sy - cy)**2);
                            if (dist < type.range) seg.hp -= type.damage;
                        }
                    }
                    particles.push({ x: cx, y: cy, vx: 0, vy: 0, life: 15, color: type.color, isAoe: true, radius: 10 });
                } else if (type.spread) {
                    for (let p = 0; p < type.pellets; p++) {
                        const spread = (Math.random() - 0.5) * type.spread * 2;
                        const angle = aimAngle + spread;
                        projectiles.push({ x: cx, y: cy, vx: Math.cos(angle)*6, vy: Math.sin(angle)*6, damage: type.damage, size: 3, color: type.color, life: 300 });
                    }
                } else {
                    const size = type.size || 4;
                    projectiles.push({ x: cx, y: cy, vx: Math.cos(aimAngle)*7, vy: Math.sin(aimAngle)*7, damage: type.damage, size, color: type.color, life: 400 });
                }
                fired = true;
            }
            
        }
        
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx; p.y += p.vy; p.vx *= 0.92; p.vy *= 0.92; p.life--;
                if (p.isAoe) p.radius += 5;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }
        
        function drawLeaderArrow() {
            if (!snake[0]) return;
            
            // Find the biggest snake (not us)
            let leader = null;
            let maxLen = snake.length;
            
            // Check AI enemies
            for (const e of enemies) {
                if (e.segments && e.segments.length > maxLen) {
                    maxLen = e.segments.length;
                    leader = { x: e.segments[0].x, y: e.segments[0].y, name: 'ALPHA', len: e.segments.length, color: e.color };
                }
            }
            
            // Check other players
            if (Multiplayer.connected) {
                for (const [pid, op] of Multiplayer.otherPlayers) {
                    if (op.segments && op.segments.length > maxLen) {
                        maxLen = op.segments.length;
                        leader = { x: op.segments[0].x, y: op.segments[0].y, name: op.name, len: op.segments.length, color: op.color };
                    }
                }
            }
            
            if (!leader) return; // We're the biggest!
            
            // Calculate angle from player to leader
            const px = snake[0].x * GRID + GRID/2;
            const py = snake[0].y * GRID + GRID/2;
            const lx = leader.x * GRID + GRID/2;
            const ly = leader.y * GRID + GRID/2;
            const angle = Math.atan2(ly - py, lx - px);
            const dist = Math.sqrt((lx-px)**2 + (ly-py)**2);
            
            // Only show if leader is off-screen (far away)
            if (dist < 300) return;
            
            // Draw arrow at edge of view pointing to leader
            const arrowDist = 120;
            const ax = px + Math.cos(angle) * arrowDist;
            const ay = py + Math.sin(angle) * arrowDist;
            
            ctx.save();
            ctx.translate(ax, ay);
            ctx.rotate(angle);
            
            // Pulsing glow
            const pulse = 0.7 + Math.sin(Date.now() / 200) * 0.3;
            ctx.globalAlpha = pulse;
            
            // Arrow shape
            ctx.fillStyle = '#ff0';
            ctx.beginPath();
            ctx.moveTo(15, 0);
            ctx.lineTo(-8, -10);
            ctx.lineTo(-8, 10);
            ctx.closePath();
            ctx.fill();
            
            // Crown icon
            ctx.fillStyle = '#ff0';
            ctx.font = '10px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText('üëë', -20, 4);
            
            ctx.restore();
            
            // Show leader name + length near arrow
            ctx.save();
            ctx.fillStyle = '#ff0';
            ctx.font = '6px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.globalAlpha = pulse;
            ctx.fillText(leader.name + ' (' + leader.len + ')', ax, ay + 20);
            ctx.restore();
        }
        
        function updateWaves(time, dt) {
            if (waveDelay > 0) { waveDelay -= dt; return; }
            
            // Update power-up timers
            if (invincibleTimer > 0) invincibleTimer -= dt;
            if (speedTimer > 0) speedTimer -= dt;
            if (magnetTimer > 0) magnetTimer -= dt;
            
            // Magnet effect - pull pickups toward player
            if (magnetTimer > 0 && snake.length > 0) {
                const head = snake[0];
                const hx = head.x * GRID + GRID/2;
                const hy = head.y * GRID + GRID/2;
                for (const p of pickups) {
                    const dx = hx - p.x;
                    const dy = hy - p.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 200 && dist > 5) { // Pull range
                        const pull = 3; // Pull strength
                        p.x += (dx / dist) * pull;
                        p.y += (dy / dist) * pull;
                    }
                }
            }
            
            // Maintain population - slither.io style continuous spawning
            const targetPopulation = 80 + Math.floor(snake.length / 2); // More enemies as player grows
            const spawnRate = 1000; // Spawn every second if needed
            
            // Spawn new snakes to maintain population
            if (enemies.length < targetPopulation && time - spawnTimer > spawnRate) {
                // Spawn size varies - some small, some medium, occasionally big
                const sizes = [2, 2, 2, 3, 3, 3, 4, 4, 5, 6, 7, 8];
                const size = sizes[Math.floor(Math.random() * sizes.length)];
                spawnEnemy();
                spawnTimer = time;
            }
            
            // Spawn pickups to keep the world interesting
            if (pickups.length < 120 && Math.random() < 0.05) {
                const px = Math.floor(Math.random() * WORLD_COLS) * GRID + GRID/2;
                const py = Math.floor(Math.random() * WORLD_ROWS) * GRID + GRID/2;
                pickups.push({
                    x: px, y: py,
                    type: GUNS[GUN_NAMES[Math.floor(Math.random() * GUN_NAMES.length)]],
                    isHealth: Math.random() < 0.1,
                    healAmount: 40,
                    bob: Math.random() * Math.PI * 2
                });
            }
            
            // Difficulty scales with player size
            wave = 3 + Math.floor(snake.length / 4);
        }
        
        function updateCamera() {
            const head = snake[0];
            targetCameraX = head.x * GRID + GRID/2 - canvas.width/2/cameraZoom;
            targetCameraY = head.y * GRID + GRID/2 - canvas.height/2/cameraZoom;
            // Start zoomed in, zoom out SLOWLY as train grows
            const minZoom = 0.6, maxZoom = 2.0, zoomPerSegment = 0.025;
            targetZoom = Math.max(minZoom, maxZoom - (snake.length - 2) * zoomPerSegment);
            cameraX += (targetCameraX - cameraX) * 0.1;
            cameraY += (targetCameraY - cameraY) * 0.1;
            cameraZoom += (targetZoom - cameraZoom) * 0.02; // Slower zoom transition
            const viewWidth = canvas.width / cameraZoom, viewHeight = canvas.height / cameraZoom;
            cameraX = Math.max(0, Math.min(WORLD_WIDTH - viewWidth, cameraX));
            cameraY = Math.max(0, Math.min(WORLD_HEIGHT - viewHeight, cameraY));
        }
        
        function updateLeaderboard() {
            const entries = [{ name: playerName || 'YOU', length: snake.length, isPlayer: true }];
            
            // Add other multiplayer players
            if (Multiplayer.connected) {
                for (const [pid, op] of Multiplayer.otherPlayers) {
                    if (op.segments && op.segments.length > 0) {
                        entries.push({ 
                            name: op.name || 'Player', 
                            length: op.segments.length, 
                            isPlayer: false, 
                            isMultiplayer: true,
                            color: op.color 
                        });
                    }
                }
            }
            
            // Add AI enemies
            for (const e of enemies) {
                if (e.segments.length > 0) {
                    let typeName;
                    if (e.segments.length >= 10) typeName = 'ALPHA';
                    else if (e.personality.neural) typeName = 'NEURAL';
                    else if (e.personality.aggression > 0.7) typeName = 'HUNTER';
                    else if (e.personality.greed > 0.7) typeName = 'COLLECTOR';
                    else if (e.personality.caution > 0.5) typeName = 'SURVIVOR';
                    else typeName = 'BERSERKER';
                    entries.push({ name: typeName, length: e.segments.length, isPlayer: false, color: e.color, isNeural: e.personality.neural });
                }
            }
            entries.sort((a, b) => b.length - a.length);
            const top = entries.slice(0, 12);
            document.getElementById('leaderboardEntries').innerHTML = top.map((e, i) => `<div class="leaderboard-entry ${e.isPlayer ? 'player' : ''} ${e.isNeural ? 'neural' : ''} ${e.isMultiplayer ? 'multiplayer' : ''}" style="${!e.isPlayer ? 'color:' + e.color : ''}"><span class="leaderboard-rank">${i + 1}.</span><span class="leaderboard-name">${e.name}</span><span class="leaderboard-score">${e.length}</span></div>`).join('');
        }
        
        function updateHUD() {
            document.getElementById('snakeLen').textContent = snake.length;
            // Calculate rank
            let rank = 1;
            for (const e of enemies) {
                if (e.segments && e.segments.length > snake.length) rank++;
            }
            document.getElementById('waveNum').textContent = '#' + rank;

            // Show active power-ups or score
            let powerupStatus = [];
            if (invincibleTimer > 0) powerupStatus.push('üõ°Ô∏è' + Math.ceil(invincibleTimer / 1000));
            if (speedTimer > 0) powerupStatus.push('üöÄ' + Math.ceil(speedTimer / 1000));
            if (magnetTimer > 0) powerupStatus.push('üß≤' + Math.ceil(magnetTimer / 1000));
            
            if (powerupStatus.length > 0) {
                document.getElementById('score').textContent = powerupStatus.join(' ');
            } else {
                document.getElementById('score').textContent = score;
            }

            // Pattern tracking display
            const stats = patternTracker.getStats();
            if (stats.totalTurns >= 5) {
                const arrow = stats.leftBias > 55 ? '‚Üê' : stats.leftBias < 45 ? '‚Üí' : '‚Üî';
                document.getElementById('patternHud').textContent = arrow + stats.leftBias + '%';
            } else {
                document.getElementById('patternHud').textContent = '...';
            }

            // Track best stats
            if (rank < bestRank) bestRank = rank;
            if (snake.length > maxLength) maxLength = snake.length;
        }
        
        function drawGrid() {
            ctx.strokeStyle = '#150d20'; ctx.lineWidth = 1;
            const startX = Math.floor(cameraX / GRID) * GRID, startY = Math.floor(cameraY / GRID) * GRID;
            const endX = Math.min(WORLD_WIDTH, cameraX + canvas.width/cameraZoom + GRID);
            const endY = Math.min(WORLD_HEIGHT, cameraY + canvas.height/cameraZoom + GRID);
            for (let x = startX; x <= endX; x += GRID) { ctx.beginPath(); ctx.moveTo(x, startY); ctx.lineTo(x, endY); ctx.stroke(); }
            for (let y = startY; y <= endY; y += GRID) { ctx.beginPath(); ctx.moveTo(startX, y); ctx.lineTo(endX, y); ctx.stroke(); }
            ctx.strokeStyle = '#402040'; ctx.lineWidth = 3; ctx.strokeRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);
        }
        
        function drawSnake() {
            // Update train frame for wheel animation
            trainFrame++;

            // Draw smoke behind everything
            drawSmoke(ctx);

            // Invincibility shield effect
            if (invincibleTimer > 0) {
                const head = snake[0];
                const hx = head.x * GRID + GRID/2, hy = head.y * GRID + GRID/2;
                const pulseSize = 25 + Math.sin(Date.now() / 100) * 5;
                const alpha = 0.3 + Math.sin(Date.now() / 150) * 0.2;
                ctx.strokeStyle = `rgba(100, 200, 255, ${alpha})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(hx, hy, pulseSize, 0, Math.PI * 2);
                ctx.stroke();
                ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.5})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(hx, hy, pulseSize - 5, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Get direction for each segment (use next segment or dir for head)
            function getSegDir(i) {
                if (i === 0) return dir;
                const curr = snake[i];
                const prev = snake[i - 1];
                const dx = prev.x - curr.x;
                const dy = prev.y - curr.y;
                if (dx > 0 || (dx < -1)) return DIR.RIGHT; // Handle wrap
                if (dx < 0 || (dx > 1)) return DIR.LEFT;
                if (dy > 0 || (dy < -1)) return DIR.DOWN;
                if (dy < 0 || (dy > 1)) return DIR.UP;
                return dir;
            }

            // Draw from back to front
            for (let i = snake.length - 1; i >= 0; i--) {
                const seg = snake[i];
                const x = seg.x * GRID + GRID/2, y = seg.y * GRID + GRID/2;
                const segDir = getSegDir(i);

                // Slight bounce based on frame
                const bounce = Math.sin(trainFrame * 0.3 + i * 0.5) * 1;
                const drawY = y + bounce;

                ctx.shadowColor = invincibleTimer > 0 ? '#5ff' : '#000';
                ctx.shadowBlur = invincibleTimer > 0 ? 15 : 5;

                if (i === 0) {
                    // LOCOMOTIVE HEAD
                    drawLocomotive(ctx, x, drawY, GRID, segDir, trainFrame);

                    // Spawn smoke occasionally
                    if (trainFrame % 8 === 0) {
                        spawnSmoke(x, drawY, segDir);
                    }
                } else {
                    // BOXCARS (gun cars)
                    drawBoxcar(ctx, x, drawY, GRID, segDir, seg.type, trainFrame, seg.hp, seg.maxHp);
                }

                ctx.shadowBlur = 0;

                // Health bar for damaged cars
                if (i > 0 && seg.hp < seg.maxHp) {
                    const bw = 16, bh = 3;
                    ctx.fillStyle = '#300';
                    ctx.fillRect(x - bw/2, y - GRID/2 - 10, bw, bh);
                    const pct = seg.hp / seg.maxHp;
                    ctx.fillStyle = pct > 0.5 ? '#0f0' : pct > 0.25 ? '#ff0' : '#f00';
                    ctx.fillRect(x - bw/2, y - GRID/2 - 10, bw * pct, bh);
                }
            }

            // Update smoke particles
            updateSmoke();

            // Draw player name tag above head
            if (snake.length > 0 && Multiplayer.username) {
                const head = snake[0];
                ctx.save();
                ctx.fillStyle = '#0f0';
                ctx.font = '8px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#000';
                ctx.shadowBlur = 3;
                ctx.fillText(Multiplayer.username, head.x * GRID + GRID/2, head.y * GRID - 8);
                ctx.restore();
            }
        }
        
        function drawAimLine() {
            const head = snake[0];
            const hx = head.x * GRID + GRID/2, hy = head.y * GRID + GRID/2;

            // Aim line is more visible when actively aiming (touch hold or mouse)
            const isActive = isHolding || isMouseAiming;
            ctx.strokeStyle = isActive ? '#0f0' : '#0f04';
            ctx.lineWidth = isActive ? 3 : 2;
            ctx.setLineDash(isActive ? [] : [8, 8]);
            ctx.beginPath();
            ctx.moveTo(hx, hy);
            ctx.lineTo(hx + Math.cos(aimAngle) * 100, hy + Math.sin(aimAngle) * 100);
            ctx.stroke();
            ctx.setLineDash([]);

            // Reticle at aim point
            if (isActive) {
                const rx = hx + Math.cos(aimAngle) * 80, ry = hy + Math.sin(aimAngle) * 80;
                ctx.strokeStyle = '#0f0';
                ctx.lineWidth = 2;
                // Crosshair
                ctx.beginPath();
                ctx.moveTo(rx - 10, ry); ctx.lineTo(rx - 4, ry);
                ctx.moveTo(rx + 4, ry); ctx.lineTo(rx + 10, ry);
                ctx.moveTo(rx, ry - 10); ctx.lineTo(rx, ry - 4);
                ctx.moveTo(rx, ry + 4); ctx.lineTo(rx, ry + 10);
                ctx.stroke();
                // Circle
                ctx.beginPath();
                ctx.arc(rx, ry, 12, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        
        // Enemy train colors based on type
        const ENEMY_PALETTES = {
            normal: { body: '#4a5568', light: '#718096', dark: '#2d3748' },
            hunter: { body: '#9b2c2c', light: '#e53e3e', dark: '#742a2a' },
            alpha: { body: '#d69e2e', light: '#ecc94b', dark: '#b7791f' },
            neural: { body: '#805ad5', light: '#b794f4', dark: '#553c9a' }
        };

        function drawEnemyLocomotive(ctx, x, y, size, direction, frame, color, isNeural) {
            // CHUNKY SIMPLE ENEMY TRAIN - same style as player
            const palette = isNeural ? ENEMY_PALETTES.neural :
                           color === '#f55' ? ENEMY_PALETTES.hunter :
                           color === '#ff0' ? ENEMY_PALETTES.alpha : ENEMY_PALETTES.normal;

            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(Math.atan2(direction.y, direction.x));

            const s = size * 0.5;

            // Main body - colored block
            ctx.fillStyle = palette.body;
            ctx.fillRect(-s, -s*0.7, s*1.8, s*1.4);

            // Cabin (taller back section)
            ctx.fillStyle = palette.light;
            ctx.fillRect(-s*1.1, -s, s*0.5, s*2);

            // Smokestack
            ctx.fillStyle = palette.dark;
            ctx.fillRect(s*0.2, -s*1.2, s*0.4, s*0.5);

            // Headlight - enemy = red/magenta
            ctx.fillStyle = isNeural ? '#f0f' : '#f44';
            ctx.fillRect(s*0.7, -s*0.2, s*0.3, s*0.4);

            // Front
            ctx.fillStyle = palette.dark;
            ctx.fillRect(s*0.8, -s*0.5, s*0.3, s*1);

            // Thick outline
            ctx.strokeStyle = palette.dark;
            ctx.lineWidth = 2;
            ctx.strokeRect(-s*1.1, -s, s*2.2, s*2);

            // Neural glow ring
            if (isNeural) {
                ctx.strokeStyle = '#f0f';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, s*1.3, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Wheels
            ctx.fillStyle = '#111';
            ctx.fillRect(-s*0.8, s*0.5, s*0.4, s*0.3);
            ctx.fillRect(s*0.2, s*0.5, s*0.4, s*0.3);
            ctx.fillRect(-s*0.8, -s*0.8, s*0.4, s*0.3);
            ctx.fillRect(s*0.2, -s*0.8, s*0.4, s*0.3);

            ctx.restore();
        }

        function drawEnemyBoxcar(ctx, x, y, size, direction, frame, color, hp, maxHp) {
            // CHUNKY SIMPLE - matches player boxcar style
            const isHunter = color === '#f55';
            const isAlpha = color === '#ff0';
            const palette = isHunter ? ENEMY_PALETTES.hunter :
                           isAlpha ? ENEMY_PALETTES.alpha : ENEMY_PALETTES.normal;

            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(Math.atan2(direction.y, direction.x));

            const s = size * 0.5;

            // Damage flash
            let bodyColor = palette.body;
            if (hp < maxHp * 0.25 && Math.sin(frame * 0.5) > 0) bodyColor = '#600';
            else if (hp < maxHp * 0.5 && Math.sin(frame * 0.3) > 0.5) bodyColor = '#880';

            // Simple boxcar rectangle
            ctx.fillStyle = bodyColor;
            ctx.fillRect(-s*0.8, -s*0.6, s*1.6, s*1.2);

            // Thick outline
            ctx.strokeStyle = palette.dark;
            ctx.lineWidth = 2;
            ctx.strokeRect(-s*0.8, -s*0.6, s*1.6, s*1.2);

            // Wheels
            ctx.fillStyle = '#111';
            ctx.fillRect(-s*0.6, s*0.4, s*0.3, s*0.25);
            ctx.fillRect(s*0.3, s*0.4, s*0.3, s*0.25);
            ctx.fillRect(-s*0.6, -s*0.65, s*0.3, s*0.25);
            ctx.fillRect(s*0.3, -s*0.65, s*0.3, s*0.25);

            ctx.restore();
        }

        function drawEnemies() {
            for (const e of enemies) {
                if (e.segments.length === 0) continue;

                // Aim line
                if (e.aimX !== undefined) {
                    ctx.strokeStyle = e.color + '44'; ctx.lineWidth = 2; ctx.setLineDash([4, 4]);
                    ctx.beginPath(); ctx.moveTo(e.aimX, e.aimY); ctx.lineTo(e.aimX + Math.cos(e.aimAngle) * 80, e.aimY + Math.sin(e.aimAngle) * 80); ctx.stroke();
                    ctx.setLineDash([]);
                }

                // Get direction for each segment
                function getEnemySegDir(i) {
                    if (i === 0) return e.dir;
                    const curr = e.segments[i];
                    const prev = e.segments[i - 1];
                    const dx = prev.x - curr.x;
                    const dy = prev.y - curr.y;
                    if (dx > 0 || dx < -1) return DIR.RIGHT;
                    if (dx < 0 || dx > 1) return DIR.LEFT;
                    if (dy > 0 || dy < -1) return DIR.DOWN;
                    if (dy < 0 || dy > 1) return DIR.UP;
                    return e.dir;
                }

                // Draw from back to front
                for (let i = e.segments.length - 1; i >= 0; i--) {
                    const seg = e.segments[i];
                    const x = seg.x * GRID + GRID/2, y = seg.y * GRID + GRID/2;
                    const segDir = getEnemySegDir(i);

                    // Slight bounce
                    const bounce = Math.sin(trainFrame * 0.3 + i * 0.5) * 1;
                    const drawY = y + bounce;

                    ctx.shadowColor = e.color;
                    ctx.shadowBlur = 5;

                    if (i === 0) {
                        // LOCOMOTIVE
                        drawEnemyLocomotive(ctx, x, drawY, GRID, segDir, trainFrame, e.color, e.personality.neural);
                    } else {
                        // BOXCAR
                        drawEnemyBoxcar(ctx, x, drawY, GRID, segDir, trainFrame, e.color, seg.hp, seg.maxHp);
                    }

                    ctx.shadowBlur = 0;

                    // Health bar
                    if (i > 0 && seg.hp < seg.maxHp) {
                        const bw = 10;
                        ctx.fillStyle = '#400';
                        ctx.fillRect(x - bw/2, y - GRID/2 - 8, bw, 2);
                        ctx.fillStyle = '#f44';
                        ctx.fillRect(x - bw/2, y - GRID/2 - 8, bw * (seg.hp / seg.maxHp), 2);
                    }
                }

                // Length indicator
                if (e.segments.length >= 3) {
                    const head = e.segments[0];
                    ctx.fillStyle = '#fff';
                    ctx.font = '8px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(e.segments.length.toString(), head.x * GRID + GRID/2, head.y * GRID - 12);
                }
            }
        }
        
        function drawProjectiles() {
            for (const p of projectiles) { ctx.shadowColor = p.color; ctx.shadowBlur = 8; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); }
            for (const p of enemyProjectiles) { ctx.shadowColor = p.color; ctx.shadowBlur = 10; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); }
            ctx.shadowBlur = 0;
        }
        
        function drawPickups(time) {
            for (const p of pickups) {
                const x = p.x, y = p.y + Math.sin(time / 150 + p.bob) * 3;
                ctx.shadowColor = p.type.color; ctx.shadowBlur = 15;
                
                if (p.isPowerup) {
                    // Power-ups: big pulsing icon with glow
                    const pulse = 1 + Math.sin(time / 100) * 0.2;
                    const radius = 14 * pulse;
                    
                    // Outer glow ring
                    ctx.strokeStyle = p.type.color + '44';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(x, y, radius + 8, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Inner filled circle
                    ctx.fillStyle = p.type.color;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Icon text
                    ctx.fillStyle = '#000';
                    ctx.font = '12px "Press Start 2P"';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(p.type.icon, x, y);
                } else if (p.isHealth) {
                    ctx.fillStyle = p.type.color;
                    ctx.fillRect(x - 2, y - 6, 4, 12);
                    ctx.fillRect(x - 6, y - 2, 12, 4);
                } else {
                    ctx.strokeStyle = p.type.color + '66';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, 8 + Math.sin(time / 200 + p.bob) * 2, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.fillStyle = p.type.color;
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.shadowBlur = 0;
            }
        }
        
        function drawParticles() {
            for (const p of particles) {
                if (p.isAoe) {
                    const alpha = Math.floor((p.life / 15) * 200).toString(16).padStart(2, '0');
                    ctx.strokeStyle = p.color + alpha; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); ctx.stroke();
                } else { ctx.globalAlpha = p.life / 30; ctx.fillStyle = p.color; ctx.fillRect(p.x - 2, p.y - 2, 4, 4); ctx.globalAlpha = 1; }
            }
        }
        
        function drawScanlines() { ctx.fillStyle = '#0002'; for (let y = 0; y < canvas.height; y += 4) ctx.fillRect(0, y, canvas.width, 2); }

        function drawFogOfWar() {
            const head = snake[0];
            if (!head) return;

            // Player position in screen space
            const px = (head.x * GRID + GRID/2 - cameraX) * cameraZoom;
            const py = (head.y * GRID + GRID/2 - cameraY) * cameraZoom;

            // Visibility radius scales with zoom
            const baseRadius = 250;
            const radius = baseRadius * cameraZoom;

            // Create radial gradient for fog
            const gradient = ctx.createRadialGradient(px, py, radius * 0.6, px, py, radius);
            gradient.addColorStop(0, 'rgba(10, 6, 16, 0)');
            gradient.addColorStop(0.7, 'rgba(10, 6, 16, 0.3)');
            gradient.addColorStop(1, 'rgba(10, 6, 16, 0.85)');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        function gameLoop(time) {
            try {
                const dt = time - lastTime; lastTime = time;
                ctx.fillStyle = '#0a0610'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                if (gameState === 'playing') {
                    moveTimer += dt;
                    let selfCollision = false;
                    if (moveTimer >= MOVE_INTERVAL) { selfCollision = updateSnake(); moveTimer = 0; }
                    if (selfCollision) {
                        console.log('RESPAWN: Self collision');
                        haptic('death');
                        respawn();
                    }
                    const gameOver = updateEnemies(dt);
                    if (gameOver || snake.length <= 1) {
                        console.log('RESPAWN:', deathReason || 'Destroyed');
                        haptic('death');
                        respawn();
                    }
                    updateEnemyProjectiles(dt); updateProjectiles(dt); fireGuns(time); updateParticles();
                    updateWaves(time, dt); updateCamera(); updateHUD(); updateLeaderboard();
                    ruleEngine.update(); // G√∂del layer tick
                }
                
                ctx.save(); ctx.scale(cameraZoom, cameraZoom); ctx.translate(-cameraX, -cameraY);
                drawGrid(); drawPickups(time); drawEnemies(); Multiplayer.drawOtherPlayers(ctx); drawSnake(); drawAimLine(); drawProjectiles(); drawParticles(); drawLeaderArrow();
                ctx.restore(); drawScanlines(); drawPatternFlash(ctx);
            } catch (err) { console.error('Game loop error:', err); }
            requestAnimationFrame(gameLoop);
        }
        
        // Controls
        let activeTouch = null, touchStartX = 0, touchStartY = 0, lastSwipeX = 0, lastSwipeY = 0, isHolding = false, holdStartTime = 0;
        const SWIPE_THRESHOLD = 30, HOLD_DELAY = 150;
        
        function setDirection(newDir) {
            if (newDir === DIR.UP && dir === DIR.DOWN) return;
            if (newDir === DIR.DOWN && dir === DIR.UP) return;
            if (newDir === DIR.LEFT && dir === DIR.RIGHT) return;
            if (newDir === DIR.RIGHT && dir === DIR.LEFT) return;

            // Track pattern: find nearest threat distance
            let nearestThreat = 999;
            if (snake.length > 0) {
                const head = snake[0];
                for (const e of enemies) {
                    if (e.segments && e.segments.length > 0) {
                        const eh = e.segments[0];
                        const dist = Math.abs(eh.x - head.x) + Math.abs(eh.y - head.y);
                        if (dist < nearestThreat) nearestThreat = dist;
                    }
                }
            }
            patternTracker.recordTurn(dir, newDir, nearestThreat);

            nextDir = newDir;
            if (!isHolding) {
                if (newDir === DIR.UP) aimAngle = -Math.PI / 2;
                else if (newDir === DIR.DOWN) aimAngle = Math.PI / 2;
                else if (newDir === DIR.LEFT) aimAngle = Math.PI;
                else if (newDir === DIR.RIGHT) aimAngle = 0;
            }
            haptic('light');
        }
        
        document.addEventListener('touchstart', e => {
            if (gameState !== 'playing') return;
            e.preventDefault();
            const touch = e.changedTouches[0];
            activeTouch = touch.identifier; touchStartX = touch.clientX; touchStartY = touch.clientY;
            lastSwipeX = touch.clientX; lastSwipeY = touch.clientY;
            isHolding = false; holdStartTime = Date.now();
        }, { passive: false });
        
        document.addEventListener('touchmove', e => {
            if (gameState !== 'playing') return;
            e.preventDefault();
            for (const touch of e.changedTouches) {
                if (touch.identifier === activeTouch) {
                    const dx = touch.clientX - lastSwipeX, dy = touch.clientY - lastSwipeY;
                    const totalDx = touch.clientX - touchStartX, totalDy = touch.clientY - touchStartY;
                    const totalDist = Math.sqrt(totalDx * totalDx + totalDy * totalDy);
                    if (!isHolding && (Math.abs(dx) > SWIPE_THRESHOLD || Math.abs(dy) > SWIPE_THRESHOLD)) {
                        if (Math.abs(dx) > Math.abs(dy)) setDirection(dx > 0 ? DIR.RIGHT : DIR.LEFT);
                        else setDirection(dy > 0 ? DIR.DOWN : DIR.UP);
                        lastSwipeX = touch.clientX; lastSwipeY = touch.clientY;
                    }
                    if (Date.now() - holdStartTime > HOLD_DELAY && totalDist > 20) {
                        isHolding = true; isAiming = true;
                        aimAngle = Math.atan2(totalDy, totalDx);
                    }
                }
            }
        }, { passive: false });
        
        document.addEventListener('touchend', e => {
            for (const touch of e.changedTouches) {
                if (touch.identifier === activeTouch) {
                    activeTouch = null; isHolding = false;
                    if (dir === DIR.UP) aimAngle = -Math.PI / 2;
                    else if (dir === DIR.DOWN) aimAngle = Math.PI / 2;
                    else if (dir === DIR.LEFT) aimAngle = Math.PI;
                    else if (dir === DIR.RIGHT) aimAngle = 0;
                }
            }
        }, { passive: true });
        
        document.addEventListener('touchcancel', e => { activeTouch = null; isHolding = false; }, { passive: true });
        
        function updateAimAngle(touchX, touchY) {
            const head = snake[0];
            const hx = head.x * GRID + GRID/2, hy = head.y * GRID + GRID/2;
            aimAngle = Math.atan2(touchY - hy, touchX - hx);
        }
        
        // Initialize username inputs with saved value
        const savedName = localStorage.getItem('locomot_username') || '';
        document.getElementById('usernameInput').value = savedName;
        document.getElementById('usernameInputDeath').value = savedName;

        document.getElementById('startBtn').addEventListener('click', () => {
            const nameInput = document.getElementById('usernameInput').value;
            if (nameInput) Multiplayer.setUsername(nameInput);
            document.getElementById('startScreen').classList.add('hidden');
            init();
            gameState = 'playing';
            canvas.classList.add('playing');
        });

        document.getElementById('usernameInputDeath').addEventListener('change', (e) => {
            if (e.target.value) Multiplayer.setUsername(e.target.value);
        });
        document.getElementById('pauseBtn').addEventListener('click', () => { if (gameState === 'playing') { gameState = 'paused'; canvas.classList.remove('playing'); document.getElementById('pauseScreen').classList.remove('hidden'); } });
        
        document.getElementById('debugBtn').addEventListener('click', () => {
            const debugInfo = {
                gameState,
                invincibleTimer,
                snakeLength: snake.length,
                snakeSegments: snake.map((s, i) => ({ index: i, x: s.x, y: s.y, hp: s.hp, maxHp: s.maxHp, type: s.type?.color })),
                nearbyEnemies: enemies.filter(e => {
                    if (!e.segments || e.segments.length === 0) return false;
                    const head = e.segments[0];
                    const dist = Math.abs(head.x - snake[0].x) + Math.abs(head.y - snake[0].y);
                    return dist < 15;
                }).map(e => ({
                    length: e.segments.length,
                    headPos: { x: e.segments[0].x, y: e.segments[0].y },
                    distToPlayer: Math.abs(e.segments[0].x - snake[0].x) + Math.abs(e.segments[0].y - snake[0].y),
                    color: e.color
                })),
                totalEnemies: enemies.length,
                projectilesNearby: enemyProjectiles.filter(p => {
                    const dist = Math.sqrt((p.x - snake[0].x * GRID) ** 2 + (p.y - snake[0].y * GRID) ** 2);
                    return dist < 200;
                }).length
            };
            const debugText = JSON.stringify(debugInfo, null, 2);
            navigator.clipboard.writeText(debugText).then(() => {
                alert('Debug info copied to clipboard!');
            }).catch(() => {
                console.log('DEBUG INFO:', debugText);
                alert('Check console for debug info');
            });
        });
        document.getElementById('resumeBtn').addEventListener('click', () => { document.getElementById('pauseScreen').classList.add('hidden'); gameState = 'playing'; canvas.classList.add('playing'); });
        document.getElementById('restartBtn').addEventListener('click', () => { doRespawn(); });
        
        document.getElementById('copyDeathBtn').addEventListener('click', () => {
            // Compact debug format
            const mp = Multiplayer;
            const ops = [];
            if (mp.connected) {
                for (const [id, p] of mp.otherPlayers) {
                    ops.push(p.name + ':' + (p.segments?.length || 0) + '@' + (p.segments?.[0]?.x || '?') + ',' + (p.segments?.[0]?.y || '?'));
                }
            }
            const compact = [
                'reason:' + (deathReason || '?'),
                'me:' + snake.length + '@' + (snake[0]?.x || '?') + ',' + (snake[0]?.y || '?'),
                'mp:' + (mp.connected ? 'Y' : 'N') + '/' + mp.otherPlayers.size + 'p',
                'players:[' + ops.join('|') + ']'
            ].join(' | ');
            
            navigator.clipboard.writeText(compact).then(() => {
                document.getElementById('copyDeathBtn').textContent = '‚úì COPIED!';
                setTimeout(() => {
                    document.getElementById('copyDeathBtn').textContent = 'üìã COPY DEBUG';
                }, 2000);
            }).catch(() => {
                alert(compact);
            });
        });
        
        document.getElementById('uploadCollectiveBtn').addEventListener('click', () => {
            const btn = document.getElementById('uploadCollectiveBtn');
            const originalText = btn.textContent;
            btn.textContent = '‚è≥ UPLOADING...';
            btn.disabled = true;
            
            // Gather training data
            const trainingData = {
                rules: ruleEngine.rules,
                patterns: patternTracker.getStats(),
                deathInfo: deathDebugInfo,
                timestamp: Date.now(),
                version: '1.0'
            };
            
            // Upload to Partykit server (or could be a separate endpoint)
            fetch('https://locomot-io.savecharlie.partykit.dev/party/collective', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ type: 'upload_training', data: trainingData })
            })
            .then(res => {
                if (res.ok) {
                    btn.textContent = '‚úÖ UPLOADED!';
                    btn.style.background = '#0f0';
                    haptic('heavy');
                } else {
                    throw new Error('Upload failed');
                }
            })
            .catch(err => {
                console.error('Upload error:', err);
                btn.textContent = '‚ùå FAILED';
                btn.style.background = '#f00';
            })
            .finally(() => {
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '#0a6';
                    btn.disabled = false;
                }, 3000);
            });
        });
        
        document.addEventListener('keydown', e => {
            if (gameState !== 'playing') return;
            // Queue direction changes for responsive controls
            let newDir = null;
            if (e.code === 'ArrowUp' || e.code === 'KeyW') newDir = DIR.UP;
            else if (e.code === 'ArrowDown' || e.code === 'KeyS') newDir = DIR.DOWN;
            else if (e.code === 'ArrowLeft' || e.code === 'KeyA') newDir = DIR.LEFT;
            else if (e.code === 'ArrowRight' || e.code === 'KeyD') newDir = DIR.RIGHT;

            if (newDir && dirQueue.length < 3) {
                const lastDir = dirQueue.length > 0 ? dirQueue[dirQueue.length - 1] : dir;
                // Prevent 180 degree turns
                if (!(lastDir.x === -newDir.x && lastDir.y === -newDir.y)) {
                    dirQueue.push(newDir);
                }
            }
            else if (e.code === 'Space') { gameState = 'paused'; canvas.classList.remove('playing'); document.getElementById('pauseScreen').classList.remove('hidden'); }
        });
        
        // Desktop mouse aiming - continuous tracking
        document.addEventListener('mousemove', e => {
            if (gameState !== 'playing') return;
            mouseX = e.clientX;
            mouseY = e.clientY;
            isMouseAiming = true;
            // Update aim angle to point at mouse cursor
            const head = snake[0];
            if (head) {
                const hx = head.x * GRID + GRID/2 - cameraX;
                const hy = head.y * GRID + GRID/2 - cameraY;
                aimAngle = Math.atan2(mouseY - hy, mouseX - hx);
            }
        });
        document.addEventListener('mouseleave', () => { isMouseAiming = false; });
        document.addEventListener('mouseenter', e => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            isMouseAiming = true;
        });
        
        patternTracker.load(); // Load saved patterns from localStorage
        init();
        requestAnimationFrame(gameLoop);

        // PWA: Register service worker for offline play
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('./sw.js')
                .then(reg => console.log('Offline mode enabled'))
                .catch(err => console.log('Offline mode unavailable'));
        }
    </script>
</body>
</html>
