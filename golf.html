<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Pixel Golf</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: monospace;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 16px;
        }
        h1 {
            color: #4ade80;
            font-size: 24px;
        }
        canvas {
            border: 2px solid #4ade80;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        .info {
            color: #888;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>Pixel Golf</h1>
        <canvas id="game"></canvas>
        <div class="info">Click and drag to shoot</div>
    </div>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        // 8x8 pixel grid, scaled up for visibility
        const GRID_SIZE = 8;
        const SCALE = 8;  // Each pixel = 8 screen pixels
        const CANVAS_WIDTH = 20;  // 20 grid cells wide
        const CANVAS_HEIGHT = 15; // 15 grid cells tall

        canvas.width = CANVAS_WIDTH * GRID_SIZE * SCALE;
        canvas.height = CANVAS_HEIGHT * GRID_SIZE * SCALE;
        ctx.imageSmoothingEnabled = false;

        // Colors
        const GRASS_GREEN = '#22c55e';
        const DARK_GREEN = '#16a34a';
        const HOLE_BLACK = '#000000';
        const FLAG_RED = '#ef4444';
        const FLAG_POLE = '#000000';
        const BALL_WHITE = '#f5f5f5';
        const BALL_SHADOW = '#d4d4d4';

        // Game state
        const state = {
            ball: { x: 3, y: 10 },  // Grid position
            hole: { x: 16, y: 4 },   // Grid position
            velocity: { x: 0, y: 0 },
            dragging: false,
            dragStart: null,
            strokes: 0,
            inHole: false
        };

        // Draw an 8x8 sprite at grid position
        function drawSprite(sprite, gridX, gridY) {
            for (let y = 0; y < 8; y++) {
                for (let x = 0; x < 8; x++) {
                    const color = sprite[y * 8 + x];
                    if (color) {
                        ctx.fillStyle = color;
                        ctx.fillRect(
                            (gridX * GRID_SIZE + x) * SCALE,
                            (gridY * GRID_SIZE + y) * SCALE,
                            SCALE, SCALE
                        );
                    }
                }
            }
        }

        // Ball sprite (8x8)
        const ballSprite = [
            0,0,0,'#ddd','#ddd',0,0,0,
            0,0,'#fff','#fff','#fff','#ddd',0,0,
            0,'#fff','#fff','#fff','#fff','#fff','#ddd',0,
            '#fff','#fff','#fff','#fff','#fff','#fff','#ddd','#bbb',
            '#fff','#fff','#fff','#fff','#fff','#fff','#ddd','#bbb',
            0,'#fff','#fff','#fff','#fff','#ddd','#bbb',0,
            0,0,'#ddd','#ddd','#ddd','#bbb',0,0,
            0,0,0,'#bbb','#bbb',0,0,0,
        ];

        // Flag sprite (8x8)
        const flagSprite = [
            0,0,'#ef4444','#ef4444','#ef4444',0,0,0,
            0,0,'#ef4444','#ef4444','#ef4444',0,0,0,
            0,0,'#ef4444','#ef4444',0,0,0,0,
            0,0,'#000',0,0,0,0,0,
            0,0,'#000',0,0,0,0,0,
            0,0,'#000',0,0,0,0,0,
            0,0,'#000',0,0,0,0,0,
            0,'#000','#000','#000',0,0,0,0,
        ];

        // Hole sprite (8x8)
        const holeSprite = [
            0,0,0,0,0,0,0,0,
            0,0,'#111','#111','#111','#111',0,0,
            0,'#111','#000','#000','#000','#000','#111',0,
            0,'#111','#000','#000','#000','#000','#111',0,
            0,'#111','#000','#000','#000','#000','#111',0,
            0,'#111','#000','#000','#000','#000','#111',0,
            0,0,'#111','#111','#111','#111',0,0,
            0,0,0,0,0,0,0,0,
        ];

        function draw() {
            // Clear
            ctx.fillStyle = GRASS_GREEN;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grass texture (darker squares randomly)
            for (let y = 0; y < CANVAS_HEIGHT; y++) {
                for (let x = 0; x < CANVAS_WIDTH; x++) {
                    if (Math.random() < 0.1) {
                        ctx.fillStyle = DARK_GREEN;
                        ctx.fillRect(
                            x * GRID_SIZE * SCALE + Math.floor(Math.random() * GRID_SIZE) * SCALE,
                            y * GRID_SIZE * SCALE + Math.floor(Math.random() * GRID_SIZE) * SCALE,
                            SCALE, SCALE
                        );
                    }
                }
            }

            // Draw hole
            drawSprite(holeSprite, state.hole.x, state.hole.y);

            // Draw flag (offset up from hole)
            drawSprite(flagSprite, state.hole.x, state.hole.y - 1);

            // Draw ball (if not in hole)
            if (!state.inHole) {
                drawSprite(ballSprite, Math.floor(state.ball.x), Math.floor(state.ball.y));
            }

            // Draw drag line
            if (state.dragging && state.dragStart) {
                const ballCenterX = (state.ball.x * GRID_SIZE + 4) * SCALE;
                const ballCenterY = (state.ball.y * GRID_SIZE + 4) * SCALE;
                ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(ballCenterX, ballCenterY);
                ctx.lineTo(state.dragStart.x, state.dragStart.y);
                ctx.stroke();
            }

            // Draw strokes
            ctx.fillStyle = '#fff';
            ctx.font = '16px monospace';
            ctx.fillText(`Strokes: ${state.strokes}`, 10, 24);

            if (state.inHole) {
                ctx.fillStyle = '#4ade80';
                ctx.font = '32px monospace';
                ctx.fillText('IN THE HOLE!', canvas.width/2 - 100, canvas.height/2);
            }
        }

        function update() {
            if (state.inHole) return;

            // Apply velocity
            state.ball.x += state.velocity.x;
            state.ball.y += state.velocity.y;

            // Friction
            state.velocity.x *= 0.98;
            state.velocity.y *= 0.98;

            // Stop if slow enough
            if (Math.abs(state.velocity.x) < 0.01 && Math.abs(state.velocity.y) < 0.01) {
                state.velocity.x = 0;
                state.velocity.y = 0;
            }

            // Bounds
            if (state.ball.x < 0) { state.ball.x = 0; state.velocity.x *= -0.5; }
            if (state.ball.x > CANVAS_WIDTH - 1) { state.ball.x = CANVAS_WIDTH - 1; state.velocity.x *= -0.5; }
            if (state.ball.y < 0) { state.ball.y = 0; state.velocity.y *= -0.5; }
            if (state.ball.y > CANVAS_HEIGHT - 1) { state.ball.y = CANVAS_HEIGHT - 1; state.velocity.y *= -0.5; }

            // Check hole
            const dx = state.ball.x - state.hole.x;
            const dy = state.ball.y - state.hole.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < 0.8 && Math.abs(state.velocity.x) < 0.3 && Math.abs(state.velocity.y) < 0.3) {
                state.inHole = true;
                state.ball.x = state.hole.x;
                state.ball.y = state.hole.y;
            }
        }

        // Input
        canvas.addEventListener('mousedown', (e) => {
            if (state.velocity.x !== 0 || state.velocity.y !== 0) return;
            if (state.inHole) return;
            state.dragging = true;
            state.dragStart = { x: e.offsetX, y: e.offsetY };
        });

        canvas.addEventListener('mousemove', (e) => {
            if (state.dragging) {
                state.dragStart = { x: e.offsetX, y: e.offsetY };
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (!state.dragging) return;
            state.dragging = false;

            const ballCenterX = (state.ball.x * GRID_SIZE + 4) * SCALE;
            const ballCenterY = (state.ball.y * GRID_SIZE + 4) * SCALE;

            // Velocity is opposite of drag direction
            const power = 0.02;
            state.velocity.x = (ballCenterX - e.offsetX) * power;
            state.velocity.y = (ballCenterY - e.offsetY) * power;

            state.strokes++;
            state.dragStart = null;
        });

        // Touch support
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            canvas.dispatchEvent(new MouseEvent('mousedown', {
                offsetX: touch.clientX - rect.left,
                offsetY: touch.clientY - rect.top
            }));
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            canvas.dispatchEvent(new MouseEvent('mousemove', {
                offsetX: touch.clientX - rect.left,
                offsetY: touch.clientY - rect.top
            }));
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            const rect = canvas.getBoundingClientRect();
            canvas.dispatchEvent(new MouseEvent('mouseup', {
                offsetX: touch.clientX - rect.left,
                offsetY: touch.clientY - rect.top
            }));
        });

        // Game loop
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>
