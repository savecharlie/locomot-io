<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="description" content="Interactive neural network pathfinding demonstration">
    <link rel="manifest" href="manifest.json">
    <title>LOCOMOT.IO - Neural Train Pathfinding</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        html, body { width: 100%; height: 100%; overflow: hidden; touch-action: none; }
        body { background: #0a0610; font-family: 'Press Start 2P', monospace; display: flex; flex-direction: column; color: #fff; user-select: none; -webkit-user-select: none; }
        
        .leaderboard { position: absolute; top: 50px; right: 10px; background: rgba(10, 6, 16, 0.85); border: 1px solid #333; border-radius: 8px; padding: 10px; min-width: 120px; z-index: 20; pointer-events: none; }
        .leaderboard h3 { font-size: 8px; color: #888; margin-bottom: 8px; text-align: center; }
        .leaderboard-entry { display: flex; justify-content: space-between; align-items: center; font-size: 7px; padding: 3px 0; border-bottom: 1px solid #222; }
        .leaderboard-entry:last-child { border-bottom: none; }
        .leaderboard-entry.player { color: #0f0; }
        .leaderboard-entry.neural { color: #f0f; }
        .leaderboard-entry.mvp { background: rgba(255,255,0,0.2); border-left: 2px solid #ff0; }
        .leaderboard-rank { color: #666; width: 16px; }
        .leaderboard-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; margin: 0 6px; }
        .leaderboard-score { color: #ff0; }
        
        .hud { display: flex; justify-content: space-between; padding: 10px 16px; background: linear-gradient(to bottom, #0a0610, #0a061000); font-size: 14px; position: absolute; top: 0; left: 0; right: 0; z-index: 10; pointer-events: none; }
        .hud-item { display: flex; align-items: center; gap: 6px; text-shadow: 0 0 10px currentColor; }
        .len-color { color: #0f0; }
        .wave-color { color: #5ff; }
        .score-color { color: #ff5; }
        
        .game-container { flex: 1; position: relative; overflow: hidden; }
        #gameCanvas { display: block; width: 100%; height: 100%; cursor: crosshair; }
        #gameCanvas.playing { cursor: none; }
        .touch-indicator { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); font-size: 7px; color: #333; pointer-events: none; text-align: center; }
        
        .overlay { position: absolute; inset: 0; background: rgba(5, 3, 10, 0.92); display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 24px; text-align: center; z-index: 100; }
        .overlay.hidden { display: none; }
        .overlay h2 { font-size: 20px; margin-bottom: 20px; }
        .overlay p { font-size: 8px; color: #888; margin-bottom: 8px; line-height: 2; }
        .start-screen h2 {
            font-size: 28px;
            background: linear-gradient(180deg, #4f8, #0f0 40%, #0a0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: none;
            filter: drop-shadow(0 0 20px #0f08) drop-shadow(0 0 40px #0f04);
            animation: titlePulse 2s ease-in-out infinite;
        }
        @keyframes titlePulse {
            0%, 100% { filter: drop-shadow(0 0 20px #0f08) drop-shadow(0 0 40px #0f04); }
            50% { filter: drop-shadow(0 0 30px #0f0a) drop-shadow(0 0 60px #0f06); }
        }
        .start-screen .tagline { color: #d4a017; font-size: 9px; margin-bottom: 12px; }
        .start-screen .subtitle { color: #aaa; font-size: 8px; margin-bottom: 16px; }
        .start-screen .neural-badge {
            display: inline-block;
            background: linear-gradient(135deg, #808 0%, #f0f 50%, #808 100%);
            background-size: 200% 100%;
            animation: shimmer 2s linear infinite;
            color: #fff;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 8px;
            margin: 8px 0;
        }
        @keyframes shimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        .start-screen input {
            font-family: 'Press Start 2P';
            font-size: 10px;
            padding: 12px 16px;
            border: 2px solid #0f0;
            background: rgba(0, 50, 0, 0.3);
            color: #0f0;
            text-align: center;
            width: 220px;
            border-radius: 6px;
            outline: none;
            transition: all 0.2s;
        }
        .start-screen input:focus {
            border-color: #4f8;
            box-shadow: 0 0 20px #0f04, inset 0 0 10px #0f02;
        }
        .start-screen input::placeholder { color: #060; }
        .mode-buttons { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
        .mode-btn {
            font-family: 'Press Start 2P';
            font-size: 10px;
            padding: 14px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .mode-btn:hover { transform: translateY(-2px); filter: brightness(1.1); }
        .mode-btn:active { transform: translateY(0); }
        .mode-btn.ffa { background: linear-gradient(135deg, #600 0%, #c00 100%); color: #fff; box-shadow: 0 4px 20px #f004; }
        .mode-btn.teams { background: linear-gradient(135deg, #006 0%, #00c 100%); color: #fff; box-shadow: 0 4px 20px #00f4; }
        .game-links { display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; margin-top: 10px; }
        .game-link {
            font-family: 'Press Start 2P';
            font-size: 7px;
            padding: 8px 12px;
            background: linear-gradient(180deg, #2a2a2a, #1a1a1a);
            text-decoration: none;
            border-radius: 6px;
            border: 1px solid #333;
            transition: all 0.2s;
        }
        .game-link:hover { border-color: #555; transform: translateY(-1px); }
        .game-link.painter { color: #f5a; }
        .game-link.sandbox { color: #fa5; }
        .game-over-screen { justify-content: flex-start; overflow-y: auto; padding-top: 40px; padding-bottom: 40px; }
        .game-over-screen h2 { color: #f55; text-shadow: 0 0 30px #f558; }
        .pause-screen h2 { color: #5ff; text-shadow: 0 0 30px #5ff8; }
        .score-display { font-size: 14px; color: #ff5; margin: 20px 0; line-height: 2; }
        .start-btn { margin-top: 24px; padding: 18px 36px; font-family: 'Press Start 2P', monospace; font-size: 12px; background: #0f0; color: #000; border: none; border-radius: 8px; box-shadow: 0 0 30px #0f06; }
        .start-btn:active { background: #0c0; transform: scale(0.97); }
        .controls-help { display: flex; gap: 30px; margin-top: 24px; font-size: 7px; color: #666; }
        .control-item { text-align: center; }
        .control-item .icon { font-size: 20px; margin-bottom: 8px; color: #888; }
        .legend { display: flex; flex-wrap: wrap; justify-content: center; gap: 12px; margin-top: 16px; font-size: 6px; }
        .legend-item { display: flex; align-items: center; gap: 6px; color: #666; }
        .legend-color { width: 14px; height: 14px; border-radius: 4px; }
        .wave-announce { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 24px; color: #5ff; text-shadow: 0 0 30px #5ff; opacity: 0; z-index: 50; pointer-events: none; }
        .wave-announce.show { opacity: 1; }
        .kill-feed { position: absolute; bottom: 60px; left: 10px; font-size: 7px; z-index: 20; pointer-events: none; }
        .kill-feed-entry { background: rgba(0,0,0,0.7); padding: 4px 8px; margin: 2px 0; border-radius: 4px; opacity: 1; transition: opacity 0.5s; }
        .kill-feed-entry.fade { opacity: 0; }
        .invite-link { position: absolute; bottom: 10px; left: 10px; font-size: 6px; color: #666; z-index: 20; background: rgba(0,0,0,0.5); padding: 4px 8px; border-radius: 4px; }
        .invite-link span { color: #0f0; cursor: pointer; }
        
        
        .shake { animation: shake 0.3s ease-in-out; }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-10px) rotate(-1deg); } 75% { transform: translateX(10px) rotate(1deg); } }
        @keyframes fadeOut { 0% { opacity: 1; transform: translate(-50%, -50%) scale(1); } 100% { opacity: 0; transform: translate(-50%, -50%) scale(1.2); } }
    </style>
    <script src='https://storage.ko-fi.com/cdn/widget/Widget_2.js'></script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7560120281604459" crossorigin="anonymous"></script>
</head>
<body>
    <!-- Debug overlay - remove after fixing multiplayer -->
    <div id="mp-debug" style="position:fixed;top:5px;left:5px;background:rgba(0,0,0,0.8);color:#0f0;font-family:monospace;font-size:12px;padding:5px 10px;z-index:9999;pointer-events:none;"></div>
    <div class="hud">
        <div class="hud-item len-color"><span>‚óà</span><span id="snakeLen">2</span></div>
        <div class="hud-item wave-color"><span>‚óÜ</span><span>RANK <span id="waveNum">#?</span></span></div>
        <div class="hud-item score-color"><span>‚òÖ</span><span id="score">0</span></div>
        <div class="hud-item" style="color: #0fc;"><span>üëÅ</span><span id="patternHud">-</span></div>
    </div>
    
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        <div class="touch-indicator">MOBILE: SWIPE TO TURN ‚Ä¢ HOLD+DRAG TO AIM | DESKTOP: WASD/ARROWS ‚Ä¢ MOUSE TO AIM</div>
        <div class="leaderboard" id="leaderboard"><h3>üèÜ LEADERBOARD</h3><div id="leaderboardEntries"></div></div>
        <div class="wave-announce" id="waveAnnounce">WAVE 1</div>
        <div class="kill-feed" id="killFeed"></div>
        <div class="invite-link">INVITE: <span id="inviteLink" onclick="copyInvite()">loading...</span></div>
        
        
        <div class="overlay start-screen" id="startScreen">
            <div style="margin-bottom: 8px;">üöÇ</div>
            <h2>LOCOMOT.IO</h2>
            <p class="tagline">üî• All aboard the pain train üî•</p>
            <p class="subtitle">Build your train ‚Ä¢ Collect gun cars ‚Ä¢ Survive</p>
            <div class="neural-badge">üß† NEURAL NETWORK AI</div>
            <div style="margin: 20px 0;">
                <input type="text" id="usernameInput" placeholder="Enter your name..." maxlength="12">
            </div>
            <div class="controls-help">
                <div class="control-item"><div class="icon">üéÆ</div><div>WASD/ARROWS</div></div>
                <div class="control-item"><div class="icon">üñ±Ô∏è</div><div>MOUSE AIM</div></div>
                <div class="control-item"><div class="icon">üì±</div><div>SWIPE</div></div>
            </div>
            <div style="margin-top: 24px;">
                <div class="mode-buttons">
                    <button class="mode-btn ffa" id="startFFA">‚öîÔ∏è FREE FOR ALL</button>
                    <button class="mode-btn teams" id="startTeams">üë• TEAM BATTLE</button>
                </div>
            </div>
            <div style="margin-top: 20px; padding-top: 16px; border-top: 1px solid #222;">
                <div id="kofiWidgetContainerStart" style="display: flex; justify-content: center; margin-bottom: 12px;"></div>
                <script>kofiwidget2.init('Support me on Ko-fi', '#72a4f2', 'S6S21JNSQJ');kofiwidget2.draw();</script>
                <div class="game-links">
                    <a href="https://painter.locomot.io" target="_blank" class="game-link painter">üé® PAINTER</a>
                    <a href="https://sandbox.locomot.io" target="_blank" class="game-link sandbox">üèñÔ∏è SANDBOX</a>
                </div>
            </div>
        </div>
        
        <div class="overlay pause-screen hidden" id="pauseScreen">
            <h2>PAUSED</h2>
            <button class="start-btn" id="resumeBtn">RESUME</button>
        </div>
        
        <div class="overlay game-over-screen hidden" id="gameOverScreen">
            <div id="spectatingLabel" style="position:absolute; top:20px; left:50%; transform:translateX(-50%); color:#5ff; font-size:12px; text-shadow:0 0 10px #5ff; display:none;">SPECTATING LEADER</div>

            <h2 style="margin-bottom: 15px;">GAME OVER</h2>

            <!-- Score Summary -->
            <div style="display: flex; gap: 20px; justify-content: center; margin-bottom: 15px;">
                <div style="text-align: center;">
                    <div style="font-size: 24px; color: #ff0;">‚òÖ<span id="finalScore">0</span></div>
                    <div style="font-size: 6px; color: #888;">SCORE</div>
                </div>
                <div style="text-align: center;">
                    <div style="font-size: 24px; color: #0f0;"><span id="finalWave">#?</span></div>
                    <div style="font-size: 6px; color: #888;">RANK</div>
                </div>
                <div style="text-align: center;">
                    <div style="font-size: 24px; color: #5ff;">‚óà<span id="finalLength">2</span></div>
                    <div style="font-size: 6px; color: #888;">LENGTH</div>
                </div>
            </div>

            <!-- Death Cause -->
            <div style="font-size: 9px; color: #f55; margin-bottom: 15px; padding: 8px 16px; background: rgba(255,50,50,0.15); border-radius: 20px;">
                ‚ò† <span id="deathReasonText">Unknown</span>
            </div>

            <!-- Main Buttons -->
            <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                <button class="start-btn" id="restartBtn" style="flex: 1;">‚ñ∂ PLAY AGAIN</button>
                <button class="start-btn" id="spectateBtn" style="flex: 1; background: #155;">üëÅ SPECTATE</button>
            </div>

            <!-- Change Name -->
            <input type="text" id="usernameInputDeath" placeholder="Change name..." maxlength="12"
                style="font-family: 'Press Start 2P'; font-size: 7px; padding: 6px 12px; border: 1px solid #444; background: #1a1a1a; color: #888; text-align: center; width: 160px; border-radius: 4px; margin-bottom: 15px;">

            <!-- AI Learning Stats (compact) -->
            <details style="max-width: 280px; margin-bottom: 15px;">
                <summary style="font-size: 8px; color: #888; cursor: pointer; padding: 8px; background: #111; border-radius: 4px;">üß† AI LEARNED FROM YOUR DEATH</summary>
                <div style="padding: 10px; background: #0a0a0a; border-radius: 0 0 4px 4px; font-size: 7px;">
                    <div style="color: #0fc; margin-bottom: 8px;"><span style="color:#666;">Pattern:</span> <span id="patternStatsText">-</span></div>
                    <div style="color: #f5a; margin-bottom: 8px;"><span style="color:#666;">Strategy:</span> <span id="strategyStatsText">-</span></div>
                    <div style="color: #f0f;"><span style="color:#666;">Neural:</span> <span id="godelStatsText">-</span></div>
                </div>
            </details>

            <!-- Hidden stats for JS compatibility -->
            <div id="reputationStatsText" style="display:none;"></div>

            <!-- Support & Other Games -->
            <div style="padding-top: 15px; border-top: 1px solid #222;">
                <div id="kofiWidgetContainer" style="display: flex; justify-content: center; margin-bottom: 12px;"></div>
                <script>kofiwidget2.init('Support me on Ko-fi', '#72a4f2', 'S6S21JNSQJ');kofiwidget2.draw();</script>
                <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-top: 8px;">
                    <a href="https://painter.locomot.io" target="_blank"
                       style="font-family: 'Press Start 2P'; font-size: 10px; padding: 12px 18px; background: linear-gradient(180deg, #333, #222); color: #f5a; text-decoration: none; border-radius: 6px; border: 1px solid #444;">
                        üé® PAINTER
                    </a>
                    <a href="https://sandbox.locomot.io" target="_blank"
                       style="font-family: 'Press Start 2P'; font-size: 10px; padding: 12px 18px; background: linear-gradient(180deg, #333, #222); color: #fa5; text-decoration: none; border-radius: 6px; border: 1px solid #444;">
                        üèñÔ∏è SANDBOX
                    </a>
                </div>
                <button id="submitIdeaBtn" style="font-family: 'Press Start 2P'; font-size: 10px; padding: 12px 20px; background: linear-gradient(180deg, #f90, #d70); color: #fff; border: none; border-radius: 6px; margin-top: 12px; cursor: pointer; border: 1px solid #fa0;">
                    üí° SUBMIT IDEA
                </button>
            </div>

            <!-- Ad Space -->
            <div style="margin-top: 15px;">
                <ins class="adsbygoogle"
                     style="display:block; width:320px; height:100px;"
                     data-ad-client="ca-pub-7560120281604459"
                     data-ad-slot="auto"
                     data-ad-format="auto"
                     data-full-width-responsive="true"></ins>
                <script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
            </div>
        </div>
    </div>

    <script id="brainData" type="application/json">
{"input_size": 60, "net.0.weight": [[-0.25134652853012085, -0.37105792760849, 0.4278101921081543, -0.03749047964811325, 0.1908222734928131, -0.02111934870481491, 0.0770081877708435, -0.10370783507823944, -0.05290059372782707, 0.03329487144947052, 0.16976934671401978, 0.06365260481834412, 0.2927277088165283, -0.42264461517333984, -0.008145211264491081, -0.1292656809091568, 0.13170360028743744, 0.11515530198812485, 0.07118187099695206, -0.03819755092263222, 0.09767334163188934, -0.017082490026950836, -0.026807140558958054, -0.11352670192718506, 0.16056719422340393, -0.03233783692121506, -0.2787828743457794, 0.025431960821151733, 0.12528525292873383, 0.17042872309684753, 0.012621902860701084, -0.09534434229135513, 0.07983111590147018, 0.03822198510169983, -0.11107220500707626, -0.12267085909843445, 0.02905735932290554, -0.05460340157151222, -0.05874938517808914, 0.15321266651153564, -0.019101709127426147, 0.0902402475476265, -0.20274755358695984, -0.005696968641132116, 0.17105025053024292, -0.18215331435203552, 0.03680114820599556, -0.09638996422290802, 0.021115487441420555, -0.11624298244714737, 0.0361936129629612, 0.11892111599445343, 0.1833292692899704, 0.07651397585868835, -0.3848460912704468, -0.034516431391239166, -0.02844696305692196, -0.2882317900657654, -0.2165207862854004, 0.25300654768943787], [0.07777628302574158, 0.043933894485235214, 0.33871009945869446, 0.1396869271993637, 0.15287703275680542, 0.5154294967651367, 0.14456342160701752, -0.008351282216608524, -0.029726453125476837, 0.07357992976903915, 0.07231862097978592, -0.01802567020058632, 0.09771660715341568, 0.1344081312417984, 0.043464381247758865, 0.15926054120063782, -0.17666365206241608, -0.056136604398489, -0.10579168051481247, -0.09258735179901123, -0.2365766167640686, 0.23426871001720428, 0.3034501373767853, -0.046776339411735535, -0.12614551186561584, 0.11309977620840073, -0.10006928443908691, -0.02343546412885189, -0.14368650317192078, -0.023938285186886787, 0.1096068024635315, 0.03621961176395416, -0.09008163213729858, -0.035013195127248764, -0.12108961492776871, 0.13346923887729645, 0.18053746223449707, -0.18919479846954346, 0.06506756693124771, -0.01921343244612217, -0.07448453456163406, -0.09492003917694092, 0.1306139975786209, 0.2797161638736725, -0.0035666795447468758, 0.0010141240200027823, -0.09272554516792297, -0.12396324425935745, -0.18428906798362732, 0.0639905333518982, -0.03701261430978775, 0.058753617107868195, 0.07255516946315765, -0.11606330424547195, -0.08817440271377563, -0.0536675788462162, 0.22847050428390503, -0.15407896041870117, -0.36572128534317017, 0.031925804913043976], [0.2705806493759155, 0.2959009110927582, -0.2182021290063858, -0.13535209000110626, 0.06417598575353622, -0.22120670974254608, -0.15889005362987518, -0.04984176158905029, -0.1048140823841095, 0.20147889852523804, 0.16671748459339142, -0.0002727544924709946, -0.16020917892456055, 0.007897571660578251, -0.1794445514678955, -0.20878151059150696, 0.29001185297966003, 0.10659098625183105, 0.19191475212574005, 0.17927812039852142, 0.10708828270435333, -0.17758655548095703, -0.2057705819606781, 0.08653033524751663, 0.2346935123205185, -0.10737079381942749, 0.22330579161643982, 0.16979652643203735, -0.0004245203163009137, -0.03242424875497818, 0.1997857689857483, -0.13148747384548187, -0.1010032519698143, -0.07960908859968185, 0.031820543110370636, -0.03941921889781952, 0.05935673788189888, 0.011193571612238884, -0.04453645274043083, 0.12650837004184723, -0.10184424370527267, -0.1453886181116104, -0.13066384196281433, -0.023385239765048027, -0.19402679800987244, 0.09810248017311096, -0.09396015852689743, -0.09131834656000137, -0.2059560865163803, -0.03713544085621834, 0.07957618683576584, 0.06638181209564209, -0.2110407054424286, 0.24508023262023926, -0.23395168781280518, -0.2792079448699951, -0.0014214380644261837, 0.15056255459785461, 0.11051687598228455, -0.10557664930820465], [-0.050125185400247574, -0.5397311449050903, 0.38915708661079407, -0.6151847839355469, 0.027740323916077614, -0.048632439225912094, -0.08024909347295761, -0.009254980832338333, 0.10797491669654846, 0.14748960733413696, -0.1292690634727478, -0.025077369064092636, -0.14282745122909546, -0.16793332993984222, 0.19256384670734406, 0.40736091136932373, -0.15426355600357056, -0.09277843683958054, -0.09166338294744492, -0.267160564661026, -0.10976102948188782, -0.41235843300819397, -0.7004740238189697, -0.0034339986741542816, 0.012644520960748196, -0.17789044976234436, -0.09416094422340393, 0.10965655744075775, -0.08494731783866882, 0.04149909317493439, 0.18141211569309235, -0.014728998765349388, -0.12598979473114014, -0.0416325181722641, -0.15138275921344757, 0.044371072202920914, -0.04343435913324356, -0.025751328095793724, -0.08010073751211166, -0.044504258781671524, -0.18331024050712585, -0.08151039481163025, 0.05142394080758095, 0.12581214308738708, 0.07697737962007523, 0.003540675388649106, -0.05394760146737099, -0.027416827157139778, 0.05861146003007889, -0.005818908102810383, -0.013392149470746517, 0.11618588119745255, -0.20268522202968597, -0.023202339187264442, 0.0035520263481885195, -0.14805607497692108, 0.005308905616402626, -0.19527368247509003, -0.3204917013645172, 0.14788411557674408], [-0.13662560284137726, -0.16700559854507446, -0.24333003163337708, -0.023017114028334618, -0.07004189491271973, 0.30088478326797485, 0.26117759943008423, -0.1144355982542038, -0.3249657154083252, 0.013397988863289356, -0.026119038462638855, 0.19858436286449432, -0.12149814516305923, 0.06338950246572495, 0.0357278473675251, 0.024603035300970078, -0.12730158865451813, -0.04978371784090996, 0.11895198374986649, -0.22929799556732178, -0.28254449367523193, -0.2221110314130783, -0.45967820286750793, 0.018580984324216843, 0.024700893089175224, -0.026637021452188492, -0.06804778426885605, 0.06707008928060532, -0.1704763025045395, 0.003508983412757516, -0.11830713599920273, -0.04259521886706352, 0.03142644837498665, -0.035401515662670135, 0.044561948627233505, -0.19687248766422272, -0.00026500658714212477, -0.09000885486602783, -0.16400909423828125, 0.06213528290390968, 0.08324943482875824, 0.005994009785354137, -0.04173629730939865, -0.08282066136598587, 0.20745176076889038, -0.10502700507640839, 0.025991007685661316, 0.10006451606750488, -0.0012305815471336246, -0.0657704547047615, 0.05334577336907387, -0.06606853008270264, -0.1582508385181427, -0.05806379020214081, -0.047638293355703354, 0.23842930793762207, 0.10227920860052109, 0.10108925402164459, -0.17193563282489777, 0.21814200282096863], [0.01489662192761898, 0.018376197665929794, -0.113657146692276, -0.0692366436123848, -0.051310621201992035, 0.08963530510663986, -0.03957483172416687, -0.18163713812828064, -0.15615811944007874, -0.12096329033374786, 0.27935415506362915, -0.07623564451932907, -0.06795655190944672, 0.006954125594347715, -0.14288225769996643, -0.11219280958175659, -0.14773014187812805, 0.28232091665267944, 0.2659408748149872, -0.04168582707643509, -0.09356790035963058, -0.11308859288692474, -0.11056852340698242, 0.012245474383234978, 0.2738954424858093, 0.06323309242725372, 0.02900618128478527, 0.18098363280296326, -0.09105311334133148, -0.05618281289935112, -0.12309775501489639, -0.01460904348641634, 0.027820657938718796, 0.06982579827308655, 0.13784149289131165, -0.00400118064135313, -0.0170348659157753, 0.022041870281100273, -0.0714375227689743, 0.25562870502471924, -0.137355238199234, -0.23507598042488098, -0.12081050127744675, -0.0894337147474289, -0.17264556884765625, -0.020996980369091034, -0.019892318174242973, 0.08121620863676071, -0.030218377709388733, -0.05548105761408806, -0.08004395663738251, -0.060626767575740814, -0.06074032932519913, 0.09966281801462173, 0.06304395943880081, 0.13125506043434143, -0.03747840225696564, -0.14472319185733795, -0.27617934346199036, -0.17302215099334717], [-0.03934480994939804, -0.03934480994939804, -0.11179899424314499, -0.06914486736059189, -0.12090493738651276, -0.05194316431879997, 0.05311319977045059, -0.13368168473243713, -0.13368168473243713, 0.10037264972925186, 0.11919673532247543, 0.082300566136837, -0.14268748462200165, 0.07191634923219681, -0.08674950152635574, -0.08674950152635574, -0.13269206881523132, -0.03800049424171448, -0.014499591663479805, 0.11080320179462433, -0.021474359557032585, -0.11079882085323334, -0.11079882085323334, -0.09779202193021774, -0.056676529347896576, 0.06603186577558517, 0.07667958736419678, -0.0878753811120987, -0.04771669581532478, -0.04771669581532478, -0.1498100459575653, 0.0036913608200848103, -0.014656152576208115, 0.07476513832807541, 0.10778715461492538, 0.08975810557603836, 0.08975810557603836, -0.029745200648903847, -0.08653123676776886, -0.13711726665496826, 0.1416170299053192, 0.0763789638876915, 0.10867767781019211, 0.10867767781019211, 0.024059489369392395, -0.055503278970718384, 0.034524668008089066, 0.10134213417768478, -0.10100017488002777, -0.16518843173980713, -0.16518843173980713, 0.06719173491001129, -0.13327521085739136, -0.13881060481071472, -0.08756820112466812, -0.08899465948343277, -0.17541179060935974, -0.020729022100567818, -0.16401222348213196, 0.1945493370294571], [0.17332470417022705, 0.17702560126781464, -0.2158980667591095, -0.020178111270070076, -0.046507034450769424, -0.09283364564180374, -0.04171013832092285, -0.2072288542985916, -0.23329977691173553, 0.08780264854431152, 0.14491203427314758, 0.31244710087776184, -0.0633552297949791, -0.011604412458837032, -0.08995350450277328, -0.14177009463310242, 0.3167625367641449, 0.1063910722732544, 0.042430248111486435, 0.20701110363006592, 0.3671146631240845, -0.03072735294699669, -0.00961917545646429, 0.08502480387687683, 0.07814913988113403, 0.13690519332885742, 0.026996953412890434, -0.04401662200689316, -0.18013805150985718, -0.13356199860572815, 0.014250430278480053, 0.09760379791259766, 0.015033942647278309, 0.004508873913437128, -0.17614313960075378, 0.038646068423986435, 0.05370338633656502, 0.13516680896282196, 0.15413905680179596, 0.033111345022916794, -0.12317898869514465, -0.14741888642311096, -0.355124294757843, -0.47284331917762756, 0.3451085388660431, 0.019771242514252663, -0.07245883345603943, -0.1752087026834488, 0.2604474723339081, -0.027407074347138405, 0.07047498226165771, -0.1114104762673378, 0.002402786398306489, -0.055178459733724594, -0.012097603641450405, 0.14619816839694977, -0.16482235491275787, 0.21736188232898712, -0.19174426794052124, 0.16242101788520813], [-0.2132946252822876, -0.18406526744365692, 0.10277434438467026, -0.04972400143742561, 0.08024554699659348, -0.15310724079608917, -0.0726260393857956, 0.02008066512644291, 0.002559499815106392, 0.006975860800594091, 0.0530613549053669, 0.08927256613969803, -0.11526408791542053, -0.18172121047973633, 0.09992519021034241, 0.10339134186506271, -0.053799454122781754, -0.08405758440494537, -0.05056280270218849, 0.07541370391845703, 0.058384016156196594, 0.09397222846746445, 0.08029880374670029, -0.04269445315003395, -0.23181992769241333, -0.03685743361711502, -0.007171936333179474, -0.1342306286096573, -0.20630931854248047, -0.17817573249340057, -0.1812591701745987, -0.07009372860193253, -0.12955358624458313, -0.05895394831895828, -0.15669238567352295, -0.1775079369544983, -0.11929961293935776, 0.059269268065690994, 0.3094235360622406, -0.2292061448097229, -0.26343366503715515, -0.05682028457522392, 0.14693854749202728, -0.014800258912146091, 0.5004892349243164, 0.23185516893863678, -0.06265830248594284, -0.1974361389875412, -0.10479561239480972, -0.1314118653535843, -0.035416487604379654, 0.14445683360099792, 0.22693364322185516, -0.06633369624614716, -0.019249239936470985, 0.057913247495889664, 0.2177402824163437, 0.07807158678770065, -0.3116079270839691, -0.030406411737203598], [-0.19417454302310944, -0.15303948521614075, -0.05796618014574051, -0.01958666555583477, 0.05306895822286606, 0.04735998436808586, -0.03535041958093643, -0.017741812393069267, -0.054998163133859634, 0.10073445737361908, 0.23592600226402283, 0.08025191724300385, -0.15757083892822266, 0.29180023074150085, -0.2977733314037323, -0.6555481553077698, 0.3969934284687042, 0.1919931024312973, -0.005601577460765839, 0.08859880268573761, 0.20985376834869385, -0.09172625094652176, -0.08340899646282196, 0.08758825808763504, 0.07102569937705994, -0.04515978321433067, 0.13070426881313324, -0.05155869200825691, 0.09306277334690094, 0.06483890861272812, -0.041605837643146515, -0.03832355886697769, 0.02713550254702568, -0.12103422731161118, -0.1690734326839447, -0.056359898298978806, 0.07384612411260605, -0.07600826025009155, 0.015032046474516392, -0.11406296491622925, -0.0505058653652668, -0.17555879056453705, -0.2538558840751648, -0.150356724858284, 0.05170219764113426, 0.12956346571445465, 0.21702340245246887, -0.059649378061294556, -0.1488524079322815, -0.0478082075715065, 0.12785489857196808, 0.04406307265162468, 0.06090221181511879, 0.09380949288606644, -0.21947042644023895, 0.10290941596031189, 0.14747805893421173, -0.19274531304836273, 0.20983271300792694, 0.058525290340185165], [-0.04909699782729149, 0.16414542496204376, 0.038958627730607986, 0.05627531185746193, -0.07880251109600067, 0.05487556383013725, 0.01822863519191742, -0.03052353858947754, -0.10473871231079102, -0.059112194925546646, 0.10742855817079544, 0.10850274562835693, 0.20564009249210358, -0.022112956270575523, 0.03588277846574783, 0.13004519045352936, -0.10705059766769409, 0.05982642248272896, 0.047585878521203995, -0.055416908115148544, 0.06365102529525757, 0.029556235298514366, 0.11307026445865631, -0.028986182063817978, -0.11656390875577927, -0.03600789234042168, 0.1871260106563568, -0.11022087186574936, -0.01606123521924019, -0.02791847474873066, -0.1748933047056198, 0.06722722947597504, -0.23140311241149902, -0.07187528163194656, 0.1347101330757141, -0.04124575853347778, -0.032345738261938095, -0.078145332634449, -0.07235890626907349, 0.008619477972388268, 0.017977522686123848, 0.09439332038164139, 0.17764294147491455, 0.030747031792998314, -0.0036988495849072933, 0.17034675180912018, -0.05652165040373802, 0.0509866327047348, -0.19032888114452362, -0.027964875102043152, 0.17382867634296417, -0.048961784690618515, 0.03892108425498009, -0.13241668045520782, -0.08255704492330551, -0.028666460886597633, -0.04482969269156456, 0.20594215393066406, -0.17950113117694855, 0.27471375465393066], [-0.021479623392224312, 0.016220729798078537, 0.10923116654157639, 0.033700380474328995, 0.1322035938501358, -0.09086102247238159, 0.0005854539922438562, -0.14689593017101288, -0.2448800802230835, 0.08080961555242538, 0.2525557279586792, 0.11470787227153778, -0.07683605700731277, 0.15014679729938507, -0.30833908915519714, -0.18263553082942963, 0.24138633906841278, 0.051656559109687805, 0.04947887361049652, -0.02752431482076645, -0.0033947075717151165, -0.17228145897388458, -0.08058208227157593, 0.06367819756269455, 0.27101847529411316, 0.10507145524024963, -0.03686721622943878, 0.015204286202788353, 0.04050839692354202, -0.021258644759655, 0.32389748096466064, 0.09399005025625229, -0.07257077097892761, -0.010499643161892891, -0.17931653559207916, 0.013821125030517578, 0.1023150235414505, 0.049362704157829285, -0.07594403624534607, 0.1275789886713028, -0.21102555096149445, -0.18109658360481262, 0.20853890478610992, 0.40179067850112915, -0.3426917791366577, -0.09726060926914215, -0.13210657238960266, -0.32568997144699097, -0.27639418840408325, 0.05990566313266754, 0.22143098711967468, 0.09219364821910858, -0.02521398849785328, 0.12096934765577316, -0.3146068751811981, -0.03731226548552513, -0.17928864061832428, 0.021242059767246246, -0.0835125595331192, 0.25765302777290344], [0.24749979376792908, 0.3223109245300293, -0.06178513541817665, 0.0030027811881154776, 0.13696172833442688, 0.00542869558557868, -0.09881450235843658, 0.12322778254747391, 0.15785427391529083, -0.01912880688905716, -0.09149257838726044, -0.10334455966949463, -0.12017372250556946, -0.08373846858739853, 0.2397855818271637, 0.43280264735221863, -0.19765689969062805, 0.1723068803548813, -0.010326164774596691, -0.3089168071746826, -0.0962890088558197, 0.09796983748674393, 0.14121317863464355, 0.04359186440706253, -0.08128770440816879, 0.0038835573941469193, -0.09787263721227646, -0.12025901675224304, -0.0584922656416893, 0.01464071124792099, 0.20207683742046356, 0.10124723613262177, 0.09355296194553375, -0.24860316514968872, 0.028210515156388283, -0.0370628759264946, -0.10166828334331512, -0.0011941296979784966, -0.041495658457279205, 0.03419951722025871, -0.061249278485774994, -0.04683772847056389, 0.184157595038414, 0.1806265264749527, -0.11073527485132217, -0.06651000678539276, -0.07390239834785461, -0.05514070764183998, -0.22435356676578522, 0.16208210587501526, 0.10795855522155762, -0.1702660471200943, -0.026684142649173737, 0.01830982230603695, -0.1623498648405075, -0.08809754997491837, 0.21137215197086334, 0.22530636191368103, -0.17612352967262268, 0.15664920210838318], [0.2297738939523697, 0.13688674569129944, -0.06300525367259979, 0.09013017266988754, -0.1452578753232956, 0.042857181280851364, -0.043638765811920166, -0.1976001113653183, -0.17861703038215637, 0.3448844850063324, -0.05257866159081459, -0.04927404224872589, -0.08658400923013687, 0.07340416312217712, 0.11094776540994644, 0.09457568824291229, 0.21313884854316711, -0.290800005197525, -0.3316117823123932, -0.01746969111263752, 0.24151504039764404, 0.10150875151157379, 0.15085968375205994, 0.02638324722647667, -0.185914546251297, -0.08592979609966278, 0.13017921149730682, 0.15133167803287506, -0.014601859264075756, 0.016004197299480438, 0.03564930334687233, -0.12629342079162598, 0.09249551594257355, -0.06817323714494705, -0.13394446671009064, -0.22658245265483856, -0.24750696122646332, 0.09585771709680557, 0.017415592446923256, 0.024848779663443565, 0.06390932202339172, -0.10410558432340622, 0.36141061782836914, 0.41798704862594604, -0.06053736060857773, -0.018878281116485596, -2.1073326934129e-05, 0.12383323907852173, -0.1527416706085205, -0.20922976732254028, -0.25520849227905273, -0.29506561160087585, -0.09366410970687866, -0.12482598423957825, 0.02442220039665699, -0.09116248041391373, -0.09469873458147049, -0.007913758978247643, -0.039816342294216156, -0.05633119121193886], [-0.13423635065555573, -0.040566202253103256, 0.2066756933927536, 0.0320013202726841, 0.11066120117902756, 0.0963551476597786, 0.18691405653953552, -0.02620813064277172, 0.058277666568756104, 0.06399639695882797, -0.12609170377254486, 0.03771377354860306, 0.1917007863521576, 0.2650485336780548, 0.11107400804758072, 0.08747177571058273, -0.07936305552721024, 0.02114078961312771, 0.26158350706100464, 0.054029300808906555, 0.05938519537448883, 0.0022859207820147276, 0.01346421055495739, 0.03187764808535576, -0.19435442984104156, 0.010724600404500961, 0.00027250900166109204, -0.23040886223316193, -0.004711448214948177, -0.06041533872485161, -0.17205478250980377, 0.0200488418340683, -0.025094853714108467, -0.11689160019159317, 0.08544573187828064, 0.35948213934898376, 0.5524336695671082, -0.13534153997898102, -0.043735940009355545, 0.08955249190330505, 0.027313588187098503, -0.00013007990492042154, 0.015440651215612888, 0.010453125461935997, 0.0699739083647728, -0.061908453702926636, -0.010082153603434563, 0.12094076722860336, 0.04844513535499573, -0.14585410058498383, -0.16391520202159882, -0.11665458977222443, 0.0030490709468722343, 0.0652557909488678, 0.11805838346481323, -0.027441006153821945, 0.14284317195415497, -0.09893008321523666, 0.05612039938569069, -0.1160491406917572], [0.0038685884792357683, -0.015063985250890255, -0.0316617377102375, 0.028668783605098724, -0.20339162647724152, -0.0018339338712394238, -0.062255680561065674, -0.13180376589298248, -0.18316878378391266, 0.0846264436841011, -0.008991681039333344, -0.033692970871925354, 0.1641300767660141, 0.16551519930362701, 0.5554854869842529, 0.6630948781967163, -0.027865827083587646, -0.0063390061259269714, -0.07856986671686172, 0.058324143290519714, 0.0546751469373703, -0.022535640746355057, 0.07632450014352798, 0.09019928425550461, 0.05826093256473541, -0.051049958914518356, 0.1955256313085556, 0.1408793181180954, -0.06783182173967361, -0.09269017726182938, -0.18069525063037872, 0.12577158212661743, 0.07829052954912186, -0.005965725518763065, 0.028813332319259644, -0.12180255353450775, -0.029313569888472557, 0.02073938213288784, -0.05075192078948021, 0.013062878511846066, 0.010124827735126019, 0.07137765735387802, -0.14059600234031677, -0.10767306387424469, 0.13923002779483795, 0.1406523883342743, -0.07948978245258331, 0.043066445738077164, -0.047693055123090744, 0.4388163387775421, 0.6575790643692017, -0.12607300281524658, 0.07838890701532364, -0.10643023997545242, 0.015796294435858727, -0.13623829185962677, 0.1113542839884758, 0.11513775587081909, 0.36364394426345825, -0.13980361819267273], [-0.028574416413903236, 0.0037039569579064846, -0.06028028205037117, -0.11368755251169205, -0.25673800706863403, -0.2218606024980545, -0.039306797087192535, 0.023872384801506996, -0.021437497809529305, 0.11366241425275803, 0.2879250943660736, 0.16564691066741943, -0.135949045419693, 0.2024684101343155, -0.4045635461807251, -0.4344300329685211, 0.20031730830669403, 0.2949301600456238, 0.036055028438568115, 0.16438542306423187, 0.3185523450374603, -0.030552271753549576, -0.11623796820640564, -0.03177938982844353, 0.10708930343389511, -0.04901321232318878, 0.09135624766349792, 0.11220106482505798, -0.046554312109947205, -0.00033983035245910287, 0.04953752085566521, 0.09056559205055237, 0.06636915355920792, 0.035021111369132996, -0.019481977447867393, -0.08764052391052246, -0.00115611357614398, 0.017060386016964912, 0.25355952978134155, 0.1495905965566635, 0.17485642433166504, 0.14065860211849213, -0.4113663136959076, -0.3956965208053589, 0.1701149344444275, 0.28059229254722595, -0.05028830096125603, 0.13915979862213135, 0.17357712984085083, -0.031012043356895447, 0.02196858637034893, -0.0959564745426178, 0.08257023990154266, 0.06659190356731415, 0.010318763554096222, 0.20439033210277557, -0.25189945101737976, 0.13424687087535858, 0.17117048799991608, -0.03456055000424385], [-0.15109488368034363, -0.10627159476280212, 0.23011097311973572, -0.12950071692466736, -0.11938900500535965, -0.07574186474084854, 0.09517170488834381, -0.0448368564248085, -0.05372484028339386, 0.19002853333950043, 0.005321653094142675, 0.011934736743569374, -0.09305214136838913, 0.2358342409133911, -0.06751331686973572, -0.13013508915901184, 0.4079033434391022, -0.193910613656044, -0.3123825490474701, 0.02339668571949005, -0.019569436088204384, -0.015095504000782967, -0.046133168041706085, 0.022773195058107376, -0.09124644845724106, 0.009559730999171734, -0.24790453910827637, -0.20845912396907806, -0.09197402745485306, -0.10752694308757782, -0.1848042756319046, -0.028936145827174187, 0.12030462175607681, -0.10804884135723114, -0.07226374745368958, -0.1702112853527069, -0.13708586990833282, -0.21347808837890625, -0.034268248826265335, 0.18257568776607513, -0.14544577896595, -0.3028489947319031, 0.037292901426553726, 0.023681629449129105, -0.20807401835918427, -0.002132630441337824, -0.12071263790130615, 0.0036487840116024017, -0.07587818801403046, -0.03235282376408577, -0.001467833761125803, 0.14590749144554138, -0.07669506967067719, 0.10916376113891602, 0.07945908606052399, -0.1887548267841339, 0.12606559693813324, 0.18321433663368225, -0.17927668988704681, 0.016511939465999603], [-0.034086767584085464, -0.017554422840476036, 0.04883544519543648, 0.053415924310684204, 0.07509448379278183, 0.0021221134811639786, 0.04803488776087761, 0.0323113389313221, 0.045307230204343796, 0.037982817739248276, -0.05661029741168022, -0.02654680609703064, -0.1262335479259491, -0.06615834683179855, 0.19705654680728912, 0.3685761094093323, -0.2032448947429657, -0.002593919401988387, 0.029725441709160805, -0.06929247826337814, -0.12944193184375763, 0.02729141153395176, 0.08474276959896088, 0.099127396941185, -0.07808882743120193, 0.20103132724761963, -0.1145925372838974, -0.0822533667087555, -0.056459181010723114, 0.09881484508514404, 0.15716110169887543, 0.056554604321718216, -0.2188907116651535, 0.014945123344659805, -0.1184631958603859, 0.07681955397129059, 0.1292135864496231, 0.014841541647911072, 0.07565192133188248, 0.1596236526966095, 0.18142645061016083, -0.12883669137954712, -0.17048431932926178, -0.1566702425479889, 0.14227049052715302, 0.03732338547706604, -0.01190886739641428, 0.026809126138687134, 0.004488223697990179, 0.11044101417064667, -0.031777869910001755, 0.21175335347652435, 0.03213668242096901, 0.012043360620737076, 0.0596066415309906, 0.056336723268032074, 0.04412126541137695, -0.17752966284751892, -0.07051867991685867, -0.13264751434326172], [-0.28865668177604675, -0.24963770806789398, 0.11615169793367386, -0.02807893231511116, -0.014993995428085327, -0.023638876155018806, -0.01987459324300289, 0.030261563137173653, -0.01721356436610222, -0.051385000348091125, -0.13086262345314026, -0.08393608033657074, -0.08807843923568726, -0.09637922048568726, -0.0889507457613945, 0.015803590416908264, 0.015230745077133179, -0.07050591707229614, 0.10155753791332245, 0.10287323594093323, -0.1265074610710144, -0.06460234522819519, -0.05460906773805618, -0.086428701877594, -0.14812467992305756, -0.2592962980270386, -0.13658811151981354, -0.10339664667844772, -0.06306709349155426, -0.1433221399784088, -0.14374132454395294, -0.00017735718574840575, 0.03274010494351387, -0.21175847947597504, -0.16529399156570435, -0.128986194729805, -0.04590921849012375, 0.07481495290994644, 0.024993134662508965, -0.08613140881061554, 0.028129203245043755, 0.014691491611301899, -0.036247365176677704, 0.04870794340968132, 0.4544585347175598, -0.03463884815573692, 0.23075668513774872, -0.021830743178725243, 0.0886748656630516, -0.03858885541558266, -0.07343435287475586, 0.1572163701057434, -0.13280746340751648, -0.11073099076747894, -0.19939158856868744, 0.08139675855636597, 0.07052824646234512, -0.05035547539591789, -0.0643591433763504, -0.03805196285247803], [-0.6025511622428894, -1.1257685422897339, 0.46258053183555603, 0.11675816774368286, 0.15601885318756104, -0.11738378554582596, -0.01042037084698677, -0.0573379285633564, -0.025945885106921196, 0.03292202576994896, 0.2039729803800583, -0.07123466581106186, -0.09795153886079788, -0.07459025084972382, 0.16714127361774445, 0.2874908149242401, -0.05398266017436981, -0.08856780081987381, -0.07741472870111465, 0.005788245238363743, -0.14657723903656006, 0.14385904371738434, 0.23743736743927002, -0.05681918188929558, -0.10806465148925781, 0.04540539160370827, -0.04007484391331673, -0.02596425637602806, -0.1031535193324089, 0.024882791563868523, 0.11156672239303589, 0.12087010592222214, 0.07574062794446945, -0.09772352874279022, -0.13916578888893127, -0.10069599747657776, -0.10870246589183807, 0.06146857142448425, -0.05178503692150116, 0.0488453209400177, -0.09214998036623001, -0.02257438749074936, 0.15961968898773193, 0.2884994149208069, -0.20145182311534882, -0.08640985190868378, -0.18611453473567963, -0.18499493598937988, -0.16441939771175385, 0.012632724829018116, -0.12801150977611542, 0.09087994694709778, 0.08599791675806046, 0.12481283396482468, -0.07574708759784698, 0.1898406594991684, 0.3060346841812134, -0.19374804198741913, 0.02773980051279068, -0.2339140623807907], [-0.09992948174476624, -0.05748334899544716, 0.057174913585186005, 0.15559060871601105, 0.1925002485513687, -0.22451075911521912, -0.18953484296798706, -0.051765840500593185, 0.020193982869386673, -0.04278329759836197, -0.14044977724552155, 0.1680355966091156, -0.12508700788021088, 0.023196719586849213, 0.10096216201782227, 0.2536885738372803, -0.07688018679618835, 0.12920227646827698, -0.04052877798676491, -0.01603391394019127, -0.1656164824962616, 0.2103736251592636, 0.23254965245723724, -0.09704390913248062, -0.11906862258911133, 0.0450785793364048, -0.10822554677724838, -0.1448945850133896, 0.12053782492876053, 0.22371886670589447, 0.24520425498485565, 0.03934872895479202, -0.08685246855020523, -0.09721815586090088, 0.08961421996355057, -0.011771407909691334, -0.0241610798984766, -0.10066697746515274, -0.036993879824876785, 0.07022257894277573, 0.13027335703372955, 0.1437767595052719, -0.3912769556045532, -0.5745394229888916, 0.2705334424972534, 0.07154278457164764, 0.22639377415180206, 0.10107119381427765, 0.15659581124782562, -0.21578675508499146, -0.23861338198184967, 0.08686795830726624, 0.17732520401477814, 0.15510697662830353, 0.006690500769764185, 0.011392410844564438, -0.05245206877589226, -0.1536458432674408, -0.13667194545269012, 0.27520978450775146], [-0.20236749947071075, -0.22939784824848175, -0.021813008934259415, 0.16626755893230438, -0.30439284443855286, -0.009419179521501064, 0.04167499765753746, 0.26650530099868774, 0.43695539236068726, 0.0023357172030955553, -0.0922582596540451, -0.05954821780323982, -0.1530849039554596, -0.10061689466238022, 0.049473538994789124, -0.05680523440241814, -0.13738876581192017, 0.11962021887302399, 0.056473176926374435, -0.034270990639925, -0.08946345001459122, -0.038524650037288666, -0.05888529121875763, -0.02074293978512287, -0.16653896868228912, -0.30879291892051697, 0.1878558099269867, 0.027810903266072273, -0.14545975625514984, -0.0647750049829483, -0.13820116221904755, -0.04554606229066849, 0.06230979785323143, -0.16666105389595032, -0.19558703899383545, -0.208535835146904, -0.17922475934028625, -0.01488345768302679, 0.0030763447284698486, -0.1820603609085083, 0.3603174686431885, 0.10336053371429443, -0.2614797055721283, -0.22059476375579834, 0.4481985867023468, -0.12009336799383163, 0.07905387133359909, 0.21287569403648376, 0.19866465032100677, -0.09730079025030136, -0.14987950026988983, 0.054886963218450546, -0.03385958448052406, 0.0039010443724691868, -0.018724355846643448, 0.2055196613073349, -0.0009256508201360703, -0.2625608742237091, 0.210287407040596, 0.02883162721991539], [-0.005893502850085497, 0.01325290184468031, -0.022864818572998047, -0.010327449068427086, -0.05273992940783501, -0.14365410804748535, -0.2034386247396469, -0.021333469077944756, -0.006587560288608074, -0.3223663866519928, 0.06928665935993195, 0.042948223650455475, -0.021331313997507095, -0.41551831364631653, -0.2625422477722168, -0.3407859802246094, -0.035351015627384186, 0.015559983439743519, 0.2034839540719986, -0.13112089037895203, 0.09701475501060486, 0.014387798495590687, -0.07754343748092651, -0.11643173545598984, 0.006325392052531242, -0.16446389257907867, 0.0438622422516346, 0.08077331632375717, -0.19998502731323242, -0.22090491652488708, 0.05147440358996391, -0.03990504518151283, 0.09386898577213287, 0.04092035070061684, -0.06266554445028305, -0.13162991404533386, -0.09072308987379074, 0.06390209496021271, 0.10452627390623093, -0.10830129683017731, 0.20091938972473145, 0.12734651565551758, -0.26766589283943176, -0.22602815926074982, 0.4400603771209717, -0.005839262157678604, 0.1337086707353592, 0.0715777724981308, 0.34454837441444397, -0.008967489004135132, -0.045809559524059296, 0.1414560228586197, -0.1269204318523407, 0.1623155176639557, 0.09173888713121414, 0.05387071892619133, -0.013973037712275982, -0.1925819367170334, -0.26944416761398315, -0.08975884318351746], [0.07575973123311996, 0.04545079916715622, -0.2855803072452545, -0.08594559878110886, -0.021952468901872635, -0.0902324765920639, 0.0011354543967172503, 0.08190210908651352, -0.01438929047435522, -0.1326781064271927, 0.05042313411831856, 0.24125181138515472, 0.4014517068862915, 0.08797121793031693, -0.10317279398441315, -0.5969496369361877, -0.08809752017259598, 0.04700043424963951, 0.11822208762168884, 0.2729324400424957, 0.3016282618045807, -0.026546446606516838, -0.11853209137916565, -0.21008367836475372, 0.013263994827866554, 0.0014966788003221154, 0.13932165503501892, 0.19762013852596283, 0.11162520945072174, 0.06392745673656464, 0.11844059824943542, -0.02173900417983532, -0.050714537501335144, 0.1998075395822525, 0.15020687878131866, -0.20308443903923035, -0.2846159040927887, 0.1125493273139, -0.093391053378582, 0.16896739602088928, 0.008982845582067966, 0.20118354260921478, 0.016535697504878044, 0.1254398673772812, -0.20149055123329163, 0.11354004591703415, -0.027746273204684258, -0.1411016881465912, -0.028961878269910812, 0.08385823667049408, 0.23248641192913055, -0.008451132103800774, -0.07521076500415802, 0.21640433371067047, -0.1137906163930893, -0.2877982556819916, 0.032746635377407074, 0.09580769389867783, -0.025077255442738533, -0.013849441893398762], [-0.16017305850982666, -0.21298009157180786, 0.0698445588350296, -0.14075368642807007, -0.036121901124715805, 0.0715506449341774, 0.03251807391643524, -0.11933813244104385, -0.08925918489694595, 0.024552596732974052, -0.042801667004823685, -0.15731248259544373, -0.25612127780914307, 0.142945796251297, 0.016609154641628265, 0.02089736983180046, -0.10508789867162704, 0.17060795426368713, 0.08014068752527237, -0.2911760210990906, -0.11922404915094376, -0.012930705212056637, -0.03753308206796646, -0.03908257558941841, 0.15701739490032196, -0.20195883512496948, -0.11568473279476166, -0.020973362028598785, -0.0028675561770796776, 0.03483843803405762, -0.008532187901437283, 0.0499570369720459, 0.0005677604931406677, -0.11893238872289658, 0.0013479586923494935, -0.036146510392427444, -0.06674759835004807, 0.13570775091648102, -0.10439874976873398, -0.055060647428035736, -0.09988655149936676, -0.03385663405060768, 0.1225057914853096, 0.11172297596931458, 0.4752366244792938, -0.022829893976449966, 0.01274653896689415, 0.0710616484284401, 0.013089070096611977, -0.05504026263952255, 0.08290177583694458, 0.14221519231796265, -0.031127316877245903, -0.050082284957170486, -0.2597448229789734, 0.05127785727381706, -0.002156926319003105, -0.2041323184967041, -0.20334820449352264, -0.12552085518836975], [0.2048833817243576, 0.23638541996479034, 0.10879562795162201, 0.038281071931123734, -0.09821062535047531, -0.10731478035449982, -0.02849479764699936, 0.13635192811489105, 0.16839472949504852, 0.123243048787117, -0.10877713561058044, 0.13770367205142975, -0.1555858999490738, -0.1535658985376358, -0.13479752838611603, -0.008237429894506931, -0.19538643956184387, -0.03398788347840309, -0.06761600077152252, -0.10789570957422256, -0.10995246469974518, 0.20010922849178314, 0.2544013559818268, -0.12364287674427032, -0.09162021428346634, 0.03128340467810631, -0.04771088436245918, 0.01819261722266674, -0.05933303013443947, 0.056801311671733856, -0.07130490988492966, -0.04741799831390381, 0.1007121354341507, 0.06503542512655258, 0.03697085753083229, -0.021571794524788857, -0.08696109056472778, -0.002704393584281206, -0.05113568529486656, 0.07700137794017792, 0.04603000730276108, 0.003533639945089817, 0.025060467422008514, -0.1330181062221527, -0.0011670944513753057, -0.18842563033103943, 0.09707121551036835, 0.016438065096735954, 0.1256825029850006, -0.043273575603961945, -0.043655335903167725, -0.0017780945636332035, 0.04712026193737984, 0.1189199686050415, -0.1236022338271141, 0.16778740286827087, 0.28450843691825867, 0.2864775061607361, -0.04476494342088699, 0.08145662397146225], [-0.15288406610488892, -0.20132380723953247, 0.2730850875377655, 0.1362626552581787, 0.04205116629600525, 0.1863226592540741, 0.19621460139751434, 0.0313870832324028, -0.045760758221149445, 0.10788361728191376, 0.22377634048461914, 0.06702210754156113, 0.11069510877132416, 0.14818550646305084, 0.031159041449427605, 0.06080510467290878, 0.40832605957984924, 0.11822523176670074, 0.10735505819320679, -0.04071540758013725, -0.12342793494462967, -0.11830485612154007, -0.07030225545167923, 0.0567062683403492, 0.34635570645332336, -0.04243617504835129, -0.2297261357307434, -0.00686696358025074, -0.14060649275779724, -0.1831546276807785, -0.08064711838960648, -0.06991317868232727, 0.1497282087802887, -0.17566287517547607, -0.034056998789310455, -0.1309724897146225, -0.07860356569290161, -0.09968366473913193, -0.03440010920166969, 0.3449125289916992, -0.30416303873062134, -0.238858163356781, 0.0012724727857857943, 0.03942924737930298, 0.0003224621759727597, -0.06027926877140999, -0.3086070716381073, 0.06738965958356857, -0.12881405651569366, -0.31008094549179077, -0.23569445312023163, 0.10438647121191025, 0.05593813955783844, 0.0032168859615921974, -0.061815306544303894, -0.022690696641802788, -0.035236507654190063, 0.18412089347839355, 0.21446602046489716, -0.0014581929426640272], [-0.23485629260540009, -0.21924613416194916, 0.29139935970306396, 0.29789915680885315, 0.21276099979877472, -0.0026859582867473364, 0.3299984633922577, 0.0245332270860672, 0.2289472222328186, 0.23011483252048492, 0.2641068398952484, -0.07935801148414612, 0.05214209109544754, 0.05876098573207855, 0.17699281871318817, 0.2030162513256073, -0.1345135122537613, -0.24383533000946045, -0.000832120596896857, -0.046434253454208374, -0.07113999873399734, 0.04986440762877464, 0.07425405085086823, -0.12112951278686523, -0.0880938470363617, -0.18832647800445557, -0.2628965675830841, 0.04389466345310211, -0.05435234308242798, -0.040242403745651245, 0.010471821762621403, 0.05553428828716278, -0.019413942471146584, -0.026889925822615623, 0.04997019097208977, 0.022746572270989418, 0.08343693614006042, 0.0540279746055603, 0.14909693598747253, 0.09488289058208466, 0.007003103382885456, 0.06359386444091797, -0.2760930061340332, -0.288937509059906, 0.3023012578487396, 0.0912981778383255, 0.15700915455818176, 0.01831595040857792, -0.04583168774843216, 0.03924047574400902, -0.020760368555784225, -0.10352116078138351, 0.3253236413002014, -0.053341593593358994, 0.22444789111614227, 0.22572214901447296, -0.18407411873340607, 0.20724792778491974, 0.1375848650932312, -0.1255049705505371], [-0.02149188332259655, -0.3194229006767273, 0.3210175037384033, -0.14672738313674927, 0.09769702702760696, 0.32501497864723206, 0.2170550376176834, -0.0066015450283885, 0.07747641205787659, 0.23966540396213531, -0.23435856401920319, 0.041937485337257385, -0.16986465454101562, 0.24337616562843323, -0.3366561532020569, -0.6162290573120117, 0.2984124422073364, -0.2320282906293869, 0.1895010769367218, 0.11000794917345047, -0.1182766854763031, 0.056343838572502136, -0.0023084296844899654, 0.0277669969946146, -0.09764377027750015, -0.08841155469417572, -0.18739941716194153, 0.14772294461727142, 0.00899407360702753, -0.030563388019800186, 0.024823933839797974, 0.01590639166533947, 0.10476436465978622, 0.05573156476020813, 0.07889601588249207, -0.004332934506237507, 0.038565874099731445, 0.018599415197968483, 0.03975557163357735, 0.05707927420735359, -0.08995763957500458, -0.03998013585805893, 0.0681837648153305, 0.24951320886611938, -0.05298079922795296, 0.0637575089931488, -0.20993104577064514, 0.021394025534391403, -0.062199752777814865, -0.3068636357784271, -0.22642599046230316, 0.007121088448911905, -0.07674702256917953, 0.1446923464536667, -0.24073460698127747, -0.10464353114366531, 0.067543625831604, 0.25179463624954224, -0.27376309037208557, -0.046100910753011703], [-0.210096076130867, -0.20061784982681274, 0.1297137588262558, -0.07768887281417847, 0.10554615408182144, -0.33829763531684875, -0.20416857302188873, 0.04922330006957054, 0.07883992791175842, -0.16692347824573517, -0.13855436444282532, -0.18537963926792145, -0.12428296357393265, -0.19922839105129242, -0.0962337851524353, -0.11444718390703201, -0.04705604910850525, -0.055089809000492096, 0.0003131696430500597, -0.06902674585580826, 0.0615946426987648, -0.09153188019990921, -0.052481502294540405, -0.055654242634773254, -0.12857484817504883, 0.03200703486800194, 0.006883773021399975, 0.05770782008767128, 0.11026468873023987, 0.14700570702552795, -0.13469718396663666, -0.08062900602817535, 0.06224265322089195, 0.04312613233923912, 0.1846747100353241, -0.18012070655822754, -0.05844241753220558, -0.049321167171001434, 0.25659066438674927, -0.006421193480491638, 0.18804730474948883, 0.10345591604709625, -0.36124661564826965, -0.31860116124153137, 0.15350353717803955, 0.164046049118042, -0.02488420531153679, 0.15119625627994537, 0.024062857031822205, -0.14435268938541412, -0.17623038589954376, 0.10768789798021317, 0.2641865313053131, 0.09021008759737015, 0.13950517773628235, -0.06297791749238968, -0.0296857301145792, -0.4107336401939392, -0.00015980414173100144, 0.14161470532417297], [0.23070082068443298, 0.31994447112083435, -0.15096639096736908, -0.0640120878815651, -0.15964816510677338, -0.08165480196475983, -0.1567477434873581, 0.008221088908612728, 0.02568403258919716, 0.00012327838339842856, -0.04735267907381058, 0.11180978268384933, -0.2147025763988495, -0.09573564678430557, 0.1915542185306549, 0.3814679682254791, -0.25720056891441345, 0.1240570992231369, -0.013891302980482578, -0.029962385073304176, -0.15682490170001984, 0.003382385242730379, 0.0503513477742672, 0.12781111896038055, -0.0031967447139322758, 0.19274777173995972, -0.05904897674918175, 0.0315466970205307, -0.11754723638296127, -0.02979397587478161, 0.22540611028671265, 0.09459404647350311, 0.03834874927997589, -0.12522362172603607, -0.14852304756641388, -0.041603803634643555, -0.044689830392599106, 0.04494098201394081, 0.19794724881649017, -0.08202581107616425, -0.14894776046276093, -0.01008148305118084, -0.18239347636699677, -0.13440003991127014, 0.06140047311782837, 0.18234840035438538, 0.15105536580085754, -0.16325980424880981, -0.05196806788444519, 0.05012756213545799, 0.10330811142921448, 0.08414176851511002, 0.015249136835336685, -0.01672813855111599, -0.0944381132721901, -0.13372758030891418, 0.0900096669793129, 0.09314606338739395, -0.40684276819229126, -0.04844922944903374], [0.06144224479794502, 0.1747182458639145, -0.04353243112564087, 0.006385628134012222, -0.1274331510066986, -0.09804491698741913, -0.23126229643821716, 0.024676308035850525, 0.06897398084402084, 0.13143466413021088, -0.11258693784475327, 0.1978752464056015, -0.19656403362751007, -0.1493501365184784, -0.03917183354496956, 0.06459618359804153, -0.10933497548103333, -0.06156449764966965, 0.09283813834190369, -0.021991688758134842, -0.10503574460744858, 0.13441252708435059, 0.1682736575603485, -0.026294806972146034, 0.027522925287485123, -0.03700951486825943, -0.20626705884933472, 0.015441308729350567, -0.13260026276111603, -0.055924300104379654, 0.2828376591205597, 0.10575253516435623, -0.1504678726196289, -0.11085248738527298, -0.11610303074121475, -0.12811698019504547, -0.10876370966434479, 0.0545300617814064, -0.04225218668580055, -0.12098047137260437, 0.12913554906845093, -0.1665528416633606, -0.23845979571342468, -0.29638949036598206, 0.16349376738071442, 0.09988641738891602, 0.11976078152656555, 0.29355180263519287, 0.0443398579955101, -0.1447194665670395, -0.26571008563041687, 0.11648468673229218, 0.16530674695968628, 0.05934743210673332, -0.17012129724025726, -0.013617940247058868, -0.15392142534255981, -0.0655057281255722, -0.22858178615570068, 0.08260880410671234], [0.06023234874010086, 0.0750291496515274, -0.0930771678686142, -0.11734779924154282, -0.06248889118432999, -0.2855619192123413, -0.21685026586055756, 0.018418272957205772, 0.07791213691234589, -0.008381265215575695, 0.0963444635272026, 0.13579073548316956, 0.07580212503671646, -0.052756160497665405, -0.2983325123786926, -0.597504734992981, 0.3853481709957123, 0.2548271119594574, 0.1886904239654541, 0.12758561968803406, 0.01631384901702404, -0.09827716648578644, -0.18691478669643402, 0.09265214204788208, 0.12065880745649338, -0.0016712171491235495, -0.1564292311668396, 0.19460146129131317, 0.02192912995815277, -0.030695617198944092, 0.11732594668865204, -0.13377586007118225, 0.06207805499434471, -0.22018931806087494, 0.02087346836924553, -0.13872194290161133, -0.019134221598505974, -0.005546592175960541, 0.23494471609592438, 0.08846734464168549, -0.09073443710803986, -0.03970072790980339, -0.3123241066932678, -0.1759306937456131, 0.1635057032108307, 0.25875577330589294, -0.07444602996110916, 0.10253860056400299, 0.0023317551240324974, -0.016531258821487427, 0.15349851548671722, 0.07319829612970352, -0.034534670412540436, 0.05034850910305977, -0.15030774474143982, -0.013214877806603909, 0.04006457328796387, 0.18454301357269287, -0.15034376084804535, 0.06898851692676544], [-0.09158963710069656, -0.21975214779376984, 0.1253405064344406, 0.05606669932603836, 0.12326131761074066, -0.07726938277482986, -0.20180878043174744, 0.0933094173669815, 0.14340274035930634, 0.21804651618003845, -0.1075097844004631, 0.10951360315084457, 0.13852818310260773, 0.006058973725885153, -0.09152109920978546, -0.5117200613021851, 0.3364958167076111, -0.28000664710998535, -0.05997435748577118, 0.17623095214366913, 0.28418585658073425, 0.032772380858659744, -0.03340677544474602, 0.03562231361865997, -0.23398490250110626, -0.009995832107961178, -0.2862972021102905, 0.1463463455438614, -0.1521405130624771, -0.18642432987689972, 0.14946489036083221, -0.0051907324232161045, 0.09806448966264725, -0.08460256457328796, -0.012834032997488976, -0.05920124053955078, -0.053104251623153687, 0.02682962641119957, 0.007283808197826147, 0.125515878200531, -0.2302224040031433, 0.10189880430698395, 0.04303571209311485, 0.12222597002983093, 0.015729285776615143, -0.16709564626216888, 0.05847020819783211, -0.1098867878317833, -0.08632725477218628, 0.039925467222929, 0.033627625554800034, -0.06263494491577148, -0.03176907077431679, -0.005458529107272625, 0.00686449371278286, 0.015184673480689526, 0.028771011158823967, -0.16720449924468994, -0.018598094582557678, 0.11190579831600189], [0.27437591552734375, 0.3277335464954376, -0.40018510818481445, -0.04869909957051277, -0.136880561709404, -0.3635651767253876, -0.25665900111198425, -0.11257583647966385, -0.13714921474456787, 0.1461263746023178, -0.05524979531764984, -0.09153112024068832, -0.05921955406665802, 0.04671424627304077, -0.003672371618449688, 0.0426449328660965, 0.2812669277191162, 0.15072502195835114, 0.15145614743232727, 0.19535790383815765, -0.10498587042093277, -0.0119224414229393, -0.1786772757768631, 0.06041514500975609, 0.14539438486099243, 0.043908365070819855, 0.029422463849186897, 0.06115427613258362, -0.04837752878665924, -0.11633352935314178, 0.15741212666034698, -0.10077140480279922, -0.05664544925093651, 0.11745230108499527, -0.039549436420202255, -0.043114807456731796, -0.11813850700855255, -0.10312269628047943, -0.00912055466324091, 0.033476993441581726, 0.14358626306056976, 0.15013563632965088, -0.1328955888748169, -0.349203884601593, -0.0012746753636747599, 0.16783426702022552, 0.023642146959900856, 0.18179550766944885, 0.039980530738830566, -0.09442795813083649, -0.18202164769172668, -0.19679880142211914, 0.09624791145324707, 0.04657258093357086, -0.08718818426132202, -0.11722834408283234, 0.007055996917188168, 0.05511670187115669, 0.07477738708257675, -0.10812646150588989], [0.017374275252223015, -0.01956774666905403, 0.17935246229171753, 0.014787323772907257, -0.04648873582482338, -0.03300972655415535, -0.01242811232805252, 0.45015749335289, 0.6754655241966248, 0.04401697218418121, -0.09609778970479965, 0.028341520577669144, 0.11787711083889008, -0.011666693724691868, -0.10720916837453842, -0.15059791505336761, -0.07352323830127716, 0.13072553277015686, -0.1041741818189621, 0.04173857718706131, 0.05804263427853584, -0.17674441635608673, -0.1595567911863327, 0.023489417508244514, -0.004605020862072706, -0.030107658356428146, -0.08742691576480865, -0.002116074087098241, -0.04367212951183319, -0.020759906619787216, -0.2290111631155014, -0.08676715940237045, -0.08304204046726227, 0.1309031993150711, 0.036455050110816956, 0.20871004462242126, 0.43138253688812256, -0.007855815812945366, 0.0900227501988411, 0.007183583918958902, 0.0994873046875, -0.03354187309741974, 0.1425686776638031, 0.09158926457166672, 0.007365367840975523, -0.060518112033605576, 0.07762307673692703, -0.13147950172424316, 0.0392083078622818, 0.34912246465682983, 0.5825574994087219, -0.0974196195602417, -0.07672054320573807, -0.028827490285038948, -0.01670708693563938, -0.040437955409288406, 0.028361445292830467, -0.10432124137878418, 0.10858596116304398, 0.11247306317090988], [0.35926729440689087, 0.2943178117275238, 0.41746318340301514, -0.02017958089709282, -0.012707652524113655, 0.1355535238981247, -0.0013635740615427494, 0.1870526820421219, 0.10195416212081909, 0.008496733382344246, -0.17645975947380066, -0.12534673511981964, 0.08242382854223251, -0.024074502289295197, 0.08977380394935608, 0.025141190737485886, -0.11835677921772003, 0.12517671287059784, -0.013972080312669277, 0.02062576450407505, -0.07282599061727524, 0.08278293907642365, 0.1083638146519661, 0.10724464803934097, 0.07952959835529327, -0.010945376940071583, 0.03144281357526779, -0.022687897086143494, 0.07024449110031128, 0.016505030915141106, -0.23042728006839752, 0.037001945078372955, 0.04131634905934334, 0.11740868538618088, -0.12334515899419785, -0.0010526841506361961, 0.07036694139242172, -0.005545325577259064, 0.029640771448612213, -0.0907093808054924, -0.02064407803118229, -0.1492072343826294, -0.07705710828304291, -0.032173849642276764, -0.0429101437330246, 0.1918238252401352, -0.05920245870947838, -0.038895368576049805, -0.07820745557546616, 0.2344631403684616, 0.265593945980072, 0.08204136043787003, -0.15210309624671936, 0.02287658490240574, 0.3573615252971649, 0.03335944563150406, 0.13957105576992035, 0.2647160589694977, 0.3175502121448517, -0.05753269046545029], [-0.6218312382698059, -0.5052794218063354, -0.043362896889448166, 0.15943841636180878, 0.16334474086761475, 0.20403002202510834, 0.3042486011981964, -0.15721294283866882, -0.19711433351039886, -0.2124784290790558, 0.15280072391033173, -0.06208677217364311, 0.2134120613336563, 0.10524390637874603, 0.10019336640834808, -0.050807371735572815, -0.050598304718732834, -0.28200599551200867, 0.06034774333238602, -0.07515367865562439, -0.07474692165851593, -0.12287481129169464, -0.05568912252783775, -0.08043431490659714, -0.23668888211250305, 0.05525725707411766, -0.12671634554862976, -0.14324800670146942, -0.024453986436128616, 0.004276536870747805, 0.03646547347307205, 0.08122479915618896, -0.08381301909685135, -0.034949466586112976, 0.018356548622250557, 0.007568684872239828, 0.05433982238173485, -0.036947302520275116, -0.17006485164165497, -0.06256578117609024, -0.09290293604135513, -0.11825855076313019, 0.24953532218933105, 0.4428377151489258, -0.182655930519104, -0.0957736149430275, -0.05802484601736069, -0.16134655475616455, -0.18516772985458374, 0.07081523537635803, 0.1152983084321022, -0.07598407566547394, 0.15686698257923126, 0.17994125187397003, -0.02494940161705017, 0.014179028570652008, -0.2703777551651001, 0.10805583000183105, -0.09188180416822433, 0.09863099455833435], [-0.0655338317155838, -0.026479382067918777, -0.005996815860271454, -0.13721667230129242, -0.10220803320407867, -0.12496139109134674, -0.014254294335842133, -0.09899737685918808, -0.18873581290245056, -0.011272349394857883, 0.36137422919273376, -0.08731687068939209, -0.08156012743711472, 0.096529521048069, -0.07946722954511642, -0.08961009234189987, 0.10394906252622604, 0.21028195321559906, 0.003947345074266195, 0.17549216747283936, 0.12507857382297516, -0.051402267068624496, -0.10638374835252762, -0.0824466273188591, 0.30233314633369446, -0.10765592008829117, 0.1686369776725769, -0.19502322375774384, 0.07864060997962952, 0.07296304404735565, -0.18380309641361237, -0.06268573552370071, 0.05369728058576584, 0.24946905672550201, -0.19414196908473969, 0.08445952832698822, 0.04473564773797989, -0.05677478387951851, -0.22231586277484894, 0.09303142875432968, 0.12300509959459305, -0.21147233247756958, 0.046548426151275635, -0.03031286597251892, -0.038871604949235916, -0.13257037103176117, 0.014986650086939335, -0.10367830097675323, -0.23422874510288239, 0.14493924379348755, 0.10035154968500137, -0.005892266985028982, -0.08078865706920624, -0.022652501240372658, 0.2237161099910736, -0.34845679998397827, -0.1652563512325287, -0.5289250016212463, -0.4069165587425232, 0.13310474157333374], [0.015144246630370617, 0.030461816117167473, 0.0792820081114769, 0.13223469257354736, 0.04013140872120857, -0.10822123289108276, -0.03378249332308769, -0.565499484539032, -0.893593430519104, 0.05599529296159744, -0.056677136570215225, -0.13392500579357147, -0.05340474471449852, 0.050908636301755905, 0.11878778785467148, 0.20814713835716248, -0.04478469863533974, -0.04616473242640495, -0.10725385695695877, -0.10600270330905914, -0.1224987730383873, -0.06496705859899521, 0.07749830186367035, -0.311603307723999, -0.047650255262851715, 0.09847438335418701, 0.017477594316005707, -0.1461825966835022, 0.13536091148853302, 0.25956982374191284, 0.17075979709625244, -0.023203717544674873, 0.023321321234107018, 0.1353561133146286, 0.13058170676231384, 0.10485554486513138, 0.056441597640514374, 0.13418255746364594, 0.08538492769002914, -0.01660369150340557, 0.12487050145864487, 0.016508078202605247, 0.2597236633300781, -0.056679196655750275, -0.06590797752141953, -0.16236554086208344, -0.2175854742527008, 0.20072408020496368, 0.045153580605983734, -0.12327088415622711, -0.21120606362819672, -0.09038468450307846, -0.0191968847066164, 0.03335226699709892, 0.15231391787528992, -0.010900735855102539, -0.14796589314937592, -0.013124445453286171, 0.07218542695045471, 0.28746092319488525], [0.554963231086731, 0.6441236138343811, 0.01423164177685976, 0.011155994608998299, 0.13608449697494507, 0.1238221675157547, 0.15513794124126434, -0.13078734278678894, -0.09120067209005356, 0.06045044958591461, 0.06501604616641998, -0.06448211520910263, -0.05575903132557869, 0.1577138453722, -0.09527771919965744, 0.06917457282543182, -0.029115602374076843, 0.016095420345664024, 0.1523299515247345, 0.115134596824646, -0.1083693653345108, 0.04049123078584671, 0.11416986584663391, -0.013255118392407894, -0.00851336307823658, 0.04761228710412979, 0.008163598366081715, -0.0499507337808609, -0.004173717927187681, -0.027091946452856064, -0.06562408059835434, -0.01763768307864666, 0.10806059092283249, 0.017343794927001, 0.07758431881666183, -0.0947357565164566, -0.027466265484690666, 0.004348917864263058, 0.0344061441719532, 0.08197268843650818, 0.1573982983827591, 0.07443875819444656, -0.1659809947013855, -0.015410107560455799, 0.021701259538531303, 0.003375060623511672, 0.0082287872210145, -0.21353714168071747, 0.06453000754117966, -0.18369437754154205, -0.19295980036258698, -0.029847126454114914, 0.0688362643122673, 0.005078794434666634, 0.10099861770868301, 0.09349455684423447, -0.13106219470500946, 0.08231857419013977, 0.03579293191432953, 0.07538110762834549], [0.17935538291931152, 0.23301126062870026, -0.09404975175857544, -0.05677091330289841, 0.06676812469959259, -0.0710601955652237, -0.24413935840129852, 0.09987969696521759, 0.11075888574123383, -0.051068078726530075, -0.17760466039180756, 0.1104707419872284, -0.12383600324392319, -0.2167181521654129, -0.02126852422952652, 0.06238287687301636, -0.2429065704345703, -0.11915308982133865, -0.019775815308094025, 0.06971307843923569, -0.1554296314716339, 0.02511119842529297, 0.03540818765759468, 0.0061981393955647945, -0.11512312293052673, 0.1554282307624817, 0.029770884662866592, -0.09880812466144562, -0.07744216173887253, -0.016941823065280914, 0.27011722326278687, 0.12157662212848663, -0.00457958597689867, 0.13703127205371857, -0.12570592761039734, -0.1130354255437851, -0.09287690371274948, 0.08212100714445114, -0.03038935549557209, 0.005180893465876579, -0.05590961128473282, 0.0773937925696373, 0.14173810184001923, 0.16568686068058014, -0.23672842979431152, -0.0675523579120636, 0.030343512073159218, 0.07383054494857788, -0.20067481696605682, 0.053157441318035126, 0.020519038662314415, -0.0006663510575890541, -0.12000212073326111, 0.17744502425193787, -0.28914183378219604, -0.16325372457504272, 0.22782061994075775, -0.053164683282375336, -0.3655252754688263, 0.1725536286830902], [-0.030504029244184494, -0.3422132432460785, -0.019563136622309685, -0.310861736536026, -0.08554824441671371, -0.2328222543001175, 0.0376744382083416, -0.07890485972166061, 0.010407591238617897, 0.0324443094432354, -0.21674542129039764, 0.046322859823703766, -0.0751284807920456, 0.013794166035950184, -0.04049645736813545, -0.19477039575576782, -0.05583755671977997, -0.16288626194000244, 0.025364644825458527, -0.14568069577217102, -0.24315433204174042, -0.02555091492831707, -0.10297548770904541, -0.024727215990424156, -0.03733273595571518, -0.06611169129610062, -0.04287757724523544, -0.019510338082909584, -0.2344418317079544, -0.1861208826303482, -0.2991730272769928, -0.0015662417281419039, 0.07576193660497665, 0.004846467170864344, -0.10256476700305939, -0.12491055577993393, -0.04619990289211273, -0.13266626000404358, 0.09634372591972351, 0.0948777049779892, -0.11823007464408875, -0.0434989295899868, -0.04848850518465042, -0.3017919063568115, 0.026996323838829994, 0.058929312974214554, -0.14896346628665924, 0.10921066254377365, -0.14556540548801422, 0.009384466335177422, 0.02374856546521187, -0.30756402015686035, -0.04275960475206375, -0.2332632839679718, -0.1534142941236496, -0.020276935771107674, 0.15403170883655548, 0.19596710801124573, -0.00923092383891344, -0.19695693254470825], [0.2945623993873596, 0.17825692892074585, -0.2918054163455963, -0.02228769287467003, -0.09615153819322586, -0.08001511543989182, -0.13600783050060272, -0.012089313939213753, -0.04563799872994423, 0.07746758311986923, 0.06556329131126404, 0.15502415597438812, -0.03283596783876419, 0.08937124907970428, 0.1815076768398285, 0.026187779381871223, 0.3452260196208954, 0.08046849817037582, 0.043353453278541565, 0.13411857187747955, 0.3219107389450073, -0.002119130687788129, -0.006567541044205427, -0.00929138995707035, 0.26541849970817566, 0.06289367377758026, 0.00784967839717865, 0.18653665482997894, -0.08666055649518967, -0.08794718980789185, -0.09783443063497543, 0.03246406838297844, -0.008511614054441452, -0.15073968470096588, 0.018607420846819878, -0.00033029538462869823, -0.00994696281850338, -0.004192659165710211, 0.1669604331254959, -0.0632108524441719, -0.2393113076686859, 0.10401560366153717, -0.09469176083803177, -0.12200988829135895, 0.29125744104385376, 0.05444393306970596, 0.1887669414281845, 0.0016517420299351215, 0.21517807245254517, -0.0034499499015510082, -0.010486423037946224, 0.027657603845000267, 0.056170567870140076, 0.24051618576049805, -0.09221600741147995, 0.1167411282658577, -0.14075513184070587, 0.18841852247714996, -0.05323835834860802, 0.06027742102742195], [-0.38164249062538147, -0.8969947099685669, 0.29375091195106506, 0.0855761468410492, 0.24338161945343018, 0.13634167611598969, 0.29085585474967957, 0.19228261709213257, 0.18822899460792542, 0.009792200289666653, 0.02117161452770233, -0.07303560525178909, -0.14727358520030975, 0.02571122720837593, 0.06365363299846649, 0.12105228006839752, -0.13290590047836304, -0.021369503811001778, 0.09219914674758911, -0.0035581765696406364, -0.1794154942035675, 0.14908549189567566, 0.1456386148929596, 0.05925193801522255, -0.01747930608689785, -0.02193150669336319, -0.13533030450344086, -0.0026810059789568186, 0.05231272429227829, 0.06283706426620483, -0.06427628546953201, 0.13905951380729675, -0.00324860867112875, -0.01593197137117386, -0.0528421513736248, 0.027375327423214912, 0.0749230831861496, -0.04207592457532883, -0.0035943035036325455, 0.1941392868757248, -0.013700530864298344, 0.028540177270770073, -0.40743666887283325, -1.0282589197158813, 0.09071680158376694, 0.1013597920536995, 0.1856599599123001, 0.010425626300275326, 0.11911909282207489, -0.1640000343322754, -0.11442097276449203, 0.09775639325380325, 0.0059831938706338406, 0.1460460126399994, -0.035288143903017044, 0.029618477448821068, -0.09283173084259033, 0.1622636318206787, 0.2062584012746811, 0.0889626070857048], [0.0704667717218399, 0.15379174053668976, -0.3250834345817566, 0.008097597397863865, 0.067973293364048, -0.2459464818239212, -0.1478504091501236, 0.0219313632696867, 0.03797883167862892, -0.06664561480283737, -0.10974278301000595, 0.2621608078479767, -0.19770215451717377, -0.2332514524459839, 0.11465848982334137, 0.24815237522125244, -0.13934649527072906, 0.08665558695793152, 0.06009410321712494, -0.05166596546769142, -0.2235921323299408, 0.09938280284404755, 0.10924462974071503, 0.05537806451320648, -0.10036692023277283, -0.01059001125395298, -0.20105457305908203, 0.01591935195028782, 0.07338611781597137, 0.11881895363330841, 0.2974358797073364, -0.021276619285345078, 0.12328866124153137, -0.027737580239772797, 0.10287673026323318, -0.03357687592506409, -0.07113612443208694, -0.07160511612892151, -0.07730653136968613, 0.1575096845626831, -0.09148234128952026, 0.017024269327521324, 0.08561593294143677, 0.0067620775662362576, 0.24120306968688965, 0.016406623646616936, 0.15317407250404358, 0.18490880727767944, 0.23586562275886536, 2.8406544515746646e-05, -0.0006013020756654441, -0.0563850924372673, -0.045044999569654465, 0.1622835397720337, -0.12321588397026062, -0.13696962594985962, -0.15959206223487854, 0.088307686150074, -0.3345661461353302, 0.1902424544095993], [-0.19271031022071838, -0.4166701138019562, -0.1340474784374237, 0.18634283542633057, 0.24730439484119415, 0.16928771138191223, 0.04552837088704109, 0.021900182589888573, 0.0533541664481163, -0.10511957854032516, -0.011157047003507614, -0.09765195846557617, -0.10432427376508713, 0.04377984255552292, 0.17365776002407074, 0.3727680742740631, -0.14685150980949402, 0.04520627111196518, -0.05651870742440224, -0.044142331928014755, -0.15039128065109253, -0.4724622964859009, -0.7285003662109375, 0.1394921839237213, -0.08493088185787201, -0.022864095866680145, 0.024956168606877327, -0.024849388748407364, -0.27505823969841003, -0.20031969249248505, 0.16202965378761292, 0.10165543109178543, -0.09989369660615921, 0.2171262502670288, -0.022706154733896255, -0.028627850115299225, -0.0657125934958458, -0.03686756268143654, -0.01498313620686531, 0.16567836701869965, -0.10548685491085052, 0.07293139398097992, -0.3555528521537781, -0.25950872898101807, 0.09988217800855637, 0.09460032731294632, 0.12244806438684464, 0.09196358919143677, -0.008577301166951656, -0.019783923402428627, -0.029777973890304565, -0.14639325439929962, 0.017979472875595093, 0.08477688580751419, 0.1467340737581253, 0.15744999051094055, 0.2368798702955246, -0.13630978763103485, -0.02657982148230076, -0.16018104553222656], [0.08961886167526245, 0.08452158421278, 0.3128722012042999, -0.06872393935918808, -0.0035090993624180555, 0.07947664707899094, 0.16898372769355774, -0.03150227293372154, -0.08715896308422089, 0.06343525648117065, 0.1399209201335907, 0.018802188336849213, 0.12485810369253159, 0.051634807139635086, -0.15906298160552979, -0.13049596548080444, 0.4228247106075287, 0.25806939601898193, 0.14817218482494354, 0.07172056287527084, -0.15544915199279785, -0.06465259194374084, -0.0713593140244484, 0.07361944019794464, 0.2590939402580261, 0.04124568775296211, -0.08772186189889908, -0.23637166619300842, 0.015432772226631641, 0.0642257034778595, -0.20403800904750824, -0.12124691158533096, -0.14643923938274384, -0.051333215087652206, -0.013362489640712738, 0.019344419240951538, 0.03405355289578438, -0.02164623513817787, -0.038548436015844345, 0.055289845913648605, -0.035141829401254654, -0.10742776840925217, 0.09217603504657745, -0.016270175576210022, -0.0422373041510582, 0.10401370376348495, -0.049882132560014725, 0.18904821574687958, 0.00754126813262701, 0.029304256662726402, 0.04229319095611572, -0.019082946702837944, -0.05253414064645767, -0.05763472989201546, -0.06662164628505707, 0.03259389474987984, -0.010320688597857952, -0.0810256153345108, 0.028000254184007645, -0.17457236349582672], [-0.24776498973369598, -0.3893377184867859, 0.07951212674379349, 0.05116765946149826, -0.04424722492694855, 0.04867859557271004, 0.26080912351608276, -0.028994986787438393, -0.05731939151883125, 0.07502105087041855, 0.16742609441280365, 0.009892988950014114, -0.1071498766541481, 0.27719393372535706, -0.32924944162368774, -0.45965999364852905, 0.33672967553138733, 0.1128382682800293, 0.06818228960037231, -0.026144472882151604, 0.09087757021188736, -0.08536367118358612, -0.036586616188287735, 0.037028856575489044, 0.30989211797714233, 0.05610590800642967, -0.0032589458860456944, 0.06879839301109314, 0.18924272060394287, 0.07597360759973526, -0.1458175927400589, -0.04039151594042778, 0.009347156621515751, 0.03282758221030235, -0.15079061686992645, 0.10032042860984802, 0.1426166445016861, -0.045938149094581604, 0.05660485103726387, -0.05097923055291176, -0.24084322154521942, 0.03818581625819206, 0.17138929665088654, 0.26068973541259766, -0.15886563062667847, -0.0021339617669582367, -0.15185856819152832, 0.07395320385694504, -0.04940524697303772, 0.07397835701704025, 0.10127511620521545, 0.17218981683254242, 0.009129908867180347, -0.06620340794324875, -0.15426331758499146, -0.05308370292186737, -0.2762068510055542, 0.2444440722465515, -0.034638870507478714, -0.04151555150747299], [0.029581967741250992, -0.025381164625287056, 0.3354414999485016, -0.12192671746015549, 0.1344115436077118, -0.015919921919703484, -0.10085074603557587, 0.011282750405371189, -0.008106870576739311, 0.051254548132419586, -0.010549982078373432, 0.08047427237033844, 0.22238579392433167, -0.028533879667520523, 0.08991673588752747, 0.2430855929851532, 0.3680132031440735, 0.12408971786499023, -0.056935928761959076, -0.040714386850595474, -0.09865062683820724, -0.005976415704935789, -0.027529042214155197, -0.013230638578534126, -0.06401673704385757, 0.018909936770796776, -0.28126975893974304, -0.13038600981235504, -0.08944715559482574, -0.15007838606834412, -0.26304417848587036, 0.040913958102464676, -0.08141365647315979, -0.236545130610466, -0.0658617839217186, -0.06179220601916313, -0.05797083303332329, 0.026903769001364708, 0.12124398350715637, -0.07934556901454926, -0.07126473635435104, 0.03568791598081589, 0.0767073854804039, 0.04797746241092682, 0.3626842796802521, 0.14183597266674042, -0.0423271544277668, -0.045873451977968216, -0.15834449231624603, -0.0995003804564476, -0.13828855752944946, 0.21793611347675323, 0.15022099018096924, 0.015132525004446507, -0.2746292054653168, -0.1873326450586319, -0.16822031140327454, 0.18193215131759644, 0.16753852367401123, 0.10619351267814636], [0.04536460340023041, -0.023783763870596886, 0.12863990664482117, 0.04361984133720398, 0.11192856729030609, 0.03101695515215397, 0.14564235508441925, 0.016026318073272705, 0.037690941244363785, -0.03836660087108612, 0.1452581286430359, 0.08719176054000854, -0.0009431564249098301, -0.1636524498462677, -0.2680501937866211, -0.20368212461471558, 0.09335530549287796, -0.11537213623523712, 0.012343963608145714, -0.13611909747123718, 0.07335742563009262, -0.046945612877607346, -0.030704161152243614, 0.04181941598653793, -0.05820494517683983, -0.05512184277176857, 0.13125663995742798, 0.09887844324111938, -0.1775895655155182, -0.11945969611406326, -0.02500784397125244, 0.011893412098288536, 0.002328889211639762, -0.06591599434614182, 0.04282272979617119, 0.1514378786087036, 0.09497126936912537, 0.039738189429044724, -0.14944712817668915, 0.17305104434490204, 0.18228277564048767, 0.08913282305002213, -0.5087031126022339, -0.7538323402404785, 0.31936565041542053, -0.3126299977302551, 0.027022864669561386, 0.08391523361206055, 0.17616865038871765, 0.03832932561635971, 0.12429898232221603, 0.10748321563005447, -0.1947992742061615, 0.031106583774089813, 0.10188240557909012, 0.09309151023626328, 0.17822441458702087, -0.23843930661678314, 0.1811007559299469, -0.16624990105628967], [-0.143098384141922, -0.055282969027757645, 0.03775690495967865, 0.1819649040699005, 0.1422710120677948, -0.2648738622665405, -0.17740055918693542, -0.004011121578514576, -0.14031001925468445, -0.1777784675359726, -0.11234873533248901, -0.04149768128991127, -0.21589010953903198, -0.3444819450378418, -0.9145605564117432, -1.6039419174194336, -0.4364701211452484, -0.14361481368541718, -0.03870123624801636, 0.1482459008693695, -0.23932084441184998, -0.009383239783346653, -0.05446232855319977, 0.04597608000040054, -0.21942444145679474, -0.06234070658683777, 0.17701464891433716, -0.0490790531039238, -0.03084924817085266, -0.0965990424156189, 0.2790695130825043, 0.18423832952976227, -0.0038631903007626534, 0.12222335487604141, 0.15158392488956451, -0.05425053462386131, 0.018919194117188454, -0.03186921775341034, 0.09293829649686813, 0.0191724244505167, -0.09251080453395844, 0.06655016541481018, -0.21613052487373352, -0.07837782800197601, 0.07908392697572708, -0.11558837443590164, 0.1321122795343399, -0.017392784357070923, -0.022219130769371986, -0.1145472526550293, -0.3667152523994446, -0.05193491280078888, 0.2369159460067749, 0.06523497402667999, -0.11940744519233704, 0.005641065072268248, -0.04310208559036255, -0.04505139961838722, 0.06417161971330643, -0.10791667550802231], [0.152578666806221, 0.191367045044899, 0.024703364819288254, 0.13498547673225403, 0.08015678077936172, -0.12987026572227478, -0.10916979610919952, -0.032011713832616806, -0.1465306431055069, -0.0939970463514328, -0.03826160356402397, 0.12779879570007324, 0.15202945470809937, 0.003766776993870735, -0.08717633783817291, -0.13043753802776337, -0.013161471113562584, -0.141127347946167, 0.003484669839963317, -0.03648434206843376, -0.06698020547628403, 0.11077332496643066, 0.10372396558523178, -0.05178770422935486, -0.1924658715724945, -0.09191717207431793, 0.22610414028167725, -0.061741020530462265, -0.044531889259815216, -0.05040218308568001, 0.08188661187887192, -0.20709733664989471, 0.06026623398065567, 0.17127472162246704, 0.18757390975952148, 0.28739023208618164, 0.27355170249938965, -0.17286168038845062, -0.15125076472759247, -0.060261789709329605, -0.059275321662425995, -0.09784791618585587, 0.32303014397621155, 0.4675769507884979, -0.02800445258617401, 0.10823353379964828, 0.10162799805402756, -0.17368187010288239, 0.025574740022420883, 0.3494720160961151, 0.3681447207927704, 0.061114951968193054, -0.07048725336790085, 0.21644212305545807, -0.19351394474506378, -0.10232473909854889, 0.25716081261634827, -0.09222829341888428, -0.16197186708450317, 0.19093731045722961], [-0.19502028822898865, -0.30278080701828003, 0.04203450679779053, -0.07914320379495621, -0.017278457060456276, -0.011414268985390663, 0.01437867246568203, 0.034086767584085464, 0.0172253530472517, -0.06892949342727661, -0.2317200005054474, -0.039158716797828674, 0.20433814823627472, -0.001967777730897069, 0.07137688249349594, 0.09827055037021637, -0.19601215422153473, -0.09583790600299835, 0.10641931742429733, 0.23764757812023163, 0.079008087515831, -0.036382291465997696, 0.022881874814629555, -0.025795243680477142, -0.11658388376235962, -0.06746743619441986, -0.06814227253198624, 0.12667132914066315, -0.1379706859588623, -0.18350335955619812, -0.11378894001245499, 0.012607761658728123, 0.0002562873996794224, -0.1231723204255104, 0.04568397253751755, 0.152353897690773, 0.08949482440948486, -0.16947773098945618, 0.0010647481540217996, 0.09361063688993454, 0.05590633675456047, -0.17343440651893616, -0.0489894337952137, -0.1135120540857315, -0.010066629387438297, -0.03779645636677742, 0.08595339208841324, 0.03355103358626366, -0.034672223031520844, 0.06182606518268585, -0.028001535683870316, -0.08484039455652237, -0.08523763716220856, -0.11353425681591034, -0.28754615783691406, -0.059389878064394, 0.24343234300613403, -0.08569766581058502, 0.16266827285289764, 0.15748129785060883], [0.03849533945322037, -0.02345135807991028, 0.4156257212162018, 0.10126471519470215, 0.11890731006860733, 0.3424428701400757, 0.32002317905426025, -0.028570124879479408, 0.06425994634628296, 0.13670174777507782, 0.09477144479751587, -0.09674738347530365, 0.14921577274799347, 0.05863141641020775, 0.06883864104747772, 0.10916230082511902, -0.0949636772274971, -0.13316428661346436, 0.05571076273918152, 0.1002623438835144, 0.09722360968589783, 0.03419806435704231, -0.007237285375595093, 0.025396451354026794, -0.09155401587486267, 0.07004085183143616, 0.03791692852973938, 0.08979504555463791, 0.04096744954586029, 0.029539678245782852, -0.2405422478914261, -0.059350110590457916, 0.14514265954494476, 0.13379184901714325, 0.1663929671049118, -0.049921914935112, 0.05305096134543419, -0.06574536859989166, -0.041354045271873474, 0.015350906178355217, 0.226130411028862, 0.0888211652636528, -0.12463385611772537, -0.11207745969295502, 0.10183260589838028, -0.049990370869636536, -0.023532189428806305, -0.1529303640127182, 0.06621234118938446, -0.08029200881719589, -0.006941518280655146, 0.0066352589055895805, 0.2957858443260193, 0.03996993973851204, 0.12310387194156647, 0.044184476137161255, 0.1659807711839676, -0.2881027162075043, -0.16940560936927795, -0.11817744374275208], [-0.14748217165470123, -0.10111681371927261, 0.3071810305118561, -0.22196699678897858, -0.1191592812538147, 0.15272486209869385, 0.014828801155090332, 0.05894102528691292, -0.03529423475265503, 0.22128337621688843, -0.047907523810863495, 0.011102414689958096, -0.07415298372507095, 0.17085285484790802, -0.14951781928539276, -0.010709439404308796, 0.023684103041887283, -0.0689079612493515, 0.008396407589316368, -0.16475990414619446, 0.1149100586771965, 0.00819952879101038, -0.09017840027809143, -0.15937842428684235, 0.032054971903562546, 0.04454559087753296, -0.08998506516218185, 0.02606547437608242, -0.05456210672855377, -0.024167587980628014, -0.06513429433107376, 0.02583005279302597, -0.15235835313796997, -0.07677100598812103, -0.202198326587677, -0.19973592460155487, -0.22199000418186188, 0.03449450433254242, -0.17346306145191193, 0.007696302607655525, 0.18105337023735046, 0.1303599625825882, 0.08768150955438614, -0.009789085946977139, 0.13574664294719696, -0.03977833688259125, 0.27593404054641724, 0.1532256156206131, 0.019103704020380974, -0.11946871876716614, -0.048492368310689926, 0.1816648244857788, -0.309042751789093, 0.25655049085617065, -0.11842460930347443, 0.15789298713207245, 0.07468391209840775, -0.05067067965865135, 0.17179566621780396, -0.060725003480911255], [-0.2041250765323639, -1.1434465646743774, 0.42917993664741516, 0.14750486612319946, 0.23532456159591675, 0.31190142035484314, 0.34405145049095154, -0.09872978180646896, -0.15706434845924377, 0.12843148410320282, 0.06205383688211441, 0.01079071406275034, -0.09936832636594772, 0.0999845489859581, -0.06475537270307541, -0.04813988879323006, -0.08749325573444366, 0.08936481177806854, 0.07974238693714142, -0.1832699328660965, -0.012620318681001663, 0.09150169789791107, 0.17730948328971863, -0.03915033116936684, -0.15530410408973694, 0.0526384674012661, -0.07989736646413803, -0.00226469524204731, -0.054119862616062164, -0.07240466773509979, 0.17212443053722382, 0.13257405161857605, 0.04641544073820114, 0.07649938762187958, 0.008420701138675213, -0.07157725840806961, -0.001029524370096624, -0.011293673887848854, 0.07559093087911606, 0.1965893805027008, -0.015095372684299946, 0.10292693227529526, -0.14991247653961182, -0.05279539152979851, 0.018442343920469284, -0.12351260334253311, 0.07076764851808548, -0.0650135725736618, -0.1418299823999405, 0.07144325971603394, 0.14736072719097137, -0.0955958291888237, 0.1754784882068634, 0.10450839251279831, 0.05819191783666611, 0.054066095501184464, 0.006301254034042358, 0.18754030764102936, 0.14346447587013245, 0.1721409112215042], [0.22539035975933075, 0.2883521318435669, -0.3887948989868164, -0.08269041031599045, -0.004850215744227171, -0.08652660250663757, -0.11975498497486115, -0.03880136087536812, -0.042643267661333084, -0.028187675401568413, 0.10532156378030777, 0.25949594378471375, 0.08732016384601593, 0.019387587904930115, -0.24912109971046448, -0.18394795060157776, 0.23544467985630035, 0.09525616466999054, 0.032016124576330185, 0.14743898808956146, 0.12594574689865112, 0.14754049479961395, 0.15286287665367126, -0.14986322820186615, 0.19777968525886536, 0.07469794154167175, -0.040644459426403046, 0.13211403787136078, -0.11734117567539215, -0.1296958029270172, 0.18809667229652405, -0.0840170606970787, 0.059324923902750015, 0.08589693903923035, -0.00824122503399849, 0.007235849741846323, 0.06599969416856766, -0.14145928621292114, 0.003910840023308992, 0.021113237366080284, -0.020862044766545296, 0.038167454302310944, -0.006325890310108662, 0.1285628229379654, -0.10345200449228287, 0.00024724373361095786, 0.02511199750006199, 0.0234979260712862, -0.11283667385578156, 0.10786203294992447, 0.22204309701919556, 0.020291317254304886, -0.1060376912355423, 0.04890856891870499, -0.3285045325756073, -0.10003948956727982, 0.18949997425079346, -0.0072143590077757835, -0.16643227636814117, -0.15811169147491455], [0.10670261085033417, 0.20256628096103668, -0.028835345059633255, 0.14950183033943176, -0.02949477545917034, -0.16383221745491028, -0.16725055873394012, 0.13621801137924194, 0.2900752127170563, 0.00021517377172131091, -0.029438095167279243, 0.15179596841335297, -0.11811371892690659, -0.01645771786570549, -0.0414775125682354, 0.029451938346028328, 0.009517657570540905, 0.08464542776346207, 0.15215283632278442, 0.09823053330183029, 0.05213429778814316, -0.10041859745979309, -0.10441279411315918, 0.061269503086805344, 0.018053002655506134, -0.1677708625793457, 0.02272135764360428, 0.050517354160547256, 0.08832868188619614, 0.08817323297262192, 0.14059866964817047, -0.1269102841615677, -0.04082857444882393, 0.12250148504972458, -0.04106076434254646, 0.16472011804580688, 0.20918162167072296, -0.092243492603302, -0.24333356320858002, 0.0967504009604454, -0.09071988612413406, -0.13006308674812317, 0.40429139137268066, 0.649648129940033, -0.06256252527236938, 0.02744777500629425, -0.05774984881281853, -0.2849445939064026, -0.006855616811662912, -0.6205859780311584, -0.7928041219711304, 0.14111822843551636, 0.0014736078446730971, 0.24712514877319336, -0.35099753737449646, -0.29049938917160034, -0.12478365004062653, 0.005217291880398989, -0.40242472290992737, 0.11578291654586792], [0.15122832357883453, 0.1579437255859375, 0.025919370353221893, 0.141252800822258, 0.08375856280326843, -0.23960775136947632, -0.12557782232761383, 0.015396240167319775, 0.1233709305524826, -0.04562600702047348, 0.12480185925960541, 0.33628585934638977, -0.12474671751260757, -0.0011306555243209004, 0.14698651432991028, 0.2238752543926239, -0.10437694191932678, 0.16342109441757202, 0.02699955552816391, -0.01846388541162014, -0.0048086694441735744, 0.07209015637636185, 0.09209587424993515, -0.08408894389867783, 0.06920164078474045, 0.016065899282693863, -0.09893316775560379, 0.014658235013484955, -0.23811815679073334, -0.1573169082403183, 0.029210427775979042, -0.08534514904022217, 0.04616653174161911, -0.048949845135211945, -0.2454870641231537, -0.11058388650417328, 0.01338793896138668, -0.12565194070339203, 0.24814452230930328, 0.007134673185646534, 0.29000723361968994, 0.22885997593402863, -0.2655874192714691, -0.2513721287250519, 0.33323758840560913, 0.28281834721565247, -0.030339522287249565, 0.283272922039032, 0.1970950961112976, -0.09621293842792511, 0.014195876196026802, 0.05611217021942139, 0.09351951628923416, -0.0010983505053445697, -0.026305286213755608, -0.10237248241901398, -0.1277652531862259, 0.1527026891708374, 0.30233991146087646, 0.00572453485801816], [0.12147490680217743, 0.09344238042831421, -0.0452747717499733, -0.3072340488433838, -0.04323391616344452, -0.13268382847309113, -0.34774717688560486, -0.06580569595098495, -0.05228939279913902, -0.04195506498217583, -0.31642279028892517, 0.05582299083471298, 0.173600971698761, -0.05841027945280075, -0.04046571999788284, -0.1409795731306076, 0.03372963145375252, -0.07566830515861511, 0.013596701435744762, -0.1389245092868805, -0.017980782315135002, -0.0724562257528305, -0.08067789673805237, -0.0009678129572421312, -0.15863960981369019, -0.016629626974463463, -0.02052135393023491, -0.060331858694553375, -0.11551403254270554, 0.04305776208639145, -0.2314639538526535, -0.01940940134227276, 0.08034542202949524, 0.08989168703556061, -0.1670147031545639, -0.17084263265132904, -0.11931098997592926, -0.07090830057859421, 0.3906967043876648, 0.17053700983524323, 0.03723663464188576, -0.13508720695972443, 0.058408599346876144, 0.036696385592222214, 0.005906477104872465, 0.4016723334789276, 0.07687164098024368, -0.1566789746284485, -0.05020156502723694, -0.14226599037647247, -0.14939679205417633, -0.10930897295475006, 0.4018387794494629, -0.09552432596683502, 0.10071612149477005, 0.017616242170333862, 0.08095213025808334, -0.26552721858024597, -0.26407772302627563, -0.14374849200248718], [-0.1676022708415985, -0.12351983040571213, 0.18500718474388123, 0.3711520731449127, -0.13617396354675293, 0.03834402933716774, -0.0920327827334404, -0.12459693849086761, -0.11882677674293518, -0.22408294677734375, 0.46801233291625977, 0.07449234277009964, -0.060184527188539505, 0.07479511946439743, -0.011916019953787327, 0.0227336585521698, -0.11131907999515533, 0.24303418397903442, -0.024059245362877846, 0.1468447744846344, -0.08455219864845276, -0.17597338557243347, -0.1713016927242279, -0.01692359521985054, 0.07277163118124008, -0.03975817188620567, -0.014426776207983494, -0.1308988332748413, -0.06543397903442383, -0.02647840790450573, -0.08296361565589905, -0.19498416781425476, -0.1805102825164795, -0.16732844710350037, 0.0010416251607239246, 0.07311403751373291, 0.23799890279769897, 0.02067091315984726, 0.05620197206735611, 0.00798780471086502, -0.022564886137843132, 0.005514516495168209, -0.001327976700849831, -0.017950456589460373, -0.15879172086715698, -0.18615202605724335, 0.21363963186740875, 0.06072910502552986, 0.014300494454801083, -0.07524064183235168, -0.12878786027431488, -0.040012963116168976, 0.3111499547958374, -0.11359284818172455, -0.10072977840900421, -0.05601460859179497, -0.24854245781898499, -0.297771692276001, 0.2241678237915039, -0.08730034530162811], [0.2082502245903015, 0.26926490664482117, -0.2567073404788971, -0.026272786781191826, -0.03633052855730057, -0.01964731514453888, -0.12793731689453125, 0.14601631462574005, 0.17974655330181122, -0.10618361830711365, -0.00030760563095100224, 0.23423419892787933, -0.19643014669418335, -0.11184907704591751, -0.08115861564874649, 0.05876166746020317, -0.18861612677574158, -0.06235704571008682, -0.007373659871518612, 0.06195833161473274, 0.033439140766859055, 0.035743631422519684, 0.07899905741214752, 0.08253142237663269, -0.04288013279438019, 0.23312973976135254, -0.07762675732374191, -0.09838905185461044, 0.05503145232796669, 0.12394378334283829, 0.24905027449131012, 0.004153495654463768, 0.042223215103149414, 0.11520154029130936, 0.09568162262439728, 0.1648833155632019, 0.12231918424367905, 0.0945182666182518, 0.124481201171875, 0.13689470291137695, -0.01739334873855114, 0.006594921462237835, -0.06729540228843689, -0.06215845048427582, -0.09077655524015427, -0.052926432341337204, -0.12408404052257538, -0.1789228320121765, -0.043596815317869186, 0.2200077772140503, 0.19694679975509644, 0.01745724305510521, -0.09554705768823624, 0.1200258731842041, -0.18366236984729767, 0.03574848920106888, -0.20972172915935516, 0.26590386033058167, -0.2530837655067444, -0.11400849372148514]], "net.0.bias": [-0.16015174984931946, 0.04836243391036987, 0.161277636885643, 0.04366159439086914, -0.06167151406407356, -0.08645451068878174, -0.1664418876171112, -0.06620697677135468, -0.24191613495349884, 0.05886412411928177, -0.14954276382923126, 0.017877569422125816, -0.002141540637239814, -0.03828706964850426, -0.1271813064813614, -0.19408747553825378, -0.07019717991352081, -0.10096701234579086, 0.13708361983299255, -0.08887933194637299, 0.06011411175131798, 0.09241003543138504, 0.06374259293079376, -0.13758081197738647, 0.018398763611912727, -0.15122486650943756, -0.0031646578572690487, -0.16233041882514954, 0.016929365694522858, 0.09999432414770126, -0.1400974988937378, 0.029210736975073814, 0.09572045505046844, -0.04696601256728172, -0.008686784654855728, -0.001677603810094297, -0.1963072568178177, 0.08679140359163284, 0.02407032996416092, -0.08102782815694809, 0.0888778418302536, -0.04777688905596733, 0.2234564870595932, 0.21791648864746094, -0.07209031283855438, 0.1923949420452118, 0.06719841063022614, -0.0021346951834857464, 0.05892637372016907, 0.170087993144989, 0.10608226805925369, 0.16266611218452454, 0.15442776679992676, -0.003991551697254181, -0.20491456985473633, 0.10804767161607742, -0.08570177853107452, -0.0902770608663559, 0.18877427279949188, 0.18338653445243835, -0.024300549179315567, -0.2343275099992752, -0.05232533439993858, 0.22378729283809662], "net.2.weight": [[-0.029977496713399887, 0.12459645420312881, 0.2624797224998474, 0.05463368073105812, -0.009376327507197857, -0.10132697224617004, -0.05987492948770523, -0.03903613239526749, -0.1711396872997284, -0.0958462730050087, -0.0027973621618002653, 0.24428792297840118, 0.1887352615594864, -0.24121080338954926, 0.03349921852350235, -0.08990468829870224, -0.011715587228536606, 0.0683899000287056, 0.16209925711154938, -0.1602708250284195, -0.08593147993087769, 0.19759860634803772, -0.026836231350898743, -0.04967295378446579, 0.06911227107048035, -0.1692384034395218, 0.23001718521118164, -0.17611615359783173, 0.003925324883311987, -0.025150803849101067, -0.11898071318864822, 0.4083133339881897, 0.23155926167964935, 0.05262618884444237, 0.016456127166748047, 0.04855092614889145, 0.4558575749397278, -0.07554996758699417, -0.17171400785446167, -0.13138742744922638, 0.10278476774692535, -0.46360740065574646, 0.41147473454475403, -0.2334011048078537, -0.1415288895368576, -0.18327397108078003, 0.14315274357795715, 0.019202016294002533, -0.23271721601486206, -0.3149443566799164, -0.09994464367628098, -0.015807246789336205, 0.07796849310398102, 0.09972482919692993, 0.049215178936719894, -0.21622641384601593, -0.005987769924104214, -0.01837591640651226, 0.20846237242221832, 0.05693309009075165, 0.034531671553850174, -0.19937075674533844, -0.39006829261779785, 0.28683537244796753], [0.0997234433889389, -0.15844634175300598, -0.07024186849594116, -0.0018774885684251785, -0.1423559933900833, 0.02943582832813263, -0.023503512144088745, -0.02516188658773899, -0.06336057931184769, 0.09387552738189697, 0.08488050103187561, -0.010982451029121876, 0.10431051254272461, -0.04997687041759491, 0.029123976826667786, -0.07618995755910873, -0.07923347502946854, 0.11244970560073853, -0.16312474012374878, -0.07326400279998779, -0.019483240321278572, 0.0024903551675379276, -0.08126776665449142, -0.03580910339951515, -0.039953429251909256, -0.06855110824108124, -0.14884361624717712, -0.05536313354969025, 0.09457319974899292, -0.11732220649719238, -0.13787801563739777, -0.036688432097435, -0.17356155812740326, -0.05910782888531685, -0.15138591825962067, 0.043982136994600296, 0.06301862001419067, -0.05426747724413872, 0.03330416604876518, -0.024289119988679886, 0.026580648496747017, 0.03662163019180298, 0.02655688114464283, -0.12343345582485199, -0.025200653821229935, -0.013215320184826851, 0.0697612315416336, -0.11035346984863281, -0.09112709760665894, -0.07301846891641617, -0.013127390295267105, 0.005953988526016474, 0.05817476287484169, -0.07393289357423782, -0.005418494343757629, -0.0461074523627758, 0.07710728049278259, -0.13001561164855957, -0.059910375624895096, -0.11808408051729202, -0.05526282638311386, -0.002408042550086975, 0.02984149381518364, 0.03369847685098648], [0.09614304453134537, -0.11593353003263474, -0.14024224877357483, 0.00477065984159708, 0.3017369210720062, -0.0030582083854824305, -0.09667627513408661, 0.09050340950489044, 0.3127392530441284, -0.015178116969764233, -0.12493636459112167, -0.07148436456918716, -0.1121876910328865, -0.11651698499917984, -0.018985329195857048, -0.24594536423683167, -0.04324820265173912, -0.1069967970252037, 0.09773056954145432, 0.2098122239112854, -0.007282930891960859, 0.09574431926012039, 0.37637296319007874, 0.2283470630645752, 0.007656266912817955, 0.23295316100120544, 0.13225112855434418, -0.2704625427722931, 0.08316594362258911, -0.09770277142524719, 0.17989639937877655, -0.09321199357509613, 0.09794016182422638, -0.024971673265099525, -0.1842612475156784, -0.08516047894954681, 0.3356999456882477, -0.2705008387565613, 0.06618145853281021, -0.045317988842725754, 0.24278749525547028, -0.4317089021205902, -0.020044470205903053, 0.04015679657459259, -0.0228754673153162, -0.15355652570724487, 0.0052144890651106834, 0.027653135359287262, -0.3106662631034851, -0.24624890089035034, 0.17717435956001282, 0.1546105295419693, -0.2584117650985718, -0.1929856240749359, 0.13160210847854614, 0.018032541498541832, 0.13224171102046967, 0.06311212480068207, -0.11383384466171265, -0.018117213621735573, 0.1912350058555603, 0.13358265161514282, -0.08856780081987381, -0.10396778583526611], [0.15302638709545135, -0.007061266340315342, -0.06324394792318344, 0.05885985121130943, 0.01781398244202137, 0.2055562287569046, -0.10536922514438629, -0.013095862232148647, 0.1566624790430069, 0.13666953146457672, 0.007421776652336121, 0.03294256329536438, -0.12227430939674377, 0.23538635671138763, -0.11686268448829651, 0.09815983474254608, 0.241437628865242, 0.19149908423423767, -0.08261428773403168, 0.2573806345462799, 0.07989604026079178, 0.1050526425242424, -0.05585232004523277, 0.16104362905025482, 0.059435244649648666, 0.14162883162498474, -0.1800849437713623, 0.36104610562324524, 0.23541133105754852, 0.13801337778568268, -0.07281465828418732, 0.0411512665450573, 0.02406141720712185, 0.1160162016749382, 0.2893027365207672, -0.07256659120321274, -0.39314982295036316, 0.057626742869615555, 0.21539635956287384, 0.2607490122318268, -0.05275062099099159, 0.3219333589076996, -0.3494969606399536, 0.33732837438583374, 0.296062707901001, 0.14220669865608215, -0.16243407130241394, -0.18076804280281067, 0.31501322984695435, 0.18500511348247528, 0.2836027145385742, 0.07938795536756516, 0.10055811703205109, -0.008478711359202862, 0.0918070524930954, 0.3086785674095154, 0.27300313115119934, 0.165214404463768, -0.0992669090628624, 0.0690862238407135, 0.042376335710287094, 0.029746636748313904, 0.3574085235595703, -0.12865479290485382], [0.05960041284561157, 0.23588933050632477, 0.14476315677165985, 0.09657541662454605, 0.1568673998117447, -0.3081928789615631, -0.05049733445048332, -0.011901283636689186, -0.22574558854103088, -0.03415634483098984, -0.021485786885023117, 0.2616490423679352, 0.138910710811615, -0.3795967996120453, 0.2590124309062958, -0.2230633795261383, -0.17500531673431396, -0.15060506761074066, 0.19180545210838318, -0.22452221810817719, 0.2962287962436676, 0.027448736131191254, -0.3450608551502228, -0.1853310763835907, -0.01722625270485878, -0.06760041415691376, -0.027865083888173103, -0.11845336109399796, 0.24178911745548248, 0.1320686787366867, -0.01029184740036726, 0.0766223594546318, 0.07355514168739319, -0.032764092087745667, -0.06107458844780922, -0.015121816657483578, 0.27371343970298767, -0.09280944615602493, 0.07150141894817352, -0.49927857518196106, -0.01617959700524807, 0.343383252620697, 0.14443959295749664, -0.11481969803571701, -0.19017969071865082, 0.001207599532790482, 0.06935995072126389, 0.2649821937084198, -0.2109941691160202, -0.20057815313339233, -0.2138260155916214, -0.11060529947280884, -0.03710438311100006, 0.01630963571369648, -0.07461914420127869, 0.04247146472334862, 0.22969242930412292, 0.3414522707462311, 0.0730690211057663, 0.18127651512622833, -0.08132743090391159, -0.2629200518131256, 0.11348886787891388, 0.22864067554473877], [-0.15999025106430054, -0.16653338074684143, 0.22558332979679108, -0.14910194277763367, 0.002956605516374111, 0.3307424783706665, 0.10174117982387543, 0.19064076244831085, -0.2954680025577545, 0.2305959314107895, 0.07107533514499664, 0.18173722922801971, -0.04661475121974945, 0.2527359127998352, 0.04558044299483299, 0.3257819414138794, 0.33020150661468506, 0.2929685413837433, -0.3440794050693512, -0.2591317892074585, -0.28918251395225525, -0.11196601390838623, -0.23180973529815674, 0.009724979288876057, 0.05810154229402542, 0.03608495369553566, -0.2979610562324524, 0.25970056653022766, -0.38062429428100586, 0.09709355235099792, -0.25728335976600647, -0.3047945201396942, -0.05239521712064743, 0.13874013721942902, 0.26556921005249023, 0.1973501741886139, 0.12777405977249146, -0.33322572708129883, -0.4848196506500244, 0.43249666690826416, 0.03029201366007328, -0.41944438219070435, -0.14297690987586975, -0.02027536928653717, 0.29575780034065247, -0.28580689430236816, 0.0698271319270134, -0.16366495192050934, 0.2747541666030884, 0.1751834750175476, 0.30308207869529724, -0.0630248486995697, -0.3380372226238251, -0.016941551119089127, 0.1556277871131897, -0.21801131963729858, 0.025615721940994263, -0.20460566878318787, 0.07977447658777237, 0.2919211685657501, 0.1381096988916397, -0.3235364258289337, 0.2938527762889862, -0.26560208201408386], [0.07889564335346222, -0.08854711800813675, 0.07378064841032028, 0.09552976489067078, 0.03171944245696068, -0.006754337344318628, 0.07193031907081604, 0.13785478472709656, 0.21791189908981323, 0.045320842415094376, -0.017407553270459175, -0.053145743906497955, -0.09269645065069199, -0.3270516097545624, -0.3659113347530365, -0.3271466791629791, 0.19199678301811218, -0.25835323333740234, 0.07578195631504059, 0.19821327924728394, -0.15690138936042786, 0.09086323529481888, 0.4711008667945862, 0.1987132728099823, -0.04834098368883133, 0.1270475834608078, 0.17357848584651947, -0.19706453382968903, 0.2486165314912796, -0.08638337254524231, 0.27922454476356506, 0.1433175951242447, 0.06408137828111649, 0.14748400449752808, -0.04060822352766991, 0.12458878755569458, -0.23113110661506653, 0.29678595066070557, -0.24447128176689148, -0.04727280139923096, 0.18449968099594116, 0.4814540147781372, -0.13306917250156403, 0.21048329770565033, 0.06869500130414963, 0.2932070195674896, -0.07811275124549866, 0.1916629672050476, -0.13051749765872955, 0.09889986366033554, 0.1549224704504013, 0.18369485437870026, 0.08369599282741547, -0.3208739757537842, -0.16138514876365662, 0.16138465702533722, 0.15745426714420319, 0.1051386296749115, 0.004769113380461931, -0.1787194013595581, 0.2957608699798584, 0.403969943523407, 0.1632891744375229, -0.013388442806899548], [-0.12148311734199524, 0.04073421657085419, 0.11624091863632202, 0.11825595796108246, 0.05020016431808472, 0.10035465657711029, -0.12118200957775116, 0.05080612003803253, -0.005777224898338318, 0.00242730975151062, -0.10540562868118286, -0.12067601084709167, 0.0409872829914093, -0.0006097704172134399, 0.11470049619674683, -0.11104899644851685, 0.004165768623352051, -0.0025383830070495605, -0.07914315164089203, -0.10315105319023132, -0.08146736025810242, -0.05706460773944855, 0.0691346824169159, 0.009744256734848022, -0.029352247714996338, 0.008015096187591553, 0.0420139878988266, -0.04402710497379303, -0.03308425843715668, -0.03723213076591492, 0.10835574567317963, -0.1152460128068924, 0.09993413090705872, -0.07727460563182831, -0.09610053896903992, -0.0782470852136612, 0.10011635720729828, -0.08222223818302155, -0.0653509795665741, 0.10267896950244904, -0.016150012612342834, -0.036944448947906494, -0.0388484001159668, 0.04469896852970123, -0.003936782479286194, -0.10866056382656097, 0.0529799610376358, 0.11492235958576202, 0.03743515908718109, -0.09000533819198608, 0.022847533226013184, -9.688735008239746e-05, -0.030377358198165894, -0.07598738372325897, -0.11174964904785156, -0.12284326553344727, 0.042464300990104675, -0.08565157651901245, 0.07362352311611176, -0.03420260548591614, -0.08371753990650177, 0.09564150869846344, -0.03774304687976837, 0.054574280977249146], [0.2129715085029602, 0.013829966075718403, -0.2619667947292328, 0.18159665167331696, 0.16730456054210663, -0.015542261302471161, -0.004483095370233059, 0.25966233015060425, 0.3838402032852173, -0.003796675708144903, -0.06259294599294662, -0.1852216124534607, 0.12632815539836884, -0.1541936844587326, -0.23793189227581024, -0.4747185707092285, 0.20784805715084076, -0.15092040598392487, 0.1746279001235962, 0.1932229846715927, -0.10362736135721207, 0.15115444362163544, 0.43352144956588745, 0.26744890213012695, -0.4793849587440491, 0.37074634432792664, 0.007353499531745911, -0.06316519528627396, 0.09742352366447449, -0.12089987844228745, 0.3510758578777313, 0.0002032089396379888, 0.14150561392307281, 0.10372087359428406, -0.1503978967666626, 0.1378454715013504, -0.06919363886117935, 0.14015153050422668, -0.13133542239665985, -0.16227245330810547, -0.10041169077157974, 0.254764199256897, -0.17607542872428894, -0.06842577457427979, 0.2581818997859955, 0.21029457449913025, 0.06262113898992538, 0.14584822952747345, -0.08050017058849335, -0.04051505774259567, 0.13743436336517334, 0.13767707347869873, -0.08044150471687317, -0.04458724707365036, -0.04983669891953468, 0.18022312223911285, 0.3246886134147644, 0.1580907553434372, 0.04378657788038254, -0.287598192691803, 0.23909929394721985, 0.3906903564929962, -0.007796973921358585, -0.19362008571624756], [0.05062034726142883, -0.18885399401187897, -0.03997781127691269, -0.16082918643951416, -0.03958004713058472, 0.1865469217300415, -0.06998006254434586, 0.22637729346752167, 0.44099077582359314, 0.0029384049121290445, 0.2293723076581955, -0.41158658266067505, -0.2252899706363678, 0.03155982866883278, -0.11410517990589142, -0.23009218275547028, 0.06759525835514069, -0.02882116287946701, 0.05077163502573967, 0.2761770784854889, -0.285016804933548, 0.18814387917518616, 0.3858579993247986, 0.26190003752708435, -0.0411418080329895, 0.2000778466463089, -0.11645946651697159, -0.21608684957027435, 0.05072299391031265, -0.24119386076927185, 0.16399304568767548, 0.016289565712213516, 0.03592821955680847, 0.10599642246961594, 0.018797360360622406, 0.009711037389934063, -0.06209966540336609, -0.1579197496175766, -0.03361526504158974, 0.19339975714683533, -0.06403765082359314, -0.19302622973918915, -0.09139568358659744, 0.30931758880615234, 0.2406875193119049, 0.11756782978773117, -0.04716365784406662, 0.07351001352071762, 0.07410386204719543, -0.1266794204711914, 0.23624464869499207, 0.10863864421844482, 0.26214155554771423, -0.2524396777153015, 0.04790080711245537, 0.05936995893716812, 0.14616172015666962, -0.10030082613229752, -0.10248194634914398, -0.12094009667634964, 0.3120693564414978, 0.5195341110229492, -0.03371927887201309, -0.02238967828452587], [0.15308421850204468, -0.3497255742549896, 0.12350717931985855, -0.05188531056046486, 0.11407113075256348, 0.30583101511001587, 0.07602834701538086, -0.05113103613257408, -0.12474187463521957, 0.08676651120185852, 0.1710333228111267, 0.1587960422039032, -0.03265479952096939, -0.16087384521961212, -0.21260985732078552, 0.6897599697113037, 0.24988049268722534, -0.20854118466377258, -0.31673377752304077, -0.06277580559253693, -0.11565545201301575, -0.08544810116291046, -0.1901477724313736, -0.04347803816199303, 0.13465462625026703, 0.13927093148231506, -0.06042513623833656, -0.012652100063860416, -0.18705642223358154, -0.3126666843891144, -0.21737802028656006, 0.08044160902500153, -0.1468493789434433, 0.13586100935935974, 0.0244560819119215, -0.11142598092556, 0.3389156758785248, -0.007691290229558945, 0.22682350873947144, 0.18355940282344818, -0.12644775211811066, -0.3670070469379425, -0.08460361510515213, 0.037870172411203384, 0.06839131563901901, -0.2639087438583374, -0.0027984757907688618, -0.0795319452881813, 0.05941641703248024, 0.085252545773983, -0.291109174489975, -0.10274317860603333, -0.25224006175994873, 0.21438048779964447, -0.17727966606616974, 0.1304280161857605, 0.022779099643230438, 0.052306607365608215, 0.14721183478832245, -0.17167261242866516, 0.2410403937101364, 0.08547867834568024, 0.186117485165596, 0.06532860547304153], [-0.1327098309993744, -0.04043423756957054, 0.23527002334594727, -0.3892907500267029, -0.010753505863249302, 0.2576722800731659, 0.03535717353224754, 0.16585534811019897, 0.0046712253242731094, 0.24955400824546814, 0.03201855346560478, 0.20234301686286926, -0.18389782309532166, 0.37923774123191833, -0.007225095760077238, 0.1368015557527542, 0.21352733671665192, 0.17597167193889618, -0.1804884672164917, -0.08205237984657288, -0.1415853649377823, 0.012162979692220688, 0.005207839421927929, -0.0643743947148323, 0.1874542534351349, 0.004867025651037693, 0.02737007848918438, 0.24517089128494263, -0.16225625574588776, 0.1368454396724701, -0.11609414219856262, -0.00790605042129755, 0.024119140580296516, 0.2721584439277649, 0.3035999834537506, 0.17144905030727386, -0.0506121926009655, -0.09619597345590591, -0.2358492910861969, 0.45649439096450806, -0.14882420003414154, -0.36079561710357666, 0.08995445817708969, -0.07467417418956757, 0.23191030323505402, -0.1192726269364357, 0.1459578275680542, -0.20436494052410126, 0.1642942875623703, 0.14210473001003265, -0.015174472704529762, 0.2198578417301178, 0.4183793067932129, 0.035189684480428696, 0.030516088008880615, -0.011322308331727982, 0.09850304573774338, -0.17013002932071686, 0.23631559312343597, 0.1619773507118225, 0.0761471539735794, -0.2408633977174759, -0.1362394243478775, 0.09518412500619888], [-0.0077109625563025475, -0.06334401667118073, -0.004902297630906105, 0.07869694381952286, 0.12755601108074188, -0.27820226550102234, 0.017459062859416008, 0.004341500345617533, 0.3002120852470398, -0.04132101684808731, 0.031193595379590988, -0.12410157173871994, 0.0239139162003994, -0.40900492668151855, -0.29991230368614197, -0.5742641687393188, 0.16619594395160675, -0.06040795147418976, 0.017792701721191406, 0.32653188705444336, 0.01841791719198227, 0.24180078506469727, 0.24918074905872345, 0.14725175499916077, -0.14844688773155212, 0.2910313308238983, 0.09510993957519531, -0.25683435797691345, 0.05426472797989845, -0.05196528881788254, 0.1417551189661026, 0.11152970790863037, 0.20434100925922394, -0.0657537430524826, -0.14995935559272766, 0.09204086661338806, -0.0846347063779831, 0.1317165642976761, -0.17702984809875488, -0.13476912677288055, 0.10318546742200851, 0.15814566612243652, -0.05716463178396225, 0.1886952519416809, -0.01029293704777956, 0.26984062790870667, -0.047880347818136215, 0.22955629229545593, -0.053702212870121, -0.10168866813182831, -0.003297757590189576, 0.20849697291851044, -0.17809616029262543, -0.14102455973625183, -0.18910706043243408, 0.16858218610286713, 0.29608282446861267, 0.22950652241706848, -0.032184503972530365, -0.35487672686576843, 0.2605278789997101, 0.4786416292190552, 0.17797093093395233, 0.0031720856204628944], [-0.05843691900372505, -0.0962589755654335, 0.19254788756370544, -0.1813400685787201, -0.011036142706871033, 0.2827470600605011, -0.018850944936275482, 0.13858731091022491, -0.00573670445010066, 0.17523632943630219, 0.04890599101781845, 0.1720641851425171, 0.05247410386800766, 0.4141736328601837, 0.24502329528331757, 0.453445702791214, 0.17483355104923248, 0.261613130569458, 0.023987792432308197, -0.15627315640449524, -0.1508418619632721, 0.08298008888959885, -0.1569463163614273, 0.08955027163028717, 0.21059063076972961, 0.013063748367130756, -0.049717918038368225, -0.026101455092430115, -0.10239382833242416, 0.15521754324436188, -0.053262859582901, 0.10242132097482681, 0.10646738857030869, 0.2062574326992035, 0.26105862855911255, 0.037750616669654846, -0.010851133614778519, -0.28843653202056885, -0.2259187400341034, 0.4059641659259796, 0.06591338664293289, -0.4059606194496155, 0.3212226331233978, -0.28819921612739563, 0.13281425833702087, -0.09407555311918259, 0.18485018610954285, -0.10951334983110428, 0.04298644885420799, 0.0944017544388771, -0.10901279747486115, -0.12236109375953674, 0.18283091485500336, 0.20411543548107147, 0.07111401855945587, -0.33330002427101135, -0.18629762530326843, -0.3068479001522064, 0.18563814461231232, 0.13157814741134644, -0.038551103323698044, -0.17896521091461182, -0.27359533309936523, 0.15862450003623962], [0.16087618470191956, 0.11114408820867538, 0.08390019088983536, 0.14294995367527008, 0.05884932726621628, 0.33449873328208923, 0.06498591601848602, 0.17239727079868317, 0.19585047662258148, 0.15979894995689392, -0.049455512315034866, 0.06730173528194427, 0.15745694935321808, 0.229559987783432, -0.14089080691337585, 0.0498507097363472, 0.3156919777393341, 0.07817920297384262, 0.04942682012915611, 0.35245639085769653, 0.15335485339164734, 0.09617359936237335, 0.23082470893859863, 0.28310519456863403, 0.1448265165090561, 0.2890883684158325, -0.23569782078266144, 0.1391969919204712, 0.1868836134672165, 0.0974070206284523, 0.05459412932395935, 0.15626078844070435, -0.010614418424665928, 0.1272536963224411, 0.20035266876220703, 0.11273058503866196, -0.4432827830314636, -0.11631444841623306, 0.023862849920988083, 0.13614603877067566, -0.06918054819107056, 0.15822377800941467, -0.30064910650253296, -0.16258692741394043, 0.1523682177066803, 0.1440925896167755, -0.005765756592154503, -0.0030644317157566547, 0.24508599936962128, 0.21801047027111053, 0.3947031497955322, 0.17962424457073212, 0.07909870892763138, -0.008172089233994484, -0.028714805841445923, 0.00025450997054576874, 0.07499115914106369, 0.15781502425670624, -0.038854051381349564, -0.04375888407230377, 0.09147093445062637, 0.3621467649936676, 0.37015312910079956, -0.24370023608207703], [-0.004624808672815561, -0.1638432741165161, -0.28319287300109863, -0.003007762599736452, 0.0898476094007492, 0.09048747271299362, -0.06212080270051956, 0.1995493769645691, 0.4712194502353668, -0.00047480282955802977, -0.03539177402853966, -0.3055972754955292, -0.18730206787586212, -0.2603895366191864, -0.1482953429222107, -0.31737780570983887, 0.10472311824560165, -0.3242083191871643, 0.13409000635147095, 0.3656226098537445, -0.24255973100662231, 0.13991473615169525, 0.3556874394416809, 0.3263845443725586, -0.2421993464231491, 0.17725171148777008, 0.08756481111049652, -0.020540453493595123, 0.06492320448160172, -0.19785025715827942, 0.2671407163143158, 0.15993967652320862, 0.17067982256412506, 0.08385215699672699, -0.1436418741941452, 0.11489130556583405, -0.1693347841501236, -0.2545473575592041, -0.10019458085298538, 0.00490465946495533, -0.027667883783578873, -0.22696255147457123, -0.21421174705028534, 0.02996298298239708, 0.22796612977981567, 0.10870504379272461, 0.19468733668327332, 0.03254903480410576, -0.23140431940555573, 0.024510646238923073, 0.1521201878786087, 0.12687548995018005, -0.04864633455872536, -0.2592765986919403, 0.0011962875723838806, -0.0004397193843033165, -0.015588639304041862, 0.06675764918327332, -0.049565162509679794, -0.18374280631542206, 0.4144308567047119, 0.3646564781665802, 0.10502025485038757, 0.10221153497695923], [-0.006327617913484573, 0.015877382829785347, -0.002275985898450017, -0.027100082486867905, 0.23328080773353577, -0.05610380694270134, 0.09576382488012314, -0.20434068143367767, -0.14465799927711487, -0.05087055638432503, -0.00867090467363596, -0.1279660016298294, 0.0843857154250145, -0.236798495054245, 0.07484246790409088, -0.16904333233833313, -0.040030110627412796, -0.09322237968444824, 0.040718212723731995, -0.1197635754942894, -0.16876329481601715, -0.04784029722213745, -0.017338547855615616, 0.011234473437070847, -0.00947071798145771, 0.03811461105942726, -0.28269755840301514, -0.043985601514577866, 0.096031054854393, 0.16589684784412384, -0.05212652310729027, -0.02713717147707939, -0.155826598405838, -0.053769297897815704, -0.11618471890687943, 0.17185498774051666, -0.2917172610759735, -0.028023026883602142, 0.11673133820295334, -0.12525738775730133, 0.06106657534837723, 0.21089483797550201, -0.047541603446006775, 0.04041770100593567, -0.03633926063776016, 0.14640472829341888, -0.015111214481294155, 0.02910132333636284, -0.02121974341571331, 0.15354852378368378, -0.026585357263684273, -0.011172386817634106, 0.12926864624023438, -0.2326747477054596, 0.11193034797906876, -0.03060855343937874, 0.0024079428985714912, -0.013164440169930458, -0.04039377719163895, -0.1844017058610916, -0.04664299637079239, 0.0669889897108078, -0.06448600441217422, -0.13086873292922974], [-0.06891915202140808, 0.015719959512352943, -0.05330934002995491, 0.11759956181049347, -0.03249409794807434, 0.03684167563915253, -0.003786921501159668, -0.0024242170620709658, -0.14316539466381073, 0.002805840689688921, 0.053864479064941406, -0.11129734665155411, 0.014593049883842468, -0.0104348910972476, 0.023477137088775635, 0.02384098805487156, -0.05366068333387375, -0.07742318511009216, -0.06400419026613235, 0.09645777940750122, -0.05057891458272934, -0.12901972234249115, -0.08351817727088928, 0.017775148153305054, 0.0874534323811531, -0.11230701208114624, -0.06570711731910706, 0.061967819929122925, -0.09724240750074387, 0.08153675496578217, 0.08024175465106964, -0.031376663595438004, -0.01038856990635395, -0.12235385179519653, 0.03734537959098816, -0.00018027906480710953, -0.05595880746841431, -0.09620390832424164, -0.025187304243445396, -0.10680951178073883, -0.11893181502819061, -0.08258490264415741, 0.004426151514053345, 0.08550778776407242, -0.07547397166490555, -0.032027117908000946, -0.11933109164237976, 0.015528153628110886, -0.07410217821598053, -0.09871657937765121, 0.014850735664367676, -0.05429467558860779, 0.005121534690260887, -0.09714299440383911, -0.12442326545715332, -0.02601727657020092, 0.10334786772727966, -0.021845629438757896, -0.019469009712338448, 0.04827907308936119, 0.027657348662614822, -0.00858021154999733, -0.037180542945861816, -0.07089363783597946], [-0.06832686066627502, -0.12321536242961884, -0.047811273485422134, -0.040748924016952515, 0.050601065158843994, 0.12443511188030243, 0.07252025604248047, 0.059716224670410156, -0.029443442821502686, -0.10792268067598343, -0.022222528234124184, -0.11505649983882904, 0.053025584667921066, -0.11089174449443817, 0.12481427192687988, 0.03997223079204559, -0.039890825748443604, -0.04078282415866852, -0.09426415711641312, -0.03848858177661896, 0.0770847350358963, 0.05080599710345268, 0.0032573440112173557, 0.09243449568748474, -0.04635334387421608, 0.045043621212244034, 0.08945707976818085, 0.01757359504699707, 0.03448417782783508, -0.1454572230577469, 0.06079097092151642, 0.04356155917048454, -0.04027585685253143, -0.08491173386573792, -0.08957210183143616, 0.07792237401008606, 0.03694993257522583, -0.06064852327108383, -0.09706657379865646, 0.07705646753311157, -0.03765125200152397, -0.014220496639609337, 0.057459961622953415, 0.08964236080646515, 0.018976891413331032, 0.11039437353610992, -0.09655540436506271, -0.11762705445289612, 0.12282085418701172, 0.020513564348220825, -0.06487865746021271, -0.07598106563091278, -0.044068269431591034, 0.07961209863424301, -0.04723846912384033, -0.048033207654953, -0.11544249206781387, -0.12279579043388367, -0.08710785955190659, 0.05328941345214844, -0.007475132122635841, -0.004966914653778076, 0.07663269340991974, -0.08019102364778519], [-0.10481087863445282, 0.0399589017033577, 0.23921607434749603, 0.17095084488391876, 0.16596856713294983, -0.05825265496969223, 0.10811091214418411, 0.07254936546087265, 0.16353818774223328, 0.033161453902721405, -0.059341780841350555, 0.17896607518196106, 0.19473303854465485, -0.01473371684551239, -0.32197386026382446, -0.17762961983680725, -0.050488732755184174, 0.030849425122141838, 0.15826159715652466, 0.1376744955778122, -0.06400752067565918, 0.29408106207847595, 0.06372634321451187, 0.19038568437099457, -0.060027021914720535, 0.06520766764879227, 0.02538366988301277, -0.07901781797409058, -0.09485409408807755, -0.11247426271438599, 0.10969307273626328, 0.23247282207012177, 0.18355132639408112, 0.058405183255672455, -0.0851118192076683, 0.2560015618801117, 0.39226678013801575, -0.35224369168281555, -0.1201862245798111, -0.1484941691160202, 0.017236951738595963, -0.32133179903030396, 0.2894638478755951, -0.21702632308006287, 0.17796418070793152, -0.18759877979755402, 0.3656734824180603, 0.05630107596516609, -0.20957623422145844, -0.08304562419652939, -0.29236671328544617, -0.03572330251336098, -0.0752519890666008, 0.05735289305448532, -0.011144254356622696, -0.25414127111434937, 0.09654510021209717, -0.18769891560077667, 0.021040936931967735, -0.06974928826093674, 0.18785898387432098, 0.3923614025115967, -0.3999711573123932, 0.11929210275411606], [0.15573465824127197, 0.12768584489822388, -0.14050841331481934, 0.12039361894130707, 0.04484546557068825, -0.2036350667476654, 0.028118615970015526, -0.19618462026119232, 0.04713303595781326, 0.0863727554678917, 0.006294505205005407, 0.1730356216430664, -0.3566797375679016, -0.23166139423847198, -0.05541939288377762, -0.46111252903938293, -0.016653431579470634, 0.08609971404075623, -0.011259197257459164, 0.17234176397323608, 0.33473557233810425, 0.09408369660377502, 0.07800721377134323, -0.15774253010749817, -0.3343456983566284, 0.11497674882411957, 0.01915775239467621, 0.19369976222515106, 0.2765618860721588, 0.18278194963932037, -0.04637059196829796, -0.36024439334869385, -0.05326654016971588, -0.0811837911605835, -0.0210842527449131, -0.2789822518825531, -0.2013520449399948, 0.11499129980802536, 0.27803730964660645, -0.17603249847888947, 0.09264970570802689, -0.05656806007027626, -0.25446557998657227, 0.19365358352661133, -0.2834402322769165, 0.21821512281894684, -0.23269394040107727, 0.10291901975870132, 0.16031110286712646, 0.15536735951900482, 0.10023410618305206, -0.03138264641165733, 0.09438452869653702, -0.013441184535622597, -0.06573226302862167, 0.4448398947715759, 0.16524317860603333, 0.22823533415794373, -0.15981699526309967, -0.0007120688678696752, -0.05273102596402168, -0.10592300444841385, 0.3590429425239563, -0.20972611010074615], [0.009229267947375774, 0.03831595554947853, 0.0363142304122448, 0.027315573766827583, 0.013936938717961311, -0.17561210691928864, -0.0045268540270626545, 0.06098610907793045, 0.17169314622879028, -0.05125771835446358, 0.017836036160588264, 0.06567268073558807, 0.14263014495372772, -0.11032045632600784, -0.13711699843406677, -0.22829975187778473, -0.10306993871927261, -0.029372166842222214, 0.04318130388855934, 0.09319327026605606, 0.07201793789863586, 0.1877431869506836, 0.04070022702217102, 0.017029574140906334, 0.004728398285806179, 0.16290438175201416, 0.2676684856414795, -0.13798870146274567, -0.0008593567181378603, -0.047667670994997025, 0.145479217171669, 0.20462459325790405, 0.24414171278476715, 0.1341143101453781, -0.02408396266400814, 0.2859644591808319, 0.34672364592552185, -0.1435561627149582, 0.009275275282561779, -0.2978448271751404, 0.24450966715812683, -0.2196563184261322, 0.1309497058391571, -0.2450552135705948, -0.09032520651817322, -0.17377017438411713, 0.1976591944694519, -0.004167740698903799, -0.23115724325180054, -0.3515532612800598, -0.20682622492313385, 0.11233144998550415, -0.21735331416130066, 0.053392618894577026, -0.17286548018455505, -0.25459134578704834, 0.12332658469676971, 0.05371824651956558, 0.13584749400615692, 0.12328299880027771, 0.1245693638920784, 0.20976172387599945, -0.29342374205589294, 0.14309994876384735], [0.09115700423717499, 0.08446333557367325, -0.19698885083198547, -0.10522948205471039, 0.3253607451915741, 0.014473466202616692, 0.12122324854135513, 0.26798853278160095, 0.315703421831131, -0.029219316318631172, 0.08283175528049469, -0.4788047671318054, -0.07388114184141159, -0.15817834436893463, 0.14011746644973755, 0.1156763881444931, 0.32694077491760254, -0.1462404429912567, 0.022517910227179527, 0.3910388648509979, -0.12960979342460632, 0.08902864158153534, 0.527540922164917, 0.2939096689224243, -0.3113972544670105, 0.34454554319381714, 0.02799435704946518, -0.11254416406154633, 0.16269968450069427, -0.05663886293768883, 0.45199477672576904, 0.08900440484285355, 0.13226793706417084, 0.13370545208454132, 0.012165896594524384, 0.1516229659318924, -0.028125660493969917, -0.15218284726142883, -0.27676448225975037, -0.11268646270036697, -0.1097228154540062, -0.3614714741706848, -0.12979482114315033, 0.08853626996278763, 0.3101102113723755, 0.072486512362957, 0.2635520398616791, 0.04883648455142975, 0.10693234205245972, 0.0006189513369463384, 0.2133888155221939, 0.23814909160137177, 0.18822437524795532, -0.008579198271036148, -0.010094593279063702, 0.1723668873310089, 0.11478662490844727, -0.07962194085121155, -0.08959729224443436, -0.22189141809940338, 0.5068773031234741, 0.38379862904548645, -0.10582662373781204, -0.23435670137405396], [0.033242013305425644, -0.15818174183368683, -0.15616486966609955, -0.07267079502344131, 0.1214379221200943, 0.07086291164159775, 0.09652602672576904, 0.10067753493785858, 0.4453234374523163, 0.030928773805499077, 0.04024474695324898, -0.16953852772712708, 0.028510406613349915, -0.01838999055325985, -0.2525699734687805, 0.08156150579452515, 0.1319851577281952, -0.15004758536815643, 0.0859125629067421, 0.19623512029647827, -0.4483611583709717, 0.17462396621704102, 0.5250223875045776, 0.3979147672653198, -0.044471610337495804, 0.31639546155929565, 0.11865423619747162, -0.014483380131423473, 0.08727094531059265, -0.12186374515295029, 0.23998907208442688, 0.12032592296600342, 0.10116883367300034, 0.020195327699184418, -0.21883948147296906, 0.17560157179832458, 0.05475914105772972, -0.34831395745277405, -0.7611329555511475, -0.17561110854148865, -0.037512145936489105, -0.6885138154029846, -0.015184042975306511, 0.06419616937637329, 0.20451568067073822, -0.23612260818481445, 0.1400943100452423, -0.021078409627079964, -0.15873268246650696, -0.11908584833145142, 0.3229459822177887, 0.07236362248659134, 0.21644937992095947, 0.09663230180740356, 0.1837790310382843, 0.03774411976337433, 0.10918990522623062, -0.2942480742931366, 0.03856121748685837, 0.19472560286521912, 0.18247416615486145, 0.262895792722702, -0.02751837484538555, 0.09270184487104416], [0.1546235829591751, -0.06663057953119278, -0.029047541320323944, 0.15644828975200653, 0.08511317521333694, 0.13138613104820251, 0.03975649178028107, 0.14625383913516998, 0.24957022070884705, 0.20452967286109924, 0.23991870880126953, 0.04265886917710304, -0.05951238051056862, 0.06807762384414673, -0.05517560616135597, -0.019534265622496605, 0.07763832062482834, 0.06568840891122818, 0.09529047459363937, 0.32357385754585266, 0.0017843750538304448, 0.0046623991802334785, 0.10005632787942886, 0.24928541481494904, 0.04986428841948509, 0.20359227061271667, -0.19520626962184906, 0.1627665013074875, 0.22323597967624664, 0.16589725017547607, 0.06212379410862923, -0.15925346314907074, 0.1267152726650238, 0.10619709640741348, 0.2700416147708893, 0.014851603657007217, -0.3163136839866638, -0.11368370801210403, 0.18134957551956177, 0.1771659255027771, -0.10361596196889877, 0.38407450914382935, -0.36244797706604004, 0.38287195563316345, 0.28496962785720825, 0.1095750629901886, -0.017466820776462555, -0.08428551256656647, 0.32333609461784363, 0.1934746652841568, 0.3551795780658722, 0.2044588029384613, 0.1318301111459732, -0.09215123951435089, -0.020253298804163933, 0.1374538391828537, 0.2674867510795593, 0.07693936675786972, -0.1267017424106598, -0.055059224367141724, 0.11099591851234436, 0.2989909052848816, 0.2325649857521057, -0.3042433261871338], [0.18736426532268524, -0.247531920671463, 0.047287214547395706, -0.12454114109277725, 0.08161937445402145, 0.3474828898906708, -0.13521628081798553, 0.1841801553964615, 0.3247302174568176, 0.15632502734661102, 0.0791000947356224, -0.16370566189289093, 0.08219495415687561, 0.00911959819495678, -0.09747756272554398, -0.053852565586566925, 0.3709273040294647, 0.044476468116045, -0.020764293149113655, 0.18078754842281342, -0.3004967272281647, 0.0824207291007042, 0.40263134241104126, 0.3277926445007324, -0.156859889626503, 0.1542370766401291, 0.04213051497936249, -0.029144158586859703, 0.14248241484165192, 0.0857383981347084, 0.023152664303779602, 0.20389947295188904, 0.14193369448184967, 0.2758117616176605, 0.0004698233096860349, 0.06921903789043427, 0.03278471529483795, -0.04757292568683624, -0.41869956254959106, 0.2766684591770172, 0.09748334437608719, 0.25177907943725586, -0.49867329001426697, 0.05694728344678879, 0.3049451410770416, -0.1106792464852333, 0.009337016381323338, -0.14150267839431763, 0.08811573684215546, -0.013511708937585354, 0.19062218070030212, 0.05884779989719391, 0.0034150020219385624, -0.05250939354300499, -0.08461611717939377, -0.005584724247455597, 0.13498510420322418, 0.0791228786110878, -0.022541740909218788, -0.22096151113510132, 0.24538995325565338, 0.3142467737197876, 0.23368634283542633, -0.2355910837650299], [0.03873388096690178, 0.18864865601062775, 0.08781988173723221, 0.23001503944396973, 0.14019088447093964, -0.42495399713516235, -0.023735376074910164, 0.0044899992644786835, -0.3010861277580261, -0.008773486129939556, -0.09384831041097641, 0.21666277945041656, 0.1650133728981018, -0.33541688323020935, 0.18758301436901093, -0.31043556332588196, -0.13423608243465424, -0.20073121786117554, 0.04824991896748543, -0.23700816929340363, 0.20440027117729187, 0.11245357990264893, -0.43198832869529724, -0.11012599617242813, 0.04934651777148247, -0.14145690202713013, 0.055270787328481674, -0.04290880262851715, 0.1511283963918686, 0.07419943064451218, -0.10916465520858765, 0.21428951621055603, 0.03356232866644859, 0.07318011671304703, 0.006199398078024387, -0.0003863549791276455, 0.2183818221092224, 0.04183360934257507, 0.13280291855335236, -0.29538264870643616, 0.017610987648367882, 0.22327837347984314, 0.2657885253429413, -0.07530593872070312, -0.18744134902954102, 0.1427580565214157, 0.040056806057691574, 0.16729672253131866, -0.2790164053440094, -0.16752122342586517, -0.18809302151203156, -0.15270200371742249, -0.11818422377109528, -0.04499036818742752, -0.1684175431728363, 0.13497541844844818, 0.17701487243175507, 0.17883893847465515, 0.20032742619514465, 0.029340850189328194, -0.11066148430109024, -0.35134458541870117, 0.0686974748969078, 0.22437189519405365], [0.1412012130022049, 0.2168370932340622, -0.0005431771860457957, -0.09117019921541214, 0.0934891402721405, 0.09608297049999237, -0.0813424214720726, 0.03701478987932205, -0.17168086767196655, 0.07246926426887512, -0.06567900627851486, -0.0949486792087555, -0.12090270221233368, -0.050386942923069, 0.46181681752204895, -0.1386772245168686, 0.040543392300605774, -0.22581331431865692, -0.02693922258913517, -0.016893533989787102, 0.11380468308925629, -0.10335544496774673, -0.4737655222415924, 0.04677769914269447, 0.01235144678503275, 0.19456343352794647, -0.09289013594388962, 0.06347674876451492, 0.3551366329193115, 0.052729636430740356, -0.12053273618221283, -0.1546807885169983, -0.10196880996227264, -0.09881740808486938, -0.20786526799201965, -0.00874271523207426, 0.06765654683113098, -0.1702556014060974, 0.2708166539669037, -0.26217973232269287, -0.16868144273757935, 0.3017958998680115, -0.23417949676513672, -0.04853500798344612, 0.09459744393825531, 0.11882741749286652, -0.1409497708082199, 0.11207073926925659, -0.18893377482891083, 0.14393359422683716, -0.29919493198394775, 0.013529877178370953, 0.18377171456813812, 0.12915067374706268, 0.09953311085700989, 0.27169230580329895, 0.024775803089141846, 0.27943941950798035, 0.0032533276826143265, -0.06416167318820953, 0.1638815701007843, -0.13991349935531616, 0.3686950206756592, -0.04506664723157883], [0.05512586236000061, -0.0011859226506203413, 0.24527639150619507, -0.3923111855983734, -0.1497620940208435, 0.33046281337738037, 0.0899224802851677, 0.11356481164693832, -0.2430809587240219, 0.16890816390514374, -0.08202476054430008, 0.20811879634857178, -0.268868625164032, 0.17306214570999146, 0.17654827237129211, 0.46169015765190125, 0.22722718119621277, 0.1819753497838974, -0.16989706456661224, -0.2724488377571106, -0.3635176420211792, -0.013849450275301933, -0.37157273292541504, 0.024137958884239197, 0.2809624671936035, -0.047908373177051544, -0.020185040310025215, 0.21226780116558075, -0.2289903610944748, 0.11117596924304962, -0.14072059094905853, -0.20552073419094086, -0.04399442300200462, 0.062474459409713745, 0.32876357436180115, 0.24358351528644562, 0.017333563417196274, -0.14106610417366028, -0.105166494846344, 0.4002015292644501, -0.09925313293933868, -0.21958497166633606, -0.011221608147025108, -0.024398600682616234, 0.30678364634513855, -0.29651209712028503, -0.01712421327829361, -0.38676273822784424, 0.26363515853881836, 0.17976105213165283, -0.020823506638407707, -0.02530796080827713, 0.13963033258914948, 0.01572183147072792, 0.10988633334636688, -0.19574664533138275, -0.18349173665046692, -0.22080588340759277, 0.16290153563022614, 0.02330951765179634, 0.033054254949092865, -0.23896434903144836, 0.12874746322631836, 0.020056987181305885], [0.13317304849624634, -0.04149659723043442, 0.1871931552886963, -0.09005802869796753, 0.17446103692054749, 0.3154575228691101, -0.03506751358509064, 0.01471799612045288, -0.2419419139623642, 0.27416643500328064, 0.15846115350723267, 0.20385801792144775, -0.0906822457909584, 0.04856674745678902, 0.3034972846508026, 0.014375253580510616, 0.12598423659801483, 0.171269491314888, -0.19046778976917267, -0.30965137481689453, -0.10177989304065704, 0.010735617019236088, -0.27658402919769287, -0.2387889325618744, 0.24064868688583374, -0.07736027985811234, -0.13168379664421082, 0.3005511462688446, 0.04600629210472107, 0.3712614178657532, -0.2572786509990692, -0.057141464203596115, -0.07534248381853104, 0.2872176468372345, 0.2571675479412079, -0.12456603348255157, -0.2384723275899887, 0.0601142942905426, -0.029825588688254356, 0.24565082788467407, -0.18032652139663696, 0.3425864279270172, -0.10130134224891663, 0.16878047585487366, 0.03807998076081276, 0.06274648010730743, -0.15242938697338104, -0.08855773508548737, 0.3577306866645813, 0.21761663258075714, 0.2680491507053375, -0.030334148555994034, 0.1584012359380722, 0.07303792983293533, 0.1745864301919937, 0.14219847321510315, 0.009119848720729351, 0.2650923430919647, 0.21550352871418, -0.047079745680093765, -0.07916183769702911, -0.3174757659435272, 0.37030258774757385, -0.14038799703121185], [0.08815192431211472, -0.13260844349861145, 0.14200185239315033, -0.24257169663906097, -0.044600751250982285, 0.29463058710098267, 0.124241404235363, 0.054096195846796036, -0.27209267020225525, 0.25845271348953247, -0.08122801780700684, 0.11973639577627182, -0.19402208924293518, 0.061583489179611206, 0.2603294849395752, 0.1555173546075821, 0.2861114740371704, 0.4007969796657562, -0.17356158792972565, -0.15097849071025848, -0.20909936726093292, 0.016484834253787994, -0.2165711373090744, -0.28581252694129944, 0.22010387480258942, 0.0757862851023674, -0.3540906608104706, 0.34201371669769287, -0.03827538341283798, 0.23213545978069305, -0.16963374614715576, -0.4089508652687073, 0.030602866783738136, 0.11991654336452484, 0.2244589477777481, 0.019533047452569008, -0.22617721557617188, -0.004733724053949118, 0.019130369648337364, 0.20954279601573944, -0.11261679977178574, 0.19442814588546753, -0.032057903707027435, 0.22776663303375244, 0.1378263384103775, 0.0468241423368454, -0.13159261643886566, -0.2467484176158905, 0.2767219543457031, 0.25871312618255615, 0.380785197019577, -0.0781586617231369, 0.0752795934677124, -0.23080991208553314, 0.11683055758476257, 0.07341502606868744, 0.19687867164611816, 0.07962848991155624, 0.012924683280289173, 0.01562979258596897, -0.13658404350280762, -0.39457616209983826, 0.3237784206867218, -0.22408494353294373], [-0.08414629846811295, -0.12183918803930283, -0.07927244156599045, -0.060818709433078766, 0.1112515926361084, -0.10872170329093933, -0.043985992670059204, -0.12921835482120514, 0.00682790344581008, 0.08598113805055618, 0.06425352394580841, -0.05993235856294632, 0.033679015934467316, 0.011761230416595936, -0.06849855184555054, 0.03642582893371582, -0.07688427716493607, 0.00014203831960912794, -0.03535564988851547, -0.03913367539644241, -0.0011484459973871708, -0.08974526077508926, 0.02810094691812992, 0.06524109840393066, -0.0022443486377596855, -0.055647820234298706, -0.08187425136566162, -0.04655153676867485, -0.08762922883033752, 0.06627687066793442, -0.12088771909475327, 0.037463121116161346, -0.05259318649768829, -0.09091926366090775, -0.047487370669841766, -0.10443044453859329, 0.07000335305929184, -0.09350735694169998, -0.028510596603155136, -0.09382818639278412, 0.0959211215376854, -0.08036287128925323, 0.06286066770553589, -0.13044476509094238, -0.14638613164424896, 0.07223441451787949, 0.05180738866329193, 0.06308172643184662, -0.08347741514444351, -0.018850235268473625, -0.15264500677585602, -0.09458433836698532, -0.05186206102371216, 0.049952130764722824, 0.11243602633476257, -0.07759380340576172, -0.13481563329696655, -0.09548495709896088, -0.10557612776756287, 0.016028333455324173, 0.06066727265715599, -0.0811678022146225, -0.019627464935183525, -0.047978464514017105], [0.035108644515275955, -0.17455251514911652, -0.11037471890449524, -0.08931270986795425, 0.019230086356401443, -0.013260659761726856, 0.12416528165340424, 0.08966799825429916, 0.47841551899909973, 7.40163231967017e-05, -0.032638367265462875, -0.24649806320667267, -0.1190268024802208, -0.15928751230239868, -0.2040509134531021, -0.1316593736410141, 0.17473219335079193, -0.15048877894878387, 0.06782013922929764, 0.3160662055015564, -0.19970683753490448, 0.2510462701320648, 0.3082028329372406, 0.27300068736076355, -0.25954166054725647, 0.24196964502334595, 0.09234608709812164, -0.20740850269794464, -0.0005444855778478086, -0.30169084668159485, 0.16072651743888855, -0.016277719289064407, 0.1484508514404297, 0.10112807899713516, -0.0067456988617777824, 0.19336822628974915, -0.09888429939746857, -0.14536496996879578, -0.36849144101142883, -0.05213811248540878, 0.07939073443412781, -0.2015656679868698, -0.13730517029762268, -0.012656212784349918, 0.3424299955368042, 0.09242554754018784, 0.08616780489683151, 0.16216130554676056, 0.036558449268341064, -0.0682138130068779, 0.1578802615404129, 0.10000242292881012, 0.009250061586499214, -0.14811672270298004, 0.13036292791366577, -0.03205430507659912, 0.04087218642234802, -0.15195243060588837, -0.133835107088089, -0.20163093507289886, 0.3080475926399231, 0.3785281181335449, -0.22749866545200348, -0.09176360815763474], [-0.11804607510566711, 0.08099927008152008, 0.0390179306268692, 0.023749887943267822, 0.061565108597278595, 0.10858490318059921, 0.05155961215496063, -0.097428098320961, -0.13192537426948547, 0.07024659216403961, -0.053659409284591675, 0.02403036318719387, 0.03322974964976311, 0.10826309025287628, 0.10460485517978668, 0.004736031871289015, -0.0889725610613823, 0.00957186333835125, -0.04243243858218193, -0.034954920411109924, 0.0920979231595993, -0.04060406610369682, -0.04736252874135971, 0.044225119054317474, 0.10237590968608856, 0.01457457896322012, 0.02763240970671177, 0.052965398877859116, -0.02862592227756977, -0.00116350082680583, 0.05733606964349747, -0.003210560418665409, -0.037137437611818314, 0.019194455817341805, -0.05612972006201744, -0.01708281971514225, 0.08075057715177536, -0.13907690346240997, -0.03134627640247345, 0.11781053245067596, 0.02793802320957184, -0.1409786343574524, -0.1663266122341156, -0.1283854991197586, -0.12765932083129883, -0.027798118069767952, -0.04298946261405945, -0.09370342642068863, -0.1306120902299881, -0.11424251645803452, -0.08499700576066971, -0.14903365075588226, -0.0013381100725382566, 0.030041152611374855, 0.10775837302207947, -0.1628110706806183, 0.08004570007324219, 0.07427824288606644, -0.029965531080961227, -0.013896198943257332, -0.08611223101615906, -0.0319998599588871, -0.04757470637559891, -0.14416325092315674], [-0.02102005109190941, 0.028466559946537018, 0.3099018931388855, 0.032701365649700165, -0.07977970689535141, -0.016474466770887375, 0.10707495361566544, 0.0018579704919829965, -0.1515849530696869, 0.04879564046859741, 0.04141900688409805, 0.08739733695983887, 0.2215108573436737, 0.034770697355270386, 0.15186522901058197, 0.2318074107170105, 0.07234745472669601, -0.010750028304755688, 0.11590409278869629, -0.07778076082468033, 0.020467722788453102, 0.15243218839168549, -0.12241432815790176, 0.05576743185520172, 0.29402706027030945, -0.04981067031621933, 0.013957892544567585, -0.1025673970580101, -0.1509326994419098, 0.10016626119613647, -0.15752682089805603, 0.2855338454246521, 0.19071626663208008, 0.19223953783512115, -0.09862042963504791, 0.15499238669872284, 0.17203941941261292, -0.24397341907024384, -0.22709307074546814, -0.042829591780900955, -0.007341805845499039, -0.33593520522117615, 0.37055665254592896, -0.2960161566734314, 0.00015302139217965305, -0.15751974284648895, 0.3485303223133087, 0.10469568520784378, -0.2211441546678543, -0.2322310507297516, -0.19558924436569214, -0.07573196291923523, 0.04471560940146446, 0.2046160250902176, -0.03168259561061859, -0.1444341242313385, -0.04689445719122887, -0.1956327110528946, 0.24966087937355042, 0.1762021780014038, -0.06584537774324417, -0.22947004437446594, -0.2939273715019226, 0.14783914387226105], [-0.050873156636953354, 0.022940892726182938, 0.12029211223125458, -0.10256589949131012, 0.24239574372768402, -0.30552002787590027, 0.12661023437976837, 0.025697560980916023, 0.39706748723983765, 0.09897683560848236, -0.014345254749059677, -0.15938466787338257, 0.011181102134287357, -0.12299764156341553, -0.23906831443309784, -0.39794179797172546, 0.024386612698435783, -0.0702013373374939, 0.024517683312296867, 0.2082662731409073, -0.16742272675037384, 0.3086003065109253, 0.36009880900382996, 0.24649356305599213, -0.24090850353240967, 0.16643603146076202, 0.07776210457086563, -0.008800249546766281, 0.15074996650218964, -0.17581912875175476, 0.3705531656742096, 0.14441201090812683, 0.2569001615047455, 0.06066002696752548, -0.11582314223051071, 0.14266732335090637, 0.09878041595220566, -0.26638177037239075, -0.24995245039463043, -0.22105777263641357, 0.021322855725884438, -0.2405203878879547, 0.16399766504764557, -0.09377303719520569, 0.12621064484119415, 0.08306383341550827, 0.10670000314712524, 0.21590843796730042, -0.20207920670509338, -0.2300790399312973, -0.12893356382846832, 0.15372850000858307, -0.08268411457538605, -0.12529197335243225, 0.029412027448415756, -0.10858878493309021, 0.08677887916564941, 0.011397058144211769, 0.04616986960172653, -0.3422457277774811, 0.10602840036153793, 0.47312772274017334, -0.3042156994342804, 0.1677984893321991], [0.1901182234287262, 0.2982693612575531, -0.021201765164732933, 0.2773887813091278, 0.09165618568658829, -0.3712240755558014, 0.13566410541534424, -0.09355665743350983, -0.06815660744905472, 0.09079355001449585, 0.055677831172943115, 0.009012301452457905, 0.0052680992521345615, -0.34394532442092896, -0.06049003824591637, -0.43928107619285583, 0.03765758126974106, -0.1470949351787567, 0.05029482766985893, -0.10409297049045563, 0.31543487310409546, 0.009903364814817905, 0.10452170670032501, -0.15827487409114838, -0.08209767937660217, 0.12432970851659775, 0.13485673069953918, -0.1864241659641266, 0.25402599573135376, 0.06196827441453934, 0.18455255031585693, 0.08420500159263611, 0.042796749621629715, -0.0030907036270946264, -0.04475662484765053, -0.0058691916055977345, 0.13336846232414246, 0.04816935583949089, 0.09807094931602478, -0.4465195834636688, -0.051241181790828705, 0.35255518555641174, -0.06321075558662415, 0.08766482025384903, -0.07045537233352661, 0.13612577319145203, 0.0002221074391854927, 0.24305683374404907, -0.003602605313062668, -0.1592944860458374, -0.05184433236718178, 0.15548282861709595, -0.23578263819217682, -0.08283240348100662, -0.02190561778843403, 0.16460883617401123, 0.23329058289527893, 0.23831894993782043, -0.014463257975876331, 0.0006314588245004416, -0.019138135015964508, 0.05213059484958649, 0.3067326843738556, 0.1071397066116333], [-0.002939612837508321, -0.04677712172269821, 0.06684607267379761, -0.03935438022017479, 0.004953242838382721, 0.029731718823313713, -0.11705955862998962, -0.023975340649485588, -0.10891649127006531, -0.11917906254529953, -0.0618821382522583, -0.06643686443567276, -0.039495475590229034, -0.047824159264564514, -0.052657559514045715, -0.05411234125494957, -0.021691499277949333, -0.08858606219291687, -0.025522656738758087, 0.0028105557430535555, 0.002830465091392398, -0.13454653322696686, 0.06136322766542435, -0.15495090186595917, -0.019050847738981247, 0.005173773039132357, -0.1893216222524643, 0.00773650873452425, -0.08979278802871704, 0.08760424703359604, 0.1262865960597992, -0.11288435757160187, 0.03602093830704689, 0.10293573141098022, -0.06369040906429291, 0.004332949873059988, -0.14668965339660645, 0.058423642069101334, -0.04694017395377159, -0.008457275107502937, 0.04143436625599861, -0.09614965319633484, -0.10915230214595795, -0.17320774495601654, -0.059766240417957306, -0.03255251422524452, 0.05986016243696213, -0.06080937758088112, -0.06902816146612167, 0.07699687033891678, -0.020258761942386627, 0.02602093107998371, 0.04158766195178032, 0.059742145240306854, 0.029587049037218094, -0.05182605981826782, 0.05585801228880882, 0.07523228973150253, -0.11494626104831696, -0.09850777685642242, -0.10054707527160645, -0.026113973930478096, 0.1527533233165741, 0.12308047711849213], [0.01753108948469162, 0.34527587890625, -0.03169503062963486, 0.053161635994911194, -0.043430350720882416, -0.3135467767715454, 0.0569746233522892, 0.0051532331854105, -0.2577272355556488, 0.045073214918375015, 0.0649280995130539, 0.11925811320543289, 0.14710721373558044, -0.27219510078430176, 0.2484600692987442, -0.3636549711227417, -0.20512549579143524, -0.15019606053829193, 0.08225781470537186, -0.44542816281318665, 0.09296964108943939, 0.038321446627378464, -0.44918060302734375, -0.3471214473247528, -0.0944134071469307, -0.30205637216567993, 0.16554546356201172, 0.060413770377635956, 0.13560906052589417, 0.01638270914554596, -0.09585198014974594, 0.174202099442482, 0.12728120386600494, -0.13543066382408142, -0.11474128067493439, -0.05289003252983093, 0.28672027587890625, 0.009807610884308815, 0.15554498136043549, -0.46918725967407227, 0.028930053114891052, 0.32979637384414673, 0.11921780556440353, -0.04076336324214935, -0.26137638092041016, 0.014313613064587116, 0.0745893120765686, 0.12636223435401917, -0.026823554188013077, -0.13940852880477905, -0.3296947479248047, -0.11619165539741516, -0.1703704595565796, 0.0004832267586607486, -0.06480082124471664, 0.050947993993759155, 0.06203657388687134, 0.311980277299881, 0.07013574987649918, 0.17206622660160065, -0.057890746742486954, -0.1833268254995346, 0.28173717856407166, 0.1167762279510498], [0.23112230002880096, 0.12563584744930267, 0.07996802777051926, 0.05144855007529259, 0.09928422421216965, 0.08699078857898712, -0.042231034487485886, -0.16023023426532745, -0.44977906346321106, 0.17721423506736755, 0.082886703312397, 0.17470860481262207, 0.07173588126897812, -0.012743561528623104, 0.38813352584838867, 0.2016395777463913, 0.02440100535750389, 0.17877808213233948, -0.06146574765443802, -0.25701016187667847, 0.07177089899778366, 0.10346397012472153, -0.4163208305835724, -0.19143696129322052, 0.1425335556268692, -0.2201649397611618, -0.02008773386478424, 0.2916966676712036, 0.11230700463056564, 0.1928333342075348, -0.2888208329677582, 0.1584414392709732, -0.03906482830643654, 0.05263131484389305, 0.24197913706302643, -0.008833477273583412, -0.10982911288738251, 0.03597182407975197, 0.11457298696041107, -0.07331124693155289, -0.1644732654094696, 0.2386091649532318, 0.11258633434772491, -0.11808742582798004, -0.06788670271635056, -0.1112278401851654, -0.04370517656207085, 0.053210094571113586, 0.1937716007232666, 0.1273798793554306, 0.03840787708759308, -0.004546917509287596, 0.23444467782974243, -0.04567936062812805, 0.05990804359316826, 0.327604740858078, 0.24567149579524994, 0.23695366084575653, 0.002043186454102397, 0.14260472357273102, -0.17131485044956207, -0.5007840394973755, 0.4021417796611786, -0.2440931349992752], [-0.006120005622506142, -0.09846889227628708, -0.00823799055069685, -0.12517739832401276, 0.02640901505947113, -0.06222821772098541, 0.02002120018005371, -0.1591941863298416, 0.04129088297486305, -0.08443442732095718, 0.06175946071743965, 0.08111315965652466, -0.06785240024328232, -0.030377661809325218, -0.0002312728320248425, 0.0030306591652333736, -0.10817790776491165, 0.03379284217953682, -0.030145395547151566, -0.10351613909006119, -0.10929040610790253, 0.03367577865719795, 0.020765678957104683, 0.0822334960103035, -0.03160504996776581, -0.1506050080060959, 0.04132084921002388, -0.12291563302278519, -0.12631754577159882, -0.06627791374921799, -0.08698421716690063, -0.07175835967063904, 0.03438756614923477, 0.02389092929661274, 0.051131051033735275, -0.0022006023209542036, 0.08257058262825012, 0.026689404621720314, 0.06803682446479797, 0.08252537250518799, 0.06136230006814003, -0.09675177186727524, -0.11920598149299622, 0.05165828391909599, 0.0002027095906669274, -0.12821221351623535, -0.0369839072227478, -0.028937706723809242, 0.07562373578548431, -0.06018448248505592, 0.08277598023414612, 0.08644285798072815, 0.1140030026435852, 0.030865266919136047, 0.10681420564651489, -0.06236451119184494, 0.06505635380744934, -0.09467172622680664, -0.13485932350158691, -0.05956661328673363, -0.034932494163513184, 0.05889599025249481, 0.022860299795866013, -0.139689102768898], [0.12232492864131927, 0.17153194546699524, -0.1773587167263031, 0.13641905784606934, 0.28096213936805725, -0.14391818642616272, -0.08060126006603241, 0.26071521639823914, 0.4905921518802643, 0.006366088520735502, 0.11782047897577286, -0.37778130173683167, -0.06639175117015839, -0.10379506647586823, -0.0026695651467889547, -0.21541385352611542, 0.36526334285736084, -0.18862563371658325, 0.061192456632852554, 0.412281334400177, -0.1758604347705841, 0.16105866432189941, 0.47351107001304626, 0.3283378779888153, -0.22610251605510712, 0.35165083408355713, 0.09314029663801193, -0.09327921271324158, 0.19577966630458832, 0.05000957474112511, 0.1825055181980133, 0.019692866131663322, 0.16547857224941254, 0.07713712006807327, 0.01410183310508728, 0.07870181649923325, -0.17856954038143158, -0.16570764780044556, -0.2614341974258423, 0.07142031937837601, -0.0922744870185852, 0.29242247343063354, -0.261913925409317, 0.0835462361574173, 0.3097400367259979, 0.14655794203281403, 0.11982934176921844, 0.1236577257514, 0.04588532820343971, -0.2529100179672241, 0.2777940034866333, 0.20859375596046448, -0.04799635708332062, 0.06709923595190048, 0.11168447136878967, 0.13095591962337494, 0.2889646887779236, 0.0031321318820118904, -0.09253499656915665, -0.345217227935791, 0.37325114011764526, 0.28268125653266907, -0.008548455312848091, -0.246193528175354], [0.10409701615571976, -0.2974036633968353, 0.046341244131326675, -0.11801430583000183, 0.04603200778365135, 0.4364575445652008, -0.015468567609786987, 0.4342031180858612, 0.2513531446456909, 0.21353676915168762, -0.0286139864474535, 0.05713998153805733, -0.1006692424416542, 0.19039331376552582, 0.12009268254041672, 0.167297825217247, 0.2483416497707367, 0.11216327548027039, -0.13487794995307922, 0.1735285520553589, -0.18397356569766998, 0.11108924448490143, 0.08185451477766037, 0.1083061620593071, 0.12900736927986145, 0.07498244941234589, -0.06844080984592438, 0.3165683150291443, -0.07228977978229523, 0.16446751356124878, 0.09741715341806412, 0.046309273689985275, 0.014614248648285866, 0.12111668288707733, 0.09329909831285477, 0.23575997352600098, 0.06407070904970169, -0.3204977214336395, -0.26368069648742676, 0.39889195561408997, -0.12684127688407898, -0.03744560480117798, -0.5535424947738647, -0.21065352857112885, 0.33053481578826904, -0.30867183208465576, 0.12629610300064087, -0.05749569088220596, 0.388411283493042, 0.16715002059936523, 0.27134960889816284, 0.01795724779367447, -0.3745432496070862, 0.04811909422278404, -0.06381562352180481, -0.25540101528167725, 0.14412076771259308, -0.02686755172908306, 0.2218121439218521, -0.10729622095823288, 0.062067531049251556, 0.31896740198135376, 0.3271086812019348, -0.1887088268995285], [-0.09544973820447922, -0.14255216717720032, -0.003047530073672533, -0.054492510855197906, 0.003397032618522644, 0.030284002423286438, 0.02526351809501648, 0.05900062248110771, -0.052862998098134995, -0.009018306620419025, -0.07741984724998474, -0.05545032024383545, -0.04513608291745186, -0.06101460009813309, 0.03383876383304596, 0.1225394755601883, -0.08412674814462662, 0.09251311421394348, -0.1140674501657486, 0.0926634818315506, -0.05460977926850319, -0.012948338873684406, 0.05253283306956291, -0.07881344854831696, -0.13192830979824066, 0.0820130929350853, -0.12722280621528625, -0.026680320501327515, 0.021249093115329742, -0.07094258815050125, -0.009055322036147118, 0.025383349508047104, -0.005756337195634842, -0.1594529151916504, -0.04693794250488281, -0.07047027349472046, 0.0488661527633667, 0.08247294276952744, -0.11584392189979553, -0.04963120445609093, 0.043955933302640915, -0.0943133682012558, -0.11369965970516205, -0.02461845614016056, -0.07896832376718521, -0.08145467936992645, -0.10718252509832382, -0.10222315043210983, -0.03189750015735626, -0.0752643495798111, -0.03002827800810337, -0.0653240904211998, -0.022319957613945007, -0.10320943593978882, -0.04606996476650238, -0.16263353824615479, -0.09969784319400787, 0.061135679483413696, -0.05146002396941185, 0.07643987983465195, 0.08520922064781189, -0.013385310769081116, 0.08953770250082016, -0.008519221097230911], [0.1314476877450943, -0.041042253375053406, 0.18429507315158844, -0.23566631972789764, 0.09021476656198502, 0.2943297028541565, 0.056280408054590225, 0.19902653992176056, -0.3083842396736145, 0.2438807338476181, 0.11920855939388275, 0.19346898794174194, -0.2348843365907669, 0.20603466033935547, 0.27976757287979126, 0.3071875274181366, 0.20943452417850494, 0.30456405878067017, -0.19004566967487335, -0.029795721173286438, -0.22434721887111664, -0.21590863168239594, -0.18093813955783844, -0.22454045712947845, 0.27934515476226807, 0.1380840539932251, -0.2427828013896942, 0.35539665818214417, -0.013433016836643219, 0.3141886293888092, -0.18580365180969238, -0.27240678668022156, -0.11833158880472183, 0.14945241808891296, 0.36900392174720764, -0.044570211321115494, -0.0004269362543709576, -0.13846200704574585, -0.03373372182250023, 0.33691680431365967, -0.09924773871898651, -0.018304966390132904, 0.01058355811983347, -0.14670495688915253, 0.12133684754371643, -0.1177392303943634, -0.07758894562721252, -0.23414169251918793, 0.26094526052474976, 0.27512407302856445, 0.13016130030155182, -0.008765561506152153, -0.10355900228023529, -0.048593804240226746, 0.05384838208556175, 0.019196288660168648, 0.28805842995643616, -0.022420506924390793, 0.05859734117984772, -0.02927783504128456, 0.03752846270799637, -0.2041764259338379, 0.15379579365253448, -0.13551218807697296], [0.0383264385163784, -0.10088083893060684, 0.056498609483242035, -0.07925410568714142, 0.03534981980919838, -0.016218319535255432, 0.11259479075670242, 0.07499843090772629, 0.2282620519399643, -0.0786338821053505, -0.135267972946167, 0.0021376805379986763, 0.19531548023223877, 0.26179593801498413, -0.40806081891059875, -0.22252747416496277, 0.11572296172380447, -0.05341539531946182, 0.06763817369937897, 0.23266275227069855, -0.07595288008451462, 0.249484583735466, 0.2817195951938629, 0.18990780413150787, -0.06006878241896629, 0.24330241978168488, 0.16363176703453064, -0.21045194566249847, -0.046822816133499146, -0.12745726108551025, 0.22269697487354279, 0.1775660216808319, 0.07158597558736801, 0.02870660088956356, 0.01954583264887333, 0.2621976137161255, 0.05991588905453682, -0.12633933126926422, -0.033559396862983704, -0.10077900439500809, 0.12030582875013351, -0.3926831781864166, 0.07349046319723129, -0.06677582859992981, 0.10513585805892944, -0.06140211969614029, 0.23593395948410034, -0.022453034296631813, -0.06780809909105301, 0.02705886773765087, 0.048821862787008286, 0.18827293813228607, -0.18384875357151031, -0.08130555599927902, 0.045954447239637375, -0.15710872411727905, -0.05134136229753494, -0.13190436363220215, 0.04376191273331642, 0.17954161763191223, 0.31418779492378235, 0.38954299688339233, -0.37682396173477173, 0.10992593318223953], [0.0898459330201149, -0.058695465326309204, -0.044454120099544525, -0.020947003737092018, 0.10027818381786346, 0.1080918237566948, -0.05208674073219299, 0.05347376689314842, 0.05429229140281677, 0.020260481163859367, -0.13841964304447174, 0.05246550589799881, -0.0031234310008585453, -0.17631563544273376, -0.05780183523893356, 0.02456510253250599, -0.09252689778804779, -0.048136744648218155, -0.10546129941940308, 0.01034540869295597, -0.14277668297290802, -0.14484626054763794, 0.08427001535892487, -0.005622318014502525, 0.05796606093645096, 0.029950499534606934, 0.014798876829445362, -0.04248996451497078, -0.03946669027209282, -0.19570502638816833, 0.09056418389081955, -0.02491847798228264, -0.0638933852314949, -0.07403063029050827, 0.08862021565437317, -0.07658987492322922, 0.027230212464928627, 0.046068061143159866, 0.03486716374754906, -0.044507574290037155, 0.027116825804114342, 0.1007341668009758, -0.04583416134119034, -0.08429999649524689, -0.07225388288497925, -0.048238713294267654, -0.12769334018230438, -0.10302216559648514, 0.004316679667681456, -0.08890724927186966, -0.10736335813999176, -0.027675703167915344, -0.011907156556844711, -0.0057665337808430195, -0.0311703160405159, -0.10832963138818741, -0.04829848185181618, -0.04938369616866112, -0.0796208456158638, 0.10558659583330154, -0.12725688517093658, -0.09420861303806305, -0.03027108870446682, 0.007127933204174042], [0.24767757952213287, 0.029353603720664978, -0.2111762911081314, 0.27651435136795044, 0.17096994817256927, -0.15250717103481293, -0.02188192680478096, 0.0791734829545021, 0.35044100880622864, -0.04952259734272957, -0.14835034310817719, -0.020486047491431236, -0.040893204510211945, -0.16574761271476746, -0.31016889214515686, -0.5070898532867432, -0.07096894085407257, -0.19196286797523499, 0.2054394632577896, 0.330584317445755, 0.183955118060112, 0.100642129778862, 0.2556350529193878, 0.04712245240807533, -0.10256527364253998, 0.128667414188385, 0.15320686995983124, -0.09244106709957123, 0.1778544783592224, 0.0645916610956192, 0.18727271258831024, 0.12285735458135605, -0.016702735796570778, -0.022675149142742157, -0.0999244749546051, -0.08993037790060043, 0.1001594141125679, 0.09497688710689545, 0.10379479080438614, -0.2763645648956299, 0.20389865338802338, 0.06213996559381485, -0.1881125569343567, 0.1056336760520935, -0.07855397462844849, 0.3101637065410614, -0.019549114629626274, 0.07072865962982178, -0.017500337213277817, -0.08220754563808441, 0.1612599939107895, 0.20995815098285675, -0.1979592740535736, -0.0561104491353035, -0.0705023854970932, 0.2766150236129761, 0.32692819833755493, 0.35983017086982727, 0.06548169255256653, -0.10596445202827454, 0.08331204205751419, 0.39102810621261597, 0.3504921495914459, -0.053054966032505035], [0.08013343065977097, 0.11057383567094803, 0.054245658218860626, 0.14007236063480377, 0.031803328543901443, -0.1335742026567459, -0.022430308163166046, 0.030798064544796944, 0.08919931948184967, 0.04713454842567444, -0.08585286140441895, 0.21045202016830444, 0.2607174813747406, -0.16792093217372894, 0.004812313709408045, -0.25864893198013306, -0.12000267207622528, -0.1251441091299057, 0.11530756950378418, 0.010070506483316422, 0.1308618038892746, 0.12390097975730896, 0.03713512420654297, 0.1253979355096817, 0.030796775594353676, -0.05306209251284599, 0.21988113224506378, -0.32988396286964417, -0.0033926628530025482, -0.10993877798318863, 0.04696623980998993, 0.2733990550041199, 0.3552660048007965, 0.10846365243196487, -0.08247438073158264, 0.2282971292734146, 0.515625536441803, -0.2860935628414154, -0.0988306924700737, -0.290319561958313, 0.10925743728876114, -0.23273029923439026, 0.4449521005153656, -0.325668066740036, 0.037242550402879715, -0.07796692848205566, 0.21454595029354095, 0.21214617788791656, -0.2264818698167801, -0.1842401623725891, -0.2298405021429062, -0.035494279116392136, -0.10653019696474075, 0.0013551192823797464, -0.03804759308695793, -0.2670328617095947, 0.047552481293678284, -0.09161227196455002, 0.19877223670482635, 0.12952440977096558, 0.013612779788672924, -0.03713960573077202, -0.3550628423690796, 0.2111741006374359], [0.06775422394275665, -0.08095100522041321, 0.016198942437767982, -0.07488702237606049, -0.06066269055008888, -0.24681879580020905, -0.08740923553705215, 0.19418369233608246, 0.3838268220424652, 0.06556122750043869, 0.04953864961862564, -0.2516530156135559, -0.042685434222221375, -0.3615688979625702, -0.37295296788215637, -0.573210597038269, 0.15168669819831848, -0.17631611227989197, -0.008290008641779423, 0.36492741107940674, -0.10147019475698471, 0.26472344994544983, 0.4165755808353424, 0.23698009550571442, -0.07401423901319504, 0.13325847685337067, 0.09991202503442764, -0.22433099150657654, 0.12752361595630646, -0.14454218745231628, 0.27128905057907104, 0.11738015711307526, 0.18648214638233185, 0.10607878863811493, -0.21478140354156494, 0.0879499763250351, -0.07587124407291412, 0.1953684687614441, -0.13926146924495697, -0.16883954405784607, 0.08412495255470276, -0.14805243909358978, -0.05297062546014786, 0.11631759256124496, 0.10962776839733124, 0.30454736948013306, 0.11120473593473434, 0.06382878124713898, -0.048753771930933, -0.17344556748867035, 0.30238181352615356, 0.12805385887622833, 0.05208968743681908, -0.11939188092947006, -0.20922087132930756, 0.10187140852212906, 0.1591491848230362, 0.02887953817844391, 5.5779652029741555e-05, -0.18098671734333038, 0.24638451635837555, 0.31226301193237305, -0.16148483753204346, 0.1208462044596672], [0.05102653428912163, -0.13407033681869507, -0.109498530626297, 0.02131899818778038, 0.030715515837073326, 0.1063053160905838, 0.10557126998901367, 0.09385640174150467, -0.12353333085775375, -0.09715108573436737, -0.10198605805635452, 0.08529448509216309, 0.010856224223971367, -0.006246595643460751, -0.06182205677032471, -0.09441777318716049, -0.0798424482345581, -0.10626564174890518, -0.07805521786212921, -0.003540715668350458, -0.10401277244091034, -0.1186080127954483, 0.11788082867860794, -0.09763962030410767, -0.0371333509683609, 0.03817127272486687, -0.11926770210266113, -0.08145438134670258, 0.07817661017179489, -0.09667396545410156, -0.15279442071914673, -0.017530495300889015, -0.10393577814102173, -0.0006146514788269997, 0.056483786553144455, 0.06651493906974792, 0.046063072979450226, -0.000998653587885201, -0.18154622614383698, 0.06481471657752991, -0.06618066132068634, -0.020473552867770195, 0.01645241491496563, -0.07648134231567383, 0.05436243116855621, -0.13750652968883514, -0.08258099108934402, -0.04425269365310669, 0.08873815834522247, -0.10760337859392166, -0.04164241626858711, -0.09845848381519318, -0.14532332122325897, -0.0028038963209837675, 0.014129050076007843, -0.12040314823389053, 0.11547886580228806, 0.05701311677694321, -0.03867167979478836, -0.13780540227890015, 0.05894911289215088, 0.035599760711193085, 0.03915529325604439, -0.18544960021972656], [-0.041382912546396255, 0.12815958261489868, 0.03600933775305748, -0.01939505711197853, 0.09531880915164948, -0.2964804172515869, 0.060268256813287735, -0.029084473848342896, -0.44395506381988525, 0.018405044451355934, 0.0471387542784214, 0.07678073644638062, 0.046913858503103256, -0.25780174136161804, 0.21285653114318848, -0.13238760828971863, -0.16505250334739685, -0.18159213662147522, 0.0039843227714300156, -0.3272281587123871, 0.16253845393657684, 0.07002805918455124, -0.35272830724716187, -0.27986517548561096, 0.11635289341211319, -0.12303566187620163, 0.20717112720012665, -0.09523870050907135, 0.0348401740193367, -0.049656063318252563, -0.1804119348526001, 0.24604129791259766, -0.005477393977344036, 0.014641192741692066, -0.2520763874053955, -0.1357116550207138, 0.24792784452438354, -0.1063319593667984, 0.11630041152238846, -0.38988226652145386, 0.017728880047798157, 0.16416959464550018, 0.09258444607257843, -0.15318948030471802, -0.2324107438325882, -0.03214332461357117, 0.1620129942893982, 0.19558607041835785, -0.1714792400598526, -0.10243721306324005, -0.47899574041366577, -0.27896997332572937, -0.01777905784547329, 0.05104174092411995, -0.09596505761146545, -0.014398271217942238, -0.1151202991604805, 0.12330013513565063, 0.12579739093780518, 0.09889546781778336, -0.0680197924375534, -0.301026314496994, 0.10603225231170654, 0.1812155842781067], [0.010495996102690697, 0.12695659697055817, -0.18845641613006592, 0.046359311789274216, 0.10963630676269531, -0.0388016477227211, 0.06239062547683716, -0.07364904880523682, 0.21490785479545593, -0.08382516354322433, 0.0974682942032814, -0.19150562584400177, 0.09318409860134125, -0.02547439932823181, 0.08919873833656311, 0.11723409593105316, 0.03069516085088253, 0.045828305184841156, 0.10893809795379639, 0.1768147498369217, -0.16377496719360352, 0.02933928556740284, 0.021313568577170372, 0.055999431759119034, 0.028467614203691483, -0.039210159331560135, -0.036796484142541885, 0.01290148589760065, 0.1481524407863617, -0.07482335716485977, -0.012305599637329578, 0.13420136272907257, 0.049763813614845276, -0.10071076452732086, 0.09704018384218216, -0.054055772721767426, -0.042096029967069626, 0.13729843497276306, -0.13798370957374573, -0.07435959577560425, -0.08734540641307831, 0.13554370403289795, 0.06797409802675247, -0.1929406374692917, 0.13984085619449615, -0.0063428753055632114, 0.13327939808368683, 0.15593941509723663, -0.11723171919584274, -0.1652890294790268, 0.090594582259655, 0.06481578946113586, -0.0557800754904747, -0.015597499907016754, 0.1099853664636612, 0.07668932527303696, -0.11474600434303284, -0.12646055221557617, -0.17551742494106293, -0.2712615132331848, 0.2360277622938156, 0.0639684870839119, 0.004936790559440851, -0.06911112368106842], [0.005525556858628988, -0.10582706332206726, -0.04980098456144333, -0.03814567252993584, -0.1417958289384842, -0.08949009329080582, 0.06070226430892944, -0.3492128849029541, -0.028608111664652824, -0.11846736073493958, -0.02983867935836315, -0.1156301274895668, -0.0024097764398902655, -0.11496534943580627, -0.09117066860198975, 0.04217053949832916, 0.0887652263045311, -0.06514693051576614, -0.03160810098052025, -0.02411329187452793, 0.07211976498365402, -0.02595803514122963, 0.5083167552947998, -0.13479405641555786, 0.18887726962566376, -0.11898220330476761, 0.07980821281671524, 0.18305453658103943, 0.14516448974609375, 0.07094339281320572, 0.1438974142074585, 0.060643404722213745, -0.03280157223343849, 0.1892717182636261, 0.0765344649553299, -0.126790389418602, 0.7903746962547302, 0.05286644026637077, -0.13030295073986053, 0.01981424354016781, -0.3341215252876282, 0.30018267035484314, -0.019248124212026596, -0.0002782255469355732, 0.13853003084659576, 0.15940719842910767, -0.11789771914482117, -0.02831410802900791, -0.08642157167196274, -0.05842548608779907, 0.054514914751052856, -0.03907362371683121, -0.337335467338562, -0.2674938440322876, -0.034888479858636856, -0.1223955824971199, -0.042536184191703796, -0.19636040925979614, 0.021195298060774803, 0.42958804965019226, 0.16117893159389496, 0.053750596940517426, 0.043615441769361496, 0.18162156641483307], [-0.14220517873764038, -0.2017802745103836, 0.009146886877715588, -0.30646148324012756, -0.30176228284835815, -0.1490315943956375, -0.017962457612156868, -0.15655836462974548, -0.01583860255777836, -0.08106449246406555, 0.08784331381320953, -0.3040417730808258, -0.2569417357444763, -0.09798865020275116, -0.002905820729210973, -0.19119906425476074, 0.1330818235874176, -0.09962489455938339, 0.04135943949222565, -0.18958036601543427, -0.2206198126077652, -0.0859045535326004, 0.03715498000383377, 0.024838855490088463, 0.13638220727443695, -0.16941213607788086, -0.1822604089975357, -0.20755761861801147, 0.037745263427495956, -0.20808155834674835, 0.28086960315704346, -0.10499115288257599, -0.07016262412071228, -0.22000999748706818, -0.0222120750695467, -0.10456974804401398, -0.26925939321517944, 0.03237224370241165, -0.034252069890499115, 0.06952926516532898, -0.17990906536579132, 0.12014798074960709, 0.1498650461435318, 0.31330984830856323, -0.059358399361371994, 0.06602472811937332, -0.00028305198065936565, -0.13519924879074097, 0.15374845266342163, 0.15360459685325623, 0.20819927752017975, -0.04259018227458, 0.15596267580986023, -0.1549324095249176, 0.06882039457559586, 0.26206570863723755, -0.009603019803762436, 0.10472425818443298, 0.06797081232070923, 0.10202178359031677, -0.08954191952943802, 0.3719693720340729, -0.09886715561151505, 0.09904422610998154], [0.04338937625288963, -0.08109989017248154, -0.013745694421231747, 0.10894598066806793, 0.02437591925263405, 0.059615012258291245, -0.09080758690834045, 0.17493490874767303, 0.31645575165748596, 0.14963102340698242, 0.15847426652908325, -0.057994987815618515, 0.04215393587946892, -0.039841428399086, -0.17001710832118988, -0.022482139989733696, 0.2309395968914032, 0.03151841461658478, 0.048386022448539734, 0.35834959149360657, -0.0675010234117508, 0.1938914656639099, 0.16613449156284332, 0.06378716230392456, 0.08077801018953323, 0.32253602147102356, 0.08483262360095978, 0.017521141096949577, 0.22940590977668762, 0.18727976083755493, 0.052337538450956345, -0.05095794424414635, 0.01544348057359457, -0.012967183254659176, 0.008073651231825352, 0.08089238405227661, -0.5168370008468628, 0.16786129772663116, 0.1416458785533905, 0.12482130527496338, 0.06883914023637772, 0.3382968604564667, -0.15795950591564178, 0.2612091600894928, 0.2946791350841522, 0.28058144450187683, -0.1735127866268158, 0.05122850835323334, 0.2728666067123413, 0.20547448098659515, 0.20052723586559296, 0.23510640859603882, 0.14519083499908447, -0.10845199972391129, 0.07246273010969162, 0.3084874153137207, 0.2291453778743744, 0.2293396145105362, -0.05507486313581467, -0.08563416451215744, 0.1410297006368637, 0.39419886469841003, 0.296232670545578, -0.1714167445898056], [0.24091492593288422, 0.035242095589637756, 0.06702785938978195, 0.15684005618095398, 0.08688484877347946, 0.06871815770864487, 0.004604389425367117, -0.06742960214614868, -0.18864493072032928, 0.172831192612648, -0.06314630806446075, 0.16841119527816772, -0.09641949087381363, 0.008129226975142956, 0.4255247712135315, 0.04549752548336983, 0.047436945140361786, 0.28612518310546875, 0.020271074026823044, -0.21779248118400574, 0.2291562706232071, 0.00012175785377621651, -0.41825202107429504, -0.16321274638175964, 0.07159120589494705, -0.0561378076672554, -0.03980867564678192, 0.30614572763442993, 0.05101539194583893, 0.3856125771999359, -0.029669463634490967, -0.16720464825630188, -0.1970377266407013, 0.136202871799469, 0.18034720420837402, -0.16724185645580292, -0.11779314279556274, 0.12816494703292847, 0.17178916931152344, -0.02476705051958561, -0.06950024515390396, 0.2895703911781311, -0.023096518591046333, 0.13579228520393372, 0.08426851779222488, 0.0688110962510109, -0.2437487095594406, -0.06039750948548317, 0.08708455413579941, 0.21283838152885437, 0.306584894657135, -0.03181786835193634, 0.1589081883430481, 0.012920998968183994, 0.11217840015888214, 0.4621089994907379, 0.0903145894408226, 0.2626495957374573, -0.05569613724946976, -0.10521742701530457, -0.14489439129829407, -0.4043782949447632, 0.3356154263019562, -0.13771462440490723], [0.37041401863098145, -0.17478728294372559, 0.2893863618373871, 0.030581269413232803, 0.14217910170555115, 0.5177823305130005, -0.0630456805229187, 0.2849155068397522, -0.08212031424045563, 0.41049593687057495, -0.10284068435430527, 0.3035830855369568, -0.07999683916568756, 0.22046545147895813, 0.18591079115867615, 0.20687884092330933, 0.3809281289577484, 0.4447788894176483, -0.4171035587787628, -0.1788388043642044, -0.22285670042037964, -0.09630021452903748, -0.15454737842082977, -0.14818385243415833, 0.14621612429618835, 0.05869759991765022, -0.16932636499404907, 0.45514005422592163, 0.012382181361317635, 0.15962372720241547, -0.30352702736854553, -0.16852721571922302, -0.31693804264068604, 0.2703966498374939, 0.2634926736354828, 0.24933895468711853, 0.0005934250075370073, 0.06916853040456772, 0.14143821597099304, 0.32633206248283386, -0.15162448585033417, 0.07129267603158951, -0.5698221325874329, 0.07630811631679535, 0.36034899950027466, -0.17071959376335144, -0.24075083434581757, -0.2666785418987274, 0.3967687785625458, 0.35658884048461914, 0.3068675994873047, -0.01215676125138998, -0.4156094789505005, -0.1354411393404007, 0.11310655623674393, -0.022381633520126343, 0.08293477445840836, -0.026689451187849045, 0.1420527994632721, 0.04360754415392876, 0.26638472080230713, -0.12819871306419373, 0.4046599268913269, -0.4431256055831909], [0.272979736328125, -0.26001855731010437, 0.16229109466075897, -0.08433271199464798, -0.1872785985469818, 0.3285294771194458, -0.08281947672367096, 0.20747487246990204, -0.23398509621620178, 0.317281574010849, -0.1269281655550003, 0.2971991002559662, -0.1500723510980606, 0.3901399075984955, 0.011025341227650642, 0.4978055953979492, 0.3761318624019623, 0.4462526738643646, -0.3286522328853607, -0.09470660984516144, -0.19778522849082947, -0.004935718607157469, -0.20333990454673767, 0.023825399577617645, 0.2502880096435547, 0.08472242951393127, -0.2357238382101059, 0.2614050507545471, -0.23446641862392426, 0.2737576365470886, -0.31503671407699585, -0.12083977460861206, -0.21853919327259064, 0.2531047761440277, 0.1871141642332077, 0.19260141253471375, 0.08630376309156418, -0.11371225863695145, -0.11626226454973221, 0.41272279620170593, -0.10340864956378937, -0.24558664858341217, -0.2850358486175537, -0.0737430676817894, 0.47771474719047546, -0.14486803114414215, -0.15980537235736847, -0.32816070318222046, 0.3907487094402313, 0.3894193470478058, 0.1843811720609665, -0.07384839653968811, -0.6396241188049316, -0.06653992086648941, 0.24254584312438965, -0.031067246571183205, 0.07806585729122162, 0.0704912319779396, 0.19922606647014618, 0.03155586123466492, 0.15378659963607788, -0.15746711194515228, 0.3163749575614929, -0.23868267238140106], [-0.01667517051100731, -0.11505257338285446, 0.047378119081258774, 0.015200020745396614, 0.04554189369082451, -0.01915140636265278, 0.08966973423957825, 0.0742940902709961, 0.4392634928226471, 0.11415042728185654, -0.012500039301812649, -0.07248236984014511, -0.07049252837896347, 0.029753316193819046, -0.274321049451828, 0.20742523670196533, 0.16253498196601868, -0.07576624304056168, 0.034347642213106155, 0.3265131711959839, -0.2536531984806061, 0.2845456898212433, 0.2457566261291504, 0.2272631973028183, -0.011170102283358574, 0.22330085933208466, 0.147449791431427, -0.06952796876430511, 0.04174869507551193, -0.16093742847442627, 0.2616056799888611, 0.14020738005638123, 0.09349691867828369, 0.0038645321037620306, 0.07709553092718124, 0.21432065963745117, -0.18201710283756256, -0.14736030995845795, -0.2809700667858124, 0.17529921233654022, 0.006375609897077084, -0.30398330092430115, -0.044409580528736115, 0.10783454775810242, 0.3083605170249939, 0.1365559846162796, 0.07758677750825882, 0.11800184845924377, -0.00027746520936489105, -0.10104743391275406, 0.11126977950334549, 0.1535385698080063, 0.023814748972654343, -0.17596009373664856, 0.03496978059411049, 0.04692201316356659, -0.003706403309479356, -0.15114159882068634, 0.057333484292030334, -0.21688754856586456, 0.1997213065624237, 0.49812453985214233, -0.01151435449719429, 0.19416125118732452], [0.0999651700258255, 0.09565892070531845, 0.02583303675055504, 0.09254077821969986, 0.06893689930438995, -0.3578811287879944, -0.03851187974214554, -0.05921383202075958, -0.06912217289209366, -0.11630243062973022, -0.09664101898670197, 0.06748519092798233, 0.14181363582611084, -0.13479045033454895, -0.0339650884270668, -0.2690829038619995, -0.060393113642930984, -0.11145755648612976, 0.10229115188121796, -0.05450154095888138, 0.11208263039588928, 0.2234320342540741, -0.014360029250383377, -0.07963792234659195, 0.07840265333652496, -0.017549211159348488, 0.17917877435684204, -0.18887683749198914, -0.07198742777109146, 0.01765078492462635, -0.04405297338962555, 0.29589229822158813, 0.07131607830524445, 0.03897988796234131, -0.02918832376599312, 0.1085544228553772, 0.4451668858528137, -0.023767957463860512, -0.21079875528812408, -0.14620806276798248, 0.23036976158618927, -0.3702322244644165, 0.47572892904281616, -0.16539683938026428, -0.12894736230373383, -0.10778375715017319, 0.33478182554244995, 0.23760372400283813, -0.035957496613264084, -0.2396901547908783, -0.19147515296936035, -0.00876371469348669, 0.012035120278596878, 0.13650324940681458, -0.133787140250206, -0.08450581878423691, -0.09734460711479187, 0.08263221383094788, 0.15238147974014282, 0.009860354475677013, 0.02109537273645401, -0.14305372536182404, -0.1641908437013626, 0.39967256784439087], [0.03601522371172905, -0.09250756353139877, -0.1265035718679428, 0.09285193681716919, 0.014595821499824524, 0.06901143491268158, 0.08581481873989105, -0.06488476693630219, -0.052677884697914124, -0.06569267809391022, -0.06518281996250153, -0.15348632633686066, 0.0789046660065651, 0.0904703289270401, -0.12237025797367096, 0.09485886991024017, 0.09469716250896454, -0.0650649219751358, -0.08304621279239655, -0.0616690069437027, 0.056986626237630844, -0.05608881637454033, -0.0839463472366333, 0.08971215784549713, 0.02484568953514099, 0.038990214467048645, -0.09522607922554016, -0.053096652030944824, -0.12898845970630646, 0.05948154628276825, 0.07638955116271973, 0.05274736136198044, -0.057586293667554855, -0.11883403360843658, -0.0857856422662735, 0.03547056391835213, -0.01945720613002777, -0.09229542315006256, 0.04565683379769325, 0.015733540058135986, -0.07589589059352875, -0.031794607639312744, 0.06465036422014236, -0.0739574134349823, 0.05783854424953461, 0.04114801436662674, 0.018628383055329323, -0.05912123620510101, 0.08011996746063232, -0.0813380628824234, -0.11182036995887756, 0.091401606798172, -0.05309648811817169, -0.06283202767372131, 0.008000552654266357, -0.132656529545784, 0.0703773945569992, -0.15077152848243713, -0.07738187164068222, -0.13177910447120667, -0.051604293286800385, -0.045032620429992676, -0.09427234530448914, -0.0874839723110199], [0.13125745952129364, 0.032721564173698425, -0.09958367794752121, 0.07944884896278381, 0.13637223839759827, -0.13638490438461304, -0.08516813069581985, -0.002952386625111103, 0.13027389347553253, -0.014894150197505951, -0.07282549142837524, 0.028233321383595467, -0.09871038794517517, -0.3269067108631134, -0.2033335417509079, -0.4853794276714325, -0.055152446031570435, 0.006033062003552914, 0.005432436242699623, 0.1824731081724167, 0.27917879819869995, 0.09667892754077911, 0.09650430828332901, -0.044753048568964005, -0.16216790676116943, 0.16317050158977509, 0.09508150815963745, -0.14761991798877716, 0.2667497992515564, 0.10589701682329178, 0.2417634129524231, 0.07469146698713303, 0.06922474503517151, -0.14694538712501526, -0.164864182472229, -0.13776835799217224, 0.07279019802808762, 0.17612318694591522, 0.22377263009548187, -0.2942933738231659, 0.004018631298094988, 0.48725107312202454, -0.11591066420078278, 0.02330395020544529, 0.0597149096429348, 0.16223716735839844, -0.03437514975667, 0.1262396275997162, -0.006137403193861246, -0.08350292593240738, 0.026624640449881554, 0.07679108530282974, -0.19351649284362793, 0.006259921472519636, -0.12469349056482315, 0.30442893505096436, 0.31105825304985046, 0.3301195800304413, 0.09211832284927368, 0.02097960375249386, 0.11485958844423294, 0.16675131022930145, 0.36191660165786743, -0.07510252296924591], [-0.0019670191686600447, -0.06260232627391815, 0.10879319161176682, -0.03992750868201256, 0.04899502545595169, 0.25958919525146484, -0.005443270318210125, 0.09560662508010864, 0.3339425325393677, 0.13359872996807098, 0.2042473405599594, -0.10193492472171783, -0.03001999296247959, 0.023057986050844193, -0.27128273248672485, 0.04961881786584854, 0.1357468217611313, 0.044177182018756866, 0.15255102515220642, 0.14232619106769562, 0.03924831748008728, -0.0015529760858044028, 0.23860101401805878, 0.10820968449115753, -0.012774481438100338, 0.2713969945907593, 0.12764428555965424, 0.04889952391386032, 0.09242171049118042, 0.04118591174483299, 0.22831524908542633, 0.011232486926019192, 0.0682801827788353, 0.1480478197336197, 0.062236085534095764, 0.04467445984482765, -0.5977885127067566, 0.19134439527988434, 0.12336212396621704, 0.2550519108772278, 0.04081522673368454, 0.40995505452156067, -0.13261452317237854, 0.19577094912528992, 0.2276194989681244, 0.22141695022583008, 0.02313089743256569, -0.1489202380180359, 0.07696060836315155, 0.23215322196483612, 0.3309567868709564, 0.22815673053264618, 0.04983477666974068, -0.0798511952161789, 0.12214793264865875, 0.2280198633670807, 0.2169760912656784, 0.2677990198135376, -0.06635299324989319, -0.11595460772514343, 0.23831462860107422, 0.2952038645744324, 0.1015159860253334, -0.18860776722431183]], "net.2.bias": [0.2145528793334961, -0.09438155591487885, -0.11063921451568604, 0.04708557575941086, 0.17966020107269287, 0.031017839908599854, 0.15721829235553741, -0.09442026913166046, -0.1685226559638977, 0.14842955768108368, -0.13555768132209778, 0.11572036147117615, 0.1292710304260254, 0.11130266636610031, -0.12765797972679138, 0.09026355296373367, -0.08302071690559387, -0.11059588193893433, -0.07713257521390915, 0.0851699635386467, 0.10141976177692413, 0.027956059202551842, -0.15589451789855957, -0.0506783127784729, 0.058836743235588074, -0.006695507559925318, 0.14721480011940002, -0.0054169767536222935, 0.06938517093658447, 0.15823592245578766, 0.13143523037433624, -0.15002848207950592, 0.05613873153924942, -0.12176042795181274, 0.18032033741474152, -0.050636373460292816, 0.06662099808454514, -0.0837436392903328, 0.13990473747253418, 0.060717858374118805, -0.07037080824375153, -0.10665412992238998, 0.10541780292987823, -0.06804632395505905, 0.030673475936055183, 0.16220979392528534, 0.021290715783834457, 0.057108525186777115, 0.04481641948223114, 0.1224413737654686, -0.05812985077500343, 0.16010001301765442, -0.11583422124385834, -0.1515609472990036, 0.14925897121429443, 0.1440657377243042, 0.12568099796772003, 0.02646627090871334, -0.06521692872047424, 0.16370093822479248, 0.08857852220535278, -0.10265614092350006, 0.0981084555387497, 0.1277306079864502], "net.4.weight": [[0.2636769711971283, -0.02237112633883953, -0.2683728337287903, -0.07001868635416031, 0.2926880717277527, 0.1081484705209732, -0.3036178946495056, 0.09813925623893738, -0.4286763072013855, -0.354902058839798, 0.48247236013412476, 0.1113550066947937, -0.21476255357265472, 0.16255459189414978, -0.22625479102134705, -0.397373229265213, 0.10936614871025085, 0.06078718602657318, -0.026266004890203476, 0.03385745361447334, 0.021288452669978142, 0.040719907730817795, -0.527450680732727, -0.4402565360069275, -0.1949187070131302, -0.33972927927970886, 0.34744563698768616, 0.2588717043399811, 0.16688533127307892, 0.2033364623785019, 0.14344291388988495, -0.04925093054771423, -0.3526117503643036, -0.07314609736204147, 0.2776934802532196, -0.26886165142059326, 0.04496545344591141, 0.00547008216381073, 0.22952410578727722, 0.28770050406455994, 0.0009832585928961635, -0.5248414874076843, -0.22096006572246552, -0.01148674264550209, 0.13605356216430664, -0.13126729428768158, 0.07395496219396591, -0.19175024330615997, 0.11248002201318741, -0.3754819631576538, -0.008107772096991539, 0.25016528367996216, -0.18004894256591797, -0.14415007829666138, -0.29650163650512695, -0.2537640631198883, 0.1977572739124298, 0.13213713467121124, 0.1118837371468544, -0.309810996055603, 0.15295016765594482, 0.01796133816242218, -0.04896797984838486, -0.18178029358386993], [0.316780149936676, -0.0024082364980131388, 0.15605966746807098, -0.22021842002868652, -0.0737047865986824, 0.2282727062702179, -0.1473652422428131, -0.10619562864303589, -0.1267247349023819, 0.0638665035367012, 0.3348499834537506, 0.248720183968544, -0.10039974004030228, 0.3144787847995758, -0.1750485599040985, 0.1118038222193718, -0.08339622616767883, -0.030648134648799896, -0.06472107023000717, 0.3493533134460449, -0.5386077761650085, 0.1911749392747879, 0.15064865350723267, 0.2712341547012329, -0.23541542887687683, -0.023739757016301155, -0.0645189955830574, -0.3311195969581604, 0.2820453643798828, -0.15715128183364868, -0.039223749190568924, 0.10536231100559235, 0.14781926572322845, 0.07899145036935806, 0.3923110067844391, 0.1619269847869873, -0.11355875432491302, 0.017651081085205078, -0.04513445869088173, -0.08780776709318161, 0.025125447660684586, -0.0539407953619957, 0.08601465076208115, 0.07800149917602539, 0.039750661700963974, 0.26907187700271606, -0.031024986878037453, -0.24189381301403046, 0.28786247968673706, 0.014958449639379978, -0.024921340867877007, -0.00765844015404582, -0.000353967392584309, 0.22671648859977722, -0.11138945817947388, -0.22325341403484344, -0.2814669609069824, 0.024696355685591698, 0.2559209167957306, 0.17566794157028198, 0.23344950377941132, 0.10522826015949249, -0.1868380308151245, -0.13219042122364044], [0.2044190913438797, -0.016797326505184174, 0.18817512691020966, -0.2041759192943573, 0.2759290039539337, -0.44941946864128113, 0.006720924284309149, 0.1187482476234436, 0.1519583910703659, -0.046097829937934875, -0.3232269585132599, -0.3153741657733917, 0.17096206545829773, -0.10555067658424377, -0.22508502006530762, 0.056895121932029724, 0.06540238857269287, -0.07249778509140015, -0.023754270747303963, 0.17823126912117004, 0.2150028496980667, 0.2361927628517151, 0.09466525912284851, 0.0893528163433075, -0.2036118358373642, -0.1850585639476776, 0.25843337178230286, 0.1913546472787857, -0.35863569378852844, -0.31776484847068787, -0.3652939796447754, -0.08533095568418503, 0.04834989830851555, 0.045812129974365234, 0.09041834622621536, 0.1500958651304245, 0.20999731123447418, 0.0005207551876083016, 0.25402122735977173, -0.07711663097143173, -0.007868279702961445, 0.18877547979354858, -0.3764892518520355, -0.05364900827407837, -0.3238683342933655, 0.1171574592590332, -0.018314151093363762, 0.21000711619853973, 0.2985873520374298, 0.06402938812971115, -0.0958985686302185, 0.1600923240184784, -0.08575129508972168, 0.5241585373878479, -0.27643057703971863, -0.14430248737335205, -0.15301427245140076, -0.6713743209838867, -0.6445226669311523, -0.01958407461643219, 0.26352453231811523, 0.03765416890382767, 0.18097268044948578, -0.11932771652936935]], "net.4.bias": [0.07835516333580017, 0.10256458073854446, -0.045726075768470764]}
    </script>

    <script>
        // ==================== NEURAL NETWORK ====================
        const BRAIN = JSON.parse(document.getElementById('brainData').textContent);
        
        // Simple neural network forward pass
        class NeuralNetwork {
            constructor(weights) {
                this.w0 = weights['net.0.weight'];
                this.b0 = weights['net.0.bias'];
                this.w2 = weights['net.2.weight'];
                this.b2 = weights['net.2.bias'];
                this.w4 = weights['net.4.weight'];
                this.b4 = weights['net.4.bias'];
            }
            
            relu(x) { return Math.max(0, x); }
            
            forward(input) {
                // Layer 0: 48 -> 64
                let h1 = new Array(64).fill(0);
                for (let i = 0; i < 64; i++) {
                    let sum = this.b0[i];
                    for (let j = 0; j < 48; j++) {
                        sum += input[j] * this.w0[i][j];
                    }
                    h1[i] = this.relu(sum);
                }
                
                // Layer 2: 64 -> 32
                let h2 = new Array(32).fill(0);
                for (let i = 0; i < 32; i++) {
                    let sum = this.b2[i];
                    for (let j = 0; j < 64; j++) {
                        sum += h1[j] * this.w2[i][j];
                    }
                    h2[i] = this.relu(sum);
                }
                
                // Layer 4: 32 -> 3 (output)
                let output = new Array(3).fill(0);
                for (let i = 0; i < 3; i++) {
                    let sum = this.b4[i];
                    for (let j = 0; j < 32; j++) {
                        sum += h2[j] * this.w4[i][j];
                    }
                    output[i] = sum;
                }
                
                return output;
            }
            
            decide(input) {
                const output = this.forward(input);
                // 0=left, 1=straight, 2=right
                let maxIdx = 0;
                for (let i = 1; i < 3; i++) {
                    if (output[i] > output[maxIdx]) maxIdx = i;
                }
                return maxIdx;
            }
        }
        
        const neuralBrain = new NeuralNetwork(BRAIN);

        // ==================== RULE ENGINE (G√∂del Layer) ====================
        class RuleEngine {
            constructor() {
                this.rules = [];
                this.pendingCredits = []; // Track which rules influenced recent decisions
                this.stateHistory = {};   // Track recent states per snake for death analysis
                this.deathPatterns = {};  // Count death patterns to find common causes
                this.ruleIdCounter = 0;
                this.tick = 0;
                this.rulesGenerated = 0;
                this.load();
            }

            // Record state before each decision (for death analysis)
            recordState(snakeId, state, chosenAction) {
                if (!this.stateHistory[snakeId]) this.stateHistory[snakeId] = [];
                this.stateHistory[snakeId].push({ state: {...state}, action: chosenAction, tick: this.tick });
                // Keep only last 10 states
                if (this.stateHistory[snakeId].length > 10) this.stateHistory[snakeId].shift();
            }

            // Analyze death and potentially generate a new rule
            analyzeDeathAndGenerateRule(snakeId) {
                const history = this.stateHistory[snakeId];
                if (!history || history.length < 2) return;

                // Look at the last few states before death
                const lastState = history[history.length - 1];
                const state = lastState.state;
                const fatalAction = lastState.action; // 0=left, 1=straight, 2=right

                // Create a "death signature" from key state features
                const signature = this.createSignature(state, fatalAction);

                // Count this death pattern
                this.deathPatterns[signature] = (this.deathPatterns[signature] || 0) + 1;

                // If we've seen this pattern 3+ times, generate a rule
                if (this.deathPatterns[signature] >= 3) {
                    // Check if we already have a similar rule
                    const existingRule = this.rules.find(r =>
                        r.source === 'death_pattern' &&
                        JSON.stringify(r.trigger.conditions) === JSON.stringify(state)
                    );

                    if (!existingRule && this.rules.length < 50) { // Cap at 50 rules
                        // Create rule to avoid the fatal action
                        const bias = [0, 0, 0];
                        bias[fatalAction] = -1.5; // Strongly discourage the fatal action
                        // Slightly encourage alternatives
                        bias[(fatalAction + 1) % 3] = 0.3;
                        bias[(fatalAction + 2) % 3] = 0.3;

                        // Simplify state to key features only
                        const keyConditions = {};
                        if (state.wallAhead) keyConditions.wallAhead = true;
                        if (state.wallLeft) keyConditions.wallLeft = true;
                        if (state.wallRight) keyConditions.wallRight = true;
                        if (state.bodyAhead) keyConditions.bodyAhead = true;
                        if (state.bodyLeft) keyConditions.bodyLeft = true;
                        if (state.bodyRight) keyConditions.bodyRight = true;
                        if (state.enemyAhead) keyConditions.enemyAhead = true;

                        if (Object.keys(keyConditions).length > 0) {
                            const newRule = this.createRule(
                                { type: 'state', conditions: keyConditions },
                                { bias },
                                'death_pattern'
                            );
                            newRule.stats.confidence = 0.35; // Start with low confidence
                            this.rulesGenerated++;
                            console.log(`[G√ñDEL] Generated rule from ${this.deathPatterns[signature]} deaths:`, keyConditions, '‚Üí avoid action', fatalAction);

                            // Reset this pattern count
                            this.deathPatterns[signature] = 0;
                        }
                    }
                }

                // Clear history for dead snake
                delete this.stateHistory[snakeId];
            }

            createSignature(state, action) {
                const parts = [];
                if (state.wallAhead) parts.push('wA');
                if (state.wallLeft) parts.push('wL');
                if (state.wallRight) parts.push('wR');
                if (state.bodyAhead) parts.push('bA');
                if (state.bodyLeft) parts.push('bL');
                if (state.bodyRight) parts.push('bR');
                if (state.enemyAhead) parts.push('eA');
                parts.push(`a${action}`);
                return parts.join('_') || 'clear_a' + action;
            }

            createRule(trigger, action, source = 'manual') {
                const rule = {
                    id: `rule_${this.ruleIdCounter++}`,
                    trigger: trigger,      // { type: 'state', conditions: {...} }
                    action: action,        // { bias: [left, straight, right] }
                    stats: { applied: 0, successes: 0, failures: 0, confidence: 0.5 },
                    source: source,
                    createdAt: Date.now(),
                    active: true
                };
                this.rules.push(rule);
                return rule;
            }

            matchesTrigger(trigger, state) {
                if (trigger.type === 'state') {
                    for (const [key, value] of Object.entries(trigger.conditions)) {
                        if (typeof value === 'boolean') {
                            if (!!state[key] !== value) return false;
                        } else if (typeof value === 'object') {
                            if (value.min !== undefined && state[key] < value.min) return false;
                            if (value.max !== undefined && state[key] > value.max) return false;
                        } else {
                            if (state[key] !== value) return false;
                        }
                    }
                    return true;
                }
                return false;
            }

            applyRules(neuralOutput, gameState, snakeId) {
                let modified = [...neuralOutput];
                let appliedRuleIds = [];

                for (const rule of this.rules) {
                    if (!rule.active) continue;
                    if (this.matchesTrigger(rule.trigger, gameState)) {
                        for (let i = 0; i < 3; i++) {
                            modified[i] += rule.action.bias[i] * rule.stats.confidence;
                        }
                        appliedRuleIds.push(rule.id);
                        rule.stats.applied++;
                    }
                }

                if (appliedRuleIds.length > 0) {
                    this.pendingCredits.push({ snakeId, ruleIds: appliedRuleIds, tick: this.tick });
                    if (this.pendingCredits.length > 200) this.pendingCredits = this.pendingCredits.slice(-100);
                }

                return modified;
            }

            onOutcome(snakeId, outcome) {
                const rewards = { death: -1, ate_food: 0.3, got_kill: 1.0, survived_30: 0.1 };
                const reward = rewards[outcome] || 0;
                const recent = this.pendingCredits.filter(p => p.snakeId === snakeId && this.tick - p.tick < 30);

                for (const credit of recent) {
                    for (const ruleId of credit.ruleIds) {
                        const rule = this.rules.find(r => r.id === ruleId);
                        if (!rule) continue;
                        if (reward > 0) rule.stats.successes++;
                        else rule.stats.failures++;
                        const total = rule.stats.successes + rule.stats.failures;
                        if (total > 0) rule.stats.confidence = 0.3 + 0.7 * (rule.stats.successes / total);
                    }
                }

                if (outcome === 'death') {
                    this.pendingCredits = this.pendingCredits.filter(p => p.snakeId !== snakeId);
                }
            }

            pruneRules() {
                const before = this.rules.length;
                this.rules = this.rules.filter(rule => {
                    if (rule.stats.applied < 10) return true;
                    if (rule.stats.confidence < 0.25) return false;
                    return true;
                });
                if (this.rules.length < before) console.log(`[G√ñDEL] Pruned ${before - this.rules.length} weak rules`);
            }

            update() {
                this.tick++;
                if (this.tick % 500 === 0) { this.pruneRules(); this.save(); }
            }

            save() {
                localStorage.setItem('locomotio_rules', JSON.stringify({
                    rules: this.rules, ruleIdCounter: this.ruleIdCounter, savedAt: Date.now()
                }));
            }

            load() {
                try {
                    const saved = localStorage.getItem('locomotio_rules');
                    if (saved) {
                        const data = JSON.parse(saved);
                        this.rules = data.rules || [];
                        this.ruleIdCounter = data.ruleIdCounter || 0;
                        console.log(`[G√ñDEL] Loaded ${this.rules.length} rules`);
                    }
                } catch (e) { console.log('[G√ñDEL] No saved rules'); }
            }

            getStats() {
                const learned = this.rules.filter(r => r.source === 'death_pattern').length;
                return {
                    total: this.rules.length,
                    active: this.rules.filter(r => r.active).length,
                    learned: learned,
                    generated: this.rulesGenerated,
                    avgConf: this.rules.length > 0
                        ? (this.rules.reduce((s, r) => s + r.stats.confidence, 0) / this.rules.length).toFixed(2) : 0,
                    patterns: Object.keys(this.deathPatterns).length
                };
            }
        }

        const ruleEngine = new RuleEngine();

        // Starter rules if none exist
        if (ruleEngine.rules.length === 0) {
            ruleEngine.createRule({ type: 'state', conditions: { wallAhead: true } }, { bias: [-0.5, -2.0, -0.5] }, 'manual');
            ruleEngine.createRule({ type: 'state', conditions: { bodyLeft: true } }, { bias: [-1.5, 0, 0.3] }, 'manual');
            ruleEngine.createRule({ type: 'state', conditions: { bodyRight: true } }, { bias: [0.3, 0, -1.5] }, 'manual');
            ruleEngine.createRule({ type: 'state', conditions: { foodAhead: true } }, { bias: [0, 0.8, 0] }, 'manual');
            ruleEngine.createRule({ type: 'state', conditions: { foodLeft: true, foodAhead: false } }, { bias: [0.6, 0, 0] }, 'manual');
            ruleEngine.createRule({ type: 'state', conditions: { foodRight: true, foodAhead: false } }, { bias: [0, 0, 0.6] }, 'manual');
            ruleEngine.createRule({ type: 'state', conditions: { enemyAhead: true } }, { bias: [0, 0.5, 0] }, 'manual');
            console.log('[G√ñDEL] Created 7 starter rules');
            ruleEngine.save();
        }

        // ==================== MULTIPLAYER ====================
        // Player username
        let playerName = localStorage.getItem('locomot_username') || 'Train' + Math.floor(Math.random() * 999);

        const Multiplayer = {
            username: playerName,
            socket: null,
            connected: false,
            playerId: null,
            roomId: null,
            hostId: null,
            otherPlayers: new Map(), // id -> player state
            playerLastSeen: new Map(), // id -> timestamp for inactive cleanup
            INACTIVE_TIMEOUT: 10000, // Boot players after 10 seconds of no updates
            serverUrl: 'locomot-io.savecharlie.partykit.dev',

            connect(roomId = 'main') {
                this.roomId = roomId;
                try {
                    // Use PartySocket for reconnection handling
                    this.socket = new WebSocket(`wss://${this.serverUrl}/party/${roomId}`);

                    this.socket.onopen = () => {
                        console.log('[MP] Connected to room:', roomId);
                        this.connected = true;
                        this.showStatus('Connected!');
                        // Send username to server
                        if (this.username) {
                            this.send({ type: 'name', name: this.username });
                        }
                    };

                    this.socket.onmessage = (event) => {
                        this.handleMessage(JSON.parse(event.data));
                    };

                    this.socket.onclose = () => {
                        console.log('[MP] Disconnected');
                        this.connected = false;
                        this.showStatus('Disconnected');
                        // Try reconnect after 2s
                        setTimeout(() => this.connect(roomId), 2000);
                    };

                    this.socket.onerror = (e) => {
                        console.log('[MP] Error:', e);
                    };
                } catch (e) {
                    console.log('[MP] Connection failed:', e);
                }
            },

            handleMessage(data) {
                switch (data.type) {
                    case 'init':
                        this.playerId = data.playerId;
                        console.log('[MP] Assigned ID:', this.playerId);
                        if (data.hostId) {
                            this.hostId = data.hostId;
                            this.isHost = this.playerId === data.hostId;
                        }
                        // Initialize other players
                        for (const p of data.players) {
                            if (p.id !== this.playerId) {
                                this.otherPlayers.set(p.id, p);
                                this.playerLastSeen.set(p.id, Date.now());
                            }
                        }
                        if (!data.hostId) {
                            this.isHost = this.otherPlayers.size === 0;
                        }
                        // If we are not host, request arena sync from them
                        if (!this.isHost && this.otherPlayers.size > 0) {
                            console.log('[MP] Other players exist, requesting arena sync');
                            this.send({ type: 'request_arena' });
                        } else if (this.isHost) {
                            console.log('[MP] We are host');
                            this.showStatus('You are HOST');
                        }
                        break;

                    case 'player_joined':
                        console.log('[MP] Player joined:', data.player.name);
                        this.otherPlayers.set(data.player.id, data.player);
                        this.playerLastSeen.set(data.player.id, Date.now());
                        this.showStatus(`${data.player.name} joined!`);
                        // Send arena state if we have enemies (any game state)
                        if (this.isHost && enemies.length > 0) {
                            console.log('[MP] Sending arena to new player');
                            this.sendArenaSync(data.player.id);
                        }
                        break;

                    case 'arena_sync':
                        // Received arena state from another player - always apply if we have fewer enemies
                        // This handles the case where we generated our own arena before sync arrived
                        if (data.enemies && data.enemies.length > 0) {
                            console.log('[MP] Received arena sync with', data.enemies.length, 'enemies (we have', enemies.length, ')');
                            this.applyArenaSync(data.enemies, data.pickups);
                            this.arenaSynced = true;
                        }
                        break;

                    case 'arena_request':
                        // Another player is requesting our arena state
                        console.log('[MP] Arena request from', data.fromId, '- we have', enemies.length, 'enemies');
                        if (this.isHost && enemies.length > 0) {
                            console.log('[MP] Responding with arena sync');
                            this.sendArenaSync(data.fromId);
                        }
                        break;

                    case 'enemy_state':
                        // Continuous enemy state from host - update positions
                        console.log('[MP] Received enemy_state:', data.enemies?.length, 'enemies,', data.pickups?.length, 'pickups, isHost:', this.isHost);
                        if (!this.isHost && data.enemies) {
                            this.applyEnemyState(data.enemies);
                        }
                        if (!this.isHost && data.pickups) {
                            this.applyPickupState(data.pickups);
                        }
                        break;

                    case 'player_left':
                        const left = this.otherPlayers.get(data.playerId);
                        this.otherPlayers.delete(data.playerId);
                        this.playerLastSeen.delete(data.playerId);
                        if (left) this.showStatus(`${left.name} left`);
                        break;

                    case 'state':
                        // Update all other players
                        for (const p of data.players) {
                            if (p.id !== this.playerId) {
                                this.otherPlayers.set(p.id, p);
                                this.playerLastSeen.set(p.id, Date.now());
                            }
                        }
                        break;
                    
                    case 'hit':
                        // We got hit by another player!
                        if (data.targetId === this.playerId) {
                            // Damage a segment - head if no body cars, otherwise random body car
                            const segIdx = snake.length === 1 ? 0 : 1 + Math.floor(Math.random() * (snake.length - 1));
                            if (snake[segIdx]) {
                                snake[segIdx].hp -= data.damage;
                                haptic('medium');
                                // Flash red
                                const seg = snake[segIdx];
                                for (let j = 0; j < 5; j++) {
                                    particles.push({ x: seg.x * GRID, y: seg.y * GRID, vx: (Math.random()-0.5)*3, vy: (Math.random()-0.5)*3, life: 10, color: '#f00' });
                                }
                            }
                        }
                        break;

                    case 'pickup_collected':
                        this.removePickupById(data.pickupId, data.x, data.y);
                        break;

                    case 'host_assigned':
                        this.hostId = data.hostId;
                        const wasHost = this.isHost;
                        this.isHost = this.playerId === data.hostId;
                        if (this.isHost && !wasHost) {
                            this.showStatus('You are now HOST');
                        }
                        break;
                }
            },

            send(data) {
                if (this.socket && this.connected) {
                    this.socket.send(JSON.stringify(data));
                }
            },

            // Send our position to server
            sendUpdate(x, y, segments, score) {
                this.send({
                    type: 'update',
                    x, y,
                    segments: segments.map(s => ({ x: s.x, y: s.y })),
                    score
                });
            },

            // Send direction change
            sendMove(dir) {
                this.send({ type: 'move', dir });
            },

            sendPickupCollected(pickup) {
                if (!pickup) return;
                this.send({ type: 'pickup_collected', pickupId: pickup.id, x: pickup.x, y: pickup.y });
            },

            serializePickup(p) {
                const type = p.isPowerup ? (p.type?.name || 'SPEED') :
                    (p.isHealth ? 'HEALTH' :
                        (Object.keys(GUNS).find(k => GUNS[k] === p.type) || 'MACHINEGUN'));
                return {
                    id: p.id,
                    x: p.x,
                    y: p.y,
                    isHealth: !!p.isHealth,
                    isPowerup: !!p.isPowerup,
                    healAmount: p.healAmount || 40,
                    type,
                    bob: p.bob || 0
                };
            },

            removePickupById(pickupId, x, y) {
                if (pickupId !== undefined && pickupId !== null) {
                    const idx = pickups.findIndex(p => p.id === pickupId);
                    if (idx !== -1) {
                        pickups.splice(idx, 1);
                        return;
                    }
                    return;
                }
                if (typeof x === 'number' && typeof y === 'number') {
                    const idx = pickups.findIndex(p => Math.hypot(p.x - x, p.y - y) < GRID * 0.6);
                    if (idx !== -1) pickups.splice(idx, 1);
                }
            },

            // Arena sync - share our enemies with a new joiner
            arenaSynced: false,
            arenaReceived: false, // True if we received arena from another player
            isHost: false, // True if we're the authoritative source for enemy state
            lastStateBroadcast: 0,
            STATE_BROADCAST_INTERVAL: 150, // ms between state broadcasts
            pendingArenaSync: false, // Prevents spamming arena sync requests
            lastDebugLog: 0,

            // Debug: update overlay every 500ms
            _enemyStateCount: 0,
            debugStatus() {
                const now = Date.now();
                if (now - this.lastDebugLog < 500) return;
                this.lastDebugLog = now;
                const e0 = enemies[0];
                const el = document.getElementById('mp-debug');
                if (el) {
                    const role = this.isHost ? 'HOST' : 'CLIENT';
                    const name = e0?.name || 'none';
                    el.textContent = `${role} | updates=${this._enemyStateCount} | e0=${name}`;
                }
            },

            sendArenaSync(targetId) {
                // Send simplified enemy data (positions only, they'll regenerate details)
                const enemyData = enemies.map(e => ({
                    x: e.segments[0]?.x || 0,
                    y: e.segments[0]?.y || 0,
                    len: e.segments.length,
                    color: e.color,
                    name: e.name
                })).filter(e => e.len > 0);

                console.log('[MP] Sending arena sync to', targetId, 'with', enemyData.length, 'enemies');
                this.send({
                    type: 'arena_sync',
                    targetId: targetId,
                    enemies: enemyData,
                    pickups: pickups.slice(0, 200).map(p => this.serializePickup(p))
                });
            },

            applyArenaSync(enemyData, pickupData) {
                // Replace our enemies with synced ones
                console.log('[MP] BEFORE sync: enemies.length =', enemies.length);
                const oldEnemies = enemies;
                enemies = []; // Clear global enemies array

                for (const e of enemyData) {
                    // Spawn enemy at synced position with synced length
                    const startDir = DIR.RIGHT;
                    const segments = [];
                    for (let i = 0; i < e.len; i++) {
                        segments.push({
                            x: e.x - i,
                            y: e.y,
                            hp: i === 0 ? Infinity : 50,
                            maxHp: i === 0 ? Infinity : 50,
                            type: i === 0 ? GUNS.HEAD : GUNS.MACHINEGUN,
                            lastFired: 0
                        });
                    }
                    enemies.push({
                        team: enemies.length % 2 === 0 ? 'blue' : 'red',
                        name: e.name || 'Train',
                        segments,
                        dir: startDir,
                        nextDir: startDir,
                        baseSpeed: 8,
                        damage: 15,
                        moveTimer: 0,
                        lastFired: 0,
                        fireRate: 1000,
                        score: 10 * e.len,
                        personality: { aggression: 0.5, greed: 0.5, caution: 0.5, neural: Math.random() < 0.5 },
                        color: e.color || '#f0f',
                        targetPos: null,
                        avoidPos: null,
                        lastDecision: 0,
                        decisionInterval: 400,
                        recentPoints: 0,
                        lastPointTime: 0,
                        isMVP: false,
                        id: enemies.length
                    });
                }
                console.log('[MP] AFTER sync: enemies.length =', enemies.length, 'first enemy:', enemies[0]?.name, 'at', enemies[0]?.segments[0]?.x, enemies[0]?.segments[0]?.y);

                // Also sync pickups if provided
                if (pickupData && pickupData.length > 0) {
                    pickups = pickupData.map(p => ({
                        id: p.id,
                        x: p.x,
                        y: p.y,
                        isHealth: !!p.isHealth,
                        isPowerup: !!p.isPowerup,
                        healAmount: p.healAmount || 40,
                        type: p.isPowerup ? (POWERUPS[p.type] || POWERUPS.SPEED) :
                              (p.isHealth ? { color: '#4f4', name: 'HEALTH' } :
                                  (GUNS[p.type] || GUNS.MACHINEGUN)),
                        bob: p.bob || Math.random() * Math.PI * 2
                    }));
                    syncPickupIdCounter(pickups);
                    console.log('[MP] Synced', pickups.length, 'pickups');
                }

                this.arenaReceived = true;
                this.arenaSynced = true;
            },

            // Host broadcasts enemy state to all clients
            broadcastEnemyState() {
                if (!this.isHost || !this.connected) return;

                const now = Date.now();
                if (now - this.lastStateBroadcast < this.STATE_BROADCAST_INTERVAL) return;
                this.lastStateBroadcast = now;

                // Send FULL enemy data so clients can render exactly what host sees
                const enemyState = enemies.map(e => ({
                    name: e.name,
                    color: e.color,
                    team: e.team,
                    score: e.score,
                    dir: { x: e.dir.x, y: e.dir.y },
                    segs: e.segments.map(s => ({ x: s.x, y: s.y, hp: s.hp, type: Object.keys(GUNS).find(k => GUNS[k] === s.type) || 'MACHINEGUN' })),
                    isMVP: e.isMVP
                })).filter(e => e.segs.length > 0);

                // Also sync pickups so all clients see same world
                const pickupState = pickups.slice(0, 200).map(p => this.serializePickup(p));

                console.log('[MP] Broadcasting:', enemyState.length, 'enemies,', pickupState.length, 'pickups');
                this.send({ type: 'enemy_state', enemies: enemyState, pickups: pickupState });
            },

            // Non-host: update enemies in-place to preserve state (guns, timers, personality)
            applyEnemyState(stateData) {
                this._enemyStateCount++;

                // Build lookup of existing enemies by name+team
                const existingMap = new Map();
                for (const e of enemies) {
                    if (e.name && e.segments?.length > 0) {
                        existingMap.set(`${e.name}_${e.team}`, e);
                    }
                }

                // Update existing or create new
                const newEnemies = [];
                for (let idx = 0; idx < stateData.length; idx++) {
                    const s = stateData[idx];
                    const key = `${s.name}_${s.team}`;
                    const existing = existingMap.get(key);

                    if (existing) {
                        // UPDATE existing enemy - preserve guns, personality, timers
                        existing.dir = s.dir || existing.dir;
                        existing.nextDir = s.dir || existing.nextDir;
                        existing.isMVP = s.isMVP || false;
                        existing.score = s.score || existing.score;
                        existing.color = s.color || existing.color;

                        // Update segment positions and HP, preserve gun types
                        for (let i = 0; i < s.segs.length; i++) {
                            if (i < existing.segments.length) {
                                existing.segments[i].x = s.segs[i].x;
                                existing.segments[i].y = s.segs[i].y;
                                if (s.segs[i].hp !== undefined) existing.segments[i].hp = s.segs[i].hp;
                            } else {
                                // Enemy grew - add new segment
                                existing.segments.push({
                                    x: s.segs[i].x, y: s.segs[i].y,
                                    hp: s.segs[i].hp || 50, maxHp: 50,
                                    type: GUNS[s.segs[i].type] || GUNS.MACHINEGUN,
                                    lastFired: 0
                                });
                            }
                        }
                        // Enemy shrunk - remove extra segments
                        if (existing.segments.length > s.segs.length) {
                            existing.segments.length = s.segs.length;
                        }
                        existingMap.delete(key); // Mark as used
                        newEnemies.push(existing);
                    } else {
                        // CREATE new enemy (spawned mid-game)
                        newEnemies.push({
                            team: s.team || 'blue',
                            name: s.name || 'Train',
                            segments: s.segs.map((seg, i) => ({
                                x: seg.x, y: seg.y,
                                hp: seg.hp || (i === 0 ? Infinity : 50),
                                maxHp: i === 0 ? Infinity : 50,
                                type: GUNS[seg.type] || (i === 0 ? GUNS.HEAD : GUNS.MACHINEGUN),
                                lastFired: 0
                            })),
                            dir: s.dir || { x: 1, y: 0 },
                            nextDir: s.dir || { x: 1, y: 0 },
                            baseSpeed: 8, damage: 15, moveTimer: 0,
                            lastFired: 0, fireRate: 1000,
                            score: s.score || 0,
                            personality: { aggression: 0.5, greed: 0.5, caution: 0.5, neural: false },
                            color: s.color || '#f0f',
                            targetPos: null, avoidPos: null,
                            lastDecision: 0, decisionInterval: 400,
                            recentPoints: 0, lastPointTime: 0,
                            isMVP: s.isMVP || false,
                            id: idx
                        });
                    }
                }
                enemies = newEnemies;
            },

            // Non-host: sync pickups from host
            applyPickupState(pickupData) {
                console.log('[MP] Applying pickup state:', pickupData?.length, 'pickups');
                if (!pickupData || pickupData.length === 0) return;
                pickups = pickupData.map(p => ({
                    id: p.id,
                    x: p.x, y: p.y,
                    isHealth: !!p.isHealth,
                    isPowerup: !!p.isPowerup,
                    healAmount: p.healAmount || 40,
                    type: p.isPowerup ? (POWERUPS[p.type] || POWERUPS.SPEED) :
                          (p.isHealth ? { color: '#4f4', name: 'HEALTH' } :
                              (GUNS[p.type] || GUNS.MACHINEGUN)),
                    bob: p.bob || Math.random() * Math.PI * 2
                }));
                syncPickupIdCounter(pickups);
            },

            setUsername(name) {
                name = name.trim().slice(0, 12) || 'Train' + Math.floor(Math.random() * 999);
                this.username = name;
                playerName = name;
                localStorage.setItem('locomot_username', name);
                this.send({ type: 'name', name });
            },

            showStatus(msg) {
                const el = document.getElementById('waveAnnounce');
                if (el) {
                    el.textContent = msg;
                    el.classList.add('show');
                    setTimeout(() => el.classList.remove('show'), 1500);
                }
            },

            // Boot inactive players (not updated in INACTIVE_TIMEOUT ms)
            cleanupInactivePlayers() {
                const now = Date.now();
                const toRemove = [];
                for (const [id, lastSeen] of this.playerLastSeen) {
                    if (now - lastSeen > this.INACTIVE_TIMEOUT) {
                        toRemove.push(id);
                    }
                }
                for (const id of toRemove) {
                    const player = this.otherPlayers.get(id);
                    console.log('[MP] Booting inactive player:', player?.name || id);
                    this.otherPlayers.delete(id);
                    this.playerLastSeen.delete(id);
                }
                if (toRemove.length > 0) {
                    console.log(`[MP] Cleaned up ${toRemove.length} inactive player(s)`);
                }
            },

            // Draw other players
            drawOtherPlayers(ctx) {
                for (const player of this.otherPlayers.values()) {
                    if (!player.segments || player.segments.length === 0) continue;

                    // Draw segments
                    for (let i = player.segments.length - 1; i >= 0; i--) {
                        const seg = player.segments[i];
                        const isHead = i === 0;

                        const teamColor = teamMode ? '#0ff' : player.color; ctx.fillStyle = isHead ? teamColor : this.dimColor(teamColor);
                        ctx.fillRect(seg.x * 12, seg.y * 12, 12, 12);

                        // Outline
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(seg.x * 12, seg.y * 12, 12, 12);
                    }

                    // Name tag with human emoji
                    const head = player.segments[0];
                    ctx.fillStyle = '#fff';
                    ctx.font = '8px "Press Start 2P"';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = '#000';
                    ctx.shadowBlur = 3;
                    ctx.fillText(`üë§ ${player.name}`, head.x * 12 + 6, head.y * 12 - 5);
                    ctx.shadowBlur = 0;
                }
            },

            dimColor(color) {
                // Dim color for body segments
                const r = parseInt(color.slice(1, 3), 16) * 0.6;
                const g = parseInt(color.slice(3, 5), 16) * 0.6;
                const b = parseInt(color.slice(5, 7), 16) * 0.6;
                return `rgb(${r},${g},${b})`;
            }
        };

        // Auto-connect to multiplayer
        const urlParams = new URLSearchParams(window.location.search);
        const roomParam = urlParams.get('room') || 'main';
        // Connect when game starts
        setTimeout(() => Multiplayer.connect(roomParam), 1000);
        
        // === KILL FEED ===
        const killFeed = {
            entries: [],
            add(killer, victim, method = '') {
                const entry = document.createElement('div');
                entry.className = 'kill-feed-entry';
                entry.innerHTML = `<span style="color:#f55">${killer}</span> üî´ <span style="color:#5ff">${victim}</span>`;
                document.getElementById('killFeed').prepend(entry);
                this.entries.push(entry);
                // Fade out after 4s
                setTimeout(() => entry.classList.add('fade'), 4000);
                setTimeout(() => entry.remove(), 4500);
                // Keep max 5
                if (this.entries.length > 5) {
                    const old = this.entries.shift();
                    old.remove();
                }
            }
        };
        
        // === HIGHLIGHT CLIP RECORDER ===
        const HighlightRecorder = {
            isRecording: false,
            mediaRecorder: null,
            chunks: [],
            clips: [],
            events: [],
            lastKillTime: 0,
            killStreak: 0,
            wasLeader: false,
            clipDuration: 10000, // 10 seconds per clip
            autoUpload: true, // Upload exciting clips to Ivy
            uploadThreshold: 120, // Min score to upload (higher = less spam)
            hotStreak: 0, // Track recent excitement
            clipCount: 0, // Total clips uploaded

            init() {
                try {
                    const stream = canvas.captureStream(30);
                    this.mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' });
                    this.mediaRecorder.ondataavailable = (e) => {
                        if (e.data.size > 0) this.chunks.push(e.data);
                    };
                    this.mediaRecorder.onstop = () => this.saveClip();
                    this.startRecording();
                    this.updateClipUI(); // Show UI immediately
                    // Silent highlight recorder initialized
                } catch (e) {
                    console.log('Highlight recorder not available:', e);
                }
            },

            startRecording() {
                if (!this.mediaRecorder || this.isRecording) return;
                this.chunks = [];
                this.mediaRecorder.start();
                this.isRecording = true;
                // Auto-stop after clipDuration to create rolling buffer
                setTimeout(() => {
                    if (this.isRecording && this.events.length === 0) {
                        // No events, just restart
                        this.mediaRecorder.stop();
                        this.chunks = [];
                        this.isRecording = false;
                        this.startRecording();
                    }
                }, this.clipDuration);
            },

            triggerHighlight(type, details = {}) {
                if (!this.isRecording) return;

                // Calculate score
                let score = 50;
                if (type === 'kill_streak') score = 80 + (details.streak || 0) * 40;
                else if (type === 'became_leader') score = 150;
                else if (type === 'long_train') score = 60 + (details.length || 0) * 2;

                this.events.push({ type, details, time: Date.now(), score });
                this.hotStreak += score;
                console.log('üé¨ Highlight:', type, 'score:', score, 'hot:', this.hotStreak);

                // Stop recording after a short delay to capture aftermath
                setTimeout(() => {
                    if (this.mediaRecorder && this.isRecording) {
                        this.mediaRecorder.stop();
                        this.isRecording = false;
                    }
                }, 3000);
            },

            saveClip() {
                if (this.chunks.length === 0 || this.events.length === 0) {
                    this.events = [];
                    this.hotStreak = Math.max(0, this.hotStreak - 20);
                    this.startRecording();
                    return;
                }

                const blob = new Blob(this.chunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const eventType = this.events[0]?.type || 'highlight';
                const totalScore = this.events.reduce((sum, e) => sum + (e.score || 0), 0);

                const clip = {
                    url, blob, type: eventType, score: totalScore,
                    timestamp: Date.now(), events: [...this.events]
                };

                this.clips.push(clip);

                // UPLOAD to Ivy if score meets threshold!
                if (this.autoUpload && totalScore >= this.uploadThreshold) {
                    this.uploadClip(blob, eventType, totalScore);
                }

                // Keep max 10 clips in memory
                while (this.clips.length > 10) {
                    const old = this.clips.shift();
                    URL.revokeObjectURL(old.url);
                }

                this.events = [];
                this.hotStreak = Math.max(0, this.hotStreak - 30);
                this.updateClipUI();
                this.startRecording();
            },

            async uploadClip(blob, type, score) {
                try {
                    this.clipCount++;
                    const filename = `locomotio_${type}_${score}pts_${Date.now()}.webm`;

                    const formData = new FormData();
                    formData.append('video', blob, filename);
                    formData.append('type', type);
                    formData.append('score', score);
                    formData.append('player', playerName || 'Unknown');

                    const response = await fetch('https://api.locomot.io/api/clip', {
                        method: 'POST',
                        body: formData
                    });

                    if (response.ok) {
                        console.log('üé¨ UPLOADED:', type, score + 'pts');
                        this.showNotification(`üé¨ CLIP UPLOADED! ${type.replace('_',' ').toUpperCase()} (${score}pts)`);
                    } else {
                        console.log('üé¨ Upload failed:', response.status);
                    }
                } catch (e) {
                    console.log('üé¨ Upload error:', e);
                }
            },

            showNotification(msg) {
                const notif = document.createElement('div');
                notif.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,255,0,0.9);color:#000;padding:15px 30px;border-radius:10px;font-size:16px;font-weight:bold;z-index:9999;animation:fadeOut 2s forwards;';
                notif.textContent = msg;
                document.body.appendChild(notif);
                setTimeout(() => notif.remove(), 2000);
            },

            // Event detectors
            onKill(killerName, victimName) {
                const now = Date.now();
                if (now - this.lastKillTime < 5000) {
                    this.killStreak++;
                } else {
                    this.killStreak = 1;
                }
                this.lastKillTime = now;

                if (this.killStreak >= 2) {
                    this.triggerHighlight('kill_streak', { streak: this.killStreak, killer: killerName, victim: victimName });
                } else {
                    this.triggerHighlight('kill', { killer: killerName, victim: victimName });
                }
            },

            onBecameLeader() {
                if (!this.wasLeader) {
                    this.triggerHighlight('became_leader', { length: snake.length });
                    this.wasLeader = true;
                }
            },

            onLostLeader() {
                this.wasLeader = false;
            },

            onLongTrain(length) {
                if (length >= 30 && length % 10 === 0) {
                    this.triggerHighlight('long_train', { length });
                }
            },

            updateClipUI() {
                // Silent mode - no visible UI
                return;
                let container = document.getElementById('clipContainer');
                if (!container) {
                    container = document.createElement('div');
                    container.id = 'clipContainer';
                    container.style.cssText = 'position:fixed;bottom:10px;right:10px;z-index:100;';
                    document.body.appendChild(container);
                }

                const icons = { kill: 'üíÄ', kill_streak: 'üî•', became_leader: 'üëë', long_train: 'üöÇ' };

                container.innerHTML = `
                    <div style="background:rgba(0,0,0,0.85);padding:10px;border-radius:8px;border:2px solid #0f0;min-width:140px;">
                        <div style="color:#0f0;font-size:10px;margin-bottom:5px;">üé¨ CLIPS ${this.clipCount > 0 ? '(' + this.clipCount + ' uploaded)' : ''}</div>
                        ${this.clips.slice(-3).map((c, i) => `
                            <button onclick="HighlightRecorder.downloadClip(${this.clips.length - 3 + i})"
                                style="display:block;background:#222;border:1px solid #0f0;color:#0f0;padding:4px 8px;margin:2px 0;font-size:8px;cursor:pointer;border-radius:4px;width:100%;">
                                ${icons[c.type] || 'üé¨'} ${c.type.replace('_', ' ').toUpperCase()} ${c.score ? '(' + c.score + 'pts)' : ''}
                            </button>
                        `).join('')}
                        ${this.clips.length > 0 ? `
                        <button onclick="HighlightRecorder.downloadAll()"
                            style="background:#0f0;border:none;color:#000;padding:4px 8px;margin-top:5px;font-size:8px;cursor:pointer;border-radius:4px;width:100%;">
                            ‚¨áÔ∏è DOWNLOAD ALL
                        </button>` : ''}
                    </div>
                `;
            },

            downloadClip(index) {
                const clip = this.clips[index];
                if (!clip) return;
                const a = document.createElement('a');
                a.href = clip.url;
                a.download = `locomotio_${clip.type}_${Date.now()}.webm`;
                a.click();
            },

            downloadAll() {
                this.clips.forEach((clip, i) => {
                    setTimeout(() => {
                        const a = document.createElement('a');
                        a.href = clip.url;
                        a.download = `locomotio_${clip.type}_${i + 1}.webm`;
                        a.click();
                    }, i * 500);
                });
            }
        };

        // Make it globally accessible for UI buttons
        window.HighlightRecorder = HighlightRecorder;

        // === INVITE LINK ===
        function updateInviteLink() {
            const room = roomParam || 'main';
            const link = 'locomot.io?room=' + room;
            document.getElementById('inviteLink').textContent = link;
        }
        function copyInvite() {
            const room = roomParam || 'main';
            const link = 'https://locomot.io?room=' + room;
            navigator.clipboard.writeText(link).then(() => {
                document.getElementById('inviteLink').textContent = 'COPIED!';
                setTimeout(updateInviteLink, 1500);
            });
        }
        setTimeout(updateInviteLink, 100);

        // === IDEA SUBMISSION ===
        document.getElementById('submitIdeaBtn')?.addEventListener('click', () => {
            const idea = prompt("Got an idea for LOCOMOT.IO? Share it!");
            if (idea && idea.trim()) {
                fetch("https://formsubmit.co/ajax/savecharlie@gmail.com", {
                    method: "POST",
                    headers: { "Content-Type": "application/json", "Accept": "application/json" },
                    body: JSON.stringify({ message: idea, _subject: "LOCOMOT.IO Idea" })
                }).then(() => alert("Thanks! Idea sent üí°")).catch(() => alert("Failed to send - try again"));
            }
        });

        // === SCREEN SHAKE ===
        function screenShake() {
            document.body.classList.add('shake');
            setTimeout(() => document.body.classList.remove('shake'), 300);
        }
        
        // === SOUND EFFECTS ===
        const sounds = {
            ctx: null,
            init() {
                if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            },
            play(type) {
                this.init();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                
                if (type === 'shoot') {
                    osc.frequency.value = 200;
                    osc.type = 'square';
                    gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                    gain.gain.exponentialDecayTo && gain.gain.exponentialDecayTo(0.01, this.ctx.currentTime + 0.1);
                    osc.start(); osc.stop(this.ctx.currentTime + 0.05);
                } else if (type === 'pickup') {
                    osc.frequency.value = 600;
                    osc.type = 'sine';
                    gain.gain.setValueAtTime(0.15, this.ctx.currentTime);
                    osc.start(); osc.stop(this.ctx.currentTime + 0.1);
                } else if (type === 'hit') {
                    osc.frequency.value = 150;
                    osc.type = 'sawtooth';
                    gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                    osc.start(); osc.stop(this.ctx.currentTime + 0.15);
                } else if (type === 'death') {
                    osc.frequency.value = 100;
                    osc.type = 'sawtooth';
                    gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(30, this.ctx.currentTime + 0.5);
                    osc.start(); osc.stop(this.ctx.currentTime + 0.5);
                } else if (type === 'powerup') {
                    osc.frequency.value = 400;
                    osc.type = 'sine';
                    gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(800, this.ctx.currentTime + 0.2);
                    osc.start(); osc.stop(this.ctx.currentTime + 0.2);
                }
            }
        };

        // ==================== GAME CODE ====================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });

        // Offscreen canvas for scanlines (pre-rendered for performance)
        const scanlinesCanvas = document.createElement('canvas');
        const scanlinesCtx = scanlinesCanvas.getContext('2d');

        function renderScanlines() {
            scanlinesCanvas.width = canvas.width;
            scanlinesCanvas.height = canvas.height;
            scanlinesCtx.fillStyle = 'rgba(0, 0, 0, 0.13)';
            for (let y = 0; y < scanlinesCanvas.height; y += 4) {
                scanlinesCtx.fillRect(0, y, scanlinesCanvas.width, 2);
            }
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            renderScanlines(); // Re-render scanlines on resize
        }
        resize();
        window.addEventListener('resize', resize);
        
        const GRID = 12;
        const WORLD_COLS = 300;
        const WORLD_ROWS = 200;
        const WORLD_WIDTH = WORLD_COLS * GRID;
        const WORLD_HEIGHT = WORLD_ROWS * GRID;

        // Interpolation helper for smooth movement
        function lerp(a, b, t) { return a + (b - a) * t; }
        
        let cameraX = 0, cameraY = 0, targetCameraX = 0, targetCameraY = 0;
        let cameraZoom = 2, targetZoom = 2; // Start zoomed in
        let gameState = 'start';
        let currentMVP = null; // Track most interesting player for spectating
        let mvpScore = 0;
        
        // Qwen AI name generator - generates realistic player names
        const FALLBACK_NAMES = ['xX_Pro_Xx', 'NoobMaster', 'ShadowKing', 'DarkWolf', 'IceQueen', 'BlazeFury', 'NightOwl', 'StormRider', 'Ninja99', 'ProSniper', 'GhostRider', 'DeathBlade'];
        const generatedNames = new Set();
        
        async function generateTrainName() {
            // Try Cloudflare tunnel first, then localhost
            const endpoints = [
                'https://ollama.locomot.io/api/generate',
                'http://localhost:11434/api/generate'
            ];
            for (const endpoint of endpoints) {
            try {
                const res = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: 'qwen2.5:0.5b',
                        prompt: 'Gaming usernames: xXShadowXx, NightWolf99, BlazeMaster, IceKing2000,',
                        stream: false,
                        options: { num_predict: 10, temperature: 1.2 }
                    }),
                    signal: AbortSignal.timeout(5000)
                });
                const data = await res.json();
                const matches = data.response.match(/[A-Za-z][A-Za-z0-9_]{2,11}/g);
                if (matches) {
                    for (const name of matches) {
                        if (!generatedNames.has(name) && name.length >= 3) {
                            generatedNames.add(name);
                            return name;
                        }
                    }
                }
            } catch (e) { continue; }
            }
            return FALLBACK_NAMES[Math.floor(Math.random() * FALLBACK_NAMES.length)] + Math.floor(Math.random() * 999);
        }
        
        let teamMode = false; // Set by mode selection at start
        let playerTeam = 'blue'; // Player's team (blue or red)
        let score = 0, wave = 1, lastTime = 0, moveTimer = 0, MOVE_INTERVAL = 70; // Faster!
        let aimAngle = 0, isAiming = false;
        let mouseX = 0, mouseY = 0, isMouseAiming = false;
        let trainFrame = 0; // For wheel animation

        // === SPAWN DIRECTOR - L4D-style adaptive spawning ===
        const SpawnDirector = {
            intensity: 50,           // 0-100 rolling combat intensity
            lastCombatTime: 0,       // timestamp of last damage event
            lastSpawnTime: 0,        // rate limiting
            TARGET_POPULATION: 80,   // total entities (AI + real players)
            COMBAT_LULL_MS: 5000,    // 5 seconds without combat = lull

            // Called when any damage happens
            onCombat(dealt, taken) {
                this.lastCombatTime = Date.now();
                this.intensity += dealt * 0.3 + taken * 1.5;
                this.intensity = Math.min(100, this.intensity);
            },

            // Called when enemy is killed
            onKill() {
                this.intensity += 10;
                this.intensity = Math.min(100, this.intensity);
            },

            // Reset on player respawn
            reset() {
                this.intensity = 50;
                this.lastCombatTime = Date.now();
                this.lastSpawnTime = Date.now(); // Ensure spawning can start fresh
            },

            // Get current population (AI + real players)
            getTotalPopulation() {
                const aiCount = enemies.filter(e => e.segments && e.segments.length > 0).length;
                const realCount = Multiplayer.connected ? Multiplayer.otherPlayers.size : 0;
                // Only count player if they're alive
                const playerAlive = (gameState === 'playing' && snake && snake.length > 0) ? 1 : 0;
                return aiCount + realCount + playerAlive;
            },

            // Main update - call each frame
            update(time) {
                // Decay intensity toward baseline
                this.intensity = Math.max(10, this.intensity * 0.997);

                const now = Date.now();
                const inCombatLull = (now - this.lastCombatTime) > this.COMBAT_LULL_MS;
                const currentPop = this.getTotalPopulation();
                const targetPop = this.TARGET_POPULATION + Math.floor((snake.length || 0) / 3);
                const timeSinceSpawn = time - this.lastSpawnTime;

                // Calculate spawn rate based on intensity
                let spawnRate;
                if (this.intensity > 70) {
                    spawnRate = 3000;  // Overwhelmed - slow down
                } else if (this.intensity > 40) {
                    spawnRate = 1500;  // Normal pace
                } else {
                    spawnRate = 800;   // Quiet - speed up
                }

                // Combat lull override - force faster spawning
                if (inCombatLull && this.intensity < 50) {
                    spawnRate = 400;  // Break the lull!
                }

                // Spawn if under population and rate allows
                if (currentPop < targetPop && timeSinceSpawn > spawnRate) {
                    // If in combat lull, spawn near player
                    if (inCombatLull && snake && snake[0]) {
                        this.spawnNearPlayer();
                    } else {
                        spawnEnemy();
                    }
                    this.lastSpawnTime = time;
                }
            },

            // Spawn enemy in ring around player (30-60 tiles away)
            spawnNearPlayer() {
                if (!snake[0]) return spawnEnemy();

                const minDist = 30, maxDist = 60;
                const angle = Math.random() * Math.PI * 2;
                const dist = minDist + Math.random() * (maxDist - minDist);

                const spawnX = Math.floor(snake[0].x + Math.cos(angle) * dist);
                const spawnY = Math.floor(snake[0].y + Math.sin(angle) * dist);

                // Clamp to world bounds
                const x = Math.max(5, Math.min(WORLD_COLS - 5, spawnX));
                const y = Math.max(5, Math.min(WORLD_ROWS - 5, spawnY));

                spawnEnemyAt(x, y);
            }
        };

        const DIR = { UP: {x:0,y:-1}, DOWN: {x:0,y:1}, LEFT: {x:-1,y:0}, RIGHT: {x:1,y:0} };
        // Security: HTML escape to prevent XSS
        const esc = s => String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
        const GUNS = {
            HEAD: { color: '#0f0', fireRate: 200, damage: 12, range: 200 },
            MACHINEGUN: { color: '#f80', fireRate: 80, damage: 5, range: 180 },
            SHOTGUN: { color: '#f55', fireRate: 350, damage: 8, range: 150, spread: 0.4, pellets: 5 },
            CANNON: { color: '#5af', fireRate: 600, damage: 35, range: 250, size: 8 },
            PULSE: { color: '#f0f', fireRate: 500, damage: 15, range: 80, aoe: true }
        };
        const GUN_NAMES = ['MACHINEGUN', 'SHOTGUN', 'CANNON', 'PULSE'];

        // TRAIN PALETTE - warm industrial 8-bit colors
        const TRAIN = {
            black: '#1a1a2e',
            dark_metal: '#4a4a5c',
            metal: '#7a7a8c',
            light_metal: '#b0b0bc',
            rust: '#8b4513',
            rust_light: '#cd853f',
            red: '#c0392b',
            red_light: '#e74c3c',
            gold: '#d4a017',
            gold_light: '#ffd700',
            smoke: '#555566',
            smoke_light: '#888899',
            window: '#87ceeb',
            window_dark: '#5f9ea0',
            green: '#27ae60',
            green_light: '#2ecc71'
        };

        // Smoke puffs from locomotive
        let smokePuffs = [];

        function drawLocomotive(ctx, x, y, size, direction, frame) {
            // CHUNKY BLOCKY DESIGN - reads at any distance
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(Math.atan2(direction.y, direction.x));

            const s = size * 0.5;

            // Main body - big red block
            ctx.fillStyle = TRAIN.red;
            ctx.fillRect(-s, -s*0.7, s*1.8, s*1.4);

            // Cabin (taller back section)
            ctx.fillStyle = TRAIN.red_light;
            ctx.fillRect(-s*1.1, -s, s*0.5, s*2);

            // Smokestack - obvious block on top
            ctx.fillStyle = TRAIN.dark_metal;
            ctx.fillRect(s*0.2, -s*1.2, s*0.4, s*0.5);

            // Headlight - bright yellow/gold
            ctx.fillStyle = (frame % 16 < 8) ? '#fff' : TRAIN.gold_light;
            ctx.fillRect(s*0.7, -s*0.2, s*0.3, s*0.4);

            // Cow catcher - front wedge
            ctx.fillStyle = TRAIN.dark_metal;
            ctx.fillRect(s*0.8, -s*0.5, s*0.3, s*1);

            // Thick black outline for readability
            ctx.strokeStyle = TRAIN.black;
            ctx.lineWidth = 2;
            ctx.strokeRect(-s*1.1, -s, s*2.2, s*2);

            // Wheels - simple black rectangles at edges
            ctx.fillStyle = TRAIN.black;
            ctx.fillRect(-s*0.8, s*0.5, s*0.4, s*0.3);
            ctx.fillRect(s*0.2, s*0.5, s*0.4, s*0.3);
            ctx.fillRect(-s*0.8, -s*0.8, s*0.4, s*0.3);
            ctx.fillRect(s*0.2, -s*0.8, s*0.4, s*0.3);

            ctx.restore();
        }

        function drawBoxcar(ctx, x, y, size, direction, gunType, frame, hp, maxHp) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(Math.atan2(direction.y, direction.x));

            const s = size * 0.5;

            // Determine car color based on gun type
            let carColor = TRAIN.rust;
            if (gunType) {
                if (gunType.color === '#f80') carColor = '#f80';      // Machinegun - orange
                else if (gunType.color === '#f55') carColor = '#e44'; // Shotgun - red
                else if (gunType.color === '#5af') carColor = '#5af'; // Cannon - blue
                else if (gunType.color === '#f0f') carColor = '#f0f'; // Pulse - purple
            }

            // Damage flash
            if (hp < maxHp * 0.25 && Math.sin(frame * 0.5) > 0) carColor = '#600';
            else if (hp < maxHp * 0.5 && Math.sin(frame * 0.3) > 0.5) carColor = '#880';

            // Simple boxcar - just a rectangle
            ctx.fillStyle = carColor;
            ctx.fillRect(-s*0.8, -s*0.6, s*1.6, s*1.2);

            // Thick black outline
            ctx.strokeStyle = TRAIN.black;
            ctx.lineWidth = 2;
            ctx.strokeRect(-s*0.8, -s*0.6, s*1.6, s*1.2);

            // Gun turret - bright colored square on top
            if (gunType) {
                ctx.fillStyle = '#fff';
                ctx.fillRect(-s*0.2, -s*0.2, s*0.4, s*0.4);
                ctx.fillStyle = gunType.color;
                ctx.fillRect(-s*0.15, -s*0.15, s*0.3, s*0.3);
            }

            // Wheels - black rectangles
            ctx.fillStyle = TRAIN.black;
            ctx.fillRect(-s*0.6, s*0.4, s*0.3, s*0.25);
            ctx.fillRect(s*0.3, s*0.4, s*0.3, s*0.25);
            ctx.fillRect(-s*0.6, -s*0.65, s*0.3, s*0.25);
            ctx.fillRect(s*0.3, -s*0.65, s*0.3, s*0.25);

            ctx.restore();
        }

        function drawCaboose(ctx, x, y, size, direction, frame) {
            const s = size / 12;
            ctx.save();
            ctx.translate(x, y);

            let angle = Math.atan2(direction.y, direction.x);
            ctx.rotate(angle);

            // CABOOSE BODY (bright red!)
            ctx.fillStyle = TRAIN.red_light;
            ctx.fillRect(-5*s, -4*s, 10*s, 8*s);
            ctx.strokeStyle = TRAIN.black;
            ctx.lineWidth = s;
            ctx.strokeRect(-5*s, -4*s, 10*s, 8*s);

            // CUPOLA (raised section)
            ctx.fillStyle = TRAIN.red;
            ctx.fillRect(-3*s, -6*s, 6*s, 3*s);
            ctx.strokeRect(-3*s, -6*s, 6*s, 3*s);

            // Cupola windows
            ctx.fillStyle = TRAIN.window;
            ctx.fillRect(-2*s, -5*s, 4*s, 2*s);

            // Side windows
            ctx.fillRect(-4*s, -2*s, 3*s, 3*s);
            ctx.fillRect(1*s, -2*s, 3*s, 3*s);

            // LANTERN (blinking!)
            const lanternBlink = Math.sin(frame * 0.4) > 0;
            ctx.fillStyle = lanternBlink ? TRAIN.gold_light : TRAIN.gold;
            ctx.fillRect(-6*s, -3*s, 2*s, 3*s);
            ctx.strokeStyle = TRAIN.gold;
            ctx.strokeRect(-6*s, -3*s, 2*s, 3*s);

            // Railing
            ctx.strokeStyle = TRAIN.gold;
            ctx.lineWidth = s * 0.8;
            ctx.beginPath();
            ctx.moveTo(-5*s, 4*s);
            ctx.lineTo(-7*s, 4*s);
            ctx.lineTo(-7*s, -4*s);
            ctx.lineTo(-5*s, -4*s);
            ctx.stroke();

            // WHEELS
            const wheelOffset = (frame % 4) * (Math.PI / 2);
            for (let wy of [-3, 3]) {
                ctx.fillStyle = TRAIN.dark_metal;
                ctx.beginPath();
                ctx.arc(0, wy*s, 2*s, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        function spawnSmoke(x, y, direction) {
            // Spawn cloud puff behind the smokestack
            const offsetX = -direction.x * 10;
            const offsetY = -direction.y * 10;
            // Spawn a cluster of overlapping circles for cloud effect
            for (let i = 0; i < 3; i++) {
                smokePuffs.push({
                    x: x + offsetX + (Math.random() - 0.5) * 6,
                    y: y + offsetY + (Math.random() - 0.5) * 6,
                    vx: -direction.x * 0.3 + (Math.random() - 0.5) * 0.8,
                    vy: -0.8 - Math.random() * 0.4,
                    size: 4 + Math.random() * 3,
                    life: 50 + Math.random() * 20,
                    maxLife: 50
                });
            }
        }

        function updateSmoke() {
            for (let i = smokePuffs.length - 1; i >= 0; i--) {
                const p = smokePuffs[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy *= 0.98; // Slow down rise
                p.vx *= 0.98;
                p.size += 0.3; // Grow as it dissipates
                p.life--;
                if (p.life <= 0) smokePuffs.splice(i, 1);
            }
            // Limit total puffs
            if (smokePuffs.length > 100) smokePuffs.splice(0, 20);
        }

        function drawSmoke(ctx) {
            for (const p of smokePuffs) {
                const alpha = (p.life / p.maxLife) * 0.6;
                // Lighter gray that fades
                const gray = 150 + (1 - p.life / p.maxLife) * 80;
                ctx.fillStyle = `rgba(${gray}, ${gray}, ${gray + 10}, ${alpha})`;
                // BLOCKY squares instead of circles
                const sz = Math.floor(p.size);
                ctx.fillRect(Math.floor(p.x) - sz/2, Math.floor(p.y) - sz/2, sz, sz);
            }
        }

        let snake = [], dir = DIR.RIGHT, nextDir = DIR.RIGHT;
        let dirQueue = []; // Queue for fast direction changes
        let tronTrail = [];
        let enemies = [], projectiles = [], enemyProjectiles = [], pickups = [], particles = [];
        let pickupIdCounter = 1;

        function addPickup(data) {
            const pickup = { id: pickupIdCounter++, ...data };
            pickups.push(pickup);
            return pickup;
        }

        function syncPickupIdCounter(list) {
            for (const p of list) {
                if (p && typeof p.id === 'number') {
                    pickupIdCounter = Math.max(pickupIdCounter, p.id + 1);
                }
            }
        }
        let isLeader = false, trailBoostTimer = 0;
        let waveEnemies = 0, waveKills = 0, spawnTimer = 0, waveDelay = 0;
        let bestRank = 999, maxLength = 2;
        let invincibleTimer = 0; // 30 seconds of spawn protection
        let speedTimer = 0; // Speed boost duration
        let magnetTimer = 0; // Magnet pull duration
        const BASE_MOVE_INTERVAL = 80; // Normal move speed (ms)
        
        // Power-up types
        const POWERUPS = {
            SPEED: { name: 'SPEED', color: '#0ff', icon: 'üöÄ', duration: 10000 },
            SHIELD: { name: 'SHIELD', color: '#ff0', icon: 'üõ°Ô∏è', duration: 15000 },
            MAGNET: { name: 'MAGNET', color: '#f0f', icon: 'üß≤', duration: 12000 }
        };
        let deathReason = ''; // Track what killed the player
        let deathDebugInfo = null; // Full debug info at death

        // === PLAYER DATA RECORDER - Collect training data from top players ===
        const playerDataRecorder = {
            data: [],
            minScore: 10, // Only record from players with score >= 10
            maxFrames: 5000, // Max frames to store
            uploadUrl: 'https://locomot-io.savecharlie.partykit.dev/party/collective',

            record(vision, action) {
                // Only record if player is doing well
                if (score < this.minScore) return;
                if (this.data.length >= this.maxFrames) return;

                this.data.push({ state: Array.from(vision), action });
            },

            upload() {
                if (this.data.length < 100) return; // Need enough data

                fetch(this.uploadUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        type: 'player_training_data',
                        data: this.data,
                        score: score,
                        timestamp: Date.now()
                    })
                }).then(() => {
                    console.log(`Uploaded ${this.data.length} training frames`);
                }).catch(() => {});
            },

            clear() {
                this.data = [];
            }
        };

        // === PATTERN TRACKER - Real-time player behavior learning ===
        const patternTracker = {
            leftTurns: 0,
            rightTurns: 0,
            straightMoves: 0,
            turnsNearThreat: [],
            fleeDistances: [],
            recentTurns: [],
            lastTurnTime: 0,

            reset() {
                // Only reset session data, keep cumulative totals
                this.recentTurns = [];
                this.lastTurnTime = 0;
                this.turnsNearThreat = [];
                // Note: leftTurns, rightTurns, fleeDistances persist across games!
            },

            fullReset() {
                // Full reset - only when explicitly requested
                this.leftTurns = 0;
                this.rightTurns = 0;
                this.straightMoves = 0;
                this.turnsNearThreat = [];
                this.fleeDistances = [];
                this.recentTurns = [];
                this.lastTurnTime = 0;
            },

            recordTurn(oldDir, newDir, threatDist) {
                const turnDir = this.getTurnDirection(oldDir, newDir);
                if (turnDir === 0) { this.straightMoves++; return; }

                if (turnDir < 0) this.leftTurns++;
                else this.rightTurns++;

                if (threatDist < 10) {
                    this.turnsNearThreat.push({ dist: threatDist, turnDir });
                    if (threatDist < 5) this.fleeDistances.push(threatDist);
                }

                this.recentTurns.push(turnDir);
                if (this.recentTurns.length > 10) this.recentTurns.shift();

                if ((this.leftTurns + this.rightTurns) % 12 === 0) {
                    showPatternFlash('adapting');
                }
            },

            getTurnDirection(oldDir, newDir) {
                if (oldDir === DIR.UP) return newDir === DIR.LEFT ? -1 : newDir === DIR.RIGHT ? 1 : 0;
                if (oldDir === DIR.DOWN) return newDir === DIR.RIGHT ? -1 : newDir === DIR.LEFT ? 1 : 0;
                if (oldDir === DIR.LEFT) return newDir === DIR.DOWN ? -1 : newDir === DIR.UP ? 1 : 0;
                if (oldDir === DIR.RIGHT) return newDir === DIR.UP ? -1 : newDir === DIR.DOWN ? 1 : 0;
                return 0;
            },

            predictTurn() {
                const total = this.leftTurns + this.rightTurns;
                if (total < 5) return null;
                const leftBias = this.leftTurns / total;
                let recentBias = 0.5;
                if (this.recentTurns.length >= 3) {
                    recentBias = this.recentTurns.filter(t => t < 0).length / this.recentTurns.length;
                }
                const finalBias = (leftBias * 0.3) + (recentBias * 0.7);
                return { predictedDir: finalBias > 0.5 ? -1 : 1, confidence: Math.abs(finalBias - 0.5) * 2 };
            },

            getFleeDistance() {
                if (this.fleeDistances.length < 3) return 5;
                return this.fleeDistances.reduce((a,b) => a+b, 0) / this.fleeDistances.length;
            },

            getStats() {
                const turns = this.leftTurns + this.rightTurns;
                return {
                    leftBias: turns > 0 ? Math.round((this.leftTurns / turns) * 100) : 50,
                    totalTurns: turns,
                    fleeDistance: this.getFleeDistance().toFixed(1),
                    threatReactions: this.turnsNearThreat.length
                };
            },

            // Save patterns to localStorage
            save() {
                const data = {
                    leftTurns: this.leftTurns,
                    rightTurns: this.rightTurns,
                    straightMoves: this.straightMoves,
                    fleeDistances: this.fleeDistances.slice(-50), // Keep last 50
                    savedAt: Date.now()
                };
                localStorage.setItem('locomotio_patterns', JSON.stringify(data));
            },

            // Load patterns from localStorage
            load() {
                try {
                    const saved = localStorage.getItem('locomotio_patterns');
                    if (saved) {
                        const data = JSON.parse(saved);
                        this.leftTurns = data.leftTurns || 0;
                        this.rightTurns = data.rightTurns || 0;
                        this.straightMoves = data.straightMoves || 0;
                        this.fleeDistances = data.fleeDistances || [];
                        console.log('Loaded pattern data:', this.getStats());
                    }
                } catch (e) { console.log('No saved patterns'); }
            },

            // Get data for collective upload
            getCollectiveData() {
                return {
                    patterns: this.getStats(),
                    fleeDistances: this.fleeDistances,
                    timestamp: Date.now(),
                    version: 'v1'
                };
            }
        };

        let patternFlashTimer = 0, patternFlashType = '';
        function showPatternFlash(type) { patternFlashType = type; patternFlashTimer = 90; }

        // === STRATEGY CLASSIFIER - Makes player strategy backfire ===
        const strategyClassifier = {
            // Raw metrics
            killTimestamps: [],
            distanceSamples: [],
            centerTicks: 0,
            totalTicks: 0,
            healthPickups: 0,
            gunPickups: 0,
            killSizes: [],
            chaseEvents: 0,    // Times player moved toward enemy
            fleeEvents: 0,     // Times player moved away from enemy

            // Computed metrics (updated periodically)
            metrics: {
                killsPerMinute: 0,
                avgDistToEnemy: 15,
                centerPct: 0.5,
                healthRatio: 0.5,
                aggression: 0.5,
                avgKillSize: 5
            },

            // Current archetype weights
            archetypes: {
                rusher: 0.2,
                sniper: 0.2,
                farmer: 0.2,
                survivor: 0.2,
                hunter: 0.2
            },

            // Dominant archetype
            dominant: 'neutral',
            confidence: 0,

            // Counter parameters applied to enemies
            counterParams: {
                leftBias: 0,
                straightBias: 0,
                rightBias: 0,
                speedMult: 1.0,
                flankTendency: 0.3
            },

            // Enemy reputation tracking
            enemyReps: new Map(),

            reset() {
                this.killTimestamps = [];
                this.distanceSamples = [];
                this.centerTicks = 0;
                this.totalTicks = 0;
                this.chaseEvents = 0;
                this.fleeEvents = 0;
                this.enemyReps.clear();
            },

            // Called when player kills an enemy
            onKill(enemySize) {
                this.killTimestamps.push(Date.now());
                this.killSizes.push(enemySize);
                if (this.killSizes.length > 30) this.killSizes.shift();
                // Keep last 2 minutes of kills
                this.killTimestamps = this.killTimestamps.filter(t => Date.now() - t < 120000);
            },

            // Called when player picks up item
            onPickup(isHealth) {
                if (isHealth) this.healthPickups++;
                else this.gunPickups++;
            },

            // Called every frame to track position and behavior
            update(playerPos, nearestEnemyDist, playerDir, prevPlayerPos) {
                this.totalTicks++;

                // Track center vs edge positioning
                const inCenter = playerPos.x > WORLD_COLS * 0.33 && playerPos.x < WORLD_COLS * 0.67 &&
                                playerPos.y > WORLD_ROWS * 0.33 && playerPos.y < WORLD_ROWS * 0.67;
                if (inCenter) this.centerTicks++;

                // Track distance to enemies
                if (nearestEnemyDist < 50) {
                    this.distanceSamples.push(nearestEnemyDist);
                    if (this.distanceSamples.length > 100) this.distanceSamples.shift();
                }

                // Track chase vs flee behavior (every 10 frames)
                if (this.totalTicks % 10 === 0 && prevPlayerPos && nearestEnemyDist < 20) {
                    const prevDist = Math.sqrt((prevPlayerPos.x - playerPos.x)**2 + (prevPlayerPos.y - playerPos.y)**2);
                    // This is simplified - would need enemy pos to do properly
                }
            },

            // Called every ~60 frames to recompute metrics
            computeMetrics() {
                // Kills per minute
                const recentKills = this.killTimestamps.filter(t => Date.now() - t < 60000);
                this.metrics.killsPerMinute = recentKills.length;

                // Average distance to enemies
                if (this.distanceSamples.length > 10) {
                    this.metrics.avgDistToEnemy = this.distanceSamples.reduce((a,b) => a+b, 0) / this.distanceSamples.length;
                }

                // Center percentage
                this.metrics.centerPct = this.totalTicks > 0 ? this.centerTicks / this.totalTicks : 0.5;

                // Health vs gun pickup ratio
                const totalPickups = this.healthPickups + this.gunPickups;
                this.metrics.healthRatio = totalPickups > 0 ? this.healthPickups / totalPickups : 0.5;

                // Average kill size
                if (this.killSizes.length > 3) {
                    this.metrics.avgKillSize = this.killSizes.reduce((a,b) => a+b, 0) / this.killSizes.length;
                }

                // Aggression (kills + close distance + center position)
                this.metrics.aggression = Math.min(1, (
                    (this.metrics.killsPerMinute / 5) * 0.4 +
                    (1 - this.metrics.avgDistToEnemy / 20) * 0.3 +
                    this.metrics.centerPct * 0.3
                ));
            },

            // Called every ~120 frames to reclassify player
            classify() {
                this.computeMetrics();
                const m = this.metrics;

                // Score each archetype
                let scores = {
                    // RUSHER: High kills, close to enemies, center map
                    rusher: m.killsPerMinute * 0.15 + (1 - m.avgDistToEnemy/20) * 0.5 + m.centerPct * 0.3,

                    // SNIPER: Moderate kills, stays distant
                    sniper: Math.min(m.killsPerMinute, 3) * 0.2 + (m.avgDistToEnemy/20) * 0.6,

                    // FARMER: Low kills, prioritizes pickups
                    farmer: (1 - Math.min(m.killsPerMinute, 4)/4) * 0.5 + m.healthRatio * 0.3,

                    // SURVIVOR: Avoids combat, edges of map
                    survivor: (1 - m.aggression) * 0.5 + (1 - m.centerPct) * 0.3,

                    // HUNTER: Targets smaller/weaker enemies
                    hunter: m.avgKillSize < 4 ? 0.6 : m.avgKillSize < 6 ? 0.3 : 0.1
                };

                // Normalize to sum to 1
                const total = Object.values(scores).reduce((a,b) => a+b, 0.001);
                for (const key of Object.keys(scores)) {
                    this.archetypes[key] = scores[key] / total;
                }

                // Find dominant archetype
                let maxScore = 0;
                for (const [arch, score] of Object.entries(this.archetypes)) {
                    if (score > maxScore) {
                        maxScore = score;
                        this.dominant = arch;
                    }
                }
                this.confidence = maxScore;

                // Update counter parameters based on dominant archetype
                this.updateCounterParams();

                // Show flash if confident enough
                if (this.confidence > 0.35 && this.totalTicks > 300) {
                    showPatternFlash('strategy');
                }
            },

            // Set counter-strategy parameters
            updateCounterParams() {
                const arch = this.dominant;
                const conf = this.confidence;

                // Base counters for each archetype (no speed boosts - not allowed)
                const counters = {
                    // vs RUSHER: Enemies flank and retreat-bait
                    rusher: { left: 0.4, straight: -0.3, right: 0.4, speed: 1.0, flank: 0.7 },

                    // vs SNIPER: Enemies rush directly, zigzag
                    sniper: { left: 0.2, straight: 0.5, right: 0.2, speed: 1.0, flank: 0.2 },

                    // vs FARMER: Aggressive chase
                    farmer: { left: 0, straight: 0.6, right: 0, speed: 1.0, flank: 0.4 },

                    // vs SURVIVOR: Pincer movement, cut off escape
                    survivor: { left: 0.3, straight: 0.2, right: 0.3, speed: 1.0, flank: 0.8 },

                    // vs HUNTER: Protect weak, bodyguard behavior
                    hunter: { left: 0.1, straight: 0.3, right: 0.1, speed: 1.0, flank: 0.5 }
                };

                const c = counters[arch] || counters.farmer;

                // Apply with confidence scaling
                this.counterParams.leftBias = c.left * conf;
                this.counterParams.straightBias = c.straight * conf;
                this.counterParams.rightBias = c.right * conf;
                this.counterParams.speedMult = 1 + (c.speed - 1) * conf;
                this.counterParams.flankTendency = c.flank * conf;
            },

            // Get bias for a specific enemy based on situation
            getCounterBias(enemyPos, playerPos, enemyId) {
                const dist = Math.abs(enemyPos.x - playerPos.x) + Math.abs(enemyPos.y - playerPos.y);

                // Scale bias by distance (stronger when closer)
                const distScale = dist < 15 ? 1.0 : dist < 25 ? 0.5 : 0.2;

                // Check enemy reputation
                const rep = this.enemyReps.get(enemyId) || { kills: 0, deaths: 0 };
                const repBonus = rep.kills > 0 ? 0.2 : 0; // Successful enemies get bonus

                return {
                    left: this.counterParams.leftBias * distScale * (1 + repBonus),
                    straight: this.counterParams.straightBias * distScale,
                    right: this.counterParams.rightBias * distScale * (1 + repBonus)
                };
            },

            // Track enemy success/failure
            onEnemyKilledPlayer(enemyId) {
                const rep = this.enemyReps.get(enemyId) || { kills: 0, deaths: 0 };
                rep.kills++;
                this.enemyReps.set(enemyId, rep);
            },

            onPlayerKilledEnemy(enemyId) {
                const rep = this.enemyReps.get(enemyId) || { kills: 0, deaths: 0 };
                rep.deaths++;
                this.enemyReps.set(enemyId, rep);
            },

            // Get stats for display
            getDisplayStats() {
                return {
                    dominant: this.dominant.toUpperCase(),
                    confidence: Math.round(this.confidence * 100),
                    kpm: this.metrics.killsPerMinute,
                    aggression: Math.round(this.metrics.aggression * 100)
                };
            }
        };

        // === PHASE 2: REPUTATION SYSTEM ===
        const reputationSystem = {
            // Player reputation (persists across games)
            playerRep: {
                gamesPlayed: 0,
                totalKills: 0,
                totalDeaths: 0,
                avgSurvivalTime: 60,
                dominantStyle: 'neutral',
                styleHistory: [],      // Last 10 game styles
                weaknesses: [],        // What killed them most
                lastPlayed: 0
            },

            // Enemy reputations this game
            enemies: new Map(),

            // Successful strategies (what killed player)
            successfulMoves: [],

            // Failed strategies (what got enemies killed)
            failedMoves: [],

            // Initialize enemy reputation
            initEnemy(enemyId, enemyName) {
                this.enemies.set(enemyId, {
                    id: enemyId,
                    name: enemyName,
                    kills: 0,
                    deaths: 0,
                    streak: 0,
                    bestStreak: 0,
                    recentMoves: [],      // Last 5 move directions
                    isDangerous: false,
                    isPackLeader: false
                });
            },

            // Enemy killed the player
            onEnemyKilledPlayer(enemyId, moveHistory) {
                const rep = this.enemies.get(enemyId);
                if (rep) {
                    rep.kills++;
                    rep.streak++;
                    rep.bestStreak = Math.max(rep.bestStreak, rep.streak);
                    rep.isDangerous = rep.kills >= 2;

                    // Record successful moves for other enemies to copy
                    if (moveHistory && moveHistory.length > 0) {
                        this.successfulMoves.push({
                            enemyId,
                            moves: moveHistory.slice(-5),
                            timestamp: Date.now()
                        });
                        // Keep last 10 successful patterns
                        if (this.successfulMoves.length > 10) this.successfulMoves.shift();
                    }

                    // Update pack leader
                    this.updatePackLeader();
                    console.log(`[REP] ${rep.name} killed player! Streak: ${rep.streak}`);
                }

                // Update player reputation
                this.playerRep.totalDeaths++;
            },

            // Player killed enemy
            onPlayerKilledEnemy(enemyId, moveHistory) {
                const rep = this.enemies.get(enemyId);
                if (rep) {
                    rep.deaths++;
                    rep.streak = 0;
                    rep.isDangerous = false;

                    // Record failed moves for other enemies to avoid
                    if (moveHistory && moveHistory.length > 0) {
                        this.failedMoves.push({
                            enemyId,
                            moves: moveHistory.slice(-5),
                            timestamp: Date.now()
                        });
                        if (this.failedMoves.length > 10) this.failedMoves.shift();
                    }

                    console.log(`[REP] ${rep.name} killed by player`);
                }

                this.playerRep.totalKills++;
            },

            // Find the pack leader (most successful enemy)
            updatePackLeader() {
                let bestKills = 0;
                let leader = null;

                for (const [id, rep] of this.enemies) {
                    rep.isPackLeader = false;
                    if (rep.kills > bestKills) {
                        bestKills = rep.kills;
                        leader = rep;
                    }
                }

                if (leader && leader.kills >= 2) {
                    leader.isPackLeader = true;
                }
            },

            // Get advice for an enemy based on collective learning
            getAdvice(enemyId) {
                const advice = {
                    copyMoves: null,      // Moves to copy from successful enemy
                    avoidMoves: null,     // Moves to avoid from failed enemy
                    followLeader: false,  // Should follow pack leader
                    leaderPos: null
                };

                // Find most recent successful pattern
                if (this.successfulMoves.length > 0) {
                    const recent = this.successfulMoves[this.successfulMoves.length - 1];
                    if (recent.enemyId !== enemyId) {
                        advice.copyMoves = recent.moves;
                    }
                }

                // Find recent failed pattern to avoid
                if (this.failedMoves.length > 0) {
                    const recent = this.failedMoves[this.failedMoves.length - 1];
                    advice.avoidMoves = recent.moves;
                }

                // Check if should follow pack leader
                for (const [id, rep] of this.enemies) {
                    if (rep.isPackLeader && id !== enemyId) {
                        advice.followLeader = true;
                        // Could add leader position tracking here
                        break;
                    }
                }

                return advice;
            },

            // Get reputation-based bias for enemy decisions
            getReputationBias(enemyId) {
                const rep = this.enemies.get(enemyId);
                const advice = this.getAdvice(enemyId);
                let bias = { left: 0, straight: 0, right: 0 };

                if (!rep) return bias;

                // Dangerous enemies are more aggressive
                if (rep.isDangerous) {
                    bias.straight += 0.2;
                }

                // Pack leaders are confident
                if (rep.isPackLeader) {
                    bias.straight += 0.3;
                }

                // Copy successful moves (if we have them)
                if (advice.copyMoves && advice.copyMoves.length > 0) {
                    const lastMove = advice.copyMoves[advice.copyMoves.length - 1];
                    // Bias toward similar moves
                    bias.left += lastMove === 0 ? 0.15 : 0;
                    bias.straight += lastMove === 1 ? 0.15 : 0;
                    bias.right += lastMove === 2 ? 0.15 : 0;
                }

                // Scale by streak (hot enemies are bolder)
                const streakBonus = Math.min(rep.streak * 0.1, 0.3);
                bias.straight += streakBonus;

                return bias;
            },

            // Record enemy move (for pattern tracking)
            recordEnemyMove(enemyId, moveDir) {
                const rep = this.enemies.get(enemyId);
                if (rep) {
                    rep.recentMoves.push(moveDir);
                    if (rep.recentMoves.length > 5) rep.recentMoves.shift();
                }
            },

            // Save player reputation to localStorage
            save() {
                this.playerRep.lastPlayed = Date.now();
                localStorage.setItem('locomotio_player_rep', JSON.stringify(this.playerRep));
            },

            // Load player reputation
            load() {
                try {
                    const saved = localStorage.getItem('locomotio_player_rep');
                    if (saved) {
                        const data = JSON.parse(saved);
                        Object.assign(this.playerRep, data);
                        console.log('[REP] Loaded player reputation:', this.playerRep);
                    }
                } catch (e) { console.log('[REP] No saved reputation'); }
            },

            // Reset for new game
            reset() {
                this.enemies.clear();
                this.successfulMoves = [];
                this.failedMoves = [];
            },

            // End of game - update player rep
            onGameEnd(survivalTime, dominantStyle) {
                this.playerRep.gamesPlayed++;
                this.playerRep.avgSurvivalTime = (this.playerRep.avgSurvivalTime * 0.8) + (survivalTime * 0.2);
                this.playerRep.styleHistory.push(dominantStyle);
                if (this.playerRep.styleHistory.length > 10) this.playerRep.styleHistory.shift();

                // Find most common style
                const styleCounts = {};
                for (const s of this.playerRep.styleHistory) {
                    styleCounts[s] = (styleCounts[s] || 0) + 1;
                }
                let maxCount = 0;
                for (const [style, count] of Object.entries(styleCounts)) {
                    if (count > maxCount) {
                        maxCount = count;
                        this.playerRep.dominantStyle = style;
                    }
                }

                this.save();
            },

            // Get display stats
            getDisplayStats() {
                return {
                    gamesPlayed: this.playerRep.gamesPlayed,
                    kd: this.playerRep.totalDeaths > 0
                        ? (this.playerRep.totalKills / this.playerRep.totalDeaths).toFixed(1)
                        : this.playerRep.totalKills,
                    avgSurvival: Math.round(this.playerRep.avgSurvivalTime),
                    dominantStyle: this.playerRep.dominantStyle.toUpperCase(),
                    dangerousEnemies: [...this.enemies.values()].filter(e => e.isDangerous).length,
                    packLeader: [...this.enemies.values()].find(e => e.isPackLeader)?.name || 'None'
                };
            }
        };

        function drawPatternFlash(ctx) {
            if (patternFlashTimer <= 0) return;
            patternFlashTimer--;
            const alpha = Math.min(1, patternFlashTimer / 30);
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.font = '10px "Press Start 2P"';
            ctx.textAlign = 'center';
            if (patternFlashType === 'adapting') {
                ctx.fillStyle = `rgba(0, 255, 200, ${alpha})`;
                ctx.fillText('ADAPTING...', canvas.width / 2, 70);
            } else if (patternFlashType === 'detected') {
                ctx.fillStyle = `rgba(255, 100, 100, ${alpha})`;
                ctx.fillText('PATTERN DETECTED', canvas.width / 2, 70);
            } else if (patternFlashType === 'strategy') {
                const stats = strategyClassifier.getDisplayStats();
                ctx.fillStyle = `rgba(255, 50, 150, ${alpha})`;
                ctx.fillText(`STRATEGY: ${stats.dominant}`, canvas.width / 2, 70);
                ctx.font = '7px "Press Start 2P"';
                ctx.fillStyle = `rgba(255, 150, 200, ${alpha * 0.8})`;
                ctx.fillText('COUNTERING...', canvas.width / 2, 85);
            }
            ctx.restore();
        }

        function haptic(style = 'light') {
            if (!navigator.vibrate) return;
            switch(style) {
                case 'light': navigator.vibrate(10); break;
                case 'medium': navigator.vibrate(25); break;
                case 'heavy': navigator.vibrate(50); break;
                case 'double': navigator.vibrate([20, 30, 20]); break;
                case 'death': navigator.vibrate([50, 50, 100, 50, 200]); break;
            }
        }
        
        // Vision system for neural network - matches training exactly
        // LOOKAHEAD AI - Simulate future moves to predict outcomes
        function simulateLookahead(headX, headY, currentDir, segments, allEnemies, allPickups, playerSnake, depth = 4) {
            const scores = [0, 0, 0]; // left, straight, right
            const directions = [turnLeft(currentDir), currentDir, turnRight(currentDir)];
            
            for (let d = 0; d < 3; d++) {
                let simX = headX;
                let simY = headY;
                let simDir = directions[d];
                let simSegments = segments.map(s => ({x: s.x, y: s.y}));
                let alive = true;
                let foodCollected = 0;
                let score = 0;
                
                // Simulate several steps ahead
                for (let step = 0; step < depth && alive; step++) {
                    // Move in current direction
                    simX += simDir.x;
                    simY += simDir.y;
                    
                    // Wrap around world
                    if (simX < 0) simX = WORLD_COLS - 1;
                    if (simX >= WORLD_COLS) simX = 0;
                    if (simY < 0) simY = WORLD_ROWS - 1;
                    if (simY >= WORLD_ROWS) simY = 0;
                    
                    // Check self collision
                    for (const seg of simSegments) {
                        if (seg.x === simX && seg.y === simY) {
                            alive = false;
                            score -= 100; // Death is very bad
                            break;
                        }
                    }
                    
                    if (!alive) break;
                    
                    // Check collision with other enemies
                    for (const enemy of allEnemies) {
                        if (!enemy.segments) continue;
                        for (const seg of enemy.segments) {
                            if (seg.x === simX && seg.y === simY) {
                                // Collision - bad if they're bigger
                                if (enemy.segments.length >= simSegments.length) {
                                    alive = false;
                                    score -= 80;
                                } else {
                                    score += 30; // Could eat them!
                                }
                                break;
                            }
                        }
                        if (!alive) break;
                    }
                    
                    if (!alive) break;
                    
                    // Check collision with player
                    if (playerSnake && playerSnake.length > 0) {
                        for (let i = 0; i < playerSnake.length; i++) {
                            const seg = playerSnake[i];
                            if (seg.x === simX && seg.y === simY) {
                                if (i === 0) {
                                    // Head collision - depends on size
                                    if (playerSnake.length >= simSegments.length) {
                                        alive = false;
                                        score -= 90;
                                    } else {
                                        score += 50; // Kill player!
                                    }
                                } else {
                                    alive = false;
                                    score -= 70;
                                }
                                break;
                            }
                        }
                    }
                    
                    if (!alive) break;
                    
                    // Check for nearby food (bonus for paths near food)
                    for (const pickup of allPickups) {
                        const px = Math.floor(pickup.x / GRID);
                        const py = Math.floor(pickup.y / GRID);
                        const dist = Math.abs(simX - px) + Math.abs(simY - py);
                        if (dist === 0) {
                            foodCollected++;
                            score += 20;
                        } else if (dist < 3) {
                            score += 5 / dist; // Closer food = better
                        }
                    }
                    
                    // Update simulated segments (move forward)
                    simSegments.unshift({x: simX, y: simY});
                    if (foodCollected === 0) simSegments.pop();
                    
                    // Slight preference for going straight (more predictable)
                    if (d === 1) score += 0.5;
                    
                    // After first step, continue straight for simulation
                    // (simplification - real tree search would branch)
                }
                
                // Bonus for staying alive
                if (alive) score += 10;
                
                scores[d] = score;
            }
            
            return scores; // [leftScore, straightScore, rightScore]
        }

        function getVision(headX, headY, currentDir, segments, allEnemies, allPickups, playerSnake) {
            // 8 directions relative to heading (matches training order)
            const angles = [0, Math.PI/4, Math.PI/2, 3*Math.PI/4, Math.PI, -3*Math.PI/4, -Math.PI/2, -Math.PI/4];
            const RAY_DIST = 25;

            // Heading angles
            let headingAngle = 0;
            if (currentDir === DIR.UP) headingAngle = -Math.PI/2;
            else if (currentDir === DIR.DOWN) headingAngle = Math.PI/2;
            else if (currentDir === DIR.LEFT) headingAngle = Math.PI;
            else if (currentDir === DIR.RIGHT) headingAngle = 0;

            const myLength = segments.length;

            // 8 directions √ó 7 values = 56 spatial + 4 state = 60 inputs
            // Per direction: [health_pickup, gun_pickup, self, wall, smaller_head, bigger_head, enemy_body]
            // State: [health_ratio, arena_position, threat_density, my_length_normalized]
            const input = new Array(60).fill(0);

            for (let i = 0; i < 8; i++) {
                const angle = headingAngle + angles[i];
                const dx = Math.round(Math.cos(angle));
                const dy = Math.round(Math.sin(angle));

                let healthPickupDist = 0, gunPickupDist = 0;
                let selfDanger = 0, wallDist = 0;
                let enemySmallerDist = 0, enemyBiggerDist = 0, enemyBodyDist = 0;

                for (let dist = 1; dist <= RAY_DIST; dist++) {
                    const checkX = headX + dx * dist;
                    const checkY = headY + dy * dist;

                    // Bounds = wall
                    if (checkX < 0 || checkX >= WORLD_COLS || checkY < 0 || checkY >= WORLD_ROWS) {
                        if (wallDist === 0) wallDist = 1 / dist;
                        break;
                    }

                    // Wall proximity
                    if (wallDist === 0) {
                        if (checkX <= 1 || checkX >= WORLD_COLS-2 || checkY <= 1 || checkY >= WORLD_ROWS-2) {
                            wallDist = 1 / dist;
                        }
                    }

                    // Self collision
                    if (selfDanger === 0) {
                        for (let s = 1; s < segments.length; s++) {
                            if (segments[s].x === checkX && segments[s].y === checkY) {
                                selfDanger = 1 / dist;
                                break;
                            }
                        }
                    }

                    // Other snakes
                    const allSnakes = [...allEnemies];
                    if (playerSnake && playerSnake.length > 0) {
                        allSnakes.push({ segments: playerSnake, isPlayer: true });
                    }

                    for (const other of allSnakes) {
                        const otherSegs = other.segments || other;
                        if (!otherSegs || otherSegs.length === 0) continue;
                        if (otherSegs === segments) continue;

                        const otherLength = otherSegs.length;

                        for (let s = 0; s < otherSegs.length; s++) {
                            const seg = otherSegs[s];
                            if (seg.x === checkX && seg.y === checkY) {
                                if (s === 0) {
                                    if (otherLength < myLength && enemySmallerDist === 0) {
                                        enemySmallerDist = 1 / dist;
                                    } else if (otherLength >= myLength && enemyBiggerDist === 0) {
                                        enemyBiggerDist = 1 / dist;
                                    }
                                } else if (enemyBodyDist === 0) {
                                    enemyBodyDist = 1 / dist;
                                }
                                break;
                            }
                        }
                    }

                    // Pickups - split by type
                    for (const p of allPickups) {
                        const px = Math.floor(p.x / GRID);
                        const py = Math.floor(p.y / GRID);
                        if (px === checkX && py === checkY) {
                            if (p.isHealth && healthPickupDist === 0) {
                                healthPickupDist = 1 / dist;
                            } else if (!p.isHealth && gunPickupDist === 0) {
                                gunPickupDist = 1 / dist;
                            }
                        }
                    }
                }

                // Store 7 features per direction
                const base = i * 7;
                input[base + 0] = healthPickupDist;
                input[base + 1] = gunPickupDist;
                input[base + 2] = selfDanger;
                input[base + 3] = wallDist;
                input[base + 4] = enemySmallerDist;
                input[base + 5] = enemyBiggerDist;
                input[base + 6] = enemyBodyDist;
            }

            // State inputs (indices 56-59)
            // Health ratio
            let totalHp = 0, totalMaxHp = 0;
            for (let s = 1; s < segments.length; s++) {
                if (segments[s].hp !== Infinity) {
                    totalHp += segments[s].hp || 0;
                    totalMaxHp += segments[s].maxHp || 100;
                }
            }
            input[56] = totalMaxHp > 0 ? totalHp / totalMaxHp : 1;

            // Arena position (distance to edge, normalized)
            const distToEdge = Math.min(headX, headY, WORLD_COLS - 1 - headX, WORLD_ROWS - 1 - headY);
            const maxDist = Math.min(WORLD_COLS, WORLD_ROWS) / 2;
            input[57] = Math.min(distToEdge / maxDist, 1);

            // Threat density (nearby enemies)
            let threat = 0;
            for (const e of allEnemies) {
                if (!e.segments || e.segments.length === 0) continue;
                const eh = e.segments[0];
                const dist = Math.abs(eh.x - headX) + Math.abs(eh.y - headY);
                if (dist < 15) {
                    const sizeFactor = e.segments.length > myLength ? 2 : 0.5;
                    threat += sizeFactor / Math.max(dist, 1);
                }
            }
            input[58] = Math.min(threat / 3, 1);

            // Length normalized
            input[59] = Math.min(myLength / 20, 1);

            return input;
        }
        
        function turnLeft(d) {
            if (d === DIR.UP) return DIR.LEFT;
            if (d === DIR.LEFT) return DIR.DOWN;
            if (d === DIR.DOWN) return DIR.RIGHT;
            return DIR.UP;
        }
        
        function turnRight(d) {
            if (d === DIR.UP) return DIR.RIGHT;
            if (d === DIR.RIGHT) return DIR.DOWN;
            if (d === DIR.DOWN) return DIR.LEFT;
            return DIR.UP;
        }
        
        // Spawn an established enemy at a specific location (for pre-population)
        function spawnEstablishedEnemy(x, y, length, isAlpha = false) {
            const dirs = [DIR.UP, DIR.DOWN, DIR.LEFT, DIR.RIGHT];
            const startDir = dirs[Math.floor(Math.random() * dirs.length)];
            
            const isNeural = Math.random() < 0.5;
            let color, personality;
            
            if (isNeural) {
                color = '#f0f';
                personality = { aggression: 0.5, greed: 0.5, caution: 0.5, neural: true };
            } else {
                const personalities = [
                    { aggression: 0.8, greed: 0.3, caution: 0.2 },
                    { aggression: 0.2, greed: 0.9, caution: 0.4 },
                    { aggression: 0.5, greed: 0.5, caution: 0.7 },
                    { aggression: 0.9, greed: 0.1, caution: 0.1 },
                ];
                personality = personalities[Math.floor(Math.random() * personalities.length)];
                
                if (isAlpha) color = '#ff0'; // Alpha predators are gold
                else if (personality.aggression > 0.7) color = '#f55';
                else if (personality.greed > 0.7) color = '#ff0';
                else if (personality.caution > 0.5) color = '#5af';
                else color = '#f80';
            }
            
            const baseHp = 20 + wave * 5;
            const segments = [];
            
            // Build snake body following a path (not just straight line)
            let curX = x, curY = y, curDir = startDir;
            for (let i = 0; i < length; i++) {
                segments.push({
                    x: curX, y: curY,
                    hp: i === 0 ? Infinity : baseHp,
                    maxHp: i === 0 ? Infinity : baseHp,
                    type: i === 0 ? GUNS.HEAD : GUNS[GUN_NAMES[Math.floor(Math.random() * GUN_NAMES.length)]],
                    lastFired: 0
                });
                // Move backwards from head, occasionally turning
                if (i > 0 && Math.random() < 0.3) {
                    curDir = dirs[Math.floor(Math.random() * dirs.length)];
                }
                curX = (curX - curDir.x + WORLD_COLS) % WORLD_COLS;
                curY = (curY - curDir.y + WORLD_ROWS) % WORLD_ROWS;
            }
            
            enemies.push({
                // Assign team to balance (alternate)
                team: enemies.filter(e => e.team === 'blue').length <= enemies.filter(e => e.team === 'red').length ? 'blue' : 'red',
                segments, dir: startDir, nextDir: startDir,
                baseSpeed: 8 + wave * 0.5, damage: 10 + wave * 2,
                moveTimer: Math.random() * 500, // Stagger movement
                lastFired: 0, fireRate: 1200 - wave * 40,
                score: 10 * length, personality,
                targetPos: null, avoidPos: null, lastDecision: 0,
                decisionInterval: 300 + Math.random() * 200
            });
            // Set color based on team in team mode
            const newEnemy = enemies[enemies.length - 1];
            if (teamMode) newEnemy.color = newEnemy.team === "blue" ? "#0af" : "#f55";
            else newEnemy.color = color;
            
            // Generate AI name asynchronously
            generateTrainName().then(name => {
                if (newEnemy.segments.length > 0) newEnemy.name = name;
            });
            
        }
        
        function simulateWorld(ticks) {
            // Run the world simulation for a while before player joins
            for (let t = 0; t < ticks; t++) {
                // Update enemies (simplified - just movement)
                for (const e of enemies) {
                    if (!e.segments || e.segments.length === 0) continue;
                    
                    e.moveTimer += 16; // ~60fps
                    const myLen = e.segments.length;
                    const speedMultiplier = 1 / (1 + (myLen - 1) * 0.05);
                    const actualSpeed = e.baseSpeed * speedMultiplier;
                    const moveInterval = 150 / actualSpeed * 10;
                    
                    if (e.moveTimer >= moveInterval) {
                        e.moveTimer = 0;
                        
                        const head = e.segments[0];
                        let newDir = e.dir;
                        
                        // Simple AI for simulation
                        if (Math.random() < 0.1) {
                            const dirs = [turnLeft(e.dir), e.dir, turnRight(e.dir)];
                            newDir = dirs[Math.floor(Math.random() * dirs.length)];
                        }
                        
                        // Go towards nearest pickup
                        if (pickups.length > 0 && Math.random() < 0.5) {
                            let nearestDist = Infinity, nearestPickup = null;
                            for (const p of pickups) {
                                const px = Math.floor(p.x / GRID), py = Math.floor(p.y / GRID);
                                const dist = Math.abs(head.x - px) + Math.abs(head.y - py);
                                if (dist < nearestDist) { nearestDist = dist; nearestPickup = p; }
                            }
                            if (nearestPickup && nearestDist < 30) {
                                const px = Math.floor(nearestPickup.x / GRID);
                                const py = Math.floor(nearestPickup.y / GRID);
                                const dx = px - head.x, dy = py - head.y;
                                if (Math.abs(dx) > Math.abs(dy)) newDir = dx > 0 ? DIR.RIGHT : DIR.LEFT;
                                else if (Math.abs(dy) > 0) newDir = dy > 0 ? DIR.DOWN : DIR.UP;
                            }
                        }
                        
                        // Don't reverse
                        if (newDir.x === -e.dir.x && newDir.y === -e.dir.y) newDir = e.dir;
                        e.dir = newDir;
                        
                        // Move
                        const prevPositions = e.segments.map(s => ({ x: s.x, y: s.y }));
                        head.x = (head.x + e.dir.x + WORLD_COLS) % WORLD_COLS;
                        head.y = (head.y + e.dir.y + WORLD_ROWS) % WORLD_ROWS;
                        for (let j = 1; j < e.segments.length; j++) {
                            const oldX = e.segments[j].x;
                            const oldY = e.segments[j].y;
                            e.segments[j].x = prevPositions[j - 1].x;
                            e.segments[j].y = prevPositions[j - 1].y;

                            // Turn sparks for enemy trains
                            const newDx = e.segments[j].x - oldX;
                            const newDy = e.segments[j].y - oldY;
                            const oldDir = e.segments[j].lastDir || { x: newDx, y: newDy };
                            if ((oldDir.x !== newDx || oldDir.y !== newDy) && (oldDir.x !== 0 || oldDir.y !== 0)) {
                                emitTurnSparks(oldX, oldY, oldDir, { x: newDx, y: newDy }, e.color);
                            }
                            e.segments[j].lastDir = { x: newDx, y: newDy };
                        }
                        
                        // Pickup collection
                        for (let pi = pickups.length - 1; pi >= 0; pi--) {
                            const p = pickups[pi];
                            const px = Math.floor(p.x / GRID), py = Math.floor(p.y / GRID);
                            if (head.x === px && head.y === py && !p.isHealth) {
                                const tail = e.segments[e.segments.length - 1];
                                e.segments.push({ 
                                    x: tail.x, y: tail.y, 
                                    hp: 20 + wave * 5, maxHp: 20 + wave * 5, 
                                    type: p.type, lastFired: 0 
                                });
                                pickups.splice(pi, 1);
                                // Track recent activity for MVP
                                e.recentPoints = (e.recentPoints || 0) + 10;
                                e.lastPointTime = Date.now();
                            }
                        }
                    }
                }
                
                // Spawn new pickups occasionally
                if (t % 60 === 0 && pickups.length < 20) {
                    const px = Math.floor(Math.random() * WORLD_COLS) * GRID + GRID/2;
                    const py = Math.floor(Math.random() * WORLD_ROWS) * GRID + GRID/2;
                    addPickup({
                        x: px, y: py,
                        type: GUNS[GUN_NAMES[Math.floor(Math.random() * GUN_NAMES.length)]],
                        isHealth: false, bob: Math.random() * Math.PI * 2
                    });
                }
                // Spawn power-ups rarely
                if (t % 300 === 0 && pickups.filter(p => p.isPowerup).length < 3) {
                    const px = Math.floor(Math.random() * WORLD_COLS) * GRID + GRID/2;
                    const py = Math.floor(Math.random() * WORLD_ROWS) * GRID + GRID/2;
                    const powerupTypes = Object.values(POWERUPS);
                    const powerup = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];
                    addPickup({
                        x: px, y: py,
                        type: powerup,
                        isPowerup: true,
                        bob: Math.random() * Math.PI * 2
                    });
                }
            }
        }
        
        function init() {
            score = 0; wave = 3; // Start at wave 3 - world is already established
            enemies = []; projectiles = []; enemyProjectiles = []; pickups = []; particles = [];
            pickupIdCounter = 1;
            waveEnemies = 0; waveKills = 0; spawnTimer = 0; waveDelay = 0;
            bestRank = 999; maxLength = 4; // Reset tracking
            invincibleTimer = 10000; // 10 seconds of spawn protection
            speedTimer = 0; magnetTimer = 0; // Reset power-up timers
            SpawnDirector.reset(); // Initialize spawn director
            patternTracker.reset(); // Reset pattern tracking for new game
            playerDataRecorder.clear(); // Clear training data for new game
            strategyClassifier.reset(); // Reset strategy classifier
            reputationSystem.reset(); // Reset enemy reputations for new game

            const canInitArena = (Multiplayer.connected && Multiplayer.isHost) ||
                (!Multiplayer.connected && !Multiplayer.socket);

            if (canInitArena) {
                // Scatter pickups around the world first
                for (let i = 0; i < 200; i++) {
                    const px = Math.floor(Math.random() * WORLD_COLS) * GRID + GRID/2;
                    const py = Math.floor(Math.random() * WORLD_ROWS) * GRID + GRID/2;
                    addPickup({
                        x: px, y: py,
                        type: GUNS[GUN_NAMES[Math.floor(Math.random() * GUN_NAMES.length)]],
                        isHealth: Math.random() < 0.15,
                        healAmount: 40,
                        bob: Math.random() * Math.PI * 2
                    });
                }
                
                // Spawn initial power-ups
                const powerupTypes = Object.values(POWERUPS);
                for (let i = 0; i < 5; i++) {
                    const px = Math.floor(Math.random() * WORLD_COLS) * GRID + GRID/2;
                    const py = Math.floor(Math.random() * WORLD_ROWS) * GRID + GRID/2;
                    addPickup({
                        x: px, y: py,
                        type: powerupTypes[Math.floor(Math.random() * powerupTypes.length)],
                        isPowerup: true,
                        bob: Math.random() * Math.PI * 2
                    });
                }
                
                // Spawn established enemies across the map
                // Alpha predators (big snakes, 12-25 segments) - fewer of them
                for (let i = 0; i < 6; i++) {
                    const x = Math.floor(Math.random() * (WORLD_COLS - 20)) + 10;
                    const y = Math.floor(Math.random() * (WORLD_ROWS - 20)) + 10;
                    spawnEstablishedEnemy(x, y, 12 + Math.floor(Math.random() * 14), true);
                }
                
                // Medium snakes (5-11 segments) - fewer
                for (let i = 0; i < 20; i++) {
                    const x = Math.floor(Math.random() * (WORLD_COLS - 10)) + 5;
                    const y = Math.floor(Math.random() * (WORLD_ROWS - 10)) + 5;
                    spawnEstablishedEnemy(x, y, 5 + Math.floor(Math.random() * 7));
                }
                
                // Small snakes (2-5 segments) - your peers
                for (let i = 0; i < 50; i++) {
                    const x = Math.floor(Math.random() * (WORLD_COLS - 6)) + 3;
                    const y = Math.floor(Math.random() * (WORLD_ROWS - 6)) + 3;
                    spawnEstablishedEnemy(x, y, 2 + Math.floor(Math.random() * 4));
                }
                
                // Simulate the world for a bit so snakes have moved around
                simulateWorld(600);
            }
            
            // Find a safe spawn location for player (away from big snakes)
            let spawnX, spawnY, attempts = 0;
            do {
                spawnX = Math.floor(Math.random() * (WORLD_COLS - 10)) + 5;
                spawnY = Math.floor(Math.random() * (WORLD_ROWS - 10)) + 5;
                attempts++;
                
                // Check distance from all enemies
                let safe = true;
                for (const e of enemies) {
                    if (e.segments.length === 0) continue;
                    const head = e.segments[0];
                    const dist = Math.abs(head.x - spawnX) + Math.abs(head.y - spawnY);
                    // Stay far away from big snakes
                    if (e.segments.length > 5 && dist < 30) safe = false;
                    // Decent distance from any snake
                    if (dist < 15) safe = false;
                }
                if (safe || attempts > 100) break;
            } while (true);
            
            // Player starts small but tough - head is 5x tougher than body cars
            const HEAD_HP = 1500; // 5x body HP (300)
            snake = [
                { x: spawnX, y: spawnY, type: GUNS.HEAD, hp: HEAD_HP, maxHp: HEAD_HP, lastFired: 0 },
                { x: spawnX - 1, y: spawnY, type: GUNS.MACHINEGUN, hp: 300, maxHp: 300, lastFired: 0 },
                { x: spawnX - 2, y: spawnY, type: GUNS.SHOTGUN, hp: 300, maxHp: 300, lastFired: 0 },
                { x: spawnX - 3, y: spawnY, type: GUNS.CANNON, hp: 300, maxHp: 300, lastFired: 0 }
            ];
            
            dir = DIR.RIGHT; nextDir = DIR.RIGHT;
            aimAngle = 0; isAiming = true;
            
            cameraZoom = 2; targetZoom = 2; // Start zoomed in
            cameraX = spawnX * GRID - canvas.width / 2 / cameraZoom;
            cameraY = spawnY * GRID - canvas.height / 2 / cameraZoom;
            dirQueue = []; // Clear direction queue
            
            updateHUD(); updateLeaderboard(); announceSpawn();
        }
        
        function announceSpawn() {
            const el = document.getElementById('waveAnnounce');
            el.textContent = 'üõ°Ô∏è 45s SHIELD';
            el.classList.add('show');
            waveDelay = 1500;
            haptic('medium');
            setTimeout(() => el.classList.remove('show'), 1500);
        }
        
        function announceWave() {
            const el = document.getElementById('waveAnnounce');
            el.textContent = `WAVE ${wave}`;
            el.classList.add('show');
            waveDelay = 2000;
            haptic('medium');
            setTimeout(() => el.classList.remove('show'), 1500);
        }

        function respawn() {
            // Death effects
            screenShake();
            // sounds disabled
            
            // Capture debug info at death
            const otherPlayersDebug = [];
            if (Multiplayer.connected) {
                for (const [pid, op] of Multiplayer.otherPlayers) {
                    otherPlayersDebug.push({
                        id: pid,
                        name: op.name,
                        segments: op.segments ? op.segments.length : 0,
                        head: op.segments && op.segments[0] ? op.segments[0] : null,
                        color: op.color
                    });
                }
            }
            
            deathDebugInfo = {
                timestamp: new Date().toISOString(),
                reason: deathReason,
                myPosition: snake[0] ? { x: snake[0].x, y: snake[0].y } : null,
                myLength: snake.length,
                myScore: score,
                multiplayer: {
                    connected: Multiplayer.connected,
                    playerId: Multiplayer.playerId,
                    roomId: Multiplayer.roomId,
                    otherPlayers: otherPlayersDebug
                },
                nearbyEnemies: enemies.filter(e => {
                    if (!e.segments || !snake[0]) return false;
                    const dist = Math.abs(e.segments[0].x - snake[0].x) + Math.abs(e.segments[0].y - snake[0].y);
                    return dist < 15;
                }).map(e => ({
                    len: e.segments.length,
                    head: e.segments[0],
                    personality: e.personality?.neural ? 'neural' : 'basic'
                }))
            };
            console.log('DEATH DEBUG:', deathDebugInfo);
            
            // Show death screen with learning stats
            patternTracker.save();
            ruleEngine.save();

            // Report leave to server for player history
            devMode.reportLeave(
                Multiplayer.username || 'Anonymous',
                maxLength,      // Track max length achieved this session
                waveKills,      // Segments destroyed this session
                score           // Final score
            );

            // Update reputation system
            const survivalTime = strategyClassifier.totalTicks / 60; // ~seconds
            reputationSystem.onGameEnd(survivalTime, strategyClassifier.dominant);

            // Update game over screen stats
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalWave').textContent = '#' + (enemies.filter(e => e.segments.length >= snake.length).length + 1);
            document.getElementById('finalLength').textContent = maxLength;
            document.getElementById('deathReasonText').textContent = deathReason || 'Unknown';

            // Pattern stats (compact)
            const pStats = patternTracker.getStats();
            document.getElementById('patternStatsText').textContent = `${pStats.leftBias}% left bias, ${pStats.fleeDistance} tile flee`;

            // Strategy stats (compact)
            const sStats = strategyClassifier.getDisplayStats();
            document.getElementById('strategyStatsText').innerHTML = `<span style="color:#ff0">${sStats.dominant}</span> (${sStats.confidence}%)`;

            // Reputation stats (hidden element for compatibility)
            const rStats = reputationSystem.getDisplayStats();
            document.getElementById('reputationStatsText').textContent = rStats.dominantStyle;

            // Neural stats (compact)
            const gStats = ruleEngine.getStats();
            document.getElementById('godelStatsText').textContent = `${gStats.total} rules, ${gStats.learned} from deaths`;

            // Silent auto-upload to collective
            try {
                fetch('https://locomot-io.savecharlie.partykit.dev/party/collective', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        type: 'upload_training',
                        data: { rules: ruleEngine.rules, patterns: patternTracker.getStats(), deathInfo: deathDebugInfo, timestamp: Date.now() }
                    })
                }).catch(() => {});
                // Upload player training data if we collected enough
                playerDataRecorder.upload();
            } catch(e) {}

            // Show game over screen
            gameState = 'dead';
            canvas.classList.remove('playing');
            document.getElementById('gameOverScreen').classList.remove('hidden');
        }

        function doRespawn() {
            document.getElementById('gameOverScreen').classList.add('hidden');
            SpawnDirector.reset(); // Reset intensity for fresh start

            // Find safe spawn location
            let spawnX, spawnY, attempts = 0;
            do {
                spawnX = Math.floor(Math.random() * (WORLD_COLS - 10)) + 5;
                spawnY = Math.floor(Math.random() * (WORLD_ROWS - 10)) + 5;
                attempts++;

                let safe = true;
                for (const e of enemies) {
                    if (e.segments.length === 0) continue;
                    const head = e.segments[0];
                    const dist = Math.abs(head.x - spawnX) + Math.abs(head.y - spawnY);
                    if (e.segments.length > 5 && dist < 30) safe = false;
                    if (dist < 15) safe = false;
                }
                if (safe || attempts > 100) break;
            } while (true);

            // Fresh start with new train - head is 5x tougher
            const HEAD_HP_RESPAWN = 1500;
            snake = [
                { x: spawnX, y: spawnY, type: GUNS.HEAD, hp: HEAD_HP_RESPAWN, maxHp: HEAD_HP_RESPAWN, lastFired: 0 },
                { x: spawnX - 1, y: spawnY, type: GUNS.MACHINEGUN, hp: 300, maxHp: 300, lastFired: 0 },
                { x: spawnX - 2, y: spawnY, type: GUNS.SHOTGUN, hp: 300, maxHp: 300, lastFired: 0 },
                { x: spawnX - 3, y: spawnY, type: GUNS.CANNON, hp: 300, maxHp: 300, lastFired: 0 }
            ];

            dir = DIR.RIGHT; nextDir = DIR.RIGHT;
            aimAngle = 0; isAiming = true;
            invincibleTimer = 5000; // 5s spawn protection

            cameraZoom = 2; targetZoom = 2;
            cameraX = spawnX * GRID - canvas.width / 2 / cameraZoom;
            cameraY = spawnY * GRID - canvas.height / 2 / cameraZoom;
            dirQueue = [];

            // Reset score on death (io game style)
            score = 0;
            maxLength = 4;
            deathReason = '';
            deathDebugInfo = null;

            gameState = 'playing';
            canvas.classList.add('playing');

            const el = document.getElementById('waveAnnounce');
            el.textContent = 'üõ°Ô∏è RESPAWNING...';
            el.classList.add('show');
            haptic('medium');
            setTimeout(() => el.classList.remove('show'), 1500);
        }

        // Join an existing arena without resetting it (continuous arena mode)
        function joinExistingArena() {
            // Find safe spawn location away from existing enemies
            let spawnX, spawnY, attempts = 0;
            do {
                spawnX = Math.floor(Math.random() * (WORLD_COLS - 10)) + 5;
                spawnY = Math.floor(Math.random() * (WORLD_ROWS - 10)) + 5;
                attempts++;

                let safe = true;
                for (const e of enemies) {
                    if (e.segments.length === 0) continue;
                    const head = e.segments[0];
                    const dist = Math.abs(head.x - spawnX) + Math.abs(head.y - spawnY);
                    if (e.segments.length > 5 && dist < 30) safe = false;
                    if (dist < 15) safe = false;
                }
                if (safe || attempts > 100) break;
            } while (true);

            // Initial player snake - head is 5x tougher
            const HEAD_HP_INIT = 1500;
            score = 0; wave = 3;
            maxLength = 4; bestRank = 999;
            invincibleTimer = 10000; // 10 seconds spawn protection
            speedTimer = 0; magnetTimer = 0;
            SpawnDirector.reset();
            patternTracker.reset();
            playerDataRecorder.clear();
            strategyClassifier.reset();

            snake = [
                { x: spawnX, y: spawnY, type: GUNS.HEAD, hp: HEAD_HP_INIT, maxHp: HEAD_HP_INIT, lastFired: 0 },
                { x: spawnX - 1, y: spawnY, type: GUNS.MACHINEGUN, hp: 300, maxHp: 300, lastFired: 0 },
                { x: spawnX - 2, y: spawnY, type: GUNS.SHOTGUN, hp: 300, maxHp: 300, lastFired: 0 },
                { x: spawnX - 3, y: spawnY, type: GUNS.CANNON, hp: 300, maxHp: 300, lastFired: 0 }
            ];

            dir = DIR.RIGHT; nextDir = DIR.RIGHT;
            aimAngle = 0; isAiming = true;
            dirQueue = [];
            projectiles = []; enemyProjectiles = []; particles = [];

            cameraZoom = 2; targetZoom = 2;
            cameraX = spawnX * GRID - canvas.width / 2 / cameraZoom;
            cameraY = spawnY * GRID - canvas.height / 2 / cameraZoom;

            const el = document.getElementById('waveAnnounce');
            el.textContent = 'üöÇ JOINING ARENA...';
            el.classList.add('show');
            haptic('medium');
            setTimeout(() => el.classList.remove('show'), 1500);
        }

        // Spawn at specific location (used by SpawnDirector for near-player spawns)
        function spawnEnemyAt(spawnX, spawnY) {
            const dirs = [DIR.UP, DIR.DOWN, DIR.LEFT, DIR.RIGHT];
            const startDir = dirs[Math.floor(Math.random() * dirs.length)];
            spawnEnemyCore(spawnX, spawnY, startDir);
        }

        function spawnEnemy() {
            const edge = Math.floor(Math.random() * 4);
            let x, y, startDir;

            switch (edge) {
                case 0: x = 0; y = Math.floor(Math.random() * WORLD_ROWS); startDir = DIR.RIGHT; break;
                case 1: x = WORLD_COLS - 1; y = Math.floor(Math.random() * WORLD_ROWS); startDir = DIR.LEFT; break;
                case 2: x = Math.floor(Math.random() * WORLD_COLS); y = 0; startDir = DIR.DOWN; break;
                case 3: x = Math.floor(Math.random() * WORLD_COLS); y = WORLD_ROWS - 1; startDir = DIR.UP; break;
            }
            spawnEnemyCore(x, y, startDir);
        }

        function spawnEnemyCore(x, y, startDir) {
            
            let trainLength = 2;
            if (wave >= 2 && Math.random() > 0.6) trainLength = 3;
            if (wave >= 4 && Math.random() > 0.7) trainLength = 4;
            if (wave >= 6 && Math.random() > 0.8) trainLength = 5;
            
            // 50% chance to be neural AI, rest are personality-based
            const isNeural = Math.random() < 0.5;
            
            let color, personality;
            if (isNeural) {
                color = '#f0f'; // Magenta for neural AI
                personality = { aggression: 0.5, greed: 0.5, caution: 0.5, neural: true };
            } else {
                const personalities = [
                    { aggression: 0.8, greed: 0.3, caution: 0.2 },
                    { aggression: 0.2, greed: 0.9, caution: 0.4 },
                    { aggression: 0.5, greed: 0.5, caution: 0.7 },
                    { aggression: 0.9, greed: 0.1, caution: 0.1 },
                ];
                personality = personalities[Math.floor(Math.random() * personalities.length)];
                
                if (personality.aggression > 0.7) color = '#f55';
                else if (personality.greed > 0.7) color = '#ff0';
                else if (personality.caution > 0.5) color = '#5af';
                else color = '#f80';
            }
            
            const baseHp = 20 + wave * 5;
            const segments = [];
            for (let i = 0; i < trainLength; i++) {
                let gunType = i === 0 ? GUNS.HEAD : GUNS[GUN_NAMES[Math.floor(Math.random() * GUN_NAMES.length)]];
                const segX = (x - startDir.x * i + WORLD_COLS) % WORLD_COLS;
                const segY = (y - startDir.y * i + WORLD_ROWS) % WORLD_ROWS;
                segments.push({
                    x: segX, y: segY,
                    hp: i === 0 ? Infinity : baseHp,
                    maxHp: i === 0 ? Infinity : baseHp,
                    type: gunType, lastFired: 0
                });
            }
            
            const enemyId = enemies.length;
            enemies.push({
                // Assign team to balance (alternate)
                team: enemies.filter(e => e.team === 'blue').length <= enemies.filter(e => e.team === 'red').length ? 'blue' : 'red',
                name: '...', // Placeholder until Qwen generates name
                segments, dir: startDir, nextDir: startDir,
                baseSpeed: 8 + wave * 0.5, damage: 10 + wave * 2,
                moveTimer: 0, lastFired: 0, fireRate: 1200 - wave * 40,
                score: 10 * trainLength, personality,
                targetPos: null, avoidPos: null, lastDecision: 0,
                decisionInterval: 300 + Math.random() * 200,
                recentPoints: 0, lastPointTime: 0, isMVP: false
            });
            // Set color based on team in team mode
            const newEnemy = enemies[enemies.length - 1];
            if (teamMode) newEnemy.color = newEnemy.team === "blue" ? "#0af" : "#f55";
            else newEnemy.color = color;
            
            // Generate AI name asynchronously
            generateTrainName().then(name => {
                if (newEnemy.segments.length > 0) {
                    newEnemy.name = name;
                    // Update reputation with real name
                    reputationSystem.initEnemy(newEnemy.id, name);
                }
            });

            // Initialize reputation for this enemy
            newEnemy.id = enemyId;
            reputationSystem.initEnemy(enemyId, newEnemy.name);
        }

        function updateSnake() {
            // Store previous positions for interpolation
            for (const seg of snake) {
                seg.prevX = seg.x;
                seg.prevY = seg.y;
            }

            // Consume from direction queue for responsive controls
            const prevDir = dir;
            if (dirQueue.length > 0) {
                const newDir = dirQueue.shift();
                // Extra check to prevent 180 turns
                if (!(dir.x === -newDir.x && dir.y === -newDir.y)) {
                    dir = newDir;
                    nextDir = newDir;
                }
            } else {
                dir = nextDir;
            }

            // Record training data: what vision the player saw and what action they took
            if (snake.length >= 4) {
                const vision = getVision(snake[0].x, snake[0].y, prevDir, snake, enemies, pickups, null);
                // Determine action: 0=left, 1=straight, 2=right relative to prevDir
                let action = 1; // default straight
                if (dir !== prevDir) {
                    const leftDir = turnLeft(prevDir);
                    const rightDir = turnRight(prevDir);
                    if (dir.x === leftDir.x && dir.y === leftDir.y) action = 0;
                    else if (dir.x === rightDir.x && dir.y === rightDir.y) action = 2;
                }
                playerDataRecorder.record(vision, action);
            }

            const head = snake[0];
            const newX = head.x + dir.x;
            const newY = head.y + dir.y;
            const wrappedX = (newX + WORLD_COLS) % WORLD_COLS;
            const wrappedY = (newY + WORLD_ROWS) % WORLD_ROWS;
            
            for (let i = 1; i < snake.length; i++) {
                if (snake[i].x === wrappedX && snake[i].y === wrappedY) {
                    snake[0].hp = 0;
                    deathReason = 'Self collision - ran into own body';
                    return true;
                }
            }
            
            const prevPositions = snake.map(s => ({ x: s.x, y: s.y }));
            // Leader trail logic
            let maxLen = snake.length;
            for(const e of enemies) if(e.segments.length > maxLen) maxLen = e.segments.length;
            if(Multiplayer.connected) for(const [,p] of Multiplayer.otherPlayers) if(p.segments && p.segments.length > maxLen) maxLen = p.segments.length;
            const wasLeaderBefore = isLeader;
            isLeader = (snake.length >= maxLen);
            if (isLeader && !wasLeaderBefore) HighlightRecorder.onBecameLeader();
            if (!isLeader && wasLeaderBefore) HighlightRecorder.onLostLeader();
            if (isLeader) { tronTrail.push({x:wrappedX,y:wrappedY}); if(tronTrail.length>50) tronTrail.shift(); }
            else { for(const t of tronTrail) if(t.x===wrappedX && t.y===wrappedY) { trailBoostTimer = 500; break; } }
            HighlightRecorder.onLongTrain(snake.length);
            snake[0].x = wrappedX;
            snake[0].y = wrappedY;
            
            for (let i = 1; i < snake.length; i++) {
                const oldX = snake[i].x;
                const oldY = snake[i].y;
                snake[i].x = prevPositions[i - 1].x;
                snake[i].y = prevPositions[i - 1].y;

                // Detect direction change for turn sparks
                const newDx = snake[i].x - oldX;
                const newDy = snake[i].y - oldY;
                const oldDir = snake[i].lastDir || { x: newDx, y: newDy };

                // If direction changed, emit sparks
                if (oldDir.x !== newDx || oldDir.y !== newDy) {
                    if (oldDir.x !== 0 || oldDir.y !== 0) { // Don't spark on first move
                        emitTurnSparks(oldX, oldY, oldDir, { x: newDx, y: newDy }, snake[i].type?.color || '#0f0');
                    }
                }
                snake[i].lastDir = { x: newDx, y: newDy };
            }
            
            const headPx = wrappedX * GRID + GRID / 2;
            const headPy = wrappedY * GRID + GRID / 2;
            const pickupRange = magnetTimer > 0 ? GRID * 3 : GRID;
            
            for (let i = pickups.length - 1; i >= 0; i--) {
                const p = pickups[i];
                const dist = Math.sqrt((p.x - headPx) ** 2 + (p.y - headPy) ** 2);
                
                if (dist < pickupRange) {
                    if (p.isPowerup) {
                        // Collect power-up!
                        if (p.type.name === 'SPEED') {
                            speedTimer = p.type.duration;
                        } else if (p.type.name === 'SHIELD') {
                            invincibleTimer = Math.max(invincibleTimer, p.type.duration);
                        } else if (p.type.name === 'MAGNET') {
                            magnetTimer = p.type.duration;
                        }
                        haptic('heavy');
                        // sounds disabled
                        // Big flashy particles
                        for (let j = 0; j < 20; j++) {
                            particles.push({ x: p.x, y: p.y, vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8, life: 40, color: p.type.color });
                        }
                        Multiplayer.sendPickupCollected(p);
                        pickups.splice(i, 1);
                        continue;
                    } else if (p.isHealth) {
                        let mostDamaged = null, lowestHp = Infinity;
                        for (let j = 1; j < snake.length; j++) {
                            if (snake[j].hp < snake[j].maxHp && snake[j].hp < lowestHp) {
                                lowestHp = snake[j].hp;
                                mostDamaged = snake[j];
                            }
                        }
                        if (mostDamaged) {
                            mostDamaged.hp = Math.min(mostDamaged.maxHp, mostDamaged.hp + p.healAmount);
                            haptic('double');
                            for (let j = 0; j < 8; j++) {
                                particles.push({ x: p.x, y: p.y, vx: (Math.random() - 0.5) * 4, vy: (Math.random() - 0.5) * 4, life: 25, color: '#4f4' });
                            }
                        }
                    } else {
                        const tailPos = prevPositions[prevPositions.length - 1];
                        snake.push({ x: tailPos.x, y: tailPos.y, type: p.type, hp: 200, maxHp: 200, lastFired: 0 });
                        haptic('double');
                        // sounds disabled
                        score += 50;
                        for (let j = 0; j < 12; j++) {
                            particles.push({ x: p.x, y: p.y, vx: (Math.random() - 0.5) * 6, vy: (Math.random() - 0.5) * 6, life: 30, color: p.type.color });
                        }
                    }
                    // Track pickup for strategy classification
                    strategyClassifier.onPickup(p.isHealth);
                    Multiplayer.sendPickupCollected(p);
                    pickups.splice(i, 1);
                }
            }

            // Send position to multiplayer server (only when alive!)
            if (Multiplayer.connected && gameState === 'playing') {
                Multiplayer.sendUpdate(snake[0].x, snake[0].y, snake, score);
                
                // PVP COLLISION DETECTION (disabled in team mode)
                if (!teamMode) {
                for (const [playerId, otherPlayer] of Multiplayer.otherPlayers) {
                    if (!otherPlayer.segments || otherPlayer.segments.length === 0) continue;
                    
                    const otherHead = otherPlayer.segments[0];
                    const myLen = snake.length;
                    const theirLen = otherPlayer.segments.length;
                    
                    // Check head vs other player's body (with 1-tile tolerance for lag)
                    for (let i = 0; i < otherPlayer.segments.length; i++) {
                        const seg = otherPlayer.segments[i];
                        const dx = Math.abs(wrappedX - seg.x);
                        const dy = Math.abs(wrappedY - seg.y);
                        
                        // Exact collision or within 1 tile (lag compensation)
                        if (dx <= 1 && dy <= 1 && dx + dy <= 1) {
                            // Collision detected
                            
                            if (i === 0) {
                                // Head-to-head collision!
                                if (myLen > theirLen) {
                                    // We win!
                                    score += theirLen * 100;
                                    haptic('heavy');
                                    // sounds disabled
                                    killFeed.add(playerName, otherPlayer.name);
                                    HighlightRecorder.onKill(playerName, otherPlayer.name);
                                    for (let j = 0; j < 20; j++) {
                                        particles.push({ x: seg.x * GRID, y: seg.y * GRID, vx: (Math.random()-0.5)*8, vy: (Math.random()-0.5)*8, life: 40, color: otherPlayer.color });
                                    }
                                    Multiplayer.send({ type: 'kill', targetId: playerId });
                                } else if (myLen < theirLen) {
                                    // We die!
                                    deathReason = 'Killed by ' + otherPlayer.name + ' (head-on, ' + theirLen + ' vs ' + myLen + ')';
                                    return true;
                                }
                                // Equal size = both survive
                            } else {
                                // Hit their body - we die!
                                deathReason = 'Ran into ' + otherPlayer.name + "'s body (seg " + i + ')';
                                return true;
                            }
                        }
                    }
                }
                
                } // end teamMode check
                
            }

            return false;
        }

        function updateEnemies(dt) {
            const playerHead = snake[0];
            const playerLen = snake.length;
            
            // Track which player segments have been damaged this frame (prevent stacking)
            const playerSegmentsDamagedThisFrame = new Set();
            
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                if (!e.segments || e.segments.length === 0) {
                    SpawnDirector.onKill(); // Enemy died
                    enemies.splice(i, 1);
                    continue;
                }
                
                const head = e.segments[0];
                const myLen = e.segments.length;
                const speedMultiplier = 1 / (1 + (myLen - 1) * 0.05); // Reduced penalty
                const actualSpeed = e.baseSpeed * speedMultiplier;
                
                e.moveTimer += dt;
                const moveInterval = 150 / actualSpeed * 10; // Fixed formula - lower = faster
                
                if (e.moveTimer >= moveInterval) {
                    e.moveTimer = 0;
                    
                    let newDir = e.dir;
                    
                    // NEURAL NETWORK AI + RULE ENGINE
                    if (e.personality.neural) {
                        const vision = getVision(head.x, head.y, e.dir, e.segments, enemies.filter(oe => oe !== e), pickups, snake);

                        // Extract gameState from vision for rule matching
                        // Vision: 8 directions √ó 6 values [food, self, wall, smaller_head, bigger_head, enemy_body]
                        // Dir 0=ahead, 2=right, 6=left
                        // Find leader (biggest snake) direction
                        let leaderDir = null;
                        let maxLen = e.segments.length;
                        for (const other of enemies) {
                            if (other !== e && other.segments && other.segments.length > maxLen) {
                                maxLen = other.segments.length;
                                const dx = other.segments[0].x - head.x;
                                const dy = other.segments[0].y - head.y;
                                leaderDir = { dx, dy, len: other.segments.length };
                            }
                        }
                        // Check player too
                        if (snake.length > maxLen) {
                            maxLen = snake.length;
                            const dx = snake[0].x - head.x;
                            const dy = snake[0].y - head.y;
                            leaderDir = { dx, dy, len: snake.length };
                        }
                        
                        // Calculate leader direction relative to our heading
                        let leaderAhead = false, leaderLeft = false, leaderRight = false;
                        if (leaderDir) {
                            const { dx, dy } = leaderDir;
                            if (e.dir === DIR.UP) { leaderAhead = dy < 0; leaderLeft = dx < 0; leaderRight = dx > 0; }
                            else if (e.dir === DIR.DOWN) { leaderAhead = dy > 0; leaderLeft = dx > 0; leaderRight = dx < 0; }
                            else if (e.dir === DIR.LEFT) { leaderAhead = dx < 0; leaderLeft = dy > 0; leaderRight = dy < 0; }
                            else { leaderAhead = dx > 0; leaderLeft = dy < 0; leaderRight = dy > 0; }
                        }
                        
                        const gameState = {
                            foodAhead: vision[0] > 0,
                            foodLeft: vision[36] > 0,
                            foodRight: vision[12] > 0,
                            wallAhead: vision[2] > 0.3,
                            wallLeft: vision[38] > 0.3,
                            wallRight: vision[14] > 0.3,
                            bodyAhead: vision[1] > 0,
                            bodyLeft: vision[37] > 0,
                            bodyRight: vision[13] > 0,
                            enemyAhead: vision[5] > 0 || vision[3] > 0 || vision[4] > 0,
                            enemyLeft: vision[41] > 0 || vision[39] > 0 || vision[40] > 0,
                            enemyRight: vision[17] > 0 || vision[15] > 0 || vision[16] > 0,
                            enemyCloser: vision[3] > vision[4],
                            leaderAhead,
                            leaderLeft, 
                            leaderRight,
                            iAmBigger: leaderDir ? e.segments.length > leaderDir.len : true
                        };

                        // Get raw neural output
                        let output = neuralBrain.forward(vision);

                        // Apply rules (G√∂del layer)
                        output = ruleEngine.applyRules(output, gameState, e.id);

                        // Apply player strategy counter (makes their strategy backfire)
                        const counterBias = strategyClassifier.getCounterBias(
                            { x: head.x, y: head.y },
                            { x: playerHead.x, y: playerHead.y },
                            e.id
                        );
                        output[0] += counterBias.left;
                        output[1] += counterBias.straight;
                        output[2] += counterBias.right;

                        // Apply reputation-based bias (pack behavior, dangerous enemies)
                        const repBias = reputationSystem.getReputationBias(e.id);
                        output[0] += repBias.left;
                        output[1] += repBias.straight;
                        output[2] += repBias.right;

                        // LOOKAHEAD: Simulate future moves to avoid bad outcomes
                        const lookaheadScores = simulateLookahead(
                            head.x, head.y, e.dir, e.segments,
                            enemies.filter(oe => oe !== e), pickups, snake, 5
                        );
                        
                        // Combine neural output with lookahead (lookahead can veto bad moves)
                        // Normalize neural output to 0-1 range
                        const maxNeural = Math.max(output[0], output[1], output[2]);
                        const minNeural = Math.min(output[0], output[1], output[2]);
                        const range = maxNeural - minNeural || 1;
                        const neuralNorm = output.map(v => (v - minNeural) / range);
                        
                        // If lookahead predicts death (very negative), heavily penalize
                        let safeDirections = 0;
                        for (let i = 0; i < 3; i++) {
                            if (lookaheadScores[i] < -50) {
                                output[i] -= 100; // Veto this direction
                            } else {
                                safeDirections++;
                                // Add lookahead bonus scaled by neural confidence
                                output[i] += lookaheadScores[i] * 0.1;
                            }
                        }

                        // PICKUP BEELINE: If safe, aggressively pursue nearest pickup
                        if (safeDirections > 0 && pickups.length > 0) {
                            // Find nearest pickup
                            let nearestPickup = null;
                            let nearestDist = Infinity;
                            for (const p of pickups) {
                                const px = Math.floor(p.x / GRID);
                                const py = Math.floor(p.y / GRID);
                                const dist = Math.abs(head.x - px) + Math.abs(head.y - py);
                                if (dist < nearestDist) {
                                    nearestDist = dist;
                                    nearestPickup = { x: px, y: py };
                                }
                            }

                            if (nearestPickup && nearestDist < 30) {
                                // Calculate direction to pickup relative to heading
                                const dx = nearestPickup.x - head.x;
                                const dy = nearestPickup.y - head.y;

                                let pickupAhead = false, pickupLeft = false, pickupRight = false;
                                if (e.dir === DIR.UP) { pickupAhead = dy < 0; pickupLeft = dx < 0; pickupRight = dx > 0; }
                                else if (e.dir === DIR.DOWN) { pickupAhead = dy > 0; pickupLeft = dx > 0; pickupRight = dx < 0; }
                                else if (e.dir === DIR.LEFT) { pickupAhead = dx < 0; pickupLeft = dy > 0; pickupRight = dy < 0; }
                                else { pickupAhead = dx > 0; pickupLeft = dy < 0; pickupRight = dy > 0; }

                                // Strong bias toward pickup if that direction is safe
                                const pickupBias = 5 + (10 / Math.max(nearestDist, 1)); // Stronger when closer
                                if (pickupAhead && lookaheadScores[1] >= -50) output[1] += pickupBias;
                                if (pickupLeft && lookaheadScores[0] >= -50) output[0] += pickupBias;
                                if (pickupRight && lookaheadScores[2] >= -50) output[2] += pickupBias;
                            }
                        }

                        // LEADER HUNTING: Bias toward the biggest snake (if we're bigger, hunt; if smaller, maybe flee)
                        if (gameState.leaderAhead || gameState.leaderLeft || gameState.leaderRight) {
                            const huntBias = gameState.iAmBigger ? 2 : -1; // Hunt if bigger, slight avoid if smaller
                            if (gameState.leaderAhead) output[1] += huntBias;
                            if (gameState.leaderLeft) output[0] += huntBias;
                            if (gameState.leaderRight) output[2] += huntBias;
                        }

                        // Make decision from modified output
                        let decision = 1; // default straight
                        if (output[0] > output[1] && output[0] > output[2]) decision = 0;
                        else if (output[2] > output[1] && output[2] > output[0]) decision = 2;

                        // Record state for death analysis (G√∂del learning)
                        ruleEngine.recordState(e.id, gameState, decision);

                        if (decision === 0) newDir = turnLeft(e.dir);
                        else if (decision === 2) newDir = turnRight(e.dir);
                        // decision === 1 means go straight

                        // PATTERN PREDICTION: Override when near player
                        const distToPlayer = Math.abs(head.x - playerHead.x) + Math.abs(head.y - playerHead.y);
                        if (distToPlayer < 8 && distToPlayer > 2) {
                            const prediction = patternTracker.predictTurn();
                            if (prediction && prediction.confidence > 0.3) {
                                // Predict where player will be based on their turn bias
                                const playerDir = dir;
                                let predictedPos = { x: playerHead.x, y: playerHead.y };

                                // If player tends to turn left, anticipate that
                                if (prediction.predictedDir < 0) {
                                    const leftDir = turnLeft(playerDir);
                                    predictedPos.x += leftDir.x * 3;
                                    predictedPos.y += leftDir.y * 3;
                                } else {
                                    const rightDir = turnRight(playerDir);
                                    predictedPos.x += rightDir.x * 3;
                                    predictedPos.y += rightDir.y * 3;
                                }

                                // Move toward predicted position
                                const dx = predictedPos.x - head.x;
                                const dy = predictedPos.y - head.y;

                                if (Math.abs(dx) > Math.abs(dy)) {
                                    const wantDir = dx > 0 ? DIR.RIGHT : DIR.LEFT;
                                    if (!(wantDir.x === -e.dir.x && wantDir.y === -e.dir.y)) {
                                        newDir = wantDir;
                                        // Flash pattern detected occasionally
                                        if (Math.random() < 0.08) showPatternFlash('detected');
                                    }
                                } else {
                                    const wantDir = dy > 0 ? DIR.DOWN : DIR.UP;
                                    if (!(wantDir.x === -e.dir.x && wantDir.y === -e.dir.y)) {
                                        newDir = wantDir;
                                        if (Math.random() < 0.08) showPatternFlash('detected');
                                    }
                                }
                            }
                        }
                    } else {
                        // Original personality-based AI
                        let targetX = playerHead.x, targetY = playerHead.y;
                        const p = e.personality;
                        
                        if (p.greed > 0.5 && pickups.length > 0) {
                            let nearestDist = Infinity;
                            for (const pickup of pickups) {
                                const px = Math.floor(pickup.x / GRID);
                                const py = Math.floor(pickup.y / GRID);
                                const dist = Math.abs(head.x - px) + Math.abs(head.y - py);
                                if (dist < nearestDist && dist < 30) {
                                    nearestDist = dist;
                                    targetX = px; targetY = py;
                                }
                            }
                        }
                        
                        if (p.aggression > 0.7) {
                            for (const other of enemies) {
                                if (other === e || other.segments.length === 0) continue;
                                if (myLen > other.segments.length) {
                                    const dist = Math.abs(head.x - other.segments[0].x) + Math.abs(head.y - other.segments[0].y);
                                    if (dist < 20) { targetX = other.segments[0].x; targetY = other.segments[0].y; break; }
                                }
                            }
                        }
                        
                        if (p.caution > 0.5 && myLen < playerLen) {
                            const dist = Math.abs(head.x - playerHead.x) + Math.abs(head.y - playerHead.y);
                            if (dist < 15) {
                                targetX = head.x + (head.x - playerHead.x) * 2;
                                targetY = head.y + (head.y - playerHead.y) * 2;
                            }
                        }
                        
                        const dx = targetX - head.x, dy = targetY - head.y;
                        if (Math.abs(dx) > Math.abs(dy)) newDir = dx > 0 ? DIR.RIGHT : DIR.LEFT;
                        else if (Math.abs(dy) > 0) newDir = dy > 0 ? DIR.DOWN : DIR.UP;
                    }
                    
                    // Don't reverse
                    if (newDir.x === -e.dir.x && newDir.y === -e.dir.y) newDir = e.dir;
                    
                    // Collision avoidance
                    const nextX = (head.x + newDir.x + WORLD_COLS) % WORLD_COLS;
                    const nextY = (head.y + newDir.y + WORLD_ROWS) % WORLD_ROWS;
                    let willCollide = false;
                    
                    for (let j = 1; j < e.segments.length; j++) {
                        if (e.segments[j].x === nextX && e.segments[j].y === nextY) { willCollide = true; break; }
                    }
                    
                    if (willCollide) {
                        const dirs = [DIR.UP, DIR.DOWN, DIR.LEFT, DIR.RIGHT];
                        for (const tryDir of dirs) {
                            if (tryDir.x === -e.dir.x && tryDir.y === -e.dir.y) continue;
                            const tryX = (head.x + tryDir.x + WORLD_COLS) % WORLD_COLS;
                            const tryY = (head.y + tryDir.y + WORLD_ROWS) % WORLD_ROWS;
                            let safe = true;
                            for (let j = 1; j < e.segments.length; j++) {
                                if (e.segments[j].x === tryX && e.segments[j].y === tryY) { safe = false; break; }
                            }
                            if (safe) { newDir = tryDir; break; }
                        }
                    }
                    
                    e.dir = newDir;
                    
                    // Move
                    const prevPositions = e.segments.map(s => ({ x: s.x, y: s.y }));
                    head.x = (head.x + e.dir.x + WORLD_COLS) % WORLD_COLS;
                    head.y = (head.y + e.dir.y + WORLD_ROWS) % WORLD_ROWS;
                    for (let j = 1; j < e.segments.length; j++) {
                        e.segments[j].x = prevPositions[j - 1].x;
                        e.segments[j].y = prevPositions[j - 1].y;
                    }
                    
                    // Pickup collection
                    for (let pi = pickups.length - 1; pi >= 0; pi--) {
                        const p = pickups[pi];
                        const px = Math.floor(p.x / GRID), py = Math.floor(p.y / GRID);
                        if (head.x === px && head.y === py) {
                            if (!p.isHealth) {
                                const tail = e.segments[e.segments.length - 1];
                                e.segments.push({ x: tail.x, y: tail.y, hp: 20 + wave * 5, maxHp: 20 + wave * 5, type: p.type, lastFired: 0 });
                            }
                            pickups.splice(pi, 1);
                            ruleEngine.onOutcome(e.id, 'ate_food'); // Credit rules for eating
                            for (let j = 0; j < 6; j++) {
                                particles.push({ x: head.x * GRID + GRID/2, y: head.y * GRID + GRID/2, vx: (Math.random()-0.5)*4, vy: (Math.random()-0.5)*4, life: 20, color: e.color });
                            }
                        }
                    }
                }
                
                // Shooting - find best target (player or other enemies)
                const now = performance.now();
                let targetX = null, targetY = null, targetDist = Infinity;
                
                // Check player distance
                const playerDist = Math.abs(head.x - playerHead.x) + Math.abs(head.y - playerHead.y);
                if (playerDist < 25) {
                    targetX = playerHead.x;
                    targetY = playerHead.y;
                    targetDist = playerDist;
                }
                
                // Check other enemies - prioritize smaller ones or threats
                for (const other of enemies) {
                    if (other === e || !other.segments || other.segments.length === 0) continue;
                    const otherHead = other.segments[0];
                    const dist = Math.abs(head.x - otherHead.x) + Math.abs(head.y - otherHead.y);
                    
                    // Engage if: close enough AND (we're bigger OR they're a threat)
                    if (dist < 20) {
                        const dominated = e.segments.length > other.segments.length;
                        const threatened = other.segments.length > e.segments.length && dist < 12;
                        
                        if ((dominated || threatened) && dist < targetDist) {
                            targetX = otherHead.x;
                            targetY = otherHead.y;
                            targetDist = dist;
                        }
                    }
                }
                
                // Fire at target if we have one
                if (targetX !== null) {
                    for (let si = 0; si < e.segments.length; si++) {
                        const seg = e.segments[si];
                        if (!seg.type) continue;
                        if (seg.lastFired === undefined) seg.lastFired = 0;
                        const type = seg.type;
                        if (now - seg.lastFired < type.fireRate) continue;
                        seg.lastFired = now;
                        
                        const sx = seg.x * GRID + GRID/2, sy = seg.y * GRID + GRID/2;
                        const tx = targetX * GRID + GRID/2, ty = targetY * GRID + GRID/2;
                        const angle = Math.atan2(ty - sy, tx - sx);
                        
                        if (si === 0) { e.aimAngle = angle; e.aimX = sx; e.aimY = sy; }
                        
                        if (type.aoe) {
                            // AOE damages player (if not invincible) and other enemies
                            if (invincibleTimer <= 0) {
                                for (const ps of snake) {
                                    const psx = ps.x * GRID + GRID/2, psy = ps.y * GRID + GRID/2;
                                    const dist = Math.sqrt((psx - sx)**2 + (psy - sy)**2);
                                    if (dist < type.range) ps.hp -= type.damage;
                                }
                            }
                            for (const other of enemies) {
                                if (other === e || !other.segments) continue;
                                for (const oseg of other.segments) {
                                    const osx = oseg.x * GRID + GRID/2, osy = oseg.y * GRID + GRID/2;
                                    const dist = Math.sqrt((osx - sx)**2 + (osy - sy)**2);
                                    if (dist < type.range) oseg.hp -= type.damage;
                                }
                            }
                            particles.push({ x: sx, y: sy, vx: 0, vy: 0, life: 15, color: type.color, isAoe: true, radius: 10 });
                        } else if (type.spread) {
                            for (let p = 0; p < type.pellets; p++) {
                                const spread = (Math.random() - 0.5) * type.spread * 2;
                                const a = angle + spread;
                                enemyProjectiles.push({ x: sx, y: sy, vx: Math.cos(a)*5, vy: Math.sin(a)*5, damage: type.damage, size: 3, color: type.color, life: 120, owner: e });
                            }
                        } else {
                            const size = type.size || 4;
                            enemyProjectiles.push({ x: sx, y: sy, vx: Math.cos(angle)*5, vy: Math.sin(angle)*5, damage: type.damage, size, color: type.color, life: 150, owner: e });
                        }
                    }
                }
                
                // Collisions - skip fatal ones during invincibility, grace period, or same team
                if (teamMode && e.team === playerTeam) continue; // Same team, no collision
                // Grace: for 500ms after shield drops, head collisions just push through
                if (head.x === playerHead.x && head.y === playerHead.y) {
                    // If player only has head (no body), any collision is instant death
                    if (playerLen <= 1 && invincibleTimer <= 0) {
                        deathReason = 'Head-only collision - no protection!';
                        return true;
                    }
                    if (invincibleTimer > -2000) {
                        // During invincibility or 2 second grace period, just pass through
                        // But deal significant damage to the enemy for touching us
                        if (e.segments.length > 1) e.segments[1].hp -= 50;
                    } else if (myLen > playerLen + 6) {
                        // Only instant death if enemy is MUCH bigger (7+ segments more)
                        deathReason = `Head collision with MUCH bigger enemy (${myLen} vs ${playerLen} segments)`;
                        console.log('DEATH: Enemy much bigger', { myLen, playerLen, invincibleTimer });
                        return true;
                    } else if (myLen > playerLen) {
                        // Bigger but not by much - take heavy damage instead of instant death
                        // Head takes damage if no body cars, otherwise body cars
                        if (snake.length === 1) {
                            snake[0].hp -= 50;
                        } else {
                            for (let si = 1; si < snake.length && si < 3; si++) {
                                snake[si].hp -= 50;
                            }
                        }
                        haptic('heavy');
                    } else if (myLen < playerLen) {
                        // Player killed this enemy - track for strategy classifier
                        strategyClassifier.onKill(e.segments.length);
                        strategyClassifier.onPlayerKilledEnemy(e.id);
                        for (const seg of e.segments) {
                            addPickup({ x: seg.x*GRID+GRID/2, y: seg.y*GRID+GRID/2, type: GUNS[GUN_NAMES[Math.floor(Math.random()*GUN_NAMES.length)]], isHealth: false, bob: Math.random()*Math.PI*2 });
                            score += 15; waveKills++;
                        }
                        e.segments = [];
                        haptic('medium');
                    } else {
                        // Equal size - both take damage, neither dies instantly
                        // Head takes damage if no body cars
                        if (snake.length === 1) {
                            snake[0].hp -= 30;
                        } else {
                            for (let si = 1; si < snake.length && si < 2; si++) {
                                snake[si].hp -= 30;
                            }
                        }
                        if (e.segments.length === 1) {
                            e.segments[0].hp -= 30;
                        } else {
                            for (let si = 1; si < e.segments.length && si < 2; si++) {
                                e.segments[si].hp -= 30;
                            }
                        }
                    }
                }
                
                // Enemy vs enemy collisions
                for (const other of enemies) {
                    if (other === e || !other.segments || other.segments.length === 0) continue;
                    if (e.segments.length === 0) break;
                    const otherHead = other.segments[0];
                    if (head.x === otherHead.x && head.y === otherHead.y) {
                        const otherLen = other.segments.length;
                        if (myLen > otherLen) {
                            for (const seg of other.segments) { addPickup({ x: seg.x*GRID+GRID/2, y: seg.y*GRID+GRID/2, type: GUNS[GUN_NAMES[Math.floor(Math.random()*GUN_NAMES.length)]], isHealth: false, bob: Math.random()*Math.PI*2 }); waveKills++; }
                            ruleEngine.onOutcome(other.id, 'death');
                            ruleEngine.analyzeDeathAndGenerateRule(other.id);
                            ruleEngine.onOutcome(e.id, 'got_kill');
                            e.recentPoints = (e.recentPoints || 0) + 50; // Big points for kill!
                            e.lastPointTime = Date.now();
                            if (e.isMVP) HighlightRecorder.onKill(e.name, other.name); // MVP kill!
                            other.segments = [];
                        } else if (myLen < otherLen) {
                            for (const seg of e.segments) { addPickup({ x: seg.x*GRID+GRID/2, y: seg.y*GRID+GRID/2, type: GUNS[GUN_NAMES[Math.floor(Math.random()*GUN_NAMES.length)]], isHealth: false, bob: Math.random()*Math.PI*2 }); waveKills++; }
                            ruleEngine.onOutcome(e.id, 'death');
                            ruleEngine.analyzeDeathAndGenerateRule(e.id);
                            ruleEngine.onOutcome(other.id, 'got_kill');
                            other.recentPoints = (other.recentPoints || 0) + 50;
                            other.lastPointTime = Date.now();
                            if (other.isMVP) HighlightRecorder.onKill(other.name, e.name); // MVP kill!
                            e.segments = [];
                        } else {
                            for (const seg of e.segments) { addPickup({ x: seg.x*GRID+GRID/2, y: seg.y*GRID+GRID/2, type: GUNS[GUN_NAMES[Math.floor(Math.random()*GUN_NAMES.length)]], isHealth: false, bob: Math.random()*Math.PI*2 }); waveKills++; }
                            for (const seg of other.segments) { addPickup({ x: seg.x*GRID+GRID/2, y: seg.y*GRID+GRID/2, type: GUNS[GUN_NAMES[Math.floor(Math.random()*GUN_NAMES.length)]], isHealth: false, bob: Math.random()*Math.PI*2 }); waveKills++; }
                            ruleEngine.onOutcome(e.id, 'death');
                            ruleEngine.analyzeDeathAndGenerateRule(e.id);
                            ruleEngine.onOutcome(other.id, 'death');
                            ruleEngine.analyzeDeathAndGenerateRule(other.id);
                            e.segments = [];
                            other.segments = [];
                        }
                    }
                }

                // Self collision
                for (let j = 1; j < e.segments.length; j++) {
                    if (head.x === e.segments[j].x && head.y === e.segments[j].y) {
                        for (const seg of e.segments) { addPickup({ x: seg.x*GRID+GRID/2, y: seg.y*GRID+GRID/2, type: GUNS[GUN_NAMES[Math.floor(Math.random()*GUN_NAMES.length)]], isHealth: false, bob: Math.random()*Math.PI*2 }); waveKills++; }
                        ruleEngine.onOutcome(e.id, 'death');
                        ruleEngine.analyzeDeathAndGenerateRule(e.id);
                        e.segments = [];
                        break;
                    }
                }
                
                // Body collisions with player - limit damage per frame globally
                for (let si = 0; si < e.segments.length; si++) {
                    const seg = e.segments[si];
                    for (let j = 0; j < snake.length; j++) {
                        const ps = snake[j];
                        if (seg.x === ps.x && seg.y === ps.y) {
                            if (si === 0 && j > 0) { seg.hp -= 50; haptic('medium'); }
                            else if (si > 0 && j === 0) {
                                seg.hp = 0; // Kill enemy body
                                // If player has no body cars, head takes damage
                                if (snake.length === 1 && invincibleTimer <= 0) {
                                    const dmg = invincibleTimer > -2000 ? e.damage * 0.3 : e.damage;
                                    snake[0].hp -= dmg;
                                    haptic('heavy');
                                }
                            }
                            else if (si > 0 && j > 0) { 
                                seg.hp -= 30; 
                                // Only damage each player segment once per frame total (not per enemy)
                                // Reduced damage during grace period
                                if (invincibleTimer <= 0 && !playerSegmentsDamagedThisFrame.has(j)) { 
                                    const dmg = invincibleTimer > -2000 ? e.damage * 0.3 : e.damage;
                                    ps.hp -= dmg; 
                                    playerSegmentsDamagedThisFrame.add(j);
                                    haptic('heavy'); 
                                }
                            }
                        }
                    }
                }
                
                // Remove dead segments
                for (let j = e.segments.length - 1; j >= 0; j--) {
                    if (e.segments[j].hp <= 0) {
                        const seg = e.segments[j];
                        score += 10; waveKills++;
                        // Track segment kills for strategy classifier
                        strategyClassifier.onKill(1); // Single segment kill
                        let totalHp = 0, maxTotalHp = 0;
                        for (let k = 1; k < snake.length; k++) { totalHp += snake[k].hp; maxTotalHp += snake[k].maxHp; }
                        const healthPct = maxTotalHp > 0 ? totalHp / maxTotalHp : 1;
                        let dropHealth = healthPct < 0.4 ? Math.random() < 0.8 : Math.random() > healthPct;
                        if (healthPct >= 0.95) dropHealth = false;
                        
                        if (dropHealth) {
                            addPickup({ x: seg.x*GRID+GRID/2, y: seg.y*GRID+GRID/2, type: { color: '#4f4', name: 'HEALTH' }, isHealth: true, healAmount: 40, bob: Math.random()*Math.PI*2 });
                        } else {
                            addPickup({ x: seg.x*GRID+GRID/2, y: seg.y*GRID+GRID/2, type: GUNS[GUN_NAMES[Math.floor(Math.random()*GUN_NAMES.length)]], isHealth: false, bob: Math.random()*Math.PI*2 });
                        }
                        for (let k = 0; k < 8; k++) { particles.push({ x: seg.x*GRID+GRID/2, y: seg.y*GRID+GRID/2, vx: (Math.random()-0.5)*6, vy: (Math.random()-0.5)*6, life: 25, color: e.color }); }
                        e.segments.splice(j);
                        break;
                    }
                }
                
                if (e.segments.length === 0) enemies.splice(i, 1);
            }
            
            const playerSpeedMultiplier = 1 / (1 + (playerLen - 3) * 0.1);
            const speedBoost = speedTimer > 0 ? 1.8 : (trailBoostTimer > 0 ? 1.5 : 1); // 80% faster with speed power-up
            MOVE_INTERVAL = 120 / playerSpeedMultiplier / speedBoost;
            
            // Passive health regen for player segments (2 HP per 100ms = 20 HP/sec)
            for (let i = 1; i < snake.length; i++) {
                const seg = snake[i];
                if (seg.hp < seg.maxHp) {
                    seg.hp = Math.min(seg.maxHp, seg.hp + dt * 0.02);
                }
            }
            
            // Passive health regen for enemy segments (slower - 5 HP/sec)
            for (const e of enemies) {
                if (!e.segments) continue;
                for (let i = 1; i < e.segments.length; i++) {
                    const seg = e.segments[i];
                    if (seg.hp < seg.maxHp) {
                        seg.hp = Math.min(seg.maxHp, seg.hp + dt * 0.005);
                    }
                }
            }
            
            // Check if head (locomotive) is destroyed
            if (snake[0] && snake[0].hp <= 0) {
                deathReason = 'Locomotive destroyed - took too much damage';
                return true;
            }

            for (let i = snake.length - 1; i >= 1; i--) {
                if (snake[i].hp <= 0) {
                    const seg = snake[i];
                    for (let j = 0; j < 10; j++) { particles.push({ x: seg.x*GRID+GRID/2, y: seg.y*GRID+GRID/2, vx: (Math.random()-0.5)*5, vy: (Math.random()-0.5)*5, life: 30, color: seg.type.color }); }
                    snake.splice(i);
                    haptic('heavy');
                    break;
                }
            }

            // Now you can survive with just the head - death only when head HP <= 0
            return false;
        }
        
        function updateEnemyProjectiles(dt) {
            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const p = enemyProjectiles[i];
                p.x += p.vx * dt * 0.2; p.y += p.vy * dt * 0.2; p.life -= dt;
                
                // Check hit on player (skip if invincible, same team, or reduced damage during grace)
                if (!(teamMode && p.owner && p.owner.team === playerTeam))
                if (invincibleTimer <= 0) {
                    for (const seg of snake) {
                        const sx = seg.x * GRID + GRID/2, sy = seg.y * GRID + GRID/2;
                        const dist = Math.sqrt((p.x - sx)**2 + (p.y - sy)**2);
                        if (dist < p.size + GRID/2) {
                            // Reduced damage during 2 second grace period
                            const dmg = invincibleTimer > -2000 ? p.damage * 0.3 : p.damage;
                            seg.hp -= dmg; p.life = 0; haptic('medium');
                            SpawnDirector.onCombat(0, dmg); // Player took damage
                            particles.push({ x: p.x, y: p.y, vx: 0, vy: 0, life: 10, color: '#f00' });
                            break;
                        }
                    }
                }
                
                // Check hit on other enemies (not the owner)
                if (p.life > 0) {
                    for (const e of enemies) {
                        if (e === p.owner || !e.segments) continue;
                        if (teamMode && p.owner && e.team === p.owner.team) continue; // Same team
                        for (const seg of e.segments) {
                            const sx = seg.x * GRID + GRID/2, sy = seg.y * GRID + GRID/2;
                            const dist = Math.sqrt((p.x - sx)**2 + (p.y - sy)**2);
                            if (dist < p.size + GRID/2) {
                                seg.hp -= p.damage; p.life = 0;
                                particles.push({ x: p.x, y: p.y, vx: 0, vy: 0, life: 10, color: '#ff0' });
                                break;
                            }
                        }
                        if (p.life <= 0) break;
                    }
                }
                
                if (p.life <= 0) enemyProjectiles.splice(i, 1);
            }
        }
        
        function updateProjectiles(dt) {
            // Combine enemies + other players into one target list
            const allTargets = [...enemies];
            if (Multiplayer.connected) {
                for (const [playerId, op] of Multiplayer.otherPlayers) {
                    if (op.segments && op.segments.length > 0) {
                        allTargets.push({
                            segments: op.segments.map(s => ({ x: s.x, y: s.y, hp: 999, maxHp: 999 })),
                            color: op.color,
                            isPlayer: true,
                            team: teamMode ? "blue" : null, // All human players on blue in team mode
                            playerId: playerId
                        });
                    }
                }
            }
            
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.x += p.vx * dt * 0.25; p.y += p.vy * dt * 0.25; p.life -= dt;
                
                // Hit any target (enemies or players)
                outer: for (const e of allTargets) {
                    // Skip same team in team mode
                    if (teamMode && e.team === playerTeam) continue;
                    if (!e.segments) continue;
                    for (const seg of e.segments) {
                        const sx = seg.x * GRID + GRID/2, sy = seg.y * GRID + GRID/2;
                        const dist = Math.sqrt((p.x - sx)**2 + (p.y - sy)**2);
                        if (dist < GRID/2 + p.size) {
                            p.life = 0;
                            particles.push({ x: p.x, y: p.y, vx: (Math.random()-0.5)*2, vy: (Math.random()-0.5)*2, life: 10, color: e.color || '#fff' });
                            
                            if (e.isPlayer) {
                                // Hit another player
                                score += 10;
                                haptic('light');
                                // sounds disabled
                                Multiplayer.send({ type: 'hit', targetId: e.playerId, damage: p.damage });
                            } else {
                                // Hit enemy AI
                                seg.hp -= p.damage;
                                SpawnDirector.onCombat(p.damage, 0); // Player dealt damage
                                // sounds disabled
                            }
                            break outer;
                        }
                    }
                }
                
                if (p.life <= 0) projectiles.splice(i, 1);
            }
        }
        
        function fireGuns(time) {
            if (!isAiming) return;
            let fired = false;
            for (let i = 0; i < snake.length; i++) {
                const seg = snake[i], type = seg.type;
                if (time - seg.lastFired < type.fireRate) continue;
                seg.lastFired = time;
                const cx = seg.x * GRID + GRID/2, cy = seg.y * GRID + GRID/2;
                if (type.aoe) {
                    for (const e of enemies) {
                        for (const seg of e.segments) {
                            const sx = seg.x * GRID + GRID/2, sy = seg.y * GRID + GRID/2;
                            const dist = Math.sqrt((sx - cx)**2 + (sy - cy)**2);
                            if (dist < type.range) {
                                seg.hp -= type.damage;
                                SpawnDirector.onCombat(type.damage, 0);
                            }
                        }
                    }
                    particles.push({ x: cx, y: cy, vx: 0, vy: 0, life: 15, color: type.color, isAoe: true, radius: 10 });
                } else if (type.spread) {
                    for (let p = 0; p < type.pellets; p++) {
                        const spread = (Math.random() - 0.5) * type.spread * 2;
                        const angle = aimAngle + spread;
                        projectiles.push({ x: cx, y: cy, vx: Math.cos(angle)*6, vy: Math.sin(angle)*6, damage: type.damage, size: 3, color: type.color, life: 120 });
                    }
                } else {
                    const size = type.size || 4;
                    projectiles.push({ x: cx, y: cy, vx: Math.cos(aimAngle)*7, vy: Math.sin(aimAngle)*7, damage: type.damage, size, color: type.color, life: 150 });
                }
                fired = true;
            }
            
        }
        
        // H6 8-bit Comet turn sparks - pixel head with fading tail
        function emitTurnSparks(x, y, oldDir, newDir, color) {
            // Sparks fly out the SIDE - perpendicular to old direction, opposite the turn
            // Cross product of oldDir and newDir tells us turn direction (left or right)
            const cross = oldDir.x * newDir.y - oldDir.y * newDir.x;

            // Perpendicular to old direction, pointing outward from turn
            // If cross > 0, turning left, so sparks go right (perpendicular right of oldDir)
            // If cross < 0, turning right, so sparks go left (perpendicular left of oldDir)
            const perpX = cross > 0 ? -oldDir.y : oldDir.y;
            const perpY = cross > 0 ? oldDir.x : -oldDir.x;
            const sparkAngle = Math.atan2(perpY, perpX);
            const px = 3; // pixel size

            // Emit 3-5 comet sparks in an arc from the side
            const numSparks = 3 + Math.floor(Math.random() * 3);
            for (let i = 0; i < numSparks; i++) {
                const angleOffset = (i / (numSparks - 1) - 0.5) * Math.PI * 0.4; // tighter arc
                const angle = sparkAngle + angleOffset;
                const speed = 2 + Math.random() * 1.5;

                // Each spark is a "comet" with head and tail segments
                const tailLen = 2 + Math.floor(Math.random() * 2);
                for (let j = 0; j < tailLen; j++) {
                    const delay = j * 0.3;
                    const alpha = 1 - (j / tailLen) * 0.6;
                    const size = j === 0 ? px + 1 : px - 1;

                    particles.push({
                        x: x * GRID + GRID / 2,
                        y: y * GRID + GRID / 2,
                        vx: Math.cos(angle) * speed * (1 - j * 0.2),
                        vy: Math.sin(angle) * speed * (1 - j * 0.2),
                        life: 12 + Math.floor(Math.random() * 8) - j * 2,
                        color: j === 0 ? '#fff' : (j === 1 ? '#ff0' : '#f80'),
                        isPixelSpark: true,
                        size: size,
                        alpha: alpha
                    });
                }
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx; p.y += p.vy; p.vx *= 0.92; p.vy *= 0.92; p.life--;
                if (p.isAoe) p.radius += 5;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }
        
        function drawLeaderArrow() {
            if (!snake[0]) return;
            
            // Find the biggest snake (not us)
            let leader = null;
            let maxLen = snake.length;
            
            // Check AI enemies
            for (const e of enemies) {
                if (e.segments && e.segments.length > maxLen) {
                    maxLen = e.segments.length;
                    leader = { x: e.segments[0].x, y: e.segments[0].y, name: 'ALPHA', len: e.segments.length, color: e.color };
                }
            }
            
            // Check other players
            if (Multiplayer.connected) {
                for (const [pid, op] of Multiplayer.otherPlayers) {
                    if (op.segments && op.segments.length > maxLen) {
                        maxLen = op.segments.length;
                        leader = { x: op.segments[0].x, y: op.segments[0].y, name: op.name, len: op.segments.length, color: op.color };
                    }
                }
            }
            
            if (!leader) return; // We're the biggest!
            
            // Calculate angle from player to leader
            const px = snake[0].x * GRID + GRID/2;
            const py = snake[0].y * GRID + GRID/2;
            const lx = leader.x * GRID + GRID/2;
            const ly = leader.y * GRID + GRID/2;
            const angle = Math.atan2(ly - py, lx - px);
            const dist = Math.sqrt((lx-px)**2 + (ly-py)**2);
            
            // Only show if leader is off-screen (far away)
            if (dist < 300) return;
            
            // Draw arrow at edge of view pointing to leader
            const arrowDist = 120;
            const ax = px + Math.cos(angle) * arrowDist;
            const ay = py + Math.sin(angle) * arrowDist;
            
            ctx.save();
            ctx.translate(ax, ay);
            ctx.rotate(angle);
            
            // Pulsing glow
            const pulse = 0.7 + Math.sin(Date.now() / 200) * 0.3;
            ctx.globalAlpha = pulse;
            
            // Arrow shape
            ctx.fillStyle = '#ff0';
            ctx.beginPath();
            ctx.moveTo(15, 0);
            ctx.lineTo(-8, -10);
            ctx.lineTo(-8, 10);
            ctx.closePath();
            ctx.fill();
            
            // Crown icon
            ctx.fillStyle = '#ff0';
            ctx.font = '10px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText('üëë', -20, 4);
            
            ctx.restore();
            
            // Show leader name + length near arrow
            ctx.save();
            ctx.fillStyle = '#ff0';
            ctx.font = '6px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.globalAlpha = pulse;
            ctx.fillText(leader.name + ' (' + leader.len + ')', ax, ay + 20);
            ctx.restore();
        }
        
        function updateWaves(time, dt) {
            if (waveDelay > 0) { waveDelay -= dt; return; }
            
            // Update power-up timers
            if (invincibleTimer > 0) invincibleTimer -= dt;
            if (speedTimer > 0) speedTimer -= dt; if (trailBoostTimer > 0) trailBoostTimer -= dt;
            if (magnetTimer > 0) magnetTimer -= dt;
            
            // Magnet effect (offline only) - pull pickups toward player
            if (magnetTimer > 0 && snake.length > 0 && !Multiplayer.connected) {
                const head = snake[0];
                const hx = head.x * GRID + GRID/2;
                const hy = head.y * GRID + GRID/2;
                for (const p of pickups) {
                    const dx = hx - p.x;
                    const dy = hy - p.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 200 && dist > 5) { // Pull range
                        const pull = 3; // Pull strength
                        p.x += (dx / dist) * pull;
                        p.y += (dy / dist) * pull;
                    }
                }
            }
            
            // SpawnDirector handles adaptive spawning (L4D-style intensity pacing)
            // Only host spawns enemies - non-hosts get enemies via arena sync
            // IMPORTANT: Don't spawn until connected (to know if we're host)
            if (Multiplayer.connected && Multiplayer.isHost) {
                SpawnDirector.update(Date.now());
            } else if (!Multiplayer.connected && !Multiplayer.socket) {
                // Not connected yet and never tried - spawn locally (single player fallback)
                SpawnDirector.update(Date.now());
            }

            const canSpawnPickups = (Multiplayer.connected && Multiplayer.isHost) ||
                (!Multiplayer.connected && !Multiplayer.socket);
            
            // Spawn pickups to keep the world interesting
            if (canSpawnPickups && pickups.length < 120 && Math.random() < 0.05) {
                const px = Math.floor(Math.random() * WORLD_COLS) * GRID + GRID/2;
                const py = Math.floor(Math.random() * WORLD_ROWS) * GRID + GRID/2;
                addPickup({
                    x: px, y: py,
                    type: GUNS[GUN_NAMES[Math.floor(Math.random() * GUN_NAMES.length)]],
                    isHealth: Math.random() < 0.1,
                    healAmount: 40,
                    bob: Math.random() * Math.PI * 2
                });
            }
            
            // Difficulty scales with player size
            wave = 3 + Math.floor(snake.length / 4);
        }
        
        function updateCamera() {
            let followTarget = null;
            let followLength = 0;

            // SPECTATOR MODE: When dead, PRIORITIZE real players, fall back to AI
            if (gameState === 'dead') {
                let bestScore = 0;
                let newMVP = null;
                const now = Date.now();
                let hasRealPlayer = false;

                // Clear old MVP status
                for (const e of enemies) if (e) e.isMVP = false;
                if (Multiplayer.connected) {
                    for (const [pid, op] of Multiplayer.otherPlayers) op.isMVP = false;
                }

                // FIRST: Check real multiplayer players (PRIORITY)
                if (Multiplayer.connected) {
                    for (const [pid, op] of Multiplayer.otherPlayers) {
                        if (!op.segments || op.segments.length === 0) continue;
                        hasRealPlayer = true;
                        // Real players get 10x score bonus to always be prioritized
                        const lengthScore = op.segments.length * 20;
                        if (lengthScore > bestScore) {
                            bestScore = lengthScore;
                            followTarget = { x: op.segments[0].x, y: op.segments[0].y };
                            followLength = op.segments.length;
                            newMVP = op;
                        }
                    }
                }

                // SECOND: If no real players, check AI enemies
                if (!hasRealPlayer) {
                    for (let i = 0; i < enemies.length; i++) {
                        const e = enemies[i];
                        if (!e || !e.segments || e.segments.length === 0) continue;

                        // Decay recentPoints over time (halves every 5 seconds)
                        const timeSincePoint = now - (e.lastPointTime || 0);
                        const decayFactor = Math.pow(0.5, timeSincePoint / 5000);
                        const decayedPoints = (e.recentPoints || 0) * decayFactor;

                        // Interest score = length weight + recent activity weight
                        const lengthScore = e.segments.length * 2;
                        const activityScore = decayedPoints * 3;
                        const totalScore = lengthScore + activityScore;

                        if (totalScore > bestScore) {
                            bestScore = totalScore;
                            followTarget = { x: e.segments[0].x, y: e.segments[0].y };
                            followLength = e.segments.length;
                            newMVP = e;
                        }
                    }
                }

                // Mark MVP and update tracking
                if (newMVP && newMVP !== currentMVP) {
                    currentMVP = newMVP;
                    mvpScore = bestScore;
                    newMVP.isMVP = true;
                }
            }

            // Dev mode override - follow selected real player
            const devTarget = devMode.getFollowTarget();
            if (devTarget) {
                followTarget = { x: devTarget.x, y: devTarget.y };
                followLength = devTarget.length;
            }

            // When spectating, use leader; otherwise use player
            const head = (gameState === 'dead' && followTarget) || devTarget ? followTarget : snake[0];
            const len = (gameState === 'dead' && followTarget) || devTarget ? followLength : snake.length;
            
            if (!head || head.x === undefined) return; // Safety check

            targetCameraX = head.x * GRID + GRID/2 - canvas.width/2/cameraZoom;
            targetCameraY = head.y * GRID + GRID/2 - canvas.height/2/cameraZoom;
            const minZoom = 0.6, maxZoom = 2.0, zoomPerSegment = 0.025;
            targetZoom = Math.max(minZoom, maxZoom - (len - 2) * zoomPerSegment);
            cameraX += (targetCameraX - cameraX) * 0.1;
            cameraY += (targetCameraY - cameraY) * 0.1;
            cameraZoom += (targetZoom - cameraZoom) * 0.02;
            const viewWidth = canvas.width / cameraZoom, viewHeight = canvas.height / cameraZoom;
            cameraX = Math.max(0, Math.min(WORLD_WIDTH - viewWidth, cameraX));
            cameraY = Math.max(0, Math.min(WORLD_HEIGHT - viewHeight, cameraY));
        }
        
        function updateLeaderboard() {
            const entries = [];

            // Only add player to leaderboard if alive
            if (gameState === 'playing') {
                entries.push({ name: playerName || 'YOU', length: snake.length, isPlayer: true, isHuman: true });
            }

            // Add other multiplayer players
            if (Multiplayer.connected) {
                for (const [pid, op] of Multiplayer.otherPlayers) {
                    if (op.segments && op.segments.length > 0) {
                        entries.push({
                            name: op.name || 'Player',
                            length: op.segments.length,
                            isPlayer: false,
                            isMultiplayer: true,
                            isHuman: true,
                            color: op.color,
                            isMVP: op.isMVP && gameState === 'dead'
                        });
                    }
                }
            }

            // Add AI enemies
            for (const e of enemies) {
                if (e.segments.length > 0) {
                    entries.push({
                        name: e.name || 'Train',
                        length: e.segments.length,
                        isPlayer: false,
                        isHuman: false,
                        color: e.color,
                        isNeural: e.personality.neural,
                        isMVP: e.isMVP && gameState === 'dead'
                    });
                }
            }
            entries.sort((a, b) => b.length - a.length);
            const top = entries.slice(0, 12);
            document.getElementById('leaderboardEntries').innerHTML = top.map((e, i) => {
                const cameraIcon = e.isMVP ? 'üì∑ ' : '';
                const typeIcon = e.isHuman ? 'üë§' : 'ü§ñ';
                return `<div class="leaderboard-entry ${e.isPlayer ? 'player' : ''} ${e.isNeural ? 'neural' : ''} ${e.isMultiplayer ? 'multiplayer' : ''} ${e.isMVP ? 'mvp' : ''}" style="${!e.isPlayer ? 'color:' + (e.color && /^#[0-9a-f]{3,6}$/i.test(e.color) ? e.color : '#fff') : ''}"><span class="leaderboard-rank">${i + 1}.</span><span class="leaderboard-name">${cameraIcon}${typeIcon} ${esc(e.name)}</span><span class="leaderboard-score">${e.length}</span></div>`;
            }).join('');
        }
        
        function updateHUD() {
            document.getElementById('snakeLen').textContent = snake.length;
            // Calculate rank
            let rank = 1;
            for (const e of enemies) {
                if (e.segments && e.segments.length > snake.length) rank++;
            }
            document.getElementById('waveNum').textContent = '#' + rank;

            // Show active power-ups or score
            let powerupStatus = [];
            if (invincibleTimer > 0) powerupStatus.push('üõ°Ô∏è' + Math.ceil(invincibleTimer / 1000));
            if (speedTimer > 0) powerupStatus.push('üöÄ' + Math.ceil(speedTimer / 1000));
            if (trailBoostTimer > 0) powerupStatus.push("‚ö°DRAFTING"); if (isLeader) powerupStatus.push("üëëLEADER"); if (teamMode) powerupStatus.push("üë•TEAM"); if (magnetTimer > 0) powerupStatus.push('üß≤' + Math.ceil(magnetTimer / 1000));
            
            if (powerupStatus.length > 0) {
                document.getElementById('score').textContent = powerupStatus.join(' ');
            } else {
                document.getElementById('score').textContent = score;
            }

            // Pattern tracking display
            const stats = patternTracker.getStats();
            if (stats.totalTurns >= 5) {
                const arrow = stats.leftBias > 55 ? '‚Üê' : stats.leftBias < 45 ? '‚Üí' : '‚Üî';
                document.getElementById('patternHud').textContent = arrow + stats.leftBias + '%';
            } else {
                document.getElementById('patternHud').textContent = '...';
            }

            // Track best stats
            if (rank < bestRank) bestRank = rank;
            if (snake.length > maxLength) maxLength = snake.length;
        }
        
        function drawGrid() {
            ctx.strokeStyle = '#150d20'; ctx.lineWidth = 1;
            const startX = Math.floor(cameraX / GRID) * GRID, startY = Math.floor(cameraY / GRID) * GRID;
            const endX = Math.min(WORLD_WIDTH, cameraX + canvas.width/cameraZoom + GRID);
            const endY = Math.min(WORLD_HEIGHT, cameraY + canvas.height/cameraZoom + GRID);
            for (let x = startX; x <= endX; x += GRID) { ctx.beginPath(); ctx.moveTo(x, startY); ctx.lineTo(x, endY); ctx.stroke(); }
            for (let y = startY; y <= endY; y += GRID) { ctx.beginPath(); ctx.moveTo(startX, y); ctx.lineTo(endX, y); ctx.stroke(); }
            ctx.strokeStyle = '#402040'; ctx.lineWidth = 3; ctx.strokeRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);
        }
        
        function drawSnake() {
            // Update train frame for wheel animation
            for(let i=1;i<tronTrail.length;i++){const t0=tronTrail[i-1],t1=tronTrail[i];if(Math.abs(t1.x-t0.x)>2||Math.abs(t1.y-t0.y)>2)continue;ctx.strokeStyle="rgba(255,215,0,"+(i/tronTrail.length)*0.7+")";ctx.lineWidth=2+(i/tronTrail.length)*3;ctx.shadowColor="#ff0";ctx.shadowBlur=8;ctx.beginPath();ctx.moveTo(t0.x*GRID+GRID/2,t0.y*GRID+GRID/2);ctx.lineTo(t1.x*GRID+GRID/2,t1.y*GRID+GRID/2);ctx.stroke();}ctx.shadowBlur=0;
            trainFrame++;

            // Draw smoke behind everything
            drawSmoke(ctx);

            // Invincibility shield effect
            if (invincibleTimer > 0) {
                const head = snake[0];
                const hx = head.x * GRID + GRID/2, hy = head.y * GRID + GRID/2;
                const pulseSize = 25 + Math.sin(Date.now() / 100) * 5;
                const alpha = 0.3 + Math.sin(Date.now() / 150) * 0.2;
                ctx.strokeStyle = `rgba(100, 200, 255, ${alpha})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(hx, hy, pulseSize, 0, Math.PI * 2);
                ctx.stroke();
                ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.5})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(hx, hy, pulseSize - 5, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Get direction for each segment (use next segment or dir for head)
            function getSegDir(i) {
                if (i === 0) return dir;
                const curr = snake[i];
                const prev = snake[i - 1];
                const dx = prev.x - curr.x;
                const dy = prev.y - curr.y;
                if (dx > 0 || (dx < -1)) return DIR.RIGHT; // Handle wrap
                if (dx < 0 || (dx > 1)) return DIR.LEFT;
                if (dy > 0 || (dy < -1)) return DIR.DOWN;
                if (dy < 0 || (dy > 1)) return DIR.UP;
                return dir;
            }

            // Draw from back to front
            const progress = Math.min(moveTimer / MOVE_INTERVAL, 1);
            for (let i = snake.length - 1; i >= 0; i--) {
                const seg = snake[i];
                // Interpolate position for smooth movement
                const prevX = seg.prevX !== undefined ? seg.prevX : seg.x;
                const prevY = seg.prevY !== undefined ? seg.prevY : seg.y;
                // Handle wrap-around (don't interpolate across world edges)
                const dx = Math.abs(seg.x - prevX);
                const dy = Math.abs(seg.y - prevY);
                const interpX = (dx > 2) ? seg.x : lerp(prevX, seg.x, progress);
                const interpY = (dy > 2) ? seg.y : lerp(prevY, seg.y, progress);
                const x = interpX * GRID + GRID/2, y = interpY * GRID + GRID/2;
                const segDir = getSegDir(i);

                // Slight bounce based on frame
                const bounce = Math.sin(trainFrame * 0.3 + i * 0.5) * 1;
                const drawY = y + bounce;

                ctx.shadowColor = invincibleTimer > 0 ? '#5ff' : '#000';
                ctx.shadowBlur = invincibleTimer > 0 ? 15 : 5;

                if (i === 0) {
                    // LOCOMOTIVE HEAD
                    drawLocomotive(ctx, x, drawY, GRID, segDir, trainFrame);

                    // Spawn smoke occasionally
                    if (trainFrame % 8 === 0) {
                        spawnSmoke(x, drawY, segDir);
                    }
                } else {
                    // BOXCARS (gun cars)
                    drawBoxcar(ctx, x, drawY, GRID, segDir, seg.type, trainFrame, seg.hp, seg.maxHp);
                }

                ctx.shadowBlur = 0;

                // Health bar for damaged cars
                if (i > 0 && seg.hp !== undefined && seg.maxHp > 0 && seg.hp < seg.maxHp) {
                    const bw = 16, bh = 3;
                    ctx.fillStyle = '#300';
                    ctx.fillRect(x - bw/2, y - GRID/2 - 10, bw, bh);
                    const pct = Math.max(0, Math.min(1, seg.hp / seg.maxHp));
                    ctx.fillStyle = pct > 0.5 ? '#0f0' : pct > 0.25 ? '#ff0' : '#f00';
                    ctx.fillRect(x - bw/2, y - GRID/2 - 10, bw * pct, bh);
                }
            }

            // Update smoke particles
            updateSmoke();

            // Draw player name tag above head with human emoji
            if (snake.length > 0 && Multiplayer.username) {
                const head = snake[0];
                ctx.save();
                ctx.fillStyle = '#0f0';
                ctx.font = '8px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#000';
                ctx.shadowBlur = 3;
                ctx.fillText(`üë§ ${Multiplayer.username}`, head.x * GRID + GRID/2, head.y * GRID - 8);
                ctx.restore();
            }
        }
        
        function drawAimLine() {
            const head = snake[0];
            const hx = head.x * GRID + GRID/2, hy = head.y * GRID + GRID/2;

            // Aim line is more visible when actively aiming (touch hold or mouse)
            const isActive = isHolding || isMouseAiming;
            ctx.strokeStyle = isActive ? '#0f0' : '#0f04';
            ctx.lineWidth = isActive ? 3 : 2;
            ctx.setLineDash(isActive ? [] : [8, 8]);
            ctx.beginPath();
            ctx.moveTo(hx, hy);
            ctx.lineTo(hx + Math.cos(aimAngle) * 100, hy + Math.sin(aimAngle) * 100);
            ctx.stroke();
            ctx.setLineDash([]);

            // Reticle at aim point
            if (isActive) {
                const rx = hx + Math.cos(aimAngle) * 80, ry = hy + Math.sin(aimAngle) * 80;
                ctx.strokeStyle = '#0f0';
                ctx.lineWidth = 2;
                // Crosshair
                ctx.beginPath();
                ctx.moveTo(rx - 10, ry); ctx.lineTo(rx - 4, ry);
                ctx.moveTo(rx + 4, ry); ctx.lineTo(rx + 10, ry);
                ctx.moveTo(rx, ry - 10); ctx.lineTo(rx, ry - 4);
                ctx.moveTo(rx, ry + 4); ctx.lineTo(rx, ry + 10);
                ctx.stroke();
                // Circle
                ctx.beginPath();
                ctx.arc(rx, ry, 12, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        // Draw queued direction indicator above snake head (max 1 turn)
        function drawDirectionQueue() {
            if (!snake[0]) return;
            const head = snake[0];
            const hx = head.x * GRID + GRID/2, hy = head.y * GRID + GRID/2;

            // Show nextDir if different from current, or first queued direction
            const nextTurn = (nextDir !== dir) ? nextDir : dirQueue[0];
            if (!nextTurn) return;

            // Draw arrow above the head
            ctx.save();
            ctx.fillStyle = 'rgba(0, 255, 100, 0.9)';
            ctx.translate(hx, hy - 25);
            ctx.rotate(Math.atan2(nextTurn.y, nextTurn.x));

            // Arrow shape
            ctx.beginPath();
            ctx.moveTo(8, 0);
            ctx.lineTo(-4, -5);
            ctx.lineTo(-4, 5);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        // Enemy train colors based on type
        const ENEMY_PALETTES = {
            normal: { body: '#4a5568', light: '#718096', dark: '#2d3748' },
            hunter: { body: '#9b2c2c', light: '#e53e3e', dark: '#742a2a' },
            alpha: { body: '#d69e2e', light: '#ecc94b', dark: '#b7791f' },
            neural: { body: '#805ad5', light: '#b794f4', dark: '#553c9a' }
        };

        function drawEnemyLocomotive(ctx, x, y, size, direction, frame, color, isNeural) {
            // CHUNKY SIMPLE ENEMY TRAIN - same style as player
            const palette = isNeural ? ENEMY_PALETTES.neural :
                           color === '#f55' ? ENEMY_PALETTES.hunter :
                           color === '#ff0' ? ENEMY_PALETTES.alpha : ENEMY_PALETTES.normal;

            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(Math.atan2(direction.y, direction.x));

            const s = size * 0.5;

            // Main body - colored block
            ctx.fillStyle = palette.body;
            ctx.fillRect(-s, -s*0.7, s*1.8, s*1.4);

            // Cabin (taller back section)
            ctx.fillStyle = palette.light;
            ctx.fillRect(-s*1.1, -s, s*0.5, s*2);

            // Smokestack
            ctx.fillStyle = palette.dark;
            ctx.fillRect(s*0.2, -s*1.2, s*0.4, s*0.5);

            // Headlight - enemy = red/magenta
            ctx.fillStyle = isNeural ? '#f0f' : '#f44';
            ctx.fillRect(s*0.7, -s*0.2, s*0.3, s*0.4);

            // Front
            ctx.fillStyle = palette.dark;
            ctx.fillRect(s*0.8, -s*0.5, s*0.3, s*1);

            // Thick outline
            ctx.strokeStyle = palette.dark;
            ctx.lineWidth = 2;
            ctx.strokeRect(-s*1.1, -s, s*2.2, s*2);

            // Neural glow ring
            if (isNeural) {
                ctx.strokeStyle = '#f0f';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, s*1.3, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Wheels
            ctx.fillStyle = '#111';
            ctx.fillRect(-s*0.8, s*0.5, s*0.4, s*0.3);
            ctx.fillRect(s*0.2, s*0.5, s*0.4, s*0.3);
            ctx.fillRect(-s*0.8, -s*0.8, s*0.4, s*0.3);
            ctx.fillRect(s*0.2, -s*0.8, s*0.4, s*0.3);

            ctx.restore();
        }

        function drawEnemyBoxcar(ctx, x, y, size, direction, frame, color, hp, maxHp) {
            // CHUNKY SIMPLE - matches player boxcar style
            const isHunter = color === '#f55';
            const isAlpha = color === '#ff0';
            const palette = isHunter ? ENEMY_PALETTES.hunter :
                           isAlpha ? ENEMY_PALETTES.alpha : ENEMY_PALETTES.normal;

            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(Math.atan2(direction.y, direction.x));

            const s = size * 0.5;

            // Damage flash
            let bodyColor = palette.body;
            if (hp < maxHp * 0.25 && Math.sin(frame * 0.5) > 0) bodyColor = '#600';
            else if (hp < maxHp * 0.5 && Math.sin(frame * 0.3) > 0.5) bodyColor = '#880';

            // Simple boxcar rectangle
            ctx.fillStyle = bodyColor;
            ctx.fillRect(-s*0.8, -s*0.6, s*1.6, s*1.2);

            // Thick outline
            ctx.strokeStyle = palette.dark;
            ctx.lineWidth = 2;
            ctx.strokeRect(-s*0.8, -s*0.6, s*1.6, s*1.2);

            // Wheels
            ctx.fillStyle = '#111';
            ctx.fillRect(-s*0.6, s*0.4, s*0.3, s*0.25);
            ctx.fillRect(s*0.3, s*0.4, s*0.3, s*0.25);
            ctx.fillRect(-s*0.6, -s*0.65, s*0.3, s*0.25);
            ctx.fillRect(s*0.3, -s*0.65, s*0.3, s*0.25);

            ctx.restore();
        }

        function drawEnemies() {
            for (const e of enemies) {
                if (e.segments.length === 0) continue;

                // Aim line
                if (e.aimX !== undefined) {
                    ctx.strokeStyle = e.color + '44'; ctx.lineWidth = 2; ctx.setLineDash([4, 4]);
                    ctx.beginPath(); ctx.moveTo(e.aimX, e.aimY); ctx.lineTo(e.aimX + Math.cos(e.aimAngle) * 80, e.aimY + Math.sin(e.aimAngle) * 80); ctx.stroke();
                    ctx.setLineDash([]);
                }

                // Get direction for each segment
                function getEnemySegDir(i) {
                    if (i === 0) return e.dir;
                    const curr = e.segments[i];
                    const prev = e.segments[i - 1];
                    const dx = prev.x - curr.x;
                    const dy = prev.y - curr.y;
                    if (dx > 0 || dx < -1) return DIR.RIGHT;
                    if (dx < 0 || dx > 1) return DIR.LEFT;
                    if (dy > 0 || dy < -1) return DIR.DOWN;
                    if (dy < 0 || dy > 1) return DIR.UP;
                    return e.dir;
                }

                // Draw from back to front
                for (let i = e.segments.length - 1; i >= 0; i--) {
                    const seg = e.segments[i];
                    const x = seg.x * GRID + GRID/2, y = seg.y * GRID + GRID/2;
                    const segDir = getEnemySegDir(i);

                    // Slight bounce
                    const bounce = Math.sin(trainFrame * 0.3 + i * 0.5) * 1;
                    const drawY = y + bounce;

                    ctx.shadowColor = e.color;
                    ctx.shadowBlur = 5;

                    if (i === 0) {
                        // LOCOMOTIVE
                        drawEnemyLocomotive(ctx, x, drawY, GRID, segDir, trainFrame, e.color, e.personality.neural);
                    } else {
                        // BOXCAR
                        drawEnemyBoxcar(ctx, x, drawY, GRID, segDir, trainFrame, e.color, seg.hp, seg.maxHp);
                    }

                    ctx.shadowBlur = 0;

                    // Health bar
                    if (i > 0 && seg.hp !== undefined && seg.maxHp > 0 && seg.hp < seg.maxHp) {
                        const bw = 10;
                        const pct = Math.max(0, Math.min(1, seg.hp / seg.maxHp));
                        ctx.fillStyle = '#400';
                        ctx.fillRect(x - bw/2, y - GRID/2 - 8, bw, 2);
                        ctx.fillStyle = '#f44';
                        ctx.fillRect(x - bw/2, y - GRID/2 - 8, bw * pct, 2);
                    }
                }

                // Name + length above head
                const head = e.segments[0];
                const hx = head.x * GRID + GRID/2;
                const hy = head.y * GRID - 12;
                ctx.save();
                ctx.fillStyle = e.color || '#fff';
                ctx.font = '6px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#000';
                ctx.shadowBlur = 3;
                const displayName = `ü§ñ ${e.name || 'Train'}`;
                ctx.fillText(displayName, hx, hy);
                ctx.restore();

                // Danger indicator - skull for enemies that killed player
                const enemyRep = reputationSystem.enemies.get(e.id);
                if (enemyRep && enemyRep.isDangerous) {
                    const head = e.segments[0];
                    const hx = head.x * GRID + GRID/2 + 12;
                    const hy = head.y * GRID - 8;
                    ctx.font = '10px monospace';
                    ctx.fillStyle = '#f55';
                    ctx.shadowColor = '#f00';
                    ctx.shadowBlur = 8;
                    ctx.fillText('‚ò†', hx, hy);
                    ctx.shadowBlur = 0;
                }

                // Pack leader indicator - star for most successful enemy
                if (enemyRep && enemyRep.isPackLeader) {
                    const head = e.segments[0];
                    const hx = head.x * GRID + GRID/2 - 12;
                    const hy = head.y * GRID - 8;
                    ctx.font = '10px monospace';
                    ctx.fillStyle = '#ff0';
                    ctx.shadowColor = '#ff0';
                    ctx.shadowBlur = 8;
                    ctx.fillText('‚òÖ', hx, hy);
                    ctx.shadowBlur = 0;
                }

                // MVP indicator - crown for the most interesting player
                if (e.isMVP && gameState === 'dead') {
                    const head = e.segments[0];
                    const hx = head.x * GRID + GRID/2;
                    const hy = head.y * GRID - 20;
                    ctx.fillStyle = '#ff0';
                    ctx.shadowColor = '#ff0';
                    ctx.shadowBlur = 10;
                    ctx.font = 'bold 12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('‚òÖ MVP ‚òÖ', hx, hy);
                    ctx.shadowBlur = 0;
                }
            }
        }
        
        function drawProjectiles() {
            for (const p of projectiles) { ctx.shadowColor = p.color; ctx.shadowBlur = 8; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); }
            for (const p of enemyProjectiles) { ctx.shadowColor = p.color; ctx.shadowBlur = 10; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); }
            ctx.shadowBlur = 0;
        }
        
        function drawPickups(time) {
            for (const p of pickups) {
                const x = p.x, y = p.y + Math.sin(time / 150 + p.bob) * 3;
                ctx.shadowColor = p.type.color; ctx.shadowBlur = 15;
                
                if (p.isPowerup) {
                    // Power-ups: big pulsing icon with glow
                    const pulse = 1 + Math.sin(time / 100) * 0.2;
                    const radius = 14 * pulse;
                    
                    // Outer glow ring
                    ctx.strokeStyle = p.type.color + '44';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(x, y, radius + 8, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Inner filled circle
                    ctx.fillStyle = p.type.color;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Icon text
                    ctx.fillStyle = '#000';
                    ctx.font = '12px "Press Start 2P"';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(p.type.icon, x, y);
                } else if (p.isHealth) {
                    ctx.fillStyle = p.type.color;
                    ctx.fillRect(x - 2, y - 6, 4, 12);
                    ctx.fillRect(x - 6, y - 2, 12, 4);
                } else {
                    ctx.strokeStyle = p.type.color + '66';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, 8 + Math.sin(time / 200 + p.bob) * 2, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.fillStyle = p.type.color;
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.shadowBlur = 0;
            }
        }
        
        function drawParticles() {
            for (const p of particles) {
                if (p.isAoe) {
                    const alpha = Math.floor((p.life / 15) * 200).toString(16).padStart(2, '0');
                    ctx.strokeStyle = p.color + alpha; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); ctx.stroke();
                } else if (p.isPixelSpark) {
                    // H6 8-bit Comet pixel sparks
                    const sz = p.size || 3;
                    ctx.globalAlpha = (p.alpha || 1) * Math.min(1, p.life / 8);
                    ctx.fillStyle = p.color;
                    // Snap to pixel grid for retro look
                    const px = Math.floor(p.x / sz) * sz;
                    const py = Math.floor(p.y / sz) * sz;
                    ctx.fillRect(px - sz/2, py - sz/2, sz, sz);
                    ctx.globalAlpha = 1;
                } else { ctx.globalAlpha = p.life / 30; ctx.fillStyle = p.color; ctx.fillRect(p.x - 2, p.y - 2, 4, 4); ctx.globalAlpha = 1; }
            }
        }
        
        function drawScanlines() { ctx.drawImage(scanlinesCanvas, 0, 0); }

        function drawFogOfWar() {
            const head = snake[0];
            if (!head) return;

            // Player position in screen space
            const px = (head.x * GRID + GRID/2 - cameraX) * cameraZoom;
            const py = (head.y * GRID + GRID/2 - cameraY) * cameraZoom;

            // Visibility radius scales with zoom
            const baseRadius = 250;
            const radius = baseRadius * cameraZoom;

            // Create radial gradient for fog
            const gradient = ctx.createRadialGradient(px, py, radius * 0.6, px, py, radius);
            gradient.addColorStop(0, 'rgba(10, 6, 16, 0)');
            gradient.addColorStop(0.7, 'rgba(10, 6, 16, 0.3)');
            gradient.addColorStop(1, 'rgba(10, 6, 16, 0.85)');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        function gameLoop(time) {
            try {
                const dt = time - lastTime; lastTime = time;
                ctx.fillStyle = '#0a0610'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                if (gameState === 'playing') {
                    moveTimer += dt;
                    let selfCollision = false;
                    if (moveTimer >= MOVE_INTERVAL) { selfCollision = updateSnake(); moveTimer -= MOVE_INTERVAL; }
                    if (selfCollision) {
                        console.log('RESPAWN: Self collision');
                        haptic('death');
                        respawn();
                    }
                    // Only host runs enemy AI - non-hosts get enemy positions from host
                    const gameOver = (Multiplayer.connected && Multiplayer.isHost) ? updateEnemies(dt) : false;
                    if (gameOver) {
                        console.log('RESPAWN:', deathReason || 'Destroyed');
                        haptic('death');
                        respawn();
                    }
                    updateEnemyProjectiles(dt); updateProjectiles(dt); fireGuns(time); updateParticles();
                    updateWaves(time, dt); updateCamera(); updateHUD(); updateLeaderboard();
                    Multiplayer.broadcastEnemyState(); // Host syncs enemies to all clients
                    Multiplayer.debugStatus(); // Debug logging
                    ruleEngine.update(); // G√∂del layer tick

                    // Strategy classifier - learns player behavior and counters it
                    if (snake[0]) {
                        let nearestDist = 999;
                        for (const e of enemies) {
                            if (e.segments && e.segments[0]) {
                                const d = Math.abs(e.segments[0].x - snake[0].x) + Math.abs(e.segments[0].y - snake[0].y);
                                if (d < nearestDist) nearestDist = d;
                            }
                        }
                        strategyClassifier.update({ x: snake[0].x, y: snake[0].y }, nearestDist);

                        // Reclassify every ~2 seconds (120 frames at 60fps)
                        if (strategyClassifier.totalTicks % 120 === 0 && strategyClassifier.totalTicks > 60) {
                            strategyClassifier.classify();
                        }
                    }
                }
                
                // SPECTATOR MODE: Keep updating when dead so player can watch
                if (gameState === 'dead') {
                    if (Multiplayer.connected && Multiplayer.isHost) updateEnemies(dt);
                    updateEnemyProjectiles(dt);
                    updateParticles();
                    updateCamera();
                    updateLeaderboard();
                    updateWaves(time, dt); // Keep spawning during spectate!
                    Multiplayer.broadcastEnemyState(); // Host syncs enemies
                }

                // CONTINUOUS ARENA: Keep arena alive during start screen
                if (gameState === 'start' && enemies.length > 0) {
                    if (Multiplayer.connected && Multiplayer.isHost) updateEnemies(dt);
                    updateEnemyProjectiles(dt);
                    updateParticles();
                    updateLeaderboard();
                    updateWaves(time, dt); // Keep spawning on start screen!
                    Multiplayer.broadcastEnemyState(); // Host syncs enemies
                }
                
                ctx.save(); ctx.scale(cameraZoom, cameraZoom); ctx.translate(-cameraX, -cameraY);
                drawGrid(); drawPickups(time); drawEnemies(); Multiplayer.drawOtherPlayers(ctx);
                if (gameState === 'playing') { drawSnake(); drawAimLine(); drawDirectionQueue(); drawLeaderArrow(); }
                drawProjectiles(); drawParticles();
                ctx.restore(); drawScanlines(); drawPatternFlash(ctx); devMode.draw(ctx);
            } catch (err) { console.error('Game loop error:', err); }
            requestAnimationFrame(gameLoop);
        }
        
        // Controls
        let activeTouch = null, touchStartX = 0, touchStartY = 0, lastSwipeX = 0, lastSwipeY = 0, isHolding = false, holdStartTime = 0;
        const SWIPE_THRESHOLD = 30, HOLD_DELAY = 150;
        
        function setDirection(newDir) {
            if (newDir === DIR.UP && dir === DIR.DOWN) return;
            if (newDir === DIR.DOWN && dir === DIR.UP) return;
            if (newDir === DIR.LEFT && dir === DIR.RIGHT) return;
            if (newDir === DIR.RIGHT && dir === DIR.LEFT) return;

            // Track pattern: find nearest threat distance
            let nearestThreat = 999;
            if (snake.length > 0) {
                const head = snake[0];
                for (const e of enemies) {
                    if (e.segments && e.segments.length > 0) {
                        const eh = e.segments[0];
                        const dist = Math.abs(eh.x - head.x) + Math.abs(eh.y - head.y);
                        if (dist < nearestThreat) nearestThreat = dist;
                    }
                }
            }
            patternTracker.recordTurn(dir, newDir, nearestThreat);

            nextDir = newDir;
            if (!isHolding) {
                if (newDir === DIR.UP) aimAngle = -Math.PI / 2;
                else if (newDir === DIR.DOWN) aimAngle = Math.PI / 2;
                else if (newDir === DIR.LEFT) aimAngle = Math.PI;
                else if (newDir === DIR.RIGHT) aimAngle = 0;
            }
            haptic('light');
        }
        
        document.addEventListener('touchstart', e => {
            const touch = e.changedTouches[0];
            // Check dev mode tap first
            if (devMode.handleTap(touch.clientX, touch.clientY)) {
                e.preventDefault();
                return;
            }
            if (gameState !== 'playing') return;
            e.preventDefault();
            activeTouch = touch.identifier; touchStartX = touch.clientX; touchStartY = touch.clientY;
            lastSwipeX = touch.clientX; lastSwipeY = touch.clientY;
            isHolding = false; holdStartTime = Date.now();
        }, { passive: false });
        
        document.addEventListener('touchmove', e => {
            if (gameState !== 'playing') return;
            e.preventDefault();
            for (const touch of e.changedTouches) {
                if (touch.identifier === activeTouch) {
                    const dx = touch.clientX - lastSwipeX, dy = touch.clientY - lastSwipeY;
                    const totalDx = touch.clientX - touchStartX, totalDy = touch.clientY - touchStartY;
                    const totalDist = Math.sqrt(totalDx * totalDx + totalDy * totalDy);
                    if (!isHolding && (Math.abs(dx) > SWIPE_THRESHOLD || Math.abs(dy) > SWIPE_THRESHOLD)) {
                        if (Math.abs(dx) > Math.abs(dy)) setDirection(dx > 0 ? DIR.RIGHT : DIR.LEFT);
                        else setDirection(dy > 0 ? DIR.DOWN : DIR.UP);
                        lastSwipeX = touch.clientX; lastSwipeY = touch.clientY;
                    }
                    if (Date.now() - holdStartTime > HOLD_DELAY && totalDist > 20) {
                        isHolding = true; isAiming = true;
                        aimAngle = Math.atan2(totalDy, totalDx);
                    }
                }
            }
        }, { passive: false });
        
        document.addEventListener('touchend', e => {
            for (const touch of e.changedTouches) {
                if (touch.identifier === activeTouch) {
                    activeTouch = null; isHolding = false;
                    if (dir === DIR.UP) aimAngle = -Math.PI / 2;
                    else if (dir === DIR.DOWN) aimAngle = Math.PI / 2;
                    else if (dir === DIR.LEFT) aimAngle = Math.PI;
                    else if (dir === DIR.RIGHT) aimAngle = 0;
                }
            }
        }, { passive: true });
        
        document.addEventListener('touchcancel', e => { activeTouch = null; isHolding = false; }, { passive: true });
        
        function updateAimAngle(touchX, touchY) {
            const head = snake[0];
            const hx = head.x * GRID + GRID/2, hy = head.y * GRID + GRID/2;
            aimAngle = Math.atan2(touchY - hy, touchX - hx);
        }
        
        // Initialize username inputs with saved value
        const savedName = localStorage.getItem('locomot_username') || '';
        document.getElementById('usernameInput').value = savedName;
        document.getElementById('usernameInputDeath').value = savedName;

        function startGame(isTeamMode) {
            teamMode = isTeamMode;
            const nameInput = document.getElementById('usernameInput').value;
            if (nameInput) Multiplayer.setUsername(nameInput);
            document.getElementById('startScreen').classList.add('hidden');
            // Initialize highlight recorder
            HighlightRecorder.init();
        }

        document.getElementById('startFFA').addEventListener('click', () => {
            startGame(false);
            // Only init if arena is empty AND we haven't received a sync
            if (enemies.length === 0 && !Multiplayer.arenaReceived) {
                console.log('[START] No enemies and no sync received, calling init()');
                init();
            } else {
                console.log('[START] Joining existing arena with', enemies.length, 'enemies (synced:', Multiplayer.arenaReceived, ')');
                joinExistingArena();
            }
            gameState = 'playing';
            canvas.classList.add('playing');
            // Report join to server for player history
            devMode.reportJoin(Multiplayer.username || 'Anonymous', Multiplayer.playerId);
        });

        document.getElementById('startTeams').addEventListener('click', () => {
            startGame(true);
            // Only init if arena is empty AND we haven't received a sync
            if (enemies.length === 0 && !Multiplayer.arenaReceived) {
                console.log('[START] No enemies and no sync received, calling init()');
                init();
            } else {
                console.log('[START] Joining existing arena with', enemies.length, 'enemies (synced:', Multiplayer.arenaReceived, ')');
                joinExistingArena();
            }
            gameState = 'playing';
            canvas.classList.add('playing');
            // Report join to server for player history
            devMode.reportJoin(Multiplayer.username || 'Anonymous', Multiplayer.playerId);
        });

        document.getElementById('usernameInputDeath').addEventListener('change', (e) => {
            if (e.target.value) Multiplayer.setUsername(e.target.value);
        });
        document.getElementById('resumeBtn').addEventListener('click', () => { document.getElementById('pauseScreen').classList.add('hidden'); gameState = 'playing'; canvas.classList.add('playing'); });
        document.getElementById('restartBtn').addEventListener('click', () => { doRespawn(); });
        document.getElementById('spectateBtn').addEventListener('click', () => {
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('spectatingLabel').style.display = 'block';
            // Create floating label that stays visible
            let floatingLabel = document.getElementById('floatingSpectateLabel');
            if (!floatingLabel) {
                floatingLabel = document.createElement('div');
                floatingLabel.id = 'floatingSpectateLabel';
                floatingLabel.style.cssText = 'position:fixed; top:20px; left:50%; transform:translateX(-50%); color:#5ff; font-size:14px; text-shadow:0 0 10px #5ff; z-index:200; pointer-events:none;';
                floatingLabel.innerHTML = '‚òÖ SPECTATING MVP ‚òÖ<br><span style="font-size:10px">Tap to respawn</span>';
                document.body.appendChild(floatingLabel);
            }
            floatingLabel.style.display = 'block';
            // Tap anywhere to respawn
            const respawnOnTap = () => {
                floatingLabel.style.display = 'none';
                doRespawn();
                document.removeEventListener('click', respawnOnTap);
            };
            setTimeout(() => document.addEventListener('click', respawnOnTap), 500);
        });

        // === DEV SPECTATE MODE - Watch real players ===
        const devMode = {
            active: new URLSearchParams(window.location.search).get('dev') === '1',
            spectating: false,
            playerIndex: 0,
            selectedPlayer: null,
            playerHistory: { players: [], sessions: [] },
            lastHistoryFetch: 0,

            toggle() {
                this.spectating = !this.spectating;
                if (this.spectating) {
                    this.playerIndex = 0;
                    this.updateSelection();
                }
                console.log('[DEV] Spectate mode:', this.spectating);
            },

            // Fetch player history from server
            async fetchHistory() {
                try {
                    const res = await fetch('https://api.locomot.io/api/players');
                    if (res.ok) {
                        this.playerHistory = await res.json();
                        console.log('[DEV] Fetched player history:', this.playerHistory.players.length, 'players');
                    }
                } catch (e) {
                    console.log('[DEV] Could not fetch player history');
                }
            },

            // Report player join to server
            async reportJoin(name, id) {
                try {
                    await fetch('https://api.locomot.io/api/player/join', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name, id })
                    });
                } catch (e) {}
            },

            // Report player leave with stats
            async reportLeave(name, maxLength, kills, score) {
                try {
                    await fetch('https://api.locomot.io/api/player/leave', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name, maxLength, kills, score })
                    });
                } catch (e) {}
            },

            // Periodic activity heartbeat
            async reportActivity(name, length, score) {
                try {
                    await fetch('https://api.locomot.io/api/player/activity', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name, length, score })
                    });
                } catch (e) {}
            },

            getPlayers() {
                const players = [];
                if (Multiplayer.connected) {
                    for (const [pid, op] of Multiplayer.otherPlayers) {
                        if (op.segments && op.segments.length > 0) {
                            players.push({ id: pid, ...op });
                        }
                    }
                }
                return players;
            },

            // Get recent sessions from history (for when no one is online)
            getRecentSessions() {
                if (!this.playerHistory.sessions) return [];
                const now = Date.now();
                return this.playerHistory.sessions
                    .filter(s => s.left) // Only completed sessions
                    .slice(-10)
                    .reverse();
            },

            nextPlayer() {
                const players = this.getPlayers();
                if (players.length === 0) return;
                this.playerIndex = (this.playerIndex + 1) % players.length;
                this.updateSelection();
            },

            prevPlayer() {
                const players = this.getPlayers();
                if (players.length === 0) return;
                this.playerIndex = (this.playerIndex - 1 + players.length) % players.length;
                this.updateSelection();
            },

            updateSelection() {
                const players = this.getPlayers();
                if (players.length > 0 && this.playerIndex < players.length) {
                    this.selectedPlayer = players[this.playerIndex];
                    console.log('[DEV] Following:', this.selectedPlayer.name, '- Length:', this.selectedPlayer.segments.length);
                } else {
                    this.selectedPlayer = null;
                }
            },

            getFollowTarget() {
                if (!this.spectating || !this.selectedPlayer) return null;
                // Refresh from live data
                const op = Multiplayer.otherPlayers.get(this.selectedPlayer.id);
                if (op && op.segments && op.segments.length > 0) {
                    return { x: op.segments[0].x, y: op.segments[0].y, length: op.segments.length, name: op.name };
                }
                return null;
            },

            draw(ctx) {
                if (!this.active) return;
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0);

                const players = this.getPlayers();
                const recentSessions = this.getRecentSessions();
                const showHistory = players.length === 0 && recentSessions.length > 0;
                const boxHeight = this.spectating && players.length > 0
                    ? 90 + Math.min(players.length, 8) * 15
                    : showHistory ? 90 + Math.min(recentSessions.length, 6) * 15 : 70;

                // Semi-transparent background for visibility
                ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                ctx.fillRect(5, 100, 280, boxHeight);
                ctx.strokeStyle = '#f0f';
                ctx.lineWidth = 2;
                ctx.strokeRect(5, 100, 280, boxHeight);

                ctx.font = '10px "Press Start 2P"';
                ctx.textAlign = 'left';

                // Dev mode indicator
                ctx.fillStyle = '#f0f';
                ctx.fillText('üîß DEV MODE', 15, 120);

                ctx.font = '8px "Press Start 2P"';
                ctx.fillStyle = '#fff';
                ctx.fillText(`Real players online: ${players.length}`, 15, 140);
                ctx.fillStyle = '#888';
                ctx.fillText('Tap here or Ctrl+Shift+S', 15, 155);

                // Debug: Show info about ALL entities (real + AI)
                ctx.fillStyle = '#f80';
                const mpCount = Multiplayer.otherPlayers.size;
                const aiCount = enemies.filter(e => e.segments && e.segments.length > 0).length;
                ctx.fillText(`MP: ${mpCount} | AI: ${aiCount}`, 200, 120);

                // Debug: Show who we're spectating
                if (gameState === 'dead') {
                    let foundTarget = null;
                    let targetType = 'none';
                    
                    // Check multiplayer players
                    for (const [pid, op] of Multiplayer.otherPlayers) {
                        if (op.name === 'grease' || (op.segments && op.segments.length > 0)) {
                            if (!foundTarget || op.name === 'grease') {
                                foundTarget = { ...op, pid };
                                targetType = 'REAL MP';
                            }
                        }
                    }
                    
                    // Check AI enemies for "grease"
                    for (const e of enemies) {
                        if (e.name === 'grease' && e.segments && e.segments.length > 0) {
                            foundTarget = e;
                            targetType = 'AI ENEMY';
                        }
                    }
                    
                    if (foundTarget && foundTarget.name === 'grease') {
                        ctx.fillStyle = '#f00';
                        ctx.fillText(`üîç grease = ${targetType}`, 15, 170);
                        if (foundTarget.pid) {
                            ctx.fillText(`   ID: ${foundTarget.pid.slice(0,12)}...`, 15, 182);
                        }
                        const lastSeen = Multiplayer.playerLastSeen.get(foundTarget.pid);
                        if (lastSeen) {
                            const ago = Math.floor((Date.now() - lastSeen) / 1000);
                            ctx.fillText(`   Last update: ${ago}s ago`, 15, 194);
                        }
                    }
                }

                if (this.spectating && players.length > 0) {
                    ctx.fillStyle = '#ff0';
                    ctx.fillText('SPECTATING - swipe ‚Üê/‚Üí to cycle', 15, 175);

                    // Player list
                    for (let i = 0; i < Math.min(players.length, 8); i++) {
                        const p = players[i];
                        const selected = i === this.playerIndex;
                        ctx.fillStyle = selected ? '#0f0' : '#888';
                        const marker = selected ? '‚ñ∫ ' : '  ';
                        ctx.fillText(`${marker}${p.name || 'Unknown'} (${p.segments?.length || 0})`, 15, 195 + i * 15);
                    }
                } else if (showHistory) {
                    ctx.fillStyle = '#5cf';
                    ctx.fillText('üìú Recent players:', 15, 175);

                    for (let i = 0; i < Math.min(recentSessions.length, 6); i++) {
                        const s = recentSessions[i];
                        const ago = this.timeAgo(s.left);
                        ctx.fillStyle = '#888';
                        ctx.fillText(`${s.name} - ${s.score}pts (${ago})`, 15, 195 + i * 15);
                    }
                } else if (players.length === 0) {
                    ctx.fillStyle = '#f55';
                    ctx.fillText('No players yet. Fetching...', 15, 175);
                }

                ctx.restore();
            },

            // Helper to format time ago
            timeAgo(isoString) {
                if (!isoString) return '?';
                const diff = Date.now() - new Date(isoString).getTime();
                const mins = Math.floor(diff / 60000);
                if (mins < 1) return 'just now';
                if (mins < 60) return `${mins}m ago`;
                const hours = Math.floor(mins / 60);
                if (hours < 24) return `${hours}h ago`;
                return `${Math.floor(hours / 24)}d ago`;
            },

            // Check if tap is in dev box
            handleTap(x, y) {
                if (!this.active) return false;
                if (x >= 5 && x <= 285 && y >= 100 && y <= 200) {
                    this.toggle();
                    return true;
                }
                return false;
            }
        };

        document.addEventListener('keydown', e => {
            // Dev mode controls (always active if dev=1)
            if (devMode.active) {
                if (e.ctrlKey && e.shiftKey && e.code === 'KeyS') {
                    devMode.toggle();
                    e.preventDefault();
                    return;
                }
                if (devMode.spectating) {
                    if (e.code === 'ArrowLeft' || e.code === 'KeyA') { devMode.prevPlayer(); e.preventDefault(); return; }
                    if (e.code === 'ArrowRight' || e.code === 'KeyD') { devMode.nextPlayer(); e.preventDefault(); return; }
                    if (e.code === 'Escape') { devMode.spectating = false; e.preventDefault(); return; }
                }
            }

            if (gameState !== 'playing') return;
            // Queue direction changes for responsive controls
            let newDir = null;
            if (e.code === 'ArrowUp' || e.code === 'KeyW') newDir = DIR.UP;
            else if (e.code === 'ArrowDown' || e.code === 'KeyS') newDir = DIR.DOWN;
            else if (e.code === 'ArrowLeft' || e.code === 'KeyA') newDir = DIR.LEFT;
            else if (e.code === 'ArrowRight' || e.code === 'KeyD') newDir = DIR.RIGHT;

            if (newDir && dirQueue.length < 1) {
                const lastDir = dirQueue.length > 0 ? dirQueue[dirQueue.length - 1] : dir;
                // Prevent 180 degree turns
                if (!(lastDir.x === -newDir.x && lastDir.y === -newDir.y)) {
                    dirQueue.push(newDir);
                }
            }
            else if (e.code === 'Space') { gameState = 'paused'; canvas.classList.remove('playing'); document.getElementById('pauseScreen').classList.remove('hidden'); }
        });
        
        // Desktop mouse aiming - continuous tracking
        document.addEventListener('mousemove', e => {
            if (gameState !== 'playing') return;
            mouseX = e.clientX;
            mouseY = e.clientY;
            isMouseAiming = true;
            // Update aim angle to point at mouse cursor
            const head = snake[0];
            if (head) {
                const hx = (head.x * GRID + GRID/2 - cameraX) * cameraZoom;
                const hy = (head.y * GRID + GRID/2 - cameraY) * cameraZoom;
                aimAngle = Math.atan2(mouseY - hy, mouseX - hx);
            }
        });
        document.addEventListener('mouseleave', () => { isMouseAiming = false; });
        document.addEventListener('mouseenter', e => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            isMouseAiming = true;
        });
        
        patternTracker.load(); // Load saved patterns from localStorage
        reputationSystem.load(); // Load player reputation from localStorage
        devMode.fetchHistory(); // Fetch recent player history
        init();
        requestAnimationFrame(gameLoop);

        // Periodic activity heartbeat (every 30 seconds)
        setInterval(() => {
            if (gameState === 'playing' && Multiplayer.connected) {
                const playerName = Multiplayer.username || 'Anonymous';
                devMode.reportActivity(playerName, snake.length, score);
            }
        }, 30000);

        // Clean up inactive players every 10 seconds
        setInterval(() => {
            if (Multiplayer.connected) {
                Multiplayer.cleanupInactivePlayers();
            }
        }, 10000);

        // PWA: Register service worker for offline play
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('./sw.js')
                .then(reg => console.log('Offline mode enabled'))
                .catch(err => console.log('Offline mode unavailable'));
        }
    </script>
</body>
</html>
