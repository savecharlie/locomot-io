<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Ice Skater</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      height: 100%;
      height: 100dvh;
      overflow: hidden;
      background: #1D2B30;
      touch-action: none;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: sans-serif;
    }
    #main-layout {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #header {
      color: #68BBC4;
      font-size: 24px;
      margin-bottom: 20px;
      text-align: center;
      font-weight: bold;
      letter-spacing: 2px;
    }
    #game-area {
      display: flex;
      align-items: flex-start;
      gap: 30px;
    }
    #game-container {
      background: transparent;
      padding: 0;
    }
    canvas {
      display: block;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    #sidebar {
      display: none;
      flex-direction: column;
      gap: 15px;
      color: #8DCBCA;
      font-size: 16px;
      min-width: 140px;
    }
    #sidebar .info-row {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    #sidebar .info-label {
      color: #5A9199;
      font-size: 12px;
      text-transform: uppercase;
    }
    #sidebar .info-value {
      color: #68BBC4;
      font-size: 18px;
      font-weight: bold;
    }
    #sidebar .btn-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 10px;
    }
    #footer {
      color: #8DCBCA;
      font-size: 16px;
      margin-top: 25px;
      display: flex;
      gap: 20px;
      align-items: center;
      flex-wrap: wrap;
      justify-content: center;
    }
    button {
      background: #2A474F;
      color: #68BBC4;
      border: 2px solid #3B8897;
      padding: 8px 16px;
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
    }
    button:hover { background: #346672; }
    button:active { background: #3B8897; }
    #keys { color: #B0D5CF; font-size: 16px; }
    #status { color: #A968C4; font-weight: bold; }
    #status.hint { color: #40ACBF; }

    /* Settings modal */
    #settings-overlay {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(29, 43, 48, 0.9);
      z-index: 100;
      justify-content: center;
      align-items: center;
    }
    #settings-overlay.visible { display: flex; }
    #settings-panel {
      background: #1D2B30;
      border: 2px solid #3B8897;
      border-radius: 8px;
      padding: 24px;
      min-width: 280px;
      max-width: 90vw;
    }
    #settings-panel h2 {
      color: #68BBC4;
      font-size: 20px;
      margin-bottom: 20px;
      text-align: center;
      letter-spacing: 1px;
    }
    .setting-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 0;
      border-bottom: 1px solid #2A474F;
    }
    .setting-row:last-of-type { border-bottom: none; }
    .setting-label {
      color: #8DCBCA;
      font-size: 14px;
    }
    .setting-desc {
      color: #5A9199;
      font-size: 11px;
      margin-top: 2px;
    }
    /* Toggle switch */
    .toggle {
      position: relative;
      width: 44px;
      height: 24px;
      background: #2A474F;
      border-radius: 12px;
      cursor: pointer;
      border: 2px solid #3B8897;
      transition: background 0.2s;
    }
    .toggle.on { background: #3B8897; }
    .toggle::after {
      content: '';
      position: absolute;
      top: 2px;
      left: 2px;
      width: 16px;
      height: 16px;
      background: #68BBC4;
      border-radius: 50%;
      transition: left 0.2s;
    }
    .toggle.on::after { left: 22px; }
    #settings-close {
      margin-top: 20px;
      width: 100%;
    }
    /* Settings button - gear icon */
    .settings-btn {
      padding: 8px 12px !important;
      font-size: 16px !important;
    }
    /* Mobile floating buttons - 16-bit pixel style */
    .mobile-float-btn {
      display: none;
      position: fixed;
      z-index: 50;
      background: #2a374f;
      color: #b0d5cf;
      padding: 6px 10px;
      font-family: monospace;
      font-size: 10px;
      font-weight: bold;
      letter-spacing: 0px;
      text-transform: uppercase;
      cursor: pointer;
      border: none;
      border-radius: 0;
      /* Pixel border - light top/left, dark bottom/right */
      box-shadow:
        inset 2px 2px 0 #696d75,
        inset -2px -2px 0 #1d2b30,
        0 0 0 2px #304d78;
    }
    .mobile-float-btn:active {
      /* Pressed - invert the inset */
      box-shadow:
        inset -2px -2px 0 #696d75,
        inset 2px 2px 0 #1d2b30,
        0 0 0 2px #304d78;
    }
    #mobile-settings { top: 12px; right: 12px; }
    #mobile-lvl { bottom: 56px; left: 12px; }
    #mobile-hint { bottom: 56px; right: 12px; }
    #mobile-undo { bottom: 12px; right: 12px; }
    #mobile-restart { bottom: 12px; left: 12px; }

    /* Level select modal */
    #level-overlay {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(29, 43, 48, 0.95);
      z-index: 100;
      justify-content: center;
      align-items: center;
      overflow-y: auto;
    }
    #level-overlay.visible { display: flex; }
    #level-panel {
      background: #1D2B30;
      border: 2px solid #3B8897;
      border-radius: 8px;
      padding: 20px;
      max-width: 90vw;
      max-height: 80vh;
      overflow-y: auto;
    }
    #level-panel h2 {
      color: #68BBC4;
      font-size: 18px;
      margin-bottom: 15px;
      text-align: center;
    }
    #level-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 8px;
      margin-bottom: 15px;
    }
    .level-btn {
      background: #2A474F;
      color: #8DCBCA;
      border: 2px solid #3B8897;
      padding: 10px 5px;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      border-radius: 4px;
    }
    .level-btn:hover { background: #346672; }
    .level-btn.current { background: #3B8897; color: #fff; }
    .level-btn.completed { background: #2A5F4F; }
    #level-close {
      width: 100%;
      margin-top: 10px;
    }
    #version-display {
      display: none;
      position: fixed;
      top: 12px;
      left: 12px;
      z-index: 50;
      background: #2a374f;
      color: #b0d5cf;
      padding: 4px 8px;
      font-family: monospace;
      font-size: 10px;
      font-weight: bold;
      text-transform: uppercase;
      border: none;
      border-radius: 0;
      box-shadow:
        inset 2px 2px 0 #696d75,
        inset -2px -2px 0 #1d2b30,
        0 0 0 2px #304d78;
    }
    @media (max-width: 899px) {
      #version-display { display: block; }
    }
    @media (max-width: 899px) {
      .mobile-float-btn { display: block; }
    }

    /* Desktop: show sidebar, hide footer info */
    @media (min-width: 900px) {
      #sidebar { display: flex; }
      #footer .mobile-only { display: none; }
    }
    /* Mobile: fullscreen canvas */
    @media (max-width: 899px) {
      #sidebar { display: none; }
      #header { display: none; }
      #footer { display: none; }
      #main-layout, #game-area, #game-container { display: contents; }
      canvas {
        position: fixed;
        top: 0;
        left: 0;
      }
    }
  </style>
</head>
<body>
  <div id="main-layout">
    <div id="header">Ice Skater</div>
    <div id="game-area">
      <div id="game-container">
        <canvas id="game"></canvas>
      </div>
      <div id="sidebar">
        <div class="info-row">
          <span class="info-label">Level</span>
          <span class="info-value" id="sidebar-level">1 / 86</span>
        </div>
        <div class="info-row">
          <span class="info-label">Par</span>
          <span class="info-value" id="sidebar-par">-</span>
        </div>
        <div class="info-row">
          <span class="info-label">Moves</span>
          <span class="info-value" id="sidebar-moves">0</span>
        </div>
        <div class="info-row">
          <span id="sidebar-status"></span>
        </div>
        <div class="btn-group">
          <button id="sidebar-prev">◀ Prev</button>
          <button id="sidebar-next">Next ▶</button>
          <button id="sidebar-restart">Restart</button>
          <button id="sidebar-undo">Undo</button>
          <button id="sidebar-hint">Hint</button>
          <button id="sidebar-settings">⚙ Settings</button>
        </div>
      </div>
    </div>
    <div id="footer">
      <button id="prev-btn" class="mobile-only">◀</button>
      <span id="level-num" class="mobile-only">Level 1</span>
      <button id="next-btn" class="mobile-only">▶</button>
      <button id="restart-btn">Restart</button>
      <button id="undo-btn">Undo</button>
      <button id="hint-btn">Hint</button>
      <button id="settings-btn" class="settings-btn">⚙</button>
      <span id="status" class="mobile-only"></span>
    </div>
  </div>

  <!-- Mobile floating buttons -->
  <div id="version-display"></div>
  <button id="mobile-settings" class="mobile-float-btn">SET</button>
  <button id="mobile-lvl" class="mobile-float-btn">LVL</button>
  <button id="mobile-hint" class="mobile-float-btn">HINT</button>
  <button id="mobile-undo" class="mobile-float-btn">UNDO</button>
  <button id="mobile-restart" class="mobile-float-btn">RST</button>

  <!-- Level Select Modal -->
  <div id="level-overlay">
    <div id="level-panel">
      <h2>Select Level</h2>
      <div id="level-grid"></div>
      <button id="level-close">Close</button>
    </div>
  </div>

  <!-- Settings Modal -->
  <div id="settings-overlay">
    <div id="settings-panel">
      <h2>Settings</h2>
      <div class="setting-row">
        <div>
          <div class="setting-label">Hints</div>
          <div class="setting-desc">Show direction when stuck</div>
        </div>
        <div id="toggle-hints" class="toggle on"></div>
      </div>
      <div class="setting-row">
        <div>
          <div class="setting-label">Show Unwinnable</div>
          <div class="setting-desc">Warn when no solution exists</div>
        </div>
        <div id="toggle-unwinnable" class="toggle"></div>
      </div>
      <button id="settings-close">Done</button>
    </div>
  </div>

  <script>
// === ICE SKATER ENGINE v2 ===
// Fixed: locked wall, height system, ramps, block stops

const GAME_VERSION = 'v268';  // Bump this and tell Ivy the version when pushing changes!

const TILE_W = 16;  // Tile width
const TILE_H = 12;  // Tile height (floor surface depth) - oblique angle
let SCALE = 4;  // Dynamic - calculated per level to fit viewport
const TOP_PADDING = 20;  // Extra space for sprites extending above grid
const ICE_MARGIN_PX = 2;  // Pixels of ice visible outside chamber walls
const WALL_H = 24;  // Wall/block height (14px top + 10px front)
const DIRS = {
  up: { dx: 0, dy: -1 },
  down: { dx: 0, dy: 1 },
  left: { dx: -1, dy: 0 },
  right: { dx: 1, dy: 0 }
};

// Tile types:
// . = ice floor, # = wall, S = start, P = goal (penguin)
// B = ice block, H = hole (hazard), K = key, L = locked wall
// T = sticky tile, 1-4 = crack variants (break if you stop on them)
// Ramps: ^ = high end north, v = high end south, < = high end west, > = high end east
// Corners: 7 = ur (up→right), 8 = ul (up→left), 9 = dr (down→right), 0 = dl (down→left)

const sprites = {};
const spriteFiles = [
  'ice_floor_16x12_v1.png', 'ice_floor_16x12_v2.png', 'ice_floor_16x12_v3.png', 'ice_floor_16x12_v4.png', 'ice_floor_16x12_v5.png', 'ice_floor_16x12_v6.png', 'ice_floor_16x12_v7.png', 'ice_floor_16x12_v8.png', 'ice_floor_16x12_v9.png', 'ice_floor_16x12_v10.png', 'ice_floor_16x12_v11.png', 'ice_floor_16x12_v12.png',
  'ice_block_v3.png', 'block_base_16.png', 'wall_16x24.png', 'wall_color_16x24.png',
  'ice_hole_16x12.png', 'goal_penguin_16.png', 'sticky_tile_16x12.png',
  'wall_keyhole_16x24.png',
  'ice_crack_1.png', 'ice_crack_2.png', 'ice_crack_3.png', 'ice_crack_4.png',
  'key_frame_1.png', 'key_frame_2.png', 'key_frame_3.png', 'key_frame_4.png',
  'ramp_north_16x24.png', 'ramp_south_16x24.png', 'ramp_east_16x24.png', 'ramp_west_16x24.png',
  'corner_ur.png', 'corner_ul.png', 'corner_dr.png', 'corner_dl.png',
  'skater_16x24.png', 'skater_back_fixed_16x24.png',
  'skater_side_16x24.png', 'skater_side_left_16x24.png',
  'skater_side_standing_16x24.png', 'skater_side_left_standing_16x24.png',
  'skater_side_skating_16x24.png', 'skater_side_left_skating_16x24.png',
  'skater_sad_16x24.png', 'skater_back_sad_16x24.png',
  'skater_side_sad_16x24.png', 'skater_side_left_sad_16x24.png',
  'skater_front_sad_16x24.png', 'skater_side_standing_sad_16x24.png', 'skater_side_left_standing_sad_16x24.png',
  'skater_front_standing_16x24.png', 'skater_back_standing_16x24.png',
  'skater_front_skating_16x24.png', 'skater_back_skating_16x24.png',
  'wall_keyhole_sink_frame_1.png', 'wall_keyhole_sink_frame_2.png',
  'wall_keyhole_sink_frame_3.png', 'wall_keyhole_sink_frame_4.png',
  'wall_keyhole_sink_frame_5.png', 'wall_keyhole_sink_frame_6.png',
  'skater_fall_frame_1.png', 'skater_fall_frame_2.png', 'skater_fall_frame_3.png',
  'skater_fall_frame_4.png', 'skater_fall_frame_5.png', 'skater_fall_frame_6.png',
  'skater_shadow.png', 'key_shadow.png', 'penguin_shadow.png', 'block_shadow.png'
];

let level = null;
let gameState = null;
let history = [];
let animating = false;
let keyFrame = 0;
let lastKeyFrameTime = 0;
let isUnwinnable = false;
let unwinnableFlashTime = 0;

// Hint display state
let hintArrow = null;  // 'up', 'down', 'left', 'right', or null
let hintShowTime = 0;
const HINT_DISPLAY_MS = 2000;  // Show hint for 2 seconds

// Trail - pixels left behind as skater moves
let trailPoints = [];  // [{tileX, tileY, pixelX, pixelY}, ...]

// Snow particles
const snowflakes = [];

// Judge scoring system
let judgeState = null;  // { scores: [10, 8, 10], revealed: 0, startTime: null, isRecord: false }
let globalBestTimes = {};  // Cache of global best times per level
let levelStartTime = 0;  // When current level started (for speed tracking)
const PARTYKIT_URL = 'https://locomot-io.savecharlie.partykit.dev/party/main';

// Player analytics
function getPlayerId() {
  let id = localStorage.getItem('ice_skater_player_id');
  if (!id) {
    id = 'p_' + Date.now().toString(36) + '_' + Math.random().toString(36).slice(2, 10);
    localStorage.setItem('ice_skater_player_id', id);
  }
  return id;
}

async function trackPlayer() {
  // Track player visit with their highest level reached (retroactive)
  const playerId = getPlayerId();
  const completed = getCompletedLevels();
  const highestLevel = completed.size > 0 ? Math.max(...completed) + 1 : currentLevelIndex;

  try {
    await fetch(PARTYKIT_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        type: 'ice_skater_track_player',
        player_id: playerId,
        highest_level: highestLevel
      })
    });
    console.log('[Analytics] Player tracked, highest level:', highestLevel);
  } catch (e) {
    console.log('[Analytics] Failed to track player:', e);
  }
}

async function trackCompletion(levelIndex, moves, timeMs) {
  const playerId = getPlayerId();

  try {
    await fetch(PARTYKIT_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        type: 'ice_skater_track_completion',
        player_id: playerId,
        level: levelIndex,
        moves: moves,
        time: timeMs
      })
    });
    console.log('[Analytics] Completion tracked for level', levelIndex);
  } catch (e) {
    console.log('[Analytics] Failed to track completion:', e);
  }
}

// Tutorial system
let tutorialText = null;  // Current level's tutorial text (if any)
let tutorialStage = null; // Current tutorial stage name
const TUTORIAL_COUNT = 7; // Number of tutorial levels (one per mechanic)

// Fetch global best for a level
async function fetchGlobalBest(levelIndex) {
  if (globalBestTimes[levelIndex] !== undefined) {
    return globalBestTimes[levelIndex];
  }
  try {
    const resp = await fetch(PARTYKIT_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ type: 'ice_skater_get_best', level: levelIndex })
    });
    const data = await resp.json();
    globalBestTimes[levelIndex] = data.best;
    return data.best;
  } catch (e) {
    console.log('Failed to fetch global best:', e);
    return null;
  }
}

// Submit speed time and check for record
async function submitSpeedTime(levelIndex, timeMs) {
  try {
    const resp = await fetch(PARTYKIT_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ type: 'ice_skater_submit_time', level: levelIndex, time: timeMs })
    });
    const data = await resp.json();
    globalBestTimes[levelIndex] = data.best;
    return data;
  } catch (e) {
    console.log('Failed to submit time:', e);
    return { best: null, isRecord: false };
  }
}

// Calculate judge scores
async function calculateJudgeScores(moves, par, levelIndex, completionTimeMs) {
  // Judge 1: always 10 (completion bonus)
  const j1 = 10;

  // Judge 2: par-based (10 ONLY for exact par, 9 for better, 0 for double par)
  const parDiff = moves - par;
  let j2;
  console.log(`PAR SCORING: moves=${moves} par=${par} moves===par=${moves === par}`);
  if (moves === par) {
    j2 = 10;  // Perfect par = 10
    console.log('PAR SCORING: exact match -> 10');
  } else if (moves < par) {
    j2 = 9;   // Better than par = max 9 (10 is reserved for exact par)
    console.log('PAR SCORING: under par -> 9');
  } else {
    // Worse than par: scale down, floor to round down
    j2 = Math.max(0, Math.floor(10 - (parDiff / par) * 10));
    console.log(`PAR SCORING: over par -> ${j2}`);
  }

  // Judge 3: speed - compare completion time to world record
  const result = await submitSpeedTime(levelIndex, completionTimeMs);
  const globalBest = result.best;  // Best time in ms
  let j3;
  let isRecord = result.isRecord;

  if (globalBest === null || completionTimeMs <= globalBest) {
    j3 = 10;  // New record or tied
  } else {
    // Score based on how close to record (within 2x = 0 points)
    const timeDiff = completionTimeMs - globalBest;
    j3 = Math.min(10, Math.max(0, Math.round(10 - (timeDiff / globalBest) * 10)));
  }

  return { scores: [j1, j2, j3], isRecord, globalBest };
}

// Draw pixel-style number (7-segment LED style)
// Each segment is a small rectangle, giving it a blocky pixel art look
const SEGMENT_PATTERNS = {
  0: [1,1,1,0,1,1,1],  // top, top-right, bottom-right, middle, bottom-left, top-left, bottom
  1: [0,1,1,0,0,0,0],
  2: [1,1,0,1,1,0,1],
  3: [1,1,1,1,0,0,1],
  4: [0,1,1,1,0,1,0],
  5: [1,0,1,1,0,1,1],
  6: [1,0,1,1,1,1,1],
  7: [1,1,1,0,0,0,0],
  8: [1,1,1,1,1,1,1],
  9: [1,1,1,1,0,1,1],
  10: [1,1,1,0,1,1,1, 0,1,1,0,0,0,0]  // Special: "10" combined
};

function drawPixelNumber(ctx, num, x, y, size, color) {
  const segW = size * 0.8;  // Segment width
  const segH = size * 0.15; // Segment thickness
  const gap = size * 0.05;  // Gap between segments

  ctx.fillStyle = color;

  // For "10", draw two compact digits
  if (num === 10) {
    // Draw "1" (simple vertical line)
    const digitW = size * 0.4;
    ctx.fillRect(x + digitW * 0.3, y + gap, segH, segW * 1.8);

    // Draw "0" next to it
    drawSingleDigit(ctx, 0, x + digitW, y, size * 0.9, color);
    return;
  }

  drawSingleDigit(ctx, num, x, y, size, color);
}

function drawSingleDigit(ctx, num, x, y, size, color) {
  const segW = size * 0.6;
  const segH = size * 0.12;
  const gap = size * 0.08;
  const pattern = SEGMENT_PATTERNS[num] || SEGMENT_PATTERNS[0];

  ctx.fillStyle = color;

  // Segment positions (7-segment display):
  // 0: top horizontal
  if (pattern[0]) ctx.fillRect(x + gap, y, segW, segH);
  // 1: top-right vertical
  if (pattern[1]) ctx.fillRect(x + segW + gap, y + gap, segH, segW * 0.5);
  // 2: bottom-right vertical
  if (pattern[2]) ctx.fillRect(x + segW + gap, y + segW * 0.5 + gap * 2, segH, segW * 0.5);
  // 3: middle horizontal
  if (pattern[3]) ctx.fillRect(x + gap, y + segW * 0.5 + gap, segW, segH);
  // 4: bottom-left vertical
  if (pattern[4]) ctx.fillRect(x, y + segW * 0.5 + gap * 2, segH, segW * 0.5);
  // 5: top-left vertical
  if (pattern[5]) ctx.fillRect(x, y + gap, segH, segW * 0.5);
  // 6: bottom horizontal
  if (pattern[6]) ctx.fillRect(x + gap, y + segW + gap * 2, segW, segH);
}

// Draw a score card that flips up
function drawScoreCard(ctx, score, x, y, cardW, cardH, flipProgress, color, bgColor) {
  // flipProgress: 0 = flat (not visible), 1 = fully flipped up

  if (flipProgress <= 0) return;

  // Card background with perspective effect
  const scaleY = flipProgress;  // Vertical scale (0 to 1)
  const actualH = cardH * scaleY;
  const offsetY = (cardH - actualH) / 2;

  // Draw card background
  ctx.fillStyle = bgColor;
  ctx.fillRect(x - cardW/2, y - actualH/2 + offsetY, cardW, actualH);

  // Draw border
  ctx.strokeStyle = color;
  ctx.lineWidth = 2 * SCALE;
  ctx.strokeRect(x - cardW/2, y - actualH/2 + offsetY, cardW, actualH);

  // Only draw number when mostly flipped
  if (flipProgress > 0.5) {
    const numScale = (flipProgress - 0.5) * 2;  // 0 to 1 after halfway
    ctx.fillStyle = color;
    ctx.font = `bold ${cardH * 0.5 * numScale}px "Press Start 2P", monospace`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(score.toString(), x, y + offsetY);
  }
}

const SNOWFLAKE_COUNT = 40;
function initSnow() {
  snowflakes.length = 0;
  for (let i = 0; i < SNOWFLAKE_COUNT; i++) {
    snowflakes.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      speed: 0.1 + Math.random() * 0.2,  // 0.1-0.3 pixels per frame (gentle)
      sway: Math.random() * Math.PI * 2,  // phase offset for sine wave
      size: Math.random() < 0.7 ? 1 : 2   // mostly 1px, some 2px
    });
  }
}

// Settings (persisted in localStorage)
const settings = {
  hintsEnabled: true,
  showUnwinnable: false
};

function loadSettings() {
  const saved = localStorage.getItem('iceSkaterSettings');
  if (saved) {
    try {
      const parsed = JSON.parse(saved);
      if (typeof parsed.hintsEnabled === 'boolean') settings.hintsEnabled = parsed.hintsEnabled;
      if (typeof parsed.showUnwinnable === 'boolean') settings.showUnwinnable = parsed.showUnwinnable;
    } catch (e) {}
  }
  updateSettingsUI();
}

function saveSettings() {
  localStorage.setItem('iceSkaterSettings', JSON.stringify(settings));
  updateSettingsUI();
}

// Level completion tracking
function getCompletedLevels() {
  const saved = localStorage.getItem('iceSkaterCompletedLevels');
  if (saved) {
    try {
      return new Set(JSON.parse(saved));
    } catch (e) {}
  }
  return new Set();
}

function markLevelComplete(levelIndex) {
  const completed = getCompletedLevels();
  completed.add(levelIndex);
  localStorage.setItem('iceSkaterCompletedLevels', JSON.stringify([...completed]));
}

function isLevelComplete(levelIndex) {
  return getCompletedLevels().has(levelIndex);
}

function updateSettingsUI() {
  const hintsToggle = document.getElementById('toggle-hints');
  const unwinnableToggle = document.getElementById('toggle-unwinnable');
  if (hintsToggle) hintsToggle.classList.toggle('on', settings.hintsEnabled);
  if (unwinnableToggle) unwinnableToggle.classList.toggle('on', settings.showUnwinnable);
}

function openSettings() {
  document.getElementById('settings-overlay').classList.add('visible');
}

function closeSettings() {
  document.getElementById('settings-overlay').classList.remove('visible');
}

// Animation state
const ANIM_SPEED = 8;  // Tiles per second
let animation = null;  // { startTime, duration, player: {fromX, fromY, toX, toY}, blocks: [...] }
let deathAnimation = null;  // { startTime, duration, x, y } - for fall into hole animation

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const GAME_ASSETS_URL = 'https://vwlbjjznvczfecjnrjen.supabase.co/functions/v1/game-assets';

// Pixel art loading screen
function drawLoadingScreen(progress) {
  const w = canvas.width;
  const h = canvas.height;

  // Dark background
  ctx.fillStyle = '#1D2B30';
  ctx.fillRect(0, 0, w, h);

  // Title - FIGURE ∞
  ctx.fillStyle = '#68BBC4';
  ctx.font = '24px "Press Start 2P", monospace';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('FIGURE', w / 2 - 20, h / 2 - 60);

  // Pixel art infinity symbol (figure 8 on its side)
  const px = 6;  // pixel size
  const infX = w / 2 + 75;
  const infY = h / 2 - 78;
  const infinityPixels = [
    [1,0],[2,0],[5,0],[6,0],
    [0,1],[3,1],[4,1],[7,1],
    [0,2],[3,2],[4,2],[7,2],
    [1,3],[2,3],[5,3],[6,3],
  ];
  for (const [dx, dy] of infinityPixels) {
    ctx.fillRect(infX + dx * px, infY + dy * px, px, px);
  }

  // Loading text
  ctx.font = '12px "Press Start 2P", monospace';
  ctx.fillStyle = '#40ACBF';
  ctx.fillText('Loading...', w / 2, h / 2 - 10);

  // Progress bar dimensions (pixel-perfect)
  const barW = 200;
  const barH = 16;
  const barX = Math.floor((w - barW) / 2);
  const barY = Math.floor(h / 2 + 20);
  const pixelSize = 4;  // Size of each "pixel" block

  // Bar border (2px pixel border)
  ctx.fillStyle = '#3B8897';
  ctx.fillRect(barX - pixelSize, barY - pixelSize, barW + pixelSize * 2, barH + pixelSize * 2);

  // Bar background
  ctx.fillStyle = '#1D2B30';
  ctx.fillRect(barX, barY, barW, barH);

  // Progress fill (pixelated blocks)
  const fillW = Math.floor((barW * progress) / pixelSize) * pixelSize;
  ctx.fillStyle = '#68BBC4';
  ctx.fillRect(barX, barY, fillW, barH);

  // Pixel grid overlay on progress bar (gives it that chunky pixel look)
  ctx.fillStyle = '#1D2B30';
  for (let x = barX; x < barX + barW; x += pixelSize * 2) {
    ctx.fillRect(x + pixelSize, barY, 1, barH);
  }
  for (let y = barY; y < barY + barH; y += pixelSize) {
    ctx.fillRect(barX, y + pixelSize - 1, barW, 1);
  }

  // Percentage text
  ctx.fillStyle = '#8DCBCA';
  ctx.font = '10px "Press Start 2P", monospace';
  ctx.fillText(Math.floor(progress * 100) + '%', w / 2, barY + barH + 25);
}

async function loadSprites(onProgress) {
  console.log('LOADING SPRITES from cloud...');

  // Try to get signed URLs from cloud (cache-bust to always get fresh URLs)
  let cloudUrls = {};
  try {
    const resp = await fetch(`${GAME_ASSETS_URL}?action=game-urls&_=${Date.now()}`);
    if (resp.ok) {
      const data = await resp.json();
      cloudUrls = data.urls || {};
      console.log(`Got ${Object.keys(cloudUrls).length} cloud URLs`);
    }
  } catch (e) {
    console.log('Cloud fetch failed, using local files:', e.message);
  }

  const cacheBust = Date.now();
  const total = spriteFiles.length;
  let loaded = 0;

  const promises = spriteFiles.map(file => {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = 'anonymous'; // Allow CORS for cloud images
      img.onload = () => {
        sprites[file.replace('.png', '')] = img;
        loaded++;
        if (onProgress) onProgress(loaded / total);
        resolve();
      };
      img.onerror = () => {
        console.log('FAILED: ' + file);
        loaded++;
        if (onProgress) onProgress(loaded / total);
        resolve();
      };
      // Floor tiles always local (git push updates them), others from cloud
      const forceLocal = file.startsWith('ice_floor_16x12_v');
      img.src = (!forceLocal && cloudUrls[file]) || (file + '?v=' + cacheBust);
    });
  });
  await Promise.all(promises);
  console.log('ALL SPRITES LOADED');
}

// Initialize game state
function initGameState(lv) {
  const state = {
    width: lv.width,
    height: lv.height,
    grid: lv.grid.map(row => [...row]),
    playerX: 0,
    playerY: 0,
    playerHeight: 0,  // 0 = ground, 1 = elevated (on blocks)
    playerDir: 'down',
    blocks: new Set(),
    ramps: new Map(),  // position key -> ramp type (^, v, <, >)
    keys: 0,
    unlockedWalls: new Set(),
    filledHoles: new Set(),
    won: false,
    dead: false
  };

  for (let y = 0; y < lv.height; y++) {
    for (let x = 0; x < lv.width; x++) {
      const c = lv.grid[y][x];
      if (c === 'S') {
        state.playerX = x;
        state.playerY = y;
      } else if (c === 'B') {
        state.blocks.add(`${x},${y}`);
      } else if (isRamp(c)) {
        // Track ramps separately for pushing
        state.ramps.set(`${x},${y}`, c);
      }
    }
  }

  // Also load blocks from level data (for blocks on top of other tiles like P)
  if (lv.blocks) {
    for (const [x, y] of lv.blocks) {
      state.blocks.add(`${x},${y}`);
    }
  }

  return state;
}

// Get base tile (ignoring blocks, but checking dynamic ramps)
function getBaseTile(state, x, y) {
  if (x < 0 || y < 0 || x >= state.width || y >= state.height) return '#';
  // Check dynamic ramp position first
  const ramp = state.ramps.get(`${x},${y}`);
  if (ramp) return ramp;
  // Grid ramps are only shown if still in ramps map (handles pushed ramps)
  const gridTile = state.grid[y][x];
  if (isRamp(gridTile) && !state.ramps.has(`${x},${y}`)) return '.';  // Ramp was pushed away
  return gridTile;
}

// Get effective tile (accounts for blocks and filled holes)
function getTile(state, x, y) {
  if (x < 0 || y < 0 || x >= state.width || y >= state.height) return '#';
  if (state.blocks.has(`${x},${y}`)) return 'B';
  if (state.filledHoles.has(`${x},${y}`)) return '.';
  const gridTile = state.grid[y][x];
  // 'B' in grid is only for initial placement - blocks come from blocks Set
  if (gridTile === 'B') return '.';
  return gridTile;
}

// Check if tile is a ramp
function isRamp(tile) {
  return tile === '^' || tile === 'v' || tile === '<' || tile === '>';
}

// Get ramp direction info: which way you must move to go UP
function getRampUpDir(tile) {
  switch(tile) {
    case '^': return { dx: 0, dy: -1 };  // Move north to go up
    case 'v': return { dx: 0, dy: 1 };   // Move south to go up
    case '<': return { dx: -1, dy: 0 };  // Move west to go up
    case '>': return { dx: 1, dy: 0 };   // Move east to go up
  }
  return null;
}

// Check if tile is a corner redirect
function isCorner(tile) {
  return tile === '7' || tile === '8' || tile === '9' || tile === '0';
}

// Get corner redirect: given incoming direction (dx, dy), return new direction
// Each corner redirects exactly 2 directions, other 2 pass through
// Names describe what UP/DOWN becomes:
// 7 = ur: UP→RIGHT, LEFT→DOWN  (use in top-LEFT of level - sends away from left wall)
// 8 = ul: UP→LEFT, RIGHT→DOWN  (use in top-RIGHT of level - sends away from right wall)
// 9 = dr: DOWN→RIGHT, LEFT→UP  (use in bottom-LEFT of level - sends away from left wall)
// 0 = dl: DOWN→LEFT, RIGHT→UP  (use in bottom-RIGHT of level - sends away from right wall)
function getCornerRedirect(tile, dx, dy) {
  switch(tile) {
    case '7': // ur: up→right, left→down
      if (dy === -1) return { dx: 1, dy: 0 };   // moving up → go right
      if (dx === -1) return { dx: 0, dy: 1 };   // moving left → go down
      return null;
    case '8': // ul: up→left, right→down
      if (dy === -1) return { dx: -1, dy: 0 };  // moving up → go left
      if (dx === 1) return { dx: 0, dy: 1 };    // moving right → go down
      return null;
    case '9': // dr: down→right, left→up
      if (dy === 1) return { dx: 1, dy: 0 };    // moving down → go right
      if (dx === -1) return { dx: 0, dy: -1 };  // moving left → go up
      return null;
    case '0': // dl: down→left, right→up
      if (dy === 1) return { dx: -1, dy: 0 };   // moving down → go left
      if (dx === 1) return { dx: 0, dy: -1 };   // moving right → go up
      return null;
  }
  return null;
}

// Check if a block at position is elevated (on wall, locked wall, or ramp)
function isBlockElevatedAt(state, x, y) {
  const baseTile = getBaseTile(state, x, y);
  if (baseTile === '#') return true;
  if (baseTile === 'L' && !state.unlockedWalls.has(`${x},${y}`)) return true;
  if (isRamp(baseTile)) return true;
  return false;
}

// Check if position is a border (test chamber) wall - can't land on these even when elevated
function isBorderWall(state, x, y) {
  return x === 0 || x === state.width - 1 || y === 0 || y === state.height - 1;
}

// Simulate player move
function simulateMove(state, dir) {
  let { dx, dy } = DIRS[dir];  // let, not const - corners can redirect!
  let x = state.playerX;
  let y = state.playerY;
  let height = state.playerHeight;


  // Clone state (deep copy grid to avoid mutation)
  let newState = {
    ...state,
    grid: state.grid.map(row => [...row]),  // Deep copy!
    blocks: new Set(state.blocks),
    ramps: new Map(state.ramps),
    unlockedWalls: new Set(state.unlockedWalls),
    filledHoles: new Set(state.filledHoles),
    playerDir: dir,
    wentUpRamp: false,  // Reset each move
    rampX: undefined,
    rampY: undefined,
    blockMoveInfo: null,  // Clear previous block move info
    path: [{ x: state.playerX, y: state.playerY }]  // Track path for corner animation
  };

  // Slide until hitting something
  for (let i = 0; i < 50; i++) {
    const nx = x + dx;
    const ny = y + dy;
    const tile = getTile(newState, nx, ny);
    const baseTile = getBaseTile(newState, nx, ny);

    // DEBUG: Show what tile we're checking
    console.log(`MOVE CHECK: (${nx},${ny}) tile='${tile}' baseTile='${baseTile}' height=${height}`);

    // --- GROUND LEVEL (height 0) ---
    if (height === 0) {
      // Wall - stop before
      if (tile === '#') { console.log('BLOCKED: wall'); break; }

      // Locked wall - stop before, unlock if have key
      if (tile === 'L' && !newState.unlockedWalls.has(`${nx},${ny}`)) {
        console.log(`HIT LOCKED WALL at (${nx},${ny}), keys=${newState.keys}`);
        if (newState.keys > 0) {
          console.log(`UNLOCKING wall at (${nx},${ny})`);
          newState.keys--;
          newState.unlockedWalls.add(`${nx},${ny}`);
          // Track for animation
          if (!newState.newlyUnlocked) newState.newlyUnlocked = [];
          newState.newlyUnlocked.push(`${nx},${ny}`);
        }
        break;  // Stop BEFORE the wall
      }

      // Block - try to push
      if (tile === 'B') {
        const pushResult = pushBlock(newState, nx, ny, dx, dy);
        if (!pushResult) break;  // Can't push, stop
        newState = pushResult;
        x = nx;
        y = ny;
        // Check if we uncovered and landed on the goal (not if penguin is elevated on wall)
        if (getBaseTile(newState, x, y) === 'P' && !level.penguinOnWall) {
          newState.won = true;
        }
        break;  // Stop after pushing
      }

      // Ramp - go UP or push from the side
      if (isRamp(baseTile)) {
        const upDir = getRampUpDir(baseTile);
        const match = upDir && upDir.dx === dx && upDir.dy === dy;
        if (match) {
          // Going UP the ramp - ascend to height 1
          x = nx;
          y = ny;
          height = 1;
          newState.wentUpRamp = true;  // Track for animation
          newState.rampX = nx;
          newState.rampY = ny;
          continue;  // Keep sliding at new height
        } else {
          // Try to push the ramp
          const pushResult = pushRamp(newState, nx, ny, dx, dy);
          if (pushResult) {
            newState = pushResult;
            x = nx;
            y = ny;
            break;  // Stop after pushing
          }
          // Can't push - ramp acts as wall
          break;
        }
      }

      // Hole - death!
      if (tile === 'H') {
        console.log(`DYING: sliding into hole at (${nx},${ny})`);
        newState.dead = true;
        newState.playerX = nx;
        newState.playerY = ny;
        return newState;
      }

      // Move to new position
      x = nx;
      y = ny;

      // Collect key (continue sliding)
      const gridChar = newState.grid[y]?.[x];
      console.log(`SLIDE to (${x},${y}), gridChar='${gridChar}', tile='${tile}', baseTile='${baseTile}'`);
      if (gridChar === 'K') {
        console.log(`KEY PICKUP at (${x},${y}), keys: ${newState.keys} -> ${newState.keys + 1}`);
        newState.keys++;
        newState.grid[y] = [...newState.grid[y]];
        newState.grid[y][x] = '.';
        console.log(`After pickup, grid[${y}][${x}] = '${newState.grid[y][x]}'`);
      }

      // Corner redirect - change direction if coming from correct side
      if (isCorner(baseTile)) {
        const redirect = getCornerRedirect(baseTile, dx, dy);
        if (redirect) {
          console.log(`CORNER ${baseTile} at (${x},${y}): redirecting (${dx},${dy}) → (${redirect.dx},${redirect.dy})`);
          // Add corner as waypoint for animation
          newState.path.push({ x, y, corner: true });
          dx = redirect.dx;
          dy = redirect.dy;
          newState.playerDir = dx === 1 ? 'right' : dx === -1 ? 'left' : dy === -1 ? 'up' : 'down';
        }
        // If no redirect (wrong direction), just continue sliding through
      }

      // Goal - win! (but if penguin is on wall, need to be elevated)
      if (baseTile === 'P') {
        if (level.penguinOnWall) {
          // Can't reach penguin on wall from ground - treat as wall, stop before it
          x -= dx;
          y -= dy;
          break;
        }
        newState.won = true;
        break;
      }

      // Sticky tile - stop
      if (baseTile === 'T') break;
      if (baseTile === 'L' && newState.unlockedWalls.has(`${x},${y}`)) break;

      // Crack becomes hole - but only AFTER checking if we can continue
      // If we stop here, we fall through. If we continue, we're safe.
      if (baseTile >= '1' && baseTile <= '4') {
        // Peek at next tile to see if we'll continue or stop
        const peekX = x + dx;
        const peekY = y + dy;
        const peekTile = getTile(newState, peekX, peekY);
        const peekBase = getBaseTile(newState, peekX, peekY);

        console.log(`CRACK at (${x},${y}), peek (${peekX},${peekY}): tile=${peekTile}, base=${peekBase}`);

        // Will we stop here? (wall, block we can't push, locked wall, ramp blocking)
        const willStop = peekTile === '#' ||
                        peekTile === 'B' ||  // Will try to push and stop
                        (peekTile === 'L' && !newState.unlockedWalls.has(`${peekX},${peekY}`)) ||
                        (isRamp(peekBase) && (() => {
                          const upDir = getRampUpDir(peekBase);
                          return !(upDir && upDir.dx === dx && upDir.dy === dy);
                        })());

        console.log(`willStop=${willStop}`);

        if (willStop) {
          // Stopping on crack = fall through
          console.log('DYING: stopping on crack');
          newState.grid[y] = [...newState.grid[y]];
          newState.grid[y][x] = 'H';
          newState.dead = true;
          newState.playerX = x;
          newState.playerY = y;
          return newState;
        }
        // Otherwise, crack breaks but we slide over safely
        console.log('SAFE: sliding over crack');
        newState.grid[y] = [...newState.grid[y]];
        newState.grid[y][x] = 'H';
      }
    }

    // --- ELEVATED (height 1) ---
    else {
      console.log(`ELEVATED: checking (${nx},${ny}) tile='${tile}' baseTile='${baseTile}'`);

      // Wall - can slide onto it (1 tile) then stop, BUT NOT border walls
      if (tile === '#') {
        if (isBorderWall(newState, nx, ny)) {
          console.log(`ELEVATED: blocked by border wall at (${nx},${ny})`);
          break;  // Stop BEFORE border wall
        }
        x = nx;
        y = ny;
        newState.lastElevatedX = x;
        newState.lastElevatedY = y;
        console.log(`ELEVATED: stopping on interior wall at (${x},${y})`);
        break;  // Stop on top of interior wall
      }

      // Locked wall - same behavior
      if (tile === 'L' && !newState.unlockedWalls.has(`${nx},${ny}`)) {
        x = nx;
        y = ny;
        newState.lastElevatedX = x;
        newState.lastElevatedY = y;
        console.log(`ELEVATED: stopping on locked wall at (${x},${y})`);
        break;
      }

      // Move to next position
      console.log(`ELEVATED: moving to (${nx},${ny})`);
      x = nx;
      y = ny;

      // Check what we're over - blocks and ramps keep us elevated
      const overBlock = newState.blocks.has(`${x},${y}`);
      const overRamp = isRamp(baseTile);

      if (overBlock) {
        // Stay elevated over block, keep sliding
        newState.lastElevatedX = x;
        newState.lastElevatedY = y;
      } else if (overRamp) {
        const upDir = getRampUpDir(baseTile);
        if (upDir && upDir.dx === -dx && upDir.dy === -dy) {
          // Going DOWN the ramp - descend to height 0
          height = 0;
        } else {
          // Stay elevated over ramp
          newState.lastElevatedX = x;
          newState.lastElevatedY = y;
        }
      } else if (baseTile === 'P' && level.penguinOnWall) {
        // Penguin on wall - stay elevated
        newState.lastElevatedX = x;
        newState.lastElevatedY = y;
      } else {
        // Not on ramp or block - drop to ground
        height = 0;
        // Check if we dropped onto a hole - die!
        if (baseTile === 'H' && !newState.filledHoles.has(`${x},${y}`)) {
          newState.dead = true;
          newState.playerX = x;
          newState.playerY = y;
          return newState;
        }
        // Check if we dropped onto a crack - break through and die!
        if (baseTile >= '1' && baseTile <= '4') {
          newState.grid[y] = [...newState.grid[y]];
          newState.grid[y][x] = 'H';  // Crack becomes hole
          newState.dead = true;
          newState.playerX = x;
          newState.playerY = y;
          return newState;
        }
      }

      // Check for goal (works from elevated too)
      if (baseTile === 'P') {
        newState.won = true;
        break;
      }
    }
  }

  // Stay elevated for now - will drop at start of next move if not on block/ramp

  // Check if we stopped on a pre-existing hole (NOT from a crack we just broke)
  // Use original level.grid since newState.grid gets modified
  const originalTile = level.grid[y]?.[x];
  const currentTile = getTile(newState, x, y);
  console.log(`POST-LOOP: pos=(${x},${y}), originalTile=${originalTile}, currentTile=${currentTile}, height=${height}`);
  if (height === 0 && originalTile === 'H' && currentTile === 'H') {
    // Only die if this was ALREADY a hole in the original level (not from a crack)
    console.log('DYING: stopped on original hole');
    newState.dead = true;
    newState.playerX = x;
    newState.playerY = y;
    return newState;
  }

  // Check if anything changed (position, height, or state like unlocked walls)
  const positionChanged = x !== state.playerX || y !== state.playerY || height !== state.playerHeight;
  const stateChanged = newState.unlockedWalls.size !== state.unlockedWalls.size ||
                       newState.keys !== state.keys ||
                       newState.filledHoles.size !== state.filledHoles.size;
  if (!positionChanged && !stateChanged) {
    return null;
  }

  newState.playerX = x;
  newState.playerY = y;
  newState.playerHeight = height;
  // Add final position to path
  newState.path.push({ x, y });
  return newState;
}

// Push a block
function pushBlock(state, bx, by, dx, dy) {
  const newState = {
    ...state,
    blocks: new Set(state.blocks),
    ramps: new Map(state.ramps),
    unlockedWalls: new Set(state.unlockedWalls),
    filledHoles: new Set(state.filledHoles),
    grid: state.grid.map(row => [...row])
  };

  newState.blocks.delete(`${bx},${by}`);

  let x = bx + dx;
  let y = by + dy;
  let blockHeight = 0;  // Track block elevation like player
  const blockPath = [{ x: bx, y: by }];  // Track path for corner animation
  let blockRampX, blockRampY;  // Where block went up ramp
  let blockWentUpRamp = false;
  let blockLastElevatedX, blockLastElevatedY;  // Last position where block was elevated
  const startTile = getTile(newState, x, y);
  const startBase = getBaseTile(newState, x, y);

  // Helper to set block move info before returning
  function finishAt(finalX, finalY) {
    blockPath.push({ x: finalX, y: finalY });
    newState.blockMoveInfo = {
      fromX: bx,
      fromY: by,
      toX: finalX,
      toY: finalY,
      wentUpRamp: blockWentUpRamp,
      rampX: blockRampX,
      rampY: blockRampY,
      lastElevatedX: blockLastElevatedX,
      lastElevatedY: blockLastElevatedY,
      path: blockPath  // Path for corner animation
    };
  }

  // Can't push into wall, block, locked wall, or ramp (wrong direction) immediately
  if (blockHeight === 0) {
    if (startTile === '#') return null;
    if (startTile === 'B') return null;  // Another block
    if (startTile === 'L' && !newState.unlockedWalls.has(`${x},${y}`)) return null;  // Locked wall
    // Can't push into ramp unless going up it
    if (isRamp(startBase)) {
      const upDir = getRampUpDir(startBase);
      if (!(upDir && upDir.dx === dx && upDir.dy === dy)) return null;
    }
  }

  for (let i = 0; i < 50; i++) {
    const tile = getTile(newState, x, y);
    const baseTile = getBaseTile(newState, x, y);

    // --- GROUND LEVEL (blockHeight 0) ---
    if (blockHeight === 0) {
      // Wall - stop at previous position
      if (tile === '#') {
        newState.blocks.add(`${x - dx},${y - dy}`);
        finishAt(x - dx, y - dy);
        return newState;
      }

      // Player - push them! (momentum transfer)
      if (x === newState.playerX && y === newState.playerY) {
        // Block stops just before player
        newState.blocks.add(`${x - dx},${y - dy}`);
        finishAt(x - dx, y - dy);
        // Mark that player should be pushed
        newState.playerPushedBy = { dx, dy };
        return newState;
      }

      // Another block - try to push it (momentum chain)
      if (tile === 'B') {
        // Try to push the other block
        const chainResult = pushBlock(newState, x, y, dx, dy);
        if (chainResult) {
          // Chain succeeded - our block stops where we are now
          chainResult.blocks.add(`${x - dx},${y - dy}`);
          // Combine path info for animation (could be enhanced)
          finishAt(x - dx, y - dy);
          chainResult.blockMoveInfo = newState.blockMoveInfo;
          chainResult.chainedBlockInfo = chainResult.blockMoveInfo; // Track the chained push
          return chainResult;
        }
        // Chain failed - just stop
        newState.blocks.add(`${x - dx},${y - dy}`);
        finishAt(x - dx, y - dy);
        return newState;
      }

      // Locked wall - stop at previous position
      if (tile === 'L' && !newState.unlockedWalls.has(`${x},${y}`)) {
        newState.blocks.add(`${x - dx},${y - dy}`);
        finishAt(x - dx, y - dy);
        return newState;
      }

      // Hole - block fills it
      if (tile === 'H') {
        newState.filledHoles.add(`${x},${y}`);
        finishAt(x, y);  // Block ends at hole
        return newState;  // Block is gone
      }

      // Crack - block breaks it, and if stopping here, falls in and fills
      if (baseTile >= '1' && baseTile <= '4') {
        // Check if we'll stop here
        const nx = x + dx;
        const ny = y + dy;
        const nextTile = getTile(newState, nx, ny);
        const nextBase = getBaseTile(newState, nx, ny);
        const willStop = nextTile === '#' || newState.blocks.has(`${nx},${ny}`) ||
                        (nextTile === 'L' && !newState.unlockedWalls.has(`${nx},${ny}`)) ||
                        (isRamp(nextBase) && (() => {
                          const upDir = getRampUpDir(nextBase);
                          return !(upDir && upDir.dx === dx && upDir.dy === dy);
                        })()) || nextBase === 'T' || nextBase === 'P' ||
                        (nextBase === 'L' && newState.unlockedWalls.has(`${nx},${ny}`));

        if (willStop) {
          // Block stops on crack - falls in, fills the hole
          newState.grid[y] = [...newState.grid[y]];
          newState.grid[y][x] = 'H';  // Crack becomes hole
          newState.filledHoles.add(`${x},${y}`);  // But it's filled
          finishAt(x, y);
          return newState;  // Block is gone
        } else {
          // Sliding over crack - breaks it
          newState.grid[y] = [...newState.grid[y]];
          newState.grid[y][x] = 'H';  // Crack becomes hole
        }
      }

      // Sticky tile - block stops here
      if (baseTile === 'T') {
        newState.blocks.add(`${x},${y}`);
        finishAt(x, y);
        return newState;
      }

      // Unlocked wall (sticky) - block stops here
      if (baseTile === 'L' && newState.unlockedWalls.has(`${x},${y}`)) {
        newState.blocks.add(`${x},${y}`);
        finishAt(x, y);
        return newState;
      }

      // Goal - block stops here (can't push onto goal)
      // If penguinOnWall, block stops BEFORE penguin (penguin is on elevated platform)
      if (baseTile === 'P') {
        if (level.penguinOnWall) {
          newState.blocks.add(`${x - dx},${y - dy}`);
          finishAt(x - dx, y - dy);
        } else {
          newState.blocks.add(`${x},${y}`);
          finishAt(x, y);
        }
        return newState;
      }

      // Ramp - block goes up if moving in the right direction, or pushes ramp
      if (isRamp(baseTile)) {
        const upDir = getRampUpDir(baseTile);
        if (upDir && upDir.dx === dx && upDir.dy === dy) {
          // Going UP the ramp - block becomes elevated
          blockHeight = 1;
          blockWentUpRamp = true;
          blockRampX = x;
          blockRampY = y;
        } else {
          // Wrong direction - try to push the ramp (momentum chain)
          const chainResult = pushRamp(newState, x, y, dx, dy);
          if (chainResult) {
            // Chain succeeded - our block stops where we are now
            chainResult.blocks.add(`${x - dx},${y - dy}`);
            finishAt(x - dx, y - dy);
            chainResult.blockMoveInfo = newState.blockMoveInfo;
            return chainResult;
          }
          // Chain failed - just stop
          newState.blocks.add(`${x - dx},${y - dy}`);
          finishAt(x - dx, y - dy);
          return newState;
        }
      }

      // Corner redirect - change block direction
      if (isCorner(baseTile)) {
        const redirect = getCornerRedirect(baseTile, dx, dy);
        if (redirect) {
          blockPath.push({ x, y, corner: true });  // Add waypoint for animation
          dx = redirect.dx;
          dy = redirect.dy;
        }
      }

      // Check next position
      const nx = x + dx;
      const ny = y + dy;
      const nextTile = getTile(newState, nx, ny);
      const nextBase = getBaseTile(newState, nx, ny);

      // If next is solid/stopping, stop here
      // But if we're elevated (just went up ramp), we can pass over ground-level blocks
      const nextBlockBlocks = (nextTile === 'B') && (blockHeight === 0 || isBlockElevatedAt(newState, nx, ny));
      if (nextTile === '#' || nextBlockBlocks ||
          (nextTile === 'L' && !newState.unlockedWalls.has(`${nx},${ny}`)) ||
          nextBase === 'T' || nextBase === 'P' ||
          (nextBase === 'L' && newState.unlockedWalls.has(`${nx},${ny}`))) {
        newState.blocks.add(`${x},${y}`);
        finishAt(x, y);
        return newState;
      }

      // Ramp ahead - check if block can go up
      if (isRamp(nextBase)) {
        const upDir = getRampUpDir(nextBase);
        if (!(upDir && upDir.dx === dx && upDir.dy === dy)) {
          // Can't go up this ramp - stop here
          newState.blocks.add(`${x},${y}`);
          finishAt(x, y);
          return newState;
        }
      }

      x = nx;
      y = ny;
    }
    // --- ELEVATED (blockHeight 1) ---
    else {
      // Wall - can slide onto it then stop, BUT NOT border walls
      if (tile === '#') {
        if (isBorderWall(newState, x, y)) {
          // Stop BEFORE border wall
          newState.blocks.add(`${x - dx},${y - dy}`);
          finishAt(x - dx, y - dy);
          return newState;
        }
        blockLastElevatedX = x;
        blockLastElevatedY = y;
        newState.blocks.add(`${x},${y}`);
        finishAt(x, y);
        return newState;
      }

      // Locked wall - same (stays elevated)
      if (tile === 'L' && !newState.unlockedWalls.has(`${x},${y}`)) {
        blockLastElevatedX = x;
        blockLastElevatedY = y;
        newState.blocks.add(`${x},${y}`);
        finishAt(x, y);
        return newState;
      }

      // Another block at this position - check elevation
      if (tile === 'B') {
        if (isBlockElevatedAt(newState, x, y)) {
          // Both elevated - can't share space, stop at previous position
          newState.blocks.add(`${x - dx},${y - dy}`);
          finishAt(x - dx, y - dy);
          return newState;
        }
        // Ground-level block - we're elevated over it, continue sliding
        blockLastElevatedX = x;
        blockLastElevatedY = y;
      }

      // Check what we're over - ramps keep us elevated
      if (isRamp(baseTile)) {
        const upDir = getRampUpDir(baseTile);
        if (upDir && upDir.dx === -dx && upDir.dy === -dy) {
          // Going DOWN the ramp - descend to ground
          blockHeight = 0;
        } else {
          // Stay elevated over ramp
          blockLastElevatedX = x;
          blockLastElevatedY = y;
        }
      } else if (tile !== '#' && tile !== 'B' && !(tile === 'L' && !newState.unlockedWalls.has(`${x},${y}`))) {
        // Not on ramp, wall, or block - drop to ground
        blockHeight = 0;
      }

      // Corner redirect - change block direction (elevated blocks too)
      if (isCorner(baseTile)) {
        const redirect = getCornerRedirect(baseTile, dx, dy);
        if (redirect) {
          blockPath.push({ x, y, corner: true });  // Add waypoint for animation
          dx = redirect.dx;
          dy = redirect.dy;
        }
      }

      // Move to next position
      const nx = x + dx;
      const ny = y + dy;
      const nextTile = getTile(newState, nx, ny);

      // If we dropped to ground, handle ground-level stopping
      if (blockHeight === 0) {
        // Ground level - stop BEFORE walls/blocks
        if (nextTile === '#' || nextTile === 'B' ||
            (nextTile === 'L' && !newState.unlockedWalls.has(`${nx},${ny}`))) {
          newState.blocks.add(`${x},${y}`);
          finishAt(x, y);
          return newState;
        }
      } else {
        // Still elevated - can stop ON TOP of walls, BUT NOT border walls
        if (nextTile === '#' || (nextTile === 'L' && !newState.unlockedWalls.has(`${nx},${ny}`))) {
          if (isBorderWall(newState, nx, ny)) {
            // Stop BEFORE border wall
            newState.blocks.add(`${x},${y}`);
            finishAt(x, y);
            return newState;
          }
          x = nx;
          y = ny;
          blockLastElevatedX = x;
          blockLastElevatedY = y;
          newState.blocks.add(`${x},${y}`);
          finishAt(x, y);
          return newState;
        }

        // If next position has an elevated block, stop here
        if (nextTile === 'B' && isBlockElevatedAt(newState, nx, ny)) {
          blockLastElevatedX = x;
          blockLastElevatedY = y;
          newState.blocks.add(`${x},${y}`);
          finishAt(x, y);
          return newState;
        }
      }

      x = nx;
      y = ny;
    }
  }

  newState.blocks.add(`${x},${y}`);
  finishAt(x, y);
  return newState;
}

// Push a ramp (slides like a block but stays on ground)
function pushRamp(state, rx, ry, dx, dy) {
  const key = `${rx},${ry}`;
  const rampType = state.ramps.get(key);
  if (!rampType) return null;

  const newState = {
    ...state,
    blocks: new Set(state.blocks),
    ramps: new Map(state.ramps),
    unlockedWalls: new Set(state.unlockedWalls),
    filledHoles: new Set(state.filledHoles),
    grid: state.grid.map(row => [...row])
  };

  newState.ramps.delete(key);

  let x = rx + dx;
  let y = ry + dy;
  let rampHeight = 0;  // Track ramp elevation like blocks

  // Track animation
  const fromX = rx, fromY = ry;
  let wentUpRamp = false;
  let elevationRampX, elevationRampY;
  const rampPath = [{ x: rx, y: ry }];  // Track path for corner animation

  // Check immediate first position - can't push into wall, block, locked wall, or another ramp
  const startTile = getTile(newState, x, y);
  const startBase = getBaseTile(newState, x, y);
  if (startTile === '#' || startTile === 'B' ||
      (startTile === 'L' && !newState.unlockedWalls.has(`${x},${y}`))) {
    return null;  // Can't push - blocked immediately
  }
  // Can't push into another ramp (unless going up it)
  if (isRamp(startBase)) {
    const upDir = getRampUpDir(startBase);
    if (!(upDir && upDir.dx === dx && upDir.dy === dy)) {
      return null;  // Wrong direction, can't push through ramp
    }
  }

  // Slide until hitting obstacle
  for (let i = 0; i < 50; i++) {
    const tile = getTile(newState, x, y);
    const baseTile = getBaseTile(newState, x, y);

    // --- GROUND LEVEL ---
    if (rampHeight === 0) {
      // Wall - stop
      if (tile === '#' || (tile === 'L' && !newState.unlockedWalls.has(`${x},${y}`))) {
        x -= dx;
        y -= dy;
        break;
      }

      // Player - push them! (momentum transfer)
      if (x === newState.playerX && y === newState.playerY) {
        x -= dx;
        y -= dy;
        newState.ramps.set(`${x},${y}`, rampType);
        rampPath.push({ x, y });
        newState.rampMoveInfo = { fromX, fromY, toX: x, toY: y, rampType, wentUpRamp, elevationRampX, elevationRampY, path: rampPath };
        newState.playerPushedBy = { dx, dy };
        return newState;
      }

      // Block - try to push it (momentum chain)
      if (tile === 'B') {
        const chainResult = pushBlock(newState, x, y, dx, dy);
        if (chainResult) {
          // Chain succeeded - ramp stops here
          x -= dx;
          y -= dy;
          // Use chain result state
          chainResult.ramps.set(`${x},${y}`, rampType);
          rampPath.push({ x, y });
          chainResult.rampMoveInfo = { fromX, fromY, toX: x, toY: y, rampType, wentUpRamp, elevationRampX, elevationRampY, path: rampPath };
          return chainResult;
        }
        // Chain failed - just stop
        x -= dx;
        y -= dy;
        break;
      }

      // Penguin - stop before it (can't push ramp onto penguin)
      if (baseTile === 'P') {
        x -= dx;
        y -= dy;
        break;
      }

      // Other ramp - try to go UP it, or push it
      if (isRamp(baseTile)) {
        const upDir = getRampUpDir(baseTile);
        if (upDir && upDir.dx === dx && upDir.dy === dy) {
          // Going UP - ramp becomes elevated
          rampHeight = 1;
          wentUpRamp = true;
          elevationRampX = x;
          elevationRampY = y;
          // Continue sliding elevated
        } else {
          // Wrong direction - try to push the other ramp (momentum chain)
          const chainResult = pushRamp(newState, x, y, dx, dy);
          if (chainResult) {
            // Chain succeeded - ramp stops here
            x -= dx;
            y -= dy;
            chainResult.ramps.set(`${x},${y}`, rampType);
            rampPath.push({ x, y });
            chainResult.rampMoveInfo = { fromX, fromY, toX: x, toY: y, rampType, wentUpRamp, elevationRampX, elevationRampY, path: rampPath };
            return chainResult;
          }
          // Chain failed - just stop
          x -= dx;
          y -= dy;
          break;
        }
      }

      // Hole - ramp falls in and fills it
      if (baseTile === 'H' && !newState.filledHoles.has(`${x},${y}`)) {
        newState.filledHoles.add(`${x},${y}`);
        newState.rampMoveInfo = { fromX, fromY, toX: x, toY: y, fell: true };
        return newState;
      }

      // Crack - ramp breaks it, and if stopping here, falls in and fills
      if (baseTile >= '1' && baseTile <= '4') {
        // Check if we'll stop here
        const nx = x + dx;
        const ny = y + dy;
        const nextTile = getTile(newState, nx, ny);
        const nextBase = getBaseTile(newState, nx, ny);
        const willStop = nextTile === '#' || nextTile === 'B' ||
                        (nextTile === 'L' && !newState.unlockedWalls.has(`${nx},${ny}`)) ||
                        (isRamp(nextBase) && (() => {
                          const upDir = getRampUpDir(nextBase);
                          return !(upDir && upDir.dx === dx && upDir.dy === dy);
                        })()) || nextBase === 'P';

        if (willStop) {
          // Ramp stops on crack - falls in, fills the hole
          newState.grid[y] = [...newState.grid[y]];
          newState.grid[y][x] = 'H';  // Crack becomes hole
          newState.filledHoles.add(`${x},${y}`);  // But it's filled
          newState.rampMoveInfo = { fromX, fromY, toX: x, toY: y, fell: true };
          return newState;
        } else {
          // Sliding over crack - breaks it
          newState.grid[y] = [...newState.grid[y]];
          newState.grid[y][x] = 'H';  // Crack becomes hole
        }
      }

      // Corner redirect - change ramp direction
      if (isCorner(baseTile)) {
        const redirect = getCornerRedirect(baseTile, dx, dy);
        if (redirect) {
          rampPath.push({ x, y, corner: true });  // Add waypoint for animation
          dx = redirect.dx;
          dy = redirect.dy;
        }
      }

      // Check next position
      const nx = x + dx;
      const ny = y + dy;
      const nextTile = getTile(newState, nx, ny);
      const nextBase = getBaseTile(newState, nx, ny);

      // Stop before obstacles
      if (nextTile === '#' || nextTile === 'B' ||
          (nextTile === 'L' && !newState.unlockedWalls.has(`${nx},${ny}`)) ||
          nextBase === 'P') {
        break;
      }

      // Ramp ahead - check if we can go up
      if (isRamp(nextBase)) {
        const upDir = getRampUpDir(nextBase);
        if (!(upDir && upDir.dx === dx && upDir.dy === dy)) {
          // Can't go up - stop here
          break;
        }
      }

      x = nx;
      y = ny;
    }
    // --- ELEVATED ---
    else {
      // Wall - slide onto it and stop (elevated on wall)
      if (tile === '#' || (tile === 'L' && !newState.unlockedWalls.has(`${x},${y}`))) {
        break;
      }

      // Penguin on wall - can land on it at elevation
      if (baseTile === 'P' && level.penguinOnWall) {
        break;
      }

      // Check what we're over
      const overRamp = isRamp(baseTile);
      if (overRamp) {
        const upDir = getRampUpDir(baseTile);
        if (upDir && upDir.dx === -dx && upDir.dy === -dy) {
          // Going DOWN - descend
          rampHeight = 0;
        }
      } else if (tile !== '#' && tile !== 'B') {
        // Not on wall/block/ramp - drop to ground
        rampHeight = 0;
      }

      // Corner redirect - change ramp direction (elevated too)
      if (isCorner(baseTile)) {
        const redirect = getCornerRedirect(baseTile, dx, dy);
        if (redirect) {
          rampPath.push({ x, y, corner: true });  // Add waypoint for animation
          dx = redirect.dx;
          dy = redirect.dy;
        }
      }

      // Check next position
      const nx = x + dx;
      const ny = y + dy;
      const nextTile = getTile(newState, nx, ny);

      if (rampHeight === 0) {
        // Ground level now - stop before walls
        if (nextTile === '#' || nextTile === 'B' ||
            (nextTile === 'L' && !newState.unlockedWalls.has(`${nx},${ny}`))) {
          break;
        }
      } else {
        // Still elevated - can land on walls, BUT NOT border walls
        if (nextTile === '#' || (nextTile === 'L' && !newState.unlockedWalls.has(`${nx},${ny}`))) {
          if (!isBorderWall(newState, nx, ny)) {
            x = nx;
            y = ny;
          }
          break;
        }
      }

      x = nx;
      y = ny;
    }
  }

  // If ramp didn't move, push failed - treat as wall
  if (x === rx && y === ry) {
    return null;
  }

  newState.ramps.set(`${x},${y}`, rampType);
  rampPath.push({ x, y });  // Add final position
  newState.rampMoveInfo = { fromX, fromY, toX: x, toY: y, rampType, wentUpRamp, elevationRampX, elevationRampY, path: rampPath };
  return newState;
}

// === SOLVER ===
// BFS solver to find solution from current state

function stateKey(s) {
  // Create unique key for state (for visited set)
  const blocks = [...s.blocks].sort().join(';');
  const ramps = [...s.ramps.entries()].sort().map(([k,v]) => `${k}:${v}`).join(';');
  const unlocked = [...s.unlockedWalls].sort().join(';');
  const filled = [...s.filledHoles].sort().join(';');
  const cracked = [...(s.crackedTiles || [])].sort().join(';');
  return `${s.playerX},${s.playerY},${s.playerHeight},${s.keys},${blocks},${ramps},${unlocked},${filled},${cracked}`;
}

function cloneState(s) {
  return {
    ...s,
    grid: s.grid.map(row => [...row]),
    blocks: new Set(s.blocks),
    ramps: new Map(s.ramps),
    unlockedWalls: new Set(s.unlockedWalls),
    filledHoles: new Set(s.filledHoles),
    crackedTiles: new Set(s.crackedTiles || [])
  };
}

function findGoal(state) {
  for (let y = 0; y < state.height; y++) {
    for (let x = 0; x < state.width; x++) {
      if (state.grid[y][x] === 'P') return { x, y };
    }
  }
  return null;
}

function solverSimulateMove(state, dir) {
  // Simplified simulation for solver - returns new state or null if invalid/death
  const result = simulateMove(cloneState(state), dir);
  if (!result || result.dead) return null;
  // Track cracked tiles
  if (!result.crackedTiles) result.crackedTiles = new Set(state.crackedTiles || []);
  return result;
}

function solveFromState(state, maxMoves = 50, maxStates = 50000, maxMs = 2000) {
  const goal = findGoal(state);
  if (!goal) return null;

  const startTime = performance.now();
  const visited = new Set();
  const queue = [{ state: cloneState(state), moves: [], depth: 0 }];
  let expanded = 0;

  while (queue.length > 0) {
    if (performance.now() - startTime > maxMs) return null;
    if (expanded > maxStates) return null;

    const { state: current, moves, depth } = queue.shift();
    expanded++;

    if (depth > maxMoves) continue;

    // Win check
    if (current.playerX === goal.x && current.playerY === goal.y) {
      return { moves, expanded };
    }

    const key = stateKey(current);
    if (visited.has(key)) continue;
    visited.add(key);

    // Try each direction
    for (const dir of ['up', 'down', 'left', 'right']) {
      const newState = solverSimulateMove(current, dir);
      if (newState && !visited.has(stateKey(newState))) {
        queue.push({ state: newState, moves: [...moves, dir], depth: depth + 1 });
      }
    }
  }

  return null; // No solution found
}

function getHint() {
  if (!gameState || gameState.won || gameState.dead) return null;
  const solution = solveFromState(gameState);
  if (solution && solution.moves.length > 0) {
    return solution.moves[0];
  }
  return null;
}

function isLevelWinnable() {
  // Check the current effective state (targetState during animation)
  const checkState = animation ? animation.targetState : gameState;
  if (!checkState || checkState.won) return true;
  if (checkState.dead) return false;
  return solveFromState(checkState) !== null;
}

// Render
const ICE_PADDING = 1;  // Minimal padding in tiles for ice draw loop

function render() {
  if (!level || !gameState) return;

  // Use animation target state if animating (so changes appear immediately)
  const renderState = animation ? animation.targetState : gameState;

  const w = level.width;
  const h = level.height;

  // Calculate scale to fit puzzle in viewport
  // Level size = just the grid, no padding
  const levelPixelW = w * TILE_W;
  const levelPixelH = h * TILE_H;

  // Scale to fit viewport
  const viewW = window.innerWidth;
  const viewH = window.innerHeight;
  const isMobile = viewW < 900;
  const scaleX = viewW / levelPixelW;
  const scaleY = viewH / levelPixelH;
  // Mobile: exact width fill (non-integer OK), desktop: integer scale
  SCALE = isMobile ? scaleX : Math.floor(Math.min(scaleX, scaleY));
  if (SCALE < 1) SCALE = 1;

  // Canvas fills ENTIRE viewport - ice everywhere
  const scaledLevelW = levelPixelW * SCALE;
  const scaledLevelH = levelPixelH * SCALE;
  canvas.width = viewW;
  canvas.height = viewH;
  canvas.style.width = viewW + 'px';
  canvas.style.height = viewH + 'px';
  ctx.imageSmoothingEnabled = false;

  // Mobile: puzzle fills width exactly (offsetX=0), desktop: center
  const offsetX = isMobile ? 0 : Math.floor((viewW - scaledLevelW) / 2);
  const offsetY = Math.floor((viewH - scaledLevelH) / 2);

  const now = performance.now();
  if (now - lastKeyFrameTime > 200) {
    keyFrame = (keyFrame + 1) % 4;
    lastKeyFrameTime = now;
  }

  // Draw ice tiles across entire canvas (12 variants for visual variety)
  const floorVariants = [
    sprites['ice_floor_16x12_v1'], sprites['ice_floor_16x12_v2'], sprites['ice_floor_16x12_v3'],
    sprites['ice_floor_16x12_v4'], sprites['ice_floor_16x12_v5'], sprites['ice_floor_16x12_v6'],
    sprites['ice_floor_16x12_v7'], sprites['ice_floor_16x12_v8'], sprites['ice_floor_16x12_v9'],
    sprites['ice_floor_16x12_v10'], sprites['ice_floor_16x12_v11'], sprites['ice_floor_16x12_v12']
  ];
  const tileW = TILE_W * SCALE;
  const tileH = TILE_H * SCALE;
  // Calculate floor grid start position aligned with level grid
  // Level tile (0,0) is at (offsetX, offsetY + TOP_PADDING * SCALE)
  const levelGridX = offsetX;
  const levelGridY = offsetY + TOP_PADDING * SCALE;
  // Find floor start position <= 0 that aligns with level grid
  const floorStartX = levelGridX - Math.ceil(levelGridX / tileW) * tileW;
  const floorStartY = levelGridY - Math.ceil(levelGridY / tileH) * tileH;
  const tilesX = Math.ceil((canvas.width - floorStartX) / tileW) + 1;
  const tilesY = Math.ceil((canvas.height - floorStartY) / tileH) + 1;
  for (let ty = 0; ty < tilesY; ty++) {
    for (let tx = 0; tx < tilesX; tx++) {
      const px = floorStartX + tx * tileW;
      const py = floorStartY + ty * tileH;
      // Pick variant based on position (deterministic pseudo-random)
      const variant = Math.abs((tx * 7 + ty * 13) % 12);
      const floorSprite = floorVariants[variant];
      if (floorSprite) {
        ctx.drawImage(floorSprite, px, py, tileW, tileH);
      }
    }
  }

  // Draw trail pixels (skate marks on ice)
  ctx.fillStyle = '#CFDFE2';  // Light color (was medium, too dark)
  for (const p of trailPoints) {
    const px = offsetX + p.tileX * TILE_W * SCALE + p.pixelX * SCALE;
    const py = offsetY + TOP_PADDING * SCALE + p.tileY * TILE_H * SCALE + p.pixelY * SCALE;
    ctx.fillRect(px, py, SCALE, SCALE);
  }

  // Floor pass - level elements
  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      const tile = renderState.grid[y][x];
      const px = offsetX + x * TILE_W * SCALE;
      const py = offsetY + TOP_PADDING * SCALE + y * TILE_H * SCALE;

      // Crack variants (floor overlays, centered on grid)
      if (tile >= '1' && tile <= '4') {
        drawSprite(`ice_crack_${tile}`, px, py - TILE_H * SCALE);
      }

      // Corner redirects (floor overlays)
      if (tile === '7') drawSprite('corner_ur', px, py - TILE_H * SCALE);
      if (tile === '8') drawSprite('corner_ul', px, py - TILE_H * SCALE);
      if (tile === '9') drawSprite('corner_dr', px, py - TILE_H * SCALE);
      if (tile === '0') drawSprite('corner_dl', px, py - TILE_H * SCALE);

      // Sticky (floor overlay, centered on grid)
      if (tile === 'T' || (tile === 'L' && renderState.unlockedWalls.has(`${x},${y}`))) {
        drawSprite('sticky_tile_16x12', px, py - TILE_H * SCALE);
      }

      // Goal rendered in objects pass for proper z-sorting

      // Keys - just draw shadow here, key sprite in objects pass for z-sorting
      if (tile === 'K') {
        const keyShadow = sprites['key_shadow'];
        if (keyShadow) {
          const shadowX = px + (TILE_W * SCALE - keyShadow.width * SCALE) / 2;
          const shadowY = py - TILE_H * SCALE;  // Half tile up from tile position
          ctx.drawImage(keyShadow, shadowX, shadowY, keyShadow.width * SCALE, keyShadow.height * SCALE);
        }
      }

      // Ramps rendered in objects pass (y-sorted with walls)
    }
  }

  // Second pass: draw holes on top of all floor tiles
  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      const tile = renderState.grid[y][x];
      if (tile === 'H' && !renderState.filledHoles.has(`${x},${y}`)) {
        const px = offsetX + x * TILE_W * SCALE;
        const py = offsetY + TOP_PADDING * SCALE + (y - 0.5) * TILE_H * SCALE;
        const holeSprite = sprites['ice_hole_16x12'];
        if (holeSprite) {
          ctx.drawImage(holeSprite, px, py - (TILE_H / 2) * SCALE, TILE_W * SCALE, TILE_H * SCALE);
        }
      }
    }
  }

  // Animation progress
  let animProgress = 0;
  if (animation) {
    const elapsed = now - animation.startTime;
    animProgress = Math.min(1, elapsed / animation.duration);
    // Ease out
    animProgress = 1 - Math.pow(1 - animProgress, 2);

    // Progressive trail drawing - add pixels as skater passes through
    if (animation.trail) {
      const t = animation.trail;
      const currentPixelIndex = Math.floor(animProgress * t.pixelDist);
      for (let i = t.lastDrawnIndex + 1; i < currentPixelIndex; i++) {
        const absX = t.startPixelX + t.pixelDirX * i;
        const absY = t.startPixelY + t.pixelDirY * i;
        const tileX = Math.floor(absX / 16);
        const tileY = Math.floor(absY / 12);
        const pixelX = ((absX % 16) + 16) % 16;  // Handle negative
        const pixelY = ((absY % 12) + 12) % 12;
        trailPoints.push({ tileX, tileY, pixelX, pixelY });
        // Keep trail max 100 pixels long
        if (trailPoints.length > 100) trailPoints.shift();
      }
      t.lastDrawnIndex = currentPixelIndex - 1;
    }

    if (elapsed >= animation.duration) {
      // Animation complete
      const targetState = animation.targetState;
      if (targetState.dead && !deathAnimation) {
        // Start death animation (falling into hole)
        deathAnimation = {
          startTime: now,
          duration: 600,  // 600ms fall animation
          x: targetState.playerX,
          y: targetState.playerY
        };
        // Keep gameState not-dead until death animation finishes
        gameState = { ...targetState, dead: false, newlyUnlocked: null, blockMoveInfo: null, rampMoveInfo: null };
      } else {
        gameState = { ...targetState, newlyUnlocked: null, blockMoveInfo: null, rampMoveInfo: null };
      }
      // Add any remaining trail pixels
      if (animation.trail) {
        const t = animation.trail;
        for (let i = t.lastDrawnIndex + 1; i < t.pixelDist; i++) {
          const absX = t.startPixelX + t.pixelDirX * i;
          const absY = t.startPixelY + t.pixelDirY * i;
          const tileX = Math.floor(absX / 16);
          const tileY = Math.floor(absY / 12);
          const pixelX = ((absX % 16) + 16) % 16;
          const pixelY = ((absY % 12) + 12) % 12;
          trailPoints.push({ tileX, tileY, pixelX, pixelY });
          if (trailPoints.length > 100) trailPoints.shift();
        }
      }
      animation = null;
      animating = false;
      animProgress = 1;
    }
  }

  // Death animation (falling into hole)
  let deathAnimProgress = 0;
  if (deathAnimation) {
    const elapsed = now - deathAnimation.startTime;
    deathAnimProgress = Math.min(1, elapsed / deathAnimation.duration);

    if (elapsed >= deathAnimation.duration) {
      // Death animation complete - now actually die
      gameState.dead = true;
      deathAnimation = null;
    }
  }

  // Player position first (needed for dynamic layering)
  let playerX, playerY, playerHeight;
  if (animation) {
    const p = animation.player;

    // Calculate player's progress (may end before full animation if pushing objects)
    const playerEndProg = animation.playerEndProgress || 1;
    let playerProgress;
    if (animProgress >= playerEndProg) {
      playerProgress = 1;  // Player has reached destination
    } else {
      playerProgress = playerEndProg > 0 ? animProgress / playerEndProg : 1;
    }

    // Use path waypoints if available (for corner animation)
    if (p.path && p.path.length > 1) {
      // Calculate segment distances
      const segments = [];
      let totalDist = 0;
      for (let i = 0; i < p.path.length - 1; i++) {
        const segDist = Math.abs(p.path[i+1].x - p.path[i].x) + Math.abs(p.path[i+1].y - p.path[i].y);
        segments.push({ start: p.path[i], end: p.path[i+1], dist: segDist, cumDist: totalDist });
        totalDist += segDist;
      }

      // Find current position along path
      const targetDist = playerProgress * totalDist;
      let currentSeg = segments[segments.length - 1];
      for (const seg of segments) {
        if (targetDist <= seg.cumDist + seg.dist) {
          currentSeg = seg;
          break;
        }
      }

      // Interpolate within segment
      const segProgress = currentSeg.dist > 0 ? (targetDist - currentSeg.cumDist) / currentSeg.dist : 0;
      playerX = currentSeg.start.x + (currentSeg.end.x - currentSeg.start.x) * Math.min(1, segProgress);
      playerY = currentSeg.start.y + (currentSeg.end.y - currentSeg.start.y) * Math.min(1, segProgress);
    } else {
      // Fallback to simple interpolation
      playerX = p.fromX + (p.toX - p.fromX) * playerProgress;
      playerY = p.fromY + (p.toY - p.fromY) * playerProgress;
    }

    // Calculate height based on ramp position (use playerProgress, not animProgress)
    if (p.wentUpRamp && p.rampX !== undefined) {
      const totalDist = Math.abs(p.toX - p.fromX) + Math.abs(p.toY - p.fromY);
      const distToRamp = Math.abs(p.rampX - p.fromX) + Math.abs(p.rampY - p.fromY);
      const rampProgressThreshold = distToRamp / totalDist;

      // Calculate drop point - after last elevated position (block/ramp)
      let dropDist = distToRamp + 1;  // Default: 1 tile after ramp
      if (p.lastElevatedX !== undefined) {
        dropDist = Math.abs(p.lastElevatedX - p.fromX) + Math.abs(p.lastElevatedY - p.fromY) + 1;
      }
      const dropProgressThreshold = dropDist / totalDist;

      // Before ramp: height 0, on ramp to drop point: height 1, after: final height
      if (playerProgress < rampProgressThreshold) {
        playerHeight = 0;
      } else if (playerProgress < dropProgressThreshold) {
        playerHeight = 1;
      } else {
        playerHeight = p.toHeight;
      }
    } else {
      playerHeight = p.fromHeight + (p.toHeight - p.fromHeight) * playerProgress;
    }
  } else {
    playerX = gameState.playerX;
    playerY = gameState.playerY;
    playerHeight = gameState.playerHeight;
  }

  // Simple y-sorting - everything together, no special cases
  const objects = [];

  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      const tile = level.grid[y][x];
      if (tile === '#') {
        // Border walls (test chamber) are double-tall
        const isBorder = (x === 0 || x === w - 1 || y === 0 || y === h - 1);
        if (isBorder) {
          objects.push({ type: 'wall', x, y, sortY: y, sprite: 'wall_color_16x24', doubleTall: true });
        } else {
          objects.push({ type: 'wall', x, y, sortY: y, sprite: 'wall_16x24' });
        }
      }
      if (tile === 'L') {
        const key = `${x},${y}`;
        const isUnlocked = renderState.unlockedWalls.has(key);
        const isNewlyUnlocked = animation && animation.targetState.newlyUnlocked?.includes(key);

        if (!isUnlocked) {
          // Still locked - show full keyhole wall
          objects.push({ type: 'wall', x, y, sortY: y, sprite: 'wall_keyhole_16x24' });
        } else if (isNewlyUnlocked && animation) {
          // Currently unlocking - show sink animation
          const sinkFrame = Math.min(6, Math.floor(animProgress * 6) + 1);
          objects.push({ type: 'wall', x, y, sortY: y, sprite: `wall_keyhole_sink_frame_${sinkFrame}` });
        }
        // else: fully unlocked, don't render wall (sticky floor shows instead)
      }
      // Ramps are rendered separately with animation support (see below)
      // Check grid directly for penguin (blocks can be on same tile)
      if (renderState.grid[y][x] === 'P') {
        // If penguin is on a wall, draw wall underneath and elevate penguin
        // Penguin on wall always draws on top; regular penguin only in front on win
        if (level.penguinOnWall) {
          objects.push({ type: 'wall', x, y, sortY: y, sprite: 'wall_16x24' });
          objects.push({ type: 'penguin', x, y, sortY: y + 0.02, elevated: true, sprite: 'goal_penguin_16' });
        } else {
          const penguinSortY = gameState.won ? y + 0.01 : y - 0.01;
          objects.push({ type: 'penguin', x, y, sortY: penguinSortY, sprite: 'goal_penguin_16' });
        }
      }
      // Keys from renderState (can be picked up)
      if (renderState.grid[y][x] === 'K') {
        objects.push({ type: 'key', x, y, sortY: y, sprite: 'key_frame_1' });
      }
    }
  }

  // Blocks
  const animatingBlockPositions = new Set();
  if (animation) {
    for (const block of animation.blocks) {
      let x, y;

      // Calculate block's own progress (delayed by startProgress)
      const startProg = block.startProgress || 0;
      let blockProgress;
      if (animProgress < startProg) {
        blockProgress = 0;  // Block hasn't started moving yet
      } else {
        blockProgress = (animProgress - startProg) / (1 - startProg);
      }
      blockProgress = Math.min(1, Math.max(0, blockProgress));

      // Use path waypoints if available (for corner animation)
      if (block.path && block.path.length > 1) {
        const segments = [];
        let totalDist = 0;
        for (let i = 0; i < block.path.length - 1; i++) {
          const segDist = Math.abs(block.path[i+1].x - block.path[i].x) + Math.abs(block.path[i+1].y - block.path[i].y);
          segments.push({ start: block.path[i], end: block.path[i+1], dist: segDist, cumDist: totalDist });
          totalDist += segDist;
        }
        const targetDist = blockProgress * totalDist;
        let currentSeg = segments[segments.length - 1];
        for (const seg of segments) {
          if (targetDist <= seg.cumDist + seg.dist) {
            currentSeg = seg;
            break;
          }
        }
        const segProgress = currentSeg.dist > 0 ? (targetDist - currentSeg.cumDist) / currentSeg.dist : 0;
        x = currentSeg.start.x + (currentSeg.end.x - currentSeg.start.x) * Math.min(1, segProgress);
        y = currentSeg.start.y + (currentSeg.end.y - currentSeg.start.y) * Math.min(1, segProgress);
      } else {
        x = block.fromX + (block.toX - block.fromX) * blockProgress;
        y = block.fromY + (block.toY - block.fromY) * blockProgress;
      }

      // Calculate block height based on ramp position (like player)
      let blockHeight = 0;
      if (block.wentUpRamp && block.rampX !== undefined) {
        const totalDist = Math.abs(block.toX - block.fromX) + Math.abs(block.toY - block.fromY);
        const distToRamp = Math.abs(block.rampX - block.fromX) + Math.abs(block.rampY - block.fromY);
        const rampProgress = totalDist > 0 ? distToRamp / totalDist : 0;

        // Calculate drop point - after last elevated position
        let dropDist = distToRamp + 1;  // Default: 1 tile after ramp
        if (block.lastElevatedX !== undefined) {
          dropDist = Math.abs(block.lastElevatedX - block.fromX) + Math.abs(block.lastElevatedY - block.fromY) + 1;
        }
        const dropProgress = totalDist > 0 ? dropDist / totalDist : 1;

        // Before ramp: height 0, ramp to drop: height 1, after drop: height 0
        if (animProgress < rampProgress) {
          blockHeight = 0;
        } else if (animProgress < dropProgress) {
          blockHeight = 1;
        } else {
          blockHeight = 0;
        }
      }

      objects.push({ type: 'block', x, y, sortY: y, height: blockHeight, sprite: 'ice_block_v3' });
      animatingBlockPositions.add(`${block.toX},${block.toY}`);
    }
  }

  for (const key of renderState.blocks) {
    if (!animatingBlockPositions.has(key)) {
      const [bx, by] = key.split(',').map(Number);
      objects.push({ type: 'block', x: bx, y: by, sortY: by, height: 0, sprite: 'ice_block_v3' });
    }
  }

  // Animated ramps
  const animatingRampPositions = new Set();
  if (animation && animation.ramps) {
    for (const ramp of animation.ramps) {
      let x, y;

      // Calculate ramp's own progress (delayed by startProgress)
      const startProg = ramp.startProgress || 0;
      let rampProgress;
      if (animProgress < startProg) {
        rampProgress = 0;  // Ramp hasn't started moving yet
      } else {
        rampProgress = (animProgress - startProg) / (1 - startProg);
      }
      rampProgress = Math.min(1, Math.max(0, rampProgress));

      // Use path waypoints if available (for corner animation)
      if (ramp.path && ramp.path.length > 1) {
        const segments = [];
        let totalDist = 0;
        for (let i = 0; i < ramp.path.length - 1; i++) {
          const segDist = Math.abs(ramp.path[i+1].x - ramp.path[i].x) + Math.abs(ramp.path[i+1].y - ramp.path[i].y);
          segments.push({ start: ramp.path[i], end: ramp.path[i+1], dist: segDist, cumDist: totalDist });
          totalDist += segDist;
        }
        const targetDist = rampProgress * totalDist;
        let currentSeg = segments[segments.length - 1];
        for (const seg of segments) {
          if (targetDist <= seg.cumDist + seg.dist) {
            currentSeg = seg;
            break;
          }
        }
        const segProgress = currentSeg.dist > 0 ? (targetDist - currentSeg.cumDist) / currentSeg.dist : 0;
        x = currentSeg.start.x + (currentSeg.end.x - currentSeg.start.x) * Math.min(1, segProgress);
        y = currentSeg.start.y + (currentSeg.end.y - currentSeg.start.y) * Math.min(1, segProgress);
      } else {
        x = ramp.fromX + (ramp.toX - ramp.fromX) * rampProgress;
        y = ramp.fromY + (ramp.toY - ramp.fromY) * rampProgress;
      }

      // Choose sprite based on ramp type
      let sprite = 'ramp_north_16x24';
      if (ramp.rampType === 'v') sprite = 'ramp_south_16x24';
      if (ramp.rampType === '<') sprite = 'ramp_west_16x24';
      if (ramp.rampType === '>') sprite = 'ramp_east_16x24';

      // If ramp fell into hole, fade out
      if (!ramp.fell) {
        objects.push({ type: 'ramp', x, y, sortY: y, sprite });
      }
      animatingRampPositions.add(`${ramp.toX},${ramp.toY}`);
    }
  }

  // Non-animating ramps (skip positions being animated)
  for (const [key, rampType] of renderState.ramps) {
    if (!animatingRampPositions.has(key)) {
      const [rx, ry] = key.split(',').map(Number);
      let sprite = 'ramp_north_16x24';
      if (rampType === 'v') sprite = 'ramp_south_16x24';
      if (rampType === '<') sprite = 'ramp_west_16x24';
      if (rampType === '>') sprite = 'ramp_east_16x24';
      objects.push({ type: 'ramp', x: rx, y: ry, sortY: ry, sprite });
    }
  }

  // Player (or death animation)
  const playerDir = renderState.playerDir;
  let playerSpriteName;
  let effectivePlayerX = playerX;
  let effectivePlayerY = playerY;

  if (deathAnimation) {
    // During death animation, shrink standing sprite into skates
    effectivePlayerX = deathAnimation.x;
    effectivePlayerY = deathAnimation.y;
    // Use standing sprite based on direction player was facing
    playerSpriteName = playerDir === 'up' ? 'skater_back_standing_16x24' : 'skater_front_standing_16x24';
  } else {
    const isMoving = animation !== null;
    playerSpriteName = getPlayerSprite(playerDir, false, isMoving);  // No sad sprite hint
  }

  objects.push({
    type: 'player',
    x: effectivePlayerX,
    y: effectivePlayerY,
    sortY: effectivePlayerY,
    sortPriority: 0,  // Player draws before penguin on same tile
    height: deathAnimation ? 0 : playerHeight,
    sprite: playerSpriteName
  });

  // Sort by Y, then X, then priority (penguin in front of player on same tile)
  objects.sort((a, b) => a.sortY - b.sortY || a.x - b.x || (a.sortPriority || 0) - (b.sortPriority || 0));

  // Find player
  const playerObj = objects.find(o => o.type === 'player');
  const playerPx = offsetX + playerObj.x * TILE_W * SCALE;
  const playerPy = offsetY + TOP_PADDING * SCALE + playerObj.y * TILE_H * SCALE;
  const playerSprite = sprites[playerObj.sprite];
  let playerSpriteY = playerPy - playerSprite.height * SCALE - (TILE_H / 2) * SCALE;
  if (playerObj.height > 0) {
    playerSpriteY -= playerObj.height * 10 * SCALE;
  }

  // Draw player shadow (on ground, not affected by elevation)
  if (!deathAnimation || deathAnimProgress < 0.8) {  // Fade shadow during fall
    const skaterShadow = sprites['skater_shadow'];
    if (skaterShadow) {
      const shadowX = playerPx + (TILE_W * SCALE - skaterShadow.width * SCALE) / 2;
      const shadowY = playerPy - TILE_H * SCALE;  // Half tile up
      const shadowAlpha = deathAnimation ? (1 - deathAnimProgress) : 1;
      ctx.globalAlpha = shadowAlpha * 0.7;
      ctx.drawImage(skaterShadow, shadowX, shadowY, skaterShadow.width * SCALE, skaterShadow.height * SCALE);
      ctx.globalAlpha = 1;
    }
  }

  // FIRST: Calculate transparency for each object (recalculated every frame)
  const transparentObjects = [];
  const opaqueObjects = [];

  for (const obj of objects) {
    if (obj.type === 'player') continue;

    // Check if something important is behind this object (1 tile behind only)
    let makeTransparent = false;
    if (obj.type === 'wall' || obj.type === 'block') {
      const checkY = Math.floor(obj.y) - 1;
      if (checkY >= 0) {
        const checkTile = renderState.grid[checkY]?.[Math.floor(obj.x)];
        const levelTile = level.grid[checkY]?.[Math.floor(obj.x)];
        if (checkTile === 'K' || checkTile === 'H' || (checkTile >= '1' && checkTile <= '4') ||
            checkTile === '7' || checkTile === '8' || checkTile === '9' || checkTile === '0') {
          makeTransparent = true;
        }
        if (levelTile === 'L' || levelTile === 'T' || levelTile === 'P') {
          makeTransparent = true;
        }
        // Check for blocks behind
        if (renderState.blocks.has(`${Math.floor(obj.x)},${checkY}`)) {
          makeTransparent = true;
        }
      }

      // Check if player is 1 tile behind this object
      const playerTileX = Math.floor(playerObj.x);
      const playerTileY = Math.floor(playerObj.y);
      const objTileX = Math.floor(obj.x);
      const objTileY = Math.floor(obj.y);
      if (playerTileX === objTileX && playerTileY === objTileY - 1) {
        makeTransparent = true;
      }
    }
    // Front walls only transparent if something important is DIRECTLY behind (1 tile up)
    if (obj.type === 'wall' && obj.y === h - 1 && obj.x > 0 && obj.x < w - 1) {
      const behindY = Math.floor(obj.y) - 1;
      const behindX = Math.floor(obj.x);
      if (behindY >= 0) {
        // Check if player is directly behind
        const playerTileX = Math.floor(playerObj.x);
        const playerTileY = Math.floor(playerObj.y);
        if (playerTileX === behindX && playerTileY === behindY) {
          makeTransparent = true;
        }
        // Check for important tiles directly behind
        const checkTile = renderState.grid[behindY]?.[behindX];
        const levelTile = level.grid[behindY]?.[behindX];
        if (checkTile === 'K' || checkTile === 'H' || (checkTile >= '1' && checkTile <= '4') ||
            checkTile === '7' || checkTile === '8' || checkTile === '9' || checkTile === '0') {
          makeTransparent = true;
        }
        if (levelTile === 'L' || levelTile === 'T' || levelTile === 'P') {
          makeTransparent = true;
        }
        // Check for blocks directly behind
        if (renderState.blocks.has(`${behindX},${behindY}`)) {
          makeTransparent = true;
        }
      }
    }
    // Penguin draws after player when won (so penguin is in front)
    if (obj.type === 'penguin' && gameState.won) {
      makeTransparent = true;
    }

    obj.transparent = makeTransparent;
    if (makeTransparent) {
      transparentObjects.push(obj);
    } else {
      opaqueObjects.push(obj);
    }
  }

  // Helper function to draw an object
  function drawObject(obj) {
    const px = offsetX + obj.x * TILE_W * SCALE;
    const py = offsetY + TOP_PADDING * SCALE + obj.y * TILE_H * SCALE;
    const sprite = sprites[obj.sprite];

    if (sprite) {
      let spriteY = py - sprite.height * SCALE;

      // Draw shadows and position sprites by type
      if (obj.type === 'penguin') {
        const shadow = sprites['penguin_shadow'];
        if (shadow) {
          const shadowX = px + (TILE_W * SCALE - shadow.width * SCALE) / 2;
          const shadowY = py - TILE_H * SCALE;
          ctx.globalAlpha = 0.5;
          ctx.drawImage(shadow, shadowX, shadowY, shadow.width * SCALE, shadow.height * SCALE);
          ctx.globalAlpha = 1;
        }
        spriteY = py - TILE_H * 1.5 * SCALE;
        // Elevate penguin if on a wall
        if (obj.elevated) {
          spriteY -= TILE_H * SCALE;  // Full tile up
        }
        // Bounce animation when won
        if (gameState.won) {
          const bounce = Math.abs(Math.sin(now / 150)) * 8 * SCALE;
          spriteY -= bounce;
        }
      } else if (obj.type === 'block') {
        const shadow = sprites['block_shadow'];
        if (shadow) {
          const shadowX = px + (TILE_W * SCALE - shadow.width * SCALE) / 2;
          const shadowY = py - TILE_H * SCALE;
          ctx.globalAlpha = 0.4;
          ctx.drawImage(shadow, shadowX, shadowY, shadow.width * SCALE, shadow.height * SCALE);
          ctx.globalAlpha = 1;
        }
        // Apply height offset for elevated blocks (like player)
        if (obj.height > 0) {
          spriteY -= obj.height * 10 * SCALE;
        }
      } else if (obj.type === 'key') {
        spriteY = py - (TILE_H / 2) * SCALE - sprite.height * SCALE;
      }

      // Transparency only for test chamber walls (border walls)
      if (obj.transparent && obj.sprite === 'wall_color_16x24') {
        ctx.globalAlpha = 0.65;
      }

      ctx.drawImage(sprite, px, spriteY, sprite.width * SCALE, sprite.height * SCALE);
      ctx.globalAlpha = 1.0;
    }
  }

  // Draw all non-player objects in sort order, with player inserted at correct position
  const allObjects = [...opaqueObjects, ...transparentObjects].sort((a, b) =>
    a.sortY - b.sortY || a.x - b.x
  );

  // Calculate player draw parameters
  const shrinkScale = deathAnimation ? (1 - deathAnimProgress) : 1;
  const drawnWidth = playerSprite.width * SCALE * shrinkScale;
  const drawnHeight = playerSprite.height * SCALE * shrinkScale;
  const shrinkPlayerY = playerSpriteY + (playerSprite.height * SCALE - drawnHeight);
  const shrinkPlayerX = playerPx + (playerSprite.width * SCALE - drawnWidth) / 2;

  let playerDrawn = false;

  function drawPlayer() {
    if (playerDrawn || gameState.dead) return;
    playerDrawn = true;

    if (shrinkScale > 0.01) {
      ctx.drawImage(playerSprite, shrinkPlayerX, shrinkPlayerY, drawnWidth, drawnHeight);
    }
  }

  // Draw objects in sort order, inserting player at correct position
  for (const obj of allObjects) {
    // Draw player before objects that are in front of her (higher sortY)
    if (!playerDrawn && obj.sortY > playerObj.sortY) {
      drawPlayer();
    }
    drawObject(obj);
  }
  // Draw player if not yet drawn (player is in front of everything)
  drawPlayer();

  if (gameState.won) {
    // Mark level complete and start judge scoring (only once per win)
    if (!gameState.completionSaved) {
      markLevelComplete(currentLevelIndex);
      gameState.completionSaved = true;

      // Calculate completion time and start judge scoring
      const moves = history.length;
      const par = level.par || 12;
      const completionTimeMs = performance.now() - levelStartTime;

      // Track completion for analytics
      trackCompletion(currentLevelIndex, moves, completionTimeMs);

      calculateJudgeScores(moves, par, currentLevelIndex, completionTimeMs).then(result => {
        judgeState = {
          scores: result.scores,
          isRecord: result.isRecord,
          globalBest: result.globalBest,
          completionTime: completionTimeMs,
          revealed: 0,
          startTime: performance.now()
        };
      });
    }

    // Draw overlay
    ctx.fillStyle = 'rgba(29, 43, 48, 0.85)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw judge scoring animation
    if (judgeState) {
      const elapsed = performance.now() - judgeState.startTime;

      // Timing: 800ms delay, then 400ms flip + 600ms pause for each judge
      // Judge 1: 800-1200ms flip, 1200-1800ms visible
      // Judge 2: 1800-2200ms flip, 2200-2800ms visible
      // Judge 3: 2800-3200ms flip, 3200+ visible

      // Size cards to fit screen width with buffer
      const maxCardW = Math.min(canvas.width / 5, 40 * SCALE);  // Max 1/5 screen width
      const cardW = maxCardW;
      const cardH = cardW * 1.2;
      const spacing = cardW * 1.4;  // Cards with comfortable gap
      const baseY = canvas.height / 2 - 10 * SCALE;

      // Game palette colors
      const colors = ['#68BBC4', '#68BBC4', '#68BBC4'];  // All same cyan
      const bgColor = '#2A474F';  // Dark teal background

      // Labels for each judge
      const labels = ['FINISH', 'PAR', 'SPEED'];
      const currentPar = allLevels[currentLevelIndex]?.par || 12;
      const userMoves = history.length;
      const parText = `${userMoves} / ${currentPar}`;
      // Format times as seconds with 1 decimal
      const userTimeStr = (judgeState.completionTime / 1000).toFixed(1) + 's';
      const recordTimeStr = judgeState.globalBest ? (judgeState.globalBest / 1000).toFixed(1) + 's' : null;
      const speedText = recordTimeStr ? `${userTimeStr} / ${recordTimeStr}` : `${userTimeStr} - first!`;
      const descriptions = ['completed!', parText, speedText];

      for (let i = 0; i < 3; i++) {
        const flipStart = 800 + i * 1000;  // 800, 1800, 2800
        const flipEnd = flipStart + 400;

        let flipProgress = 0;
        if (elapsed >= flipEnd) {
          flipProgress = 1;
          if (judgeState.revealed < i + 1) judgeState.revealed = i + 1;
        } else if (elapsed >= flipStart) {
          flipProgress = (elapsed - flipStart) / 400;
        }

        const x = canvas.width / 2 + (i - 1) * spacing;
        drawScoreCard(ctx, judgeState.scores[i], x, baseY, cardW, cardH, flipProgress, colors[i], bgColor);

        // Draw label above card (only when card is revealed)
        if (flipProgress > 0.5) {
          ctx.fillStyle = '#40ACBF';
          ctx.font = `bold ${6 * SCALE}px sans-serif`;
          ctx.textAlign = 'center';
          ctx.fillText(labels[i], x, baseY - cardH / 2 - 8 * SCALE);

          // Description below card
          ctx.fillStyle = '#3B8897';
          ctx.font = `${5 * SCALE}px sans-serif`;
          ctx.fillText(descriptions[i], x, baseY + cardH / 2 + 10 * SCALE);
        }
      }

      // Show total after all revealed
      if (judgeState.revealed >= 3) {
        const total = judgeState.scores.reduce((a, b) => a + b, 0);
        const textY = baseY + cardH / 2 + 25 * SCALE;

        ctx.fillStyle = '#68BBC4';
        ctx.font = `bold ${14 * SCALE}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.fillText(`Total: ${total}/30`, canvas.width / 2, textY);

        // Show world record indicator
        if (judgeState.isRecord) {
          ctx.fillStyle = '#40ACBF';
          ctx.font = `bold ${10 * SCALE}px sans-serif`;
          ctx.fillText('NEW WORLD RECORD!', canvas.width / 2, textY + 18 * SCALE);
        }

        ctx.fillStyle = '#68BBC4';
        ctx.font = `${10 * SCALE}px sans-serif`;
        const continueY = judgeState.isRecord ? textY + 38 * SCALE : textY + 22 * SCALE;
        ctx.fillText('Tap to continue', canvas.width / 2, continueY);
      }
    } else {
      // Fallback while calculating scores
      ctx.fillStyle = '#68BBC4';
      ctx.font = `${16 * SCALE}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.fillText('Calculating scores...', canvas.width / 2, canvas.height / 2);
    }
  }

  // Draw hint arrow on player
  if (hintArrow && !gameState.won && !gameState.dead) {
    const elapsed = performance.now() - hintShowTime;
    if (elapsed < HINT_DISPLAY_MS) {
      // Position: center of tile, half tile higher
      const ax = offsetX + playerObj.x * TILE_W * SCALE + 8 * SCALE;
      const ay = offsetY + (TOP_PADDING + playerObj.y * TILE_H) * SCALE + 8 * SCALE - (TILE_H / 2) * SCALE;

      // Draw arrow with tail
      ctx.fillStyle = '#40ACBF';
      ctx.strokeStyle = '#40ACBF';
      ctx.lineWidth = 3 * SCALE;
      ctx.lineCap = 'round';

      const headSize = 6 * SCALE;
      const tailLen = 10 * SCALE;

      ctx.beginPath();
      if (hintArrow === 'up') {
        // Tail
        ctx.moveTo(ax, ay + headSize + tailLen);
        ctx.lineTo(ax, ay + headSize);
        ctx.stroke();
        // Head
        ctx.beginPath();
        ctx.moveTo(ax, ay);
        ctx.lineTo(ax - headSize, ay + headSize);
        ctx.lineTo(ax + headSize, ay + headSize);
        ctx.closePath();
        ctx.fill();
      } else if (hintArrow === 'down') {
        ctx.moveTo(ax, ay - headSize - tailLen);
        ctx.lineTo(ax, ay - headSize);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(ax, ay);
        ctx.lineTo(ax - headSize, ay - headSize);
        ctx.lineTo(ax + headSize, ay - headSize);
        ctx.closePath();
        ctx.fill();
      } else if (hintArrow === 'left') {
        ctx.moveTo(ax + headSize + tailLen, ay);
        ctx.lineTo(ax + headSize, ay);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(ax, ay);
        ctx.lineTo(ax + headSize, ay - headSize);
        ctx.lineTo(ax + headSize, ay + headSize);
        ctx.closePath();
        ctx.fill();
      } else if (hintArrow === 'right') {
        ctx.moveTo(ax - headSize - tailLen, ay);
        ctx.lineTo(ax - headSize, ay);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(ax, ay);
        ctx.lineTo(ax - headSize, ay - headSize);
        ctx.lineTo(ax - headSize, ay + headSize);
        ctx.closePath();
        ctx.fill();
      }
    } else {
      hintArrow = null;  // Clear after timeout
    }
  }

  // Draw START OVER text when unwinnable
  if (isUnwinnable && !gameState.won && !gameState.dead && settings.showUnwinnable) {
    ctx.fillStyle = '#696d75';
    ctx.font = `bold ${10 * SCALE}px monospace`;
    ctx.textAlign = 'center';
    ctx.fillText('START OVER', canvas.width / 2, 20 * SCALE);
  }

  // Draw tutorial text (show for first 2 moves only)
  if (tutorialText && history.length < 2 && !gameState.won && !gameState.dead) {
    ctx.fillStyle = '#68BBC4';  // Teal color matching game theme
    ctx.font = `bold 14px monospace`;  // Fixed size, not scaled
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText(tutorialText.toUpperCase(), canvas.width / 2, 8);
  }

  // Snow animation
  ctx.fillStyle = '#CFDFE2';  // Light color
  for (const flake of snowflakes) {
    // Update position
    flake.y += flake.speed * SCALE;
    flake.x += Math.sin(now / 1000 + flake.sway) * 0.3 * SCALE;  // Gentle sway

    // Reset when falls off screen
    if (flake.y > canvas.height) {
      flake.y = -flake.size * SCALE;
      flake.x = Math.random() * canvas.width;
    }
    // Wrap horizontally
    if (flake.x < 0) flake.x = canvas.width;
    if (flake.x > canvas.width) flake.x = 0;

    // Draw pixel-aligned
    ctx.fillRect(Math.floor(flake.x), Math.floor(flake.y), flake.size * SCALE, flake.size * SCALE);
  }

  requestAnimationFrame(render);
}

function drawSprite(name, x, y) {
  const sprite = sprites[name];
  if (sprite) {
    ctx.drawImage(sprite, x, y, sprite.width * SCALE, sprite.height * SCALE);
  }
}

function getPlayerSprite(dir, sad = false, isMoving = false) {
  if (sad) {
    switch (dir) {
      case 'up': return 'skater_back_standing_16x24';  // can't see face from back
      case 'down': return 'skater_front_sad_16x24';
      case 'left': return 'skater_side_standing_sad_16x24';
      case 'right': return 'skater_side_left_standing_sad_16x24';
      default: return 'skater_front_sad_16x24';
    }
  }
  // Use skating vs standing sprites for all directions based on movement
  switch (dir) {
    case 'up': return isMoving ? 'skater_back_skating_16x24' : 'skater_back_standing_16x24';
    case 'down': return isMoving ? 'skater_front_skating_16x24' : 'skater_front_standing_16x24';
    case 'left': return isMoving ? 'skater_side_skating_16x24' : 'skater_side_standing_16x24';
    case 'right': return isMoving ? 'skater_side_left_skating_16x24' : 'skater_side_left_standing_16x24';
    default: return isMoving ? 'skater_front_skating_16x24' : 'skater_front_standing_16x24';
  }
}

function handleInput(dir) {
  if (animating || deathAnimation || gameState.won || gameState.dead) return;

  // Clear hint arrow on any move
  hintArrow = null;
  isUnwinnable = false;

  const oldState = gameState;
  let newState = simulateMove(gameState, dir);

  // Handle player being pushed by block/ramp
  if (newState && newState.playerPushedBy) {
    const push = newState.playerPushedBy;
    // Slide player from their position in push direction
    let px = newState.playerX + push.dx;
    let py = newState.playerY + push.dy;
    for (let i = 0; i < 50; i++) {
      const tile = getTile(newState, px, py);
      const baseTile = getBaseTile(newState, px, py);
      // Stop at walls, blocks, locked walls
      if (tile === '#' || tile === 'B' ||
          (tile === 'L' && !newState.unlockedWalls.has(`${px},${py}`))) {
        px -= push.dx;
        py -= push.dy;
        break;
      }
      // Stop at ramps (can't go up when pushed)
      if (isRamp(baseTile)) {
        px -= push.dx;
        py -= push.dy;
        break;
      }
      // Corner redirect
      if (isCorner(baseTile)) {
        const redirect = getCornerRedirect(baseTile, push.dx, push.dy);
        if (redirect) {
          push.dx = redirect.dx;
          push.dy = redirect.dy;
        }
      }
      px += push.dx;
      py += push.dy;
    }
    newState.playerX = px;
    newState.playerY = py;
    delete newState.playerPushedBy;
  }

  if (newState) {
    // Save for undo - convert Sets/Maps to arrays for JSON serialization
    const historyEntry = {
      ...oldState,
      blocks: [...oldState.blocks],
      unlockedWalls: [...oldState.unlockedWalls],
      filledHoles: [...oldState.filledHoles],
      ramps: [...oldState.ramps.entries()]
    };
    history.push(JSON.parse(JSON.stringify(historyEntry)));
    updateMoveCount();

    // Calculate animation distance
    const dx = newState.playerX - oldState.playerX;
    const dy = newState.playerY - oldState.playerY;
    const playerDist = Math.abs(dx) + Math.abs(dy);

    if (playerDist > 0) {
      // Find moved blocks - use blockMoveInfo if available
      const movedBlocks = [];
      let maxObjectDist = 0;  // Track longest object movement for animation timing
      let playerDistToCollision = playerDist;  // Default: player travels full distance

      if (newState.blockMoveInfo) {
        const info = newState.blockMoveInfo;
        // Calculate when player hit the block (for animation delay)
        // Player was at oldState position, block was at info.fromX, info.fromY
        // Player hit block one tile before it, so collision at (fromX - dir, fromY - dir)
        const playerDir = {
          dx: newState.playerX === oldState.playerX ? 0 : (newState.playerX > oldState.playerX ? 1 : -1),
          dy: newState.playerY === oldState.playerY ? 0 : (newState.playerY > oldState.playerY ? 1 : -1)
        };
        const collisionX = info.fromX - playerDir.dx;
        const collisionY = info.fromY - playerDir.dy;
        playerDistToCollision = Math.abs(collisionX - oldState.playerX) + Math.abs(collisionY - oldState.playerY);
        const blockDist = Math.abs(info.toX - info.fromX) + Math.abs(info.toY - info.fromY);
        maxObjectDist = Math.max(maxObjectDist, blockDist);
        const totalAnimDist = playerDistToCollision + blockDist;
        const startProgress = totalAnimDist > 0 ? playerDistToCollision / totalAnimDist : 0;

        movedBlocks.push({
          fromX: info.fromX,
          fromY: info.fromY,
          toX: info.toX,
          toY: info.toY,
          wentUpRamp: info.wentUpRamp,
          rampX: info.rampX,
          rampY: info.rampY,
          lastElevatedX: info.lastElevatedX,
          lastElevatedY: info.lastElevatedY,
          path: info.path,  // Path for corner animation
          startProgress  // When in animation this block starts moving (0-1)
        });
      } else {
        // Fallback: detect moved blocks from position changes
        const oldBlocks = new Map();
        for (const key of oldState.blocks) {
          const [x, y] = key.split(',').map(Number);
          oldBlocks.set(key, { x, y });
        }
        for (const key of newState.blocks) {
          const [x, y] = key.split(',').map(Number);
          for (const [oldKey, oldPos] of oldBlocks) {
            if (!newState.blocks.has(oldKey) && !movedBlocks.some(b => b.fromX === oldPos.x && b.fromY === oldPos.y)) {
              movedBlocks.push({ fromX: oldPos.x, fromY: oldPos.y, toX: x, toY: y });
              break;
            }
          }
        }
      }

      // Find moved ramps - use rampMoveInfo if available
      const movedRamps = [];
      if (newState.rampMoveInfo) {
        const info = newState.rampMoveInfo;
        // Calculate startProgress similar to blocks
        const playerDir = {
          dx: newState.playerX === oldState.playerX ? 0 : (newState.playerX > oldState.playerX ? 1 : -1),
          dy: newState.playerY === oldState.playerY ? 0 : (newState.playerY > oldState.playerY ? 1 : -1)
        };
        const collisionX = info.fromX - playerDir.dx;
        const collisionY = info.fromY - playerDir.dy;
        const rampPlayerDist = Math.abs(collisionX - oldState.playerX) + Math.abs(collisionY - oldState.playerY);
        playerDistToCollision = Math.min(playerDistToCollision, rampPlayerDist);  // Use closest collision
        const rampDist = Math.abs(info.toX - info.fromX) + Math.abs(info.toY - info.fromY);
        maxObjectDist = Math.max(maxObjectDist, rampDist);
        const totalAnimDist = rampPlayerDist + rampDist;
        const startProgress = totalAnimDist > 0 ? rampPlayerDist / totalAnimDist : 0;

        movedRamps.push({
          fromX: info.fromX,
          fromY: info.fromY,
          toX: info.toX,
          toY: info.toY,
          rampType: info.rampType,
          wentUpRamp: info.wentUpRamp,
          elevationRampX: info.elevationRampX,
          elevationRampY: info.elevationRampY,
          path: info.path,
          fell: info.fell,
          startProgress
        });
      }

      // Trail info for progressive drawing during animation
      const bladeOffsetX = 8;
      const bladeOffsetY = -6;
      const trailInfo = {
        startPixelX: oldState.playerX * 16 + bladeOffsetX,
        startPixelY: oldState.playerY * 12 + bladeOffsetY,
        endPixelX: newState.playerX * 16 + bladeOffsetX,
        endPixelY: newState.playerY * 12 + bladeOffsetY,
        lastDrawnIndex: -1
      };
      trailInfo.pixelDist = Math.abs(trailInfo.endPixelX - trailInfo.startPixelX) + Math.abs(trailInfo.endPixelY - trailInfo.startPixelY);
      trailInfo.pixelDirX = trailInfo.endPixelX === trailInfo.startPixelX ? 0 : (trailInfo.endPixelX - trailInfo.startPixelX) / Math.abs(trailInfo.endPixelX - trailInfo.startPixelX);
      trailInfo.pixelDirY = trailInfo.endPixelY === trailInfo.startPixelY ? 0 : (trailInfo.endPixelY - trailInfo.startPixelY) / Math.abs(trailInfo.endPixelY - trailInfo.startPixelY);

      // Start animation
      // Total animation distance includes object movement so timing syncs correctly
      const totalAnimDist = maxObjectDist > 0 ? (playerDistToCollision + maxObjectDist) : playerDist;
      const playerEndProgress = totalAnimDist > 0 ? playerDist / totalAnimDist : 1;

      animating = true;
      animation = {
        startTime: performance.now(),
        duration: (totalAnimDist / ANIM_SPEED) * 1000,
        playerEndProgress,  // When player stops moving (0-1)
        player: {
          fromX: oldState.playerX,
          fromY: oldState.playerY,
          toX: newState.playerX,
          toY: newState.playerY,
          fromHeight: oldState.playerHeight,
          toHeight: newState.playerHeight,
          wentUpRamp: newState.wentUpRamp,
          rampX: newState.rampX,
          rampY: newState.rampY,
          lastElevatedX: newState.lastElevatedX,
          lastElevatedY: newState.lastElevatedY,
          path: newState.path || []  // Waypoints for corner animation
        },
        blocks: movedBlocks,
        ramps: movedRamps,
        targetState: newState,
        trail: trailInfo
      };
      console.log('Animation height:', oldState.playerHeight, '->', newState.playerHeight);
      console.log('Animation pos:', oldState.playerX+','+oldState.playerY, '->', newState.playerX+','+newState.playerY);
      console.log('Animation targetState.keys:', newState.keys);
      // Debug: check if key was picked up in this move
      for (let gy = 0; gy < newState.height; gy++) {
        for (let gx = 0; gx < newState.width; gx++) {
          if (newState.grid[gy][gx] === 'K') {
            console.log(`Key still in targetState.grid at (${gx},${gy})`);
          }
        }
      }
    } else if (newState.newlyUnlocked && newState.newlyUnlocked.length > 0) {
      // No movement but wall was unlocked - create short animation for sink effect
      animating = true;
      animation = {
        startTime: performance.now(),
        duration: 300,  // Short animation for wall sink
        player: {
          fromX: oldState.playerX,
          fromY: oldState.playerY,
          toX: newState.playerX,
          toY: newState.playerY,
          fromHeight: oldState.playerHeight,
          toHeight: newState.playerHeight
        },
        blocks: [],
        targetState: newState
      };
    } else {
      gameState = newState;
    }
    updateStatus();
  }
}

function restartLevel() {
  animation = null;
  animating = false;
  deathAnimation = null;
  gameState = initGameState(level);
  history = [];
  // trailPoints persists - players see their shame
  isUnwinnable = false;
  document.getElementById('status').textContent = '';
}

document.addEventListener('keydown', e => {
  // Advance when won (only after all judges revealed)
  if (gameState.won && (e.key === 'Enter' || e.key === ' ')) {
    if (judgeState && judgeState.revealed >= 3) {
      judgeState = null;  // Reset for next level
      nextLevel();
    }
    return;
  }
  switch (e.key) {
    case 'ArrowUp': case 'w': handleInput('up'); break;
    case 'ArrowDown': case 's': handleInput('down'); break;
    case 'ArrowLeft': case 'a': handleInput('left'); break;
    case 'ArrowRight': case 'd': handleInput('right'); break;
  }
});

let touchStart = null;
canvas.addEventListener('touchstart', e => {
  touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
});

// Click to advance on desktop (only after all judges revealed)
canvas.addEventListener('click', () => {
  if (gameState.won && judgeState && judgeState.revealed >= 3) {
    judgeState = null;
    nextLevel();
  }
});
canvas.addEventListener('touchend', e => {
  if (!touchStart) return;
  const dx = e.changedTouches[0].clientX - touchStart.x;
  const dy = e.changedTouches[0].clientY - touchStart.y;

  // Tap to advance when won (only after all judges revealed)
  if (Math.abs(dx) < 30 && Math.abs(dy) < 30) {
    if (gameState.won && judgeState && judgeState.revealed >= 3) {
      judgeState = null;
      nextLevel();
      touchStart = null;
      return;
    }
  }

  if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 30) {
    handleInput(dx > 0 ? 'right' : 'left');
  } else if (Math.abs(dy) > 30) {
    handleInput(dy > 0 ? 'down' : 'up');
  }
  touchStart = null;
});

document.getElementById('restart-btn').onclick = restartLevel;

function undo() {
  // Clear any animations
  animation = null;
  animating = false;
  deathAnimation = null;

  if (history.length > 0) {
    const prev = history.pop();
    gameState = {
      ...prev,
      blocks: new Set(prev.blocks),
      unlockedWalls: new Set(prev.unlockedWalls),
      filledHoles: new Set(prev.filledHoles),
      ramps: new Map(prev.ramps),
      dead: false  // Ensure not dead after undo
    };
    isUnwinnable = false;
    document.getElementById('status').textContent = '';
    document.getElementById('sidebar-status').textContent = '';
    updateMoveCount();
    updateStatus();
  }
}

document.getElementById('undo-btn').onclick = undo;

function showHint() {
  if (!settings.hintsEnabled) return;  // Hints disabled
  const hint = getHint();
  if (hint) {
    // Show arrow on canvas
    hintArrow = hint;
    hintShowTime = performance.now();
    isUnwinnable = false;
  } else if (!gameState.won) {
    // No solution - show START OVER if setting enabled
    hintArrow = null;
    if (settings.showUnwinnable) {
      isUnwinnable = true;
    }
  }
}

document.getElementById('hint-btn').onclick = showHint;

function updateStatus() {
  // Winnability check removed - let players figure it out themselves
  const status = document.getElementById('status');
  status.textContent = '';
}

let allLevels = [];
let currentLevelIndex = 0;

// Chunked level loading
let levelIndex = null;  // Chunk index metadata
let loadedChunks = {};  // Cache of loaded chunks
let totalLevels = 0;

async function ensureChunkLoaded(levelIdx) {
  if (!levelIndex) return false;
  const chunkSize = levelIndex.chunk_size;
  const chunkId = Math.floor(levelIdx / chunkSize);

  if (loadedChunks[chunkId]) return true;

  const chunk = levelIndex.chunks.find(c => c.id === chunkId);
  if (!chunk) return false;

  try {
    console.log(`Loading chunk ${chunkId}...`);
    const response = await fetch(`level_chunks/${chunk.file}?v=${Date.now()}`);
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    const data = await response.json();

    // Store levels in allLevels array at correct positions
    data.levels.forEach((lv, i) => {
      allLevels[chunk.start + i] = lv;
    });

    loadedChunks[chunkId] = true;
    console.log(`Loaded chunk ${chunkId}: levels ${chunk.start}-${chunk.end - 1}`);
    return true;
  } catch (e) {
    console.error(`Failed to load chunk ${chunkId}:`, e);
    return false;
  }
}

async function loadLevel(index) {
  if (index < 0 || index >= totalLevels) return;

  // Ensure chunk is loaded
  if (levelIndex && !allLevels[index]) {
    const loaded = await ensureChunkLoaded(index);
    if (!loaded) {
      console.error(`Could not load level ${index}`);
      return;
    }
  }

  currentLevelIndex = index;
  const lv = allLevels[index];
  if (!lv) {
    console.error(`Level ${index} not available`);
    return;
  }
  level = {
    width: lv.width,
    height: lv.height,
    grid: lv.grid.map(row => row.split('')),
    penguinOnWall: lv.penguinOnWall || false
  };
  animation = null;
  animating = false;
  deathAnimation = null;
  gameState = initGameState(level);
  history = [];
  trailPoints = [];
  isUnwinnable = false;
  levelStartTime = performance.now();  // Start timing for speed record
  // Tutorial text (first 7 levels are tutorials)
  tutorialText = lv.tutorial_text || null;
  tutorialStage = lv.stage || null;
  // Update footer (mobile) - show "Tutorial X" for first 24 levels
  const isTutorial = index < TUTORIAL_COUNT && tutorialText;
  const levelLabel = isTutorial ? `Tutorial ${index + 1}` : `Level ${index + 1 - TUTORIAL_COUNT}`;
  document.getElementById('level-num').textContent = isTutorial ? levelLabel : `Level ${index + 1}/${totalLevels}`;
  document.getElementById('status').textContent = '';
  // Update sidebar (desktop)
  document.getElementById('sidebar-level').textContent = isTutorial ? `T${index + 1}` : `${index + 1 - TUTORIAL_COUNT} / ${totalLevels - TUTORIAL_COUNT}`;
  document.getElementById('sidebar-par').textContent = lv.par || '-';
  document.getElementById('sidebar-moves').textContent = '0';
  document.getElementById('sidebar-status').textContent = '';
  render();
}

function updateMoveCount() {
  const moves = history.length;
  document.getElementById('sidebar-moves').textContent = moves;
}

async function nextLevel() {
  if (currentLevelIndex < totalLevels - 1) {
    await loadLevel(currentLevelIndex + 1);
  }
}

async function prevLevel() {
  if (currentLevelIndex > 0) {
    await loadLevel(currentLevelIndex - 1);
  }
}

async function init() {
  // Display version
  document.getElementById('version-display').textContent = GAME_VERSION;

  // Draw initial loading screen
  drawLoadingScreen(0);

  // Load sprites with progress updates
  await loadSprites(progress => drawLoadingScreen(progress));

  // Try chunked loading first, fall back to single file
  try {
    // Try to load chunk index
    const indexResponse = await fetch('level_chunks/index.json?v=' + Date.now());
    if (indexResponse.ok) {
      levelIndex = await indexResponse.json();
      totalLevels = levelIndex.total_levels;
      allLevels = new Array(totalLevels);  // Sparse array
      console.log(`Chunked levels: ${totalLevels} total in ${levelIndex.chunks.length} chunks`);
    } else {
      throw new Error('No chunk index');
    }
  } catch (e) {
    // Fall back to single file loading
    console.log('Falling back to single file loading');
    try {
      const response = await fetch('levels_dense.json?v=' + Date.now());
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      const data = await response.json();
      allLevels = data.levels;
      totalLevels = allLevels.length;
      console.log(`Loaded ${totalLevels} levels from single file`);
    } catch (e2) {
      console.error('Failed to load levels:', e2);
      allLevels = [{
        width: 7,
        height: 7,
        grid: ['#######', '#..P..#', '#.....#', '#..B..#', '#.....#', '#S....#', '#######']
      }];
      totalLevels = 1;
    }
  }

  // Check URL for level skip (e.g., ?level=9)
  const urlParams = new URLSearchParams(window.location.search);
  const startLevel = parseInt(urlParams.get('level')) || 0;
  initSnow();  // Initialize snow particles
  await loadLevel(Math.min(startLevel, totalLevels - 1));

  // Track player visit with retroactive progress
  trackPlayer();
}

// Level navigation buttons (mobile footer)
document.getElementById('prev-btn')?.addEventListener('click', prevLevel);
document.getElementById('next-btn')?.addEventListener('click', nextLevel);

// Sidebar buttons (desktop)
document.getElementById('sidebar-prev')?.addEventListener('click', prevLevel);
document.getElementById('sidebar-next')?.addEventListener('click', nextLevel);
document.getElementById('sidebar-restart')?.addEventListener('click', restartLevel);
document.getElementById('sidebar-undo')?.addEventListener('click', undo);
document.getElementById('sidebar-hint')?.addEventListener('click', showHint);

// Settings event listeners
document.getElementById('settings-btn')?.addEventListener('click', openSettings);
document.getElementById('sidebar-settings')?.addEventListener('click', openSettings);
document.getElementById('mobile-settings')?.addEventListener('click', openSettings);
document.getElementById('mobile-hint')?.addEventListener('click', showHint);
document.getElementById('mobile-undo')?.addEventListener('click', undo);
document.getElementById('mobile-restart')?.addEventListener('click', restartLevel);
document.getElementById('settings-close')?.addEventListener('click', closeSettings);
document.getElementById('settings-overlay')?.addEventListener('click', (e) => {
  if (e.target.id === 'settings-overlay') closeSettings();
});
document.getElementById('toggle-hints')?.addEventListener('click', () => {
  settings.hintsEnabled = !settings.hintsEnabled;
  saveSettings();
});
document.getElementById('toggle-unwinnable')?.addEventListener('click', () => {
  settings.showUnwinnable = !settings.showUnwinnable;
  saveSettings();
});

// Level select
function openLevelSelect() {
  const grid = document.getElementById('level-grid');
  grid.innerHTML = '';
  const completedLevels = getCompletedLevels();

  for (let i = 0; i < totalLevels; i++) {
    const btn = document.createElement('button');
    btn.className = 'level-btn';
    btn.textContent = i + 1;
    if (i === currentLevelIndex) btn.classList.add('current');
    if (completedLevels.has(i)) btn.classList.add('completed');
    btn.addEventListener('click', () => {
      loadLevel(i);
      closeLevelSelect();
    });
    grid.appendChild(btn);
  }
  document.getElementById('level-overlay').classList.add('visible');
}

function closeLevelSelect() {
  document.getElementById('level-overlay').classList.remove('visible');
}

document.getElementById('mobile-lvl')?.addEventListener('click', openLevelSelect);
document.getElementById('level-close')?.addEventListener('click', closeLevelSelect);
document.getElementById('level-overlay')?.addEventListener('click', (e) => {
  if (e.target.id === 'level-overlay') closeLevelSelect();
});

loadSettings();
init();
  </script>
</body>
</html>
