<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="description" content="Interactive neural network pathfinding demonstration">
    <link rel="manifest" href="manifest.json">
    <title>LOCOMOT.IO - Neural Train Pathfinding</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        html, body { width: 100%; height: 100%; overflow: hidden; touch-action: none; }
        body { background: #0a0610; font-family: 'Press Start 2P', monospace; display: flex; flex-direction: column; color: #fff; user-select: none; -webkit-user-select: none; }
        
        .leaderboard { position: absolute; top: 50px; right: 10px; background: rgba(10, 6, 16, 0.85); border: 1px solid #333; border-radius: 8px; padding: 10px; min-width: 120px; z-index: 20; pointer-events: none; }
        .leaderboard h3 { font-size: 8px; color: #888; margin-bottom: 8px; text-align: center; }
        .leaderboard-entry { display: flex; justify-content: space-between; align-items: center; font-size: 7px; padding: 3px 0; border-bottom: 1px solid #222; }
        .leaderboard-entry:last-child { border-bottom: none; }
        .leaderboard-entry.player { color: #0f0; }
        .leaderboard-entry.neural { color: #f0f; }
        .leaderboard-entry.mvp { background: rgba(255,255,0,0.2); border-left: 2px solid #ff0; }
        .leaderboard-rank { color: #666; width: 16px; }
        .leaderboard-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; margin: 0 6px; }
        .leaderboard-score { color: #ff0; }
        
        .hud { display: flex; justify-content: space-between; padding: 10px 16px; background: linear-gradient(to bottom, #0a0610, #0a061000); font-size: 10px; position: absolute; top: 0; left: 0; right: 0; z-index: 10; pointer-events: none; }
        .hud-item { display: flex; align-items: center; gap: 6px; text-shadow: 0 0 10px currentColor; }
        .len-color { color: #0f0; }
        .wave-color { color: #5ff; }
        .score-color { color: #ff5; }
        
        .game-container { flex: 1; position: relative; overflow: hidden; }
        #gameCanvas { display: block; width: 100%; height: 100%; cursor: crosshair; }
        #gameCanvas.playing { cursor: none; }
        .touch-indicator { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); font-size: 7px; color: #333; pointer-events: none; text-align: center; }
        
        .overlay { position: absolute; inset: 0; background: rgba(5, 3, 10, 0.92); display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 24px; text-align: center; z-index: 100; }
        .overlay.hidden { display: none; }
        .overlay h2 { font-size: 20px; margin-bottom: 20px; }
        .overlay p { font-size: 8px; color: #888; margin-bottom: 8px; line-height: 2; }
        .start-screen h2 { color: #0f0; text-shadow: 0 0 30px #0f08; }
        .game-over-screen { justify-content: flex-start; overflow-y: auto; padding-top: 40px; padding-bottom: 40px; }
        .game-over-screen h2 { color: #f55; text-shadow: 0 0 30px #f558; }
        .pause-screen h2 { color: #5ff; text-shadow: 0 0 30px #5ff8; }
        .score-display { font-size: 14px; color: #ff5; margin: 20px 0; line-height: 2; }
        .start-btn { margin-top: 24px; padding: 18px 36px; font-family: 'Press Start 2P', monospace; font-size: 12px; background: #0f0; color: #000; border: none; border-radius: 8px; box-shadow: 0 0 30px #0f06; }
        .start-btn:active { background: #0c0; transform: scale(0.97); }
        .controls-help { display: flex; gap: 30px; margin-top: 24px; font-size: 7px; color: #666; }
        .control-item { text-align: center; }
        .control-item .icon { font-size: 20px; margin-bottom: 8px; color: #888; }
        .legend { display: flex; flex-wrap: wrap; justify-content: center; gap: 12px; margin-top: 16px; font-size: 6px; }
        .legend-item { display: flex; align-items: center; gap: 6px; color: #666; }
        .legend-color { width: 14px; height: 14px; border-radius: 4px; }
        .wave-announce { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 24px; color: #5ff; text-shadow: 0 0 30px #5ff; opacity: 0; z-index: 50; pointer-events: none; }
        .wave-announce.show { opacity: 1; }
        .pause-btn-fixed { position: absolute; top: 10px; right: 16px; width: 40px; height: 40px; background: transparent; border: 2px solid #333; border-radius: 8px; color: #555; font-size: 14px; z-index: 20; display: flex; align-items: center; justify-content: center; }
        .debug-btn-fixed { position: absolute; top: 10px; right: 66px; width: 40px; height: 40px; background: transparent; border: 2px solid #333; border-radius: 8px; color: #555; font-size: 14px; z-index: 20; display: flex; align-items: center; justify-content: center; }
        .kill-feed { position: absolute; bottom: 60px; left: 10px; font-size: 7px; z-index: 20; pointer-events: none; }
        .kill-feed-entry { background: rgba(0,0,0,0.7); padding: 4px 8px; margin: 2px 0; border-radius: 4px; opacity: 1; transition: opacity 0.5s; }
        .kill-feed-entry.fade { opacity: 0; }
        .invite-link { position: absolute; bottom: 10px; left: 10px; font-size: 6px; color: #666; z-index: 20; background: rgba(0,0,0,0.5); padding: 4px 8px; border-radius: 4px; }
        .invite-link span { color: #0f0; cursor: pointer; }
        
        
        .shake { animation: shake 0.3s ease-in-out; }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-10px) rotate(-1deg); } 75% { transform: translateX(10px) rotate(1deg); } }
        @keyframes fadeOut { 0% { opacity: 1; transform: translate(-50%, -50%) scale(1); } 100% { opacity: 0; transform: translate(-50%, -50%) scale(1.2); } }
    </style>
    <script src='https://storage.ko-fi.com/cdn/widget/Widget_2.js'></script>
</head>
<body>
    <div class="hud">
        <div class="hud-item len-color"><span>‚óà</span><span id="snakeLen">2</span></div>
        <div class="hud-item wave-color"><span>‚óÜ</span><span>RANK <span id="waveNum">#?</span></span></div>
        <div class="hud-item score-color"><span>‚òÖ</span><span id="score">0</span></div>
        <div class="hud-item" style="color: #0fc;"><span>üëÅ</span><span id="patternHud">-</span></div>
    </div>
    
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        <div class="touch-indicator">MOBILE: SWIPE TO TURN ‚Ä¢ HOLD+DRAG TO AIM | DESKTOP: WASD/ARROWS ‚Ä¢ MOUSE TO AIM</div>
        <div class="leaderboard" id="leaderboard"><h3>üèÜ LEADERBOARD</h3><div id="leaderboardEntries"></div></div>
        <div class="wave-announce" id="waveAnnounce">WAVE 1</div>
        <button class="pause-btn-fixed" id="pauseBtn">‚ùö‚ùö</button>
        <button class="debug-btn-fixed" id="debugBtn">üêõ</button>
        <div class="kill-feed" id="killFeed"></div>
        <div class="invite-link">INVITE: <span id="inviteLink" onclick="copyInvite()">loading...</span></div>
        
        
        <div class="overlay start-screen" id="startScreen">
            <h2>LOCOMOT.IO</h2>
            <p style="color:#d4a017;">All aboard the pain train</p>
            <p>Build your train ‚Ä¢ Collect gun cars ‚Ä¢ Survive</p>
            <p style="color:#f0f;">üß† Neural Network AI Enemies!</p>
            <div style="margin: 15px 0;">
                <input type="text" id="usernameInput" placeholder="Enter your name..." maxlength="12"
                    style="font-family: 'Press Start 2P'; font-size: 10px; padding: 10px; border: 2px solid #0f0; background: #111; color: #0f0; text-align: center; width: 200px;">
            </div>
            <div class="controls-help">
                <div class="control-item"><div class="icon">üéÆ</div><div>WASD/ARROWS<br>to turn</div></div>
                <div class="control-item"><div class="icon">üñ±Ô∏è</div><div>MOUSE<br>to aim</div></div>
                <div class="control-item"><div class="icon">üëã</div><div>SWIPE<br>mobile</div></div>
            </div>
            <div class="legend">
                <div class="legend-item"><div class="legend-color" style="background:#f0f;"></div> NEURAL AI</div>
                <div class="legend-item"><div class="legend-color" style="background:#f55;"></div> HUNTER</div>
                <div class="legend-item"><div class="legend-color" style="background:#ff0;"></div> ALPHA</div>
                <div class="legend-item"><div class="legend-color" style="background:#4f4;"></div> HEALTH</div>
            </div>
            <div style="margin-top: 20px;">
                <p style="color:#0ff; font-size: 10px; margin-bottom: 10px;">CHOOSE YOUR MODE:</p>
                <button class="start-btn" id="startFFA" style="background: linear-gradient(135deg, #500 0%, #a00 100%); margin: 5px;">‚öîÔ∏è FREE FOR ALL</button>
                <button class="start-btn" id="startTeams" style="background: linear-gradient(135deg, #005 0%, #00a 100%); margin: 5px;">üë• TEAM BATTLE</button>
            </div>
        </div>
        
        <div class="overlay pause-screen hidden" id="pauseScreen">
            <h2>PAUSED</h2>
            <button class="start-btn" id="resumeBtn">RESUME</button>
        </div>
        
        <div class="overlay game-over-screen hidden" id="gameOverScreen">
            <div id="spectatingLabel" style="position:absolute; top:20px; left:50%; transform:translateX(-50%); color:#5ff; font-size:12px; text-shadow:0 0 10px #5ff; display:none;">SPECTATING LEADER</div>
            <h2>GAME OVER</h2>
            <div style="margin: 10px 0;">
                <input type="text" id="usernameInputDeath" placeholder="Change name..." maxlength="12"
                    style="font-family: 'Press Start 2P'; font-size: 8px; padding: 8px; border: 2px solid #f55; background: #111; color: #f55; text-align: center; width: 180px;">
            </div>
            <div class="score-display">SCORE: <span id="finalScore">0</span><br>BEST RANK: <span id="finalWave">#?</span><br>MAX LENGTH: <span id="finalLength">2</span></div>
            <div id="deathReasonBox" style="font-size: 8px; color: #f55; margin: 10px 0; padding: 10px; background: #200; border-radius: 4px; max-width: 280px;">CAUSE: <span id="deathReasonText">Unknown</span></div>
            <div id="patternStatsBox" style="font-size: 8px; color: #0fc; margin: 10px 0; padding: 10px; background: #021; border: 1px solid #0fc; border-radius: 4px; max-width: 280px;">
                <div style="color: #fff; margin-bottom: 5px;">üëÅ I OBSERVED YOUR PATTERNS:</div>
                <div id="patternStatsText">Loading...</div>
            </div>
            <div id="strategyStatsBox" style="font-size: 8px; color: #f5a; margin: 10px 0; padding: 10px; background: #210; border: 1px solid #f5a; border-radius: 4px; max-width: 280px;">
                <div style="color: #fff; margin-bottom: 5px;">üéØ YOUR STRATEGY BACKFIRED:</div>
                <div id="strategyStatsText">Loading...</div>
            </div>
            <div id="reputationStatsBox" style="font-size: 8px; color: #5cf; margin: 10px 0; padding: 10px; background: #012; border: 1px solid #5cf; border-radius: 4px; max-width: 280px;">
                <div style="color: #fff; margin-bottom: 5px;">üëë REPUTATION SYSTEM:</div>
                <div id="reputationStatsText">Loading...</div>
            </div>
            <div id="godelStatsBox" style="font-size: 8px; color: #f0f; margin: 10px 0; padding: 10px; background: #201; border: 1px solid #f0f; border-radius: 4px; max-width: 280px;">
                <div style="color: #fff; margin-bottom: 5px;">üß† NEURAL TRAINS LEARNED:</div>
                <div id="godelStatsText">Loading...</div>
            </div>
            <button class="start-btn" id="restartBtn">TRY AGAIN</button>
            <button class="start-btn" id="spectateBtn" style="background:#155; margin-left:10px;">SPECTATE</button>
            <button class="start-btn" id="uploadCollectiveBtn" style="background: #0a6; margin-top: 10px; font-size: 9px;">üß† UPLOAD TO COLLECTIVE</button>
            <button class="start-btn" id="copyDeathBtn" style="background: #5af; margin-top: 10px; font-size: 9px;">üìã COPY DEBUG</button>
            <button class="start-btn" id="submitIdeaBtn" style="background: #f80; margin-top: 10px; font-size: 9px;">üí° SUBMIT IDEA</button>

            <!-- Support & Other Games -->
            <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #333;">
                <div style="font-size: 8px; color: #888; margin-bottom: 10px;">MORE FROM THE DEV:</div>
                <div id="kofiWidgetContainer" style="display: flex; justify-content: center;"></div>
                <script>kofiwidget2.init('Support me on Ko-fi', '#72a4f2', 'S6S21JNSQJ');kofiwidget2.draw();</script>
                <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-top: 10px;">
                    <a href="https://painter.locomot.io" target="_blank"
                       style="font-family: 'Press Start 2P'; font-size: 7px; padding: 6px 10px; background: #333; color: #f5a; text-decoration: none; border-radius: 4px; border: 1px solid #f5a;">
                        üé® PORTRAIT PAINTER
                    </a>
                    <a href="https://sandbox.locomot.io" target="_blank"
                       style="font-family: 'Press Start 2P'; font-size: 7px; padding: 6px 10px; background: #333; color: #fa5; text-decoration: none; border-radius: 4px; border: 1px solid #fa5;">
                        üèñÔ∏è SAND BUDDY
                    </a>
                </div>
            </div>
        </div>
    </div>

    <script id="brainData" type="application/json">
{"net.0.weight": [[-0.3175843358039856, 0.3501962423324585, -0.04258507117629051, 0.15824173390865326, -0.06822315603494644, -0.03362172469496727, 0.00702861649915576, 0.002442840952426195, 0.1311696171760559, 0.013881194405257702, 0.27131298184394836, -0.5013553500175476, -0.06283204257488251, 0.10965310037136078, 0.12084528803825378, 0.08581218868494034, 0.006919188424944878, 0.05311232805252075, -0.063705675303936, -0.027516396716237068, 0.14295539259910583, 0.0630117654800415, -0.22190037369728088, 0.013791989535093307, 0.20030392706394196, 0.09590767323970795, -0.07632756233215332, 0.07426854968070984, -0.017903469502925873, -0.10616608709096909, -0.031948793679475784, -0.025897018611431122, -0.017418580129742622, 0.060038093477487564, 0.061411190778017044, 0.08345665782690048, -0.1387758105993271, 0.12471529841423035, -0.13902463018894196, 0.04265648499131203, -0.0026110007893294096, 0.03607543930411339, 0.018997032195329666, 0.15454281866550446, 0.17084787786006927, 0.03952258825302124, -0.3025798201560974, -0.11243849992752075], [0.08351686596870422, 0.29529091715812683, 0.08219949156045914, 0.07938825339078903, 0.3745606243610382, 0.08228029310703278, 0.0643414556980133, 0.08832757920026779, 0.06622426211833954, 0.07911784201860428, 0.1804017275571823, 0.14513607323169708, 0.17904329299926758, -0.16877438127994537, -0.01575796864926815, -0.08308040350675583, 0.0013575186021625996, -0.18152643740177155, 0.27873215079307556, -0.028558313846588135, -0.05905074253678322, 0.12025673687458038, -0.08820141106843948, -0.0224386528134346, -0.09112652391195297, 0.08351155370473862, 0.10855935513973236, -0.11053204536437988, -0.07431530952453613, -0.14732235670089722, 0.14368799328804016, -0.17869022488594055, 0.11900965869426727, -0.11333420127630234, -0.038772400468587875, -0.0760064646601677, 0.2822057902812958, -0.0020618431735783815, 0.02338978834450245, -0.029066456481814384, 0.018475208431482315, -0.12714318931102753, -0.01570303924381733, 0.10092087090015411, 0.022022807970643044, -0.1373690515756607, 0.021732531487941742, 0.006522980518639088], [0.28999876976013184, -0.13013328611850739, -0.12203801423311234, 0.07529480755329132, -0.22606244683265686, -0.11740337312221527, -0.06706662476062775, 0.19257807731628418, 0.18238946795463562, -0.04460590332746506, -0.3442312777042389, -0.09336548298597336, -0.20665563642978668, 0.2454988658428192, 0.08882849663496017, 0.14781086146831512, 0.09432168304920197, 0.08420790731906891, -0.20312628149986267, 0.08929882198572159, 0.1901734471321106, -0.13197313249111176, 0.17439058423042297, 0.1569400280714035, 0.011106815189123154, 0.14016737043857574, -0.1489051878452301, -0.12305984646081924, -0.04196112975478172, 0.03730037063360214, 0.06700119376182556, 0.01394373457878828, -0.020401354879140854, 0.04261968284845352, 0.015518981963396072, -0.0985027328133583, -0.04089580848813057, -0.17919977009296417, 0.14046110212802887, -0.05254771560430527, -0.018467187881469727, -0.2386128157377243, 0.05300528556108475, 0.12331315129995346, -0.16743963956832886, 0.1679907739162445, -0.11888936161994934, -0.20453105866909027], [-0.21415108442306519, 0.35058027505874634, -0.3084335923194885, -0.0584796667098999, -0.16303196549415588, -0.09840118139982224, 0.06093062832951546, 0.1876889169216156, -0.01480965968221426, 0.01809065230190754, -0.03696763515472412, -0.1804833561182022, 0.33260011672973633, -0.1157999262213707, -0.013878103345632553, -0.14240553975105286, -0.2137029767036438, -0.10889545828104019, -0.39696916937828064, -0.035660576075315475, 0.09711895883083344, -0.1295839548110962, -0.08032643795013428, 0.05336736515164375, 0.03988884761929512, 0.12612539529800415, -0.011159265413880348, -1.673194856266491e-05, -0.1902887523174286, -0.1846982091665268, -0.025836613029241562, 0.010602735914289951, -0.12122257798910141, -0.04241281747817993, -0.14963029325008392, -0.03676779195666313, 0.055529166013002396, 0.1320054680109024, -0.04875657334923744, -0.05248849838972092, 0.01772293448448181, 0.08686275780200958, -0.06635323911905289, 0.17601589858531952, -0.09465297311544418, -0.004253990948200226, 0.05043170228600502, -0.05212707445025444], [-0.07510515302419662, -0.1154291182756424, -0.0016514080343768, -0.09137481451034546, 0.12614119052886963, 0.18823891878128052, -0.10955625027418137, 0.06594584882259369, 0.018118958920240402, 0.2389952689409256, -0.11216546595096588, 0.08267302066087723, 0.062359657138586044, -0.056486740708351135, -0.014207176864147186, 0.12259796261787415, -0.020440684631466866, -0.23032239079475403, -0.07766872644424438, 0.03507915139198303, 0.07415006309747696, -0.031245464459061623, 0.04471329599618912, -0.005853486247360706, -0.08885384351015091, -0.11885050684213638, -0.03333659842610359, 0.07087895274162292, 0.04443812370300293, 0.12998048961162567, -0.10918770730495453, -0.11713115125894547, -0.14128020405769348, 0.07977382093667984, 0.08895120769739151, -0.016761401668190956, 0.03556157648563385, 0.08528214693069458, -0.08242322504520416, 0.032298602163791656, 0.026144040748476982, -0.05255177244544029, -0.04748684912919998, -0.024533366784453392, -0.1487521231174469, -0.0015542710898444057, -0.183221235871315, 0.19840875267982483], [0.03756880760192871, -0.06706634163856506, -0.048559125512838364, -0.11954718828201294, 0.0952678918838501, -0.0950033888220787, -0.18163713812828064, -0.12096329033374786, 0.19083118438720703, -0.07623564451932907, -0.06795655190944672, 0.006954125594347715, -0.12368874996900558, -0.14773014187812805, 0.19222840666770935, 0.16080647706985474, -0.04168582707643509, -0.043195001780986786, -0.08480238169431686, 0.05713869258761406, 0.1838768571615219, 0.060530345886945724, 0.03566012531518936, 0.13603350520133972, -0.08975888788700104, -0.12362724542617798, 0.013194015249609947, -0.04685399681329727, 0.032578352838754654, 0.04352990910410881, -0.010342500172555447, -0.046308133751153946, -0.04397617280483246, 0.14698109030723572, -0.10574602335691452, -0.2026318907737732, -0.19637556374073029, -0.20365940034389496, -0.00683876546099782, -0.05220650136470795, 0.1426578164100647, -0.062343254685401917, -0.01574759930372238, -0.13891975581645966, -0.040245261043310165, 0.09041854739189148, -0.10298958420753479, 0.13000665605068207], [-0.03934480994939804, -0.11179899424314499, -0.06914486736059189, -0.12090493738651276, -0.05194316431879997, 0.05311319977045059, -0.13368168473243713, 0.10037264972925186, 0.11919673532247543, 0.082300566136837, -0.14268748462200165, 0.07191634923219681, -0.08674950152635574, -0.13269206881523132, -0.03800049424171448, -0.014499591663479805, 0.11080320179462433, -0.021474359557032585, -0.11079882085323334, -0.09779202193021774, -0.056676529347896576, 0.06603186577558517, 0.07667958736419678, -0.0878753811120987, -0.04771669581532478, -0.1498100459575653, 0.0036913608200848103, -0.014656152576208115, 0.07476513832807541, 0.10778715461492538, 0.08975810557603836, -0.029745200648903847, -0.08653123676776886, -0.13711726665496826, 0.1416170299053192, 0.0763789638876915, 0.10867767781019211, 0.024059489369392395, -0.055503278970718384, 0.034524668008089066, 0.10134213417768478, -0.10100017488002777, -0.16518843173980713, 0.06719173491001129, -0.13327521085739136, -0.13881060481071472, -0.08756820112466812, -0.08899465948343277], [0.20686425268650055, -0.17104244232177734, 0.041364215314388275, 0.03043949231505394, -0.12751053273677826, -0.03819069638848305, -0.2022051364183426, 0.09723664820194244, 0.1382424533367157, 0.24008719623088837, -0.10854435712099075, -0.05996420234441757, -0.14040622115135193, 0.29017525911331177, 0.05979236960411072, 0.045355916023254395, 0.08245547115802765, 0.2830522060394287, 0.005930705927312374, 0.10642135143280029, 0.0231979601085186, 0.08336739242076874, 0.04764500632882118, -0.05186529457569122, -0.08686238527297974, 0.029831482097506523, 0.07425913214683533, -0.021561259403824806, 0.005774268880486488, -0.1793256402015686, 0.07621504366397858, 0.1608625054359436, 0.10196328163146973, 0.0020669489167630672, -0.14811955392360687, -0.09101992845535278, -0.2863790988922119, 0.32119959592819214, -0.005253460258245468, -0.11485598981380463, -0.16972917318344116, 0.18249337375164032, 0.0641971230506897, -0.07072602957487106, 0.023786228150129318, -0.07631047815084457, 0.011631602421402931, 0.13608944416046143], [-0.1888902187347412, 0.04194217547774315, -0.09125920385122299, 0.132993683218956, -0.12901464104652405, -0.020334560424089432, 0.0062944842502474785, 0.06442685425281525, 0.029719922691583633, 0.12025150656700134, -0.07565772533416748, -0.16123610734939575, 0.04507293552160263, -0.058986157178878784, -0.060499124228954315, 0.051827359944581985, 0.01459686178714037, 0.026085520163178444, 0.09869765490293503, 0.004747034050524235, -0.21670648455619812, -0.024948744103312492, 0.020621366798877716, -0.15665550529956818, -0.21118807792663574, -0.10590588301420212, -0.10057081282138824, -0.11480480432510376, -0.054073765873909, -0.211611807346344, -0.09059776365756989, 0.07804792374372482, 0.2731454372406006, -0.24024012684822083, -0.2614838778972626, -0.06677024811506271, 0.01892883889377117, 0.4573819041252136, 0.23645088076591492, -0.0666569322347641, -0.18908314406871796, 0.0259682796895504, -0.12902720272541046, 0.13669763505458832, 0.21309855580329895, -0.08770193159580231, -0.04548979550600052, 0.0938381552696228], [-0.12183918058872223, -0.02828293852508068, -0.02439180761575699, 0.04613069072365761, 0.08136199414730072, -0.0004191038606222719, -0.04223012179136276, 0.08864884823560715, 0.21433661878108978, -0.06474032998085022, -0.18060126900672913, 0.24580071866512299, -0.4379833936691284, 0.3571586012840271, 0.17482618987560272, -0.03462835028767586, -0.022534146904945374, 0.15385594964027405, -0.06739737838506699, 0.10817912966012955, 0.026180168613791466, -0.020743560045957565, 0.20042738318443298, -0.06288868933916092, 0.1456969976425171, -0.013827739283442497, -0.023673146963119507, -0.0255635604262352, -0.06099281087517738, -0.1783437728881836, 0.046616870909929276, -0.023777158930897713, 0.03858824446797371, -0.15176323056221008, 0.12343072146177292, -0.11041440069675446, -0.20111016929149628, 0.08553225547075272, 0.14160723984241486, 0.14663605391979218, 0.012797010131180286, -0.1422845721244812, 0.09010612219572067, 0.09707121551036835, 0.07712199538946152, 0.08318743109703064, -0.09923741221427917, 0.11833079159259796], [0.07084545493125916, -0.00024187006056308746, -0.07917291671037674, -0.04905128851532936, 0.1358393281698227, 0.09719227999448776, -0.022982748225331306, -0.028592923656105995, 0.057722099125385284, 0.09476678818464279, 0.059076275676488876, -0.056364528834819794, 0.03256838768720627, -0.038022104650735855, 0.0665566474199295, -0.0920112133026123, -0.08667238056659698, 0.08694352954626083, -0.046867307275533676, -0.008532918058335781, -0.1132485419511795, -0.020581409335136414, 0.09730558097362518, -0.12468526512384415, -0.02660510502755642, -0.16458944976329803, 0.07264350354671478, -0.09426884353160858, 0.03097524866461754, 0.1295422911643982, 0.04858805984258652, -0.06054823845624924, -0.14213670790195465, 0.04736948758363724, -0.030766604468226433, 0.01150020956993103, 0.05074876919388771, 0.06153581291437149, 0.07911663502454758, -0.03932426497340202, 0.06459914892911911, -0.020832115784287453, 0.08519363403320312, 0.08808848261833191, -0.10415653139352798, 0.029613295570015907, -0.08551453053951263, 0.031877100467681885], [0.029968854039907455, 0.15652024745941162, 0.056980714201927185, 0.13157492876052856, -0.14857257902622223, -0.02669922076165676, -0.11324223130941391, 0.04650990292429924, 0.26365748047828674, 0.06879869103431702, -0.1362532079219818, 0.037342339754104614, -0.2625420093536377, 0.20144334435462952, 0.045583076775074005, 0.0010835452703759074, -0.07999983429908752, -0.022481732070446014, -0.12057987600564957, 0.06824095547199249, 0.25177133083343506, 0.0909896194934845, 0.025285234674811363, -0.024069013074040413, 0.021043602377176285, 0.27299273014068604, 0.12762464582920074, -0.09265637397766113, 0.008684755302965641, -0.1466304510831833, 0.09184616804122925, 0.05798674002289772, -0.0192875936627388, 0.0591132827103138, -0.11162541806697845, -0.1404379904270172, 0.32096415758132935, -0.3000143766403198, -0.05567486211657524, -0.06535642594099045, -0.15749742090702057, -0.283488392829895, 0.19917690753936768, 0.08105292171239853, 0.02901126630604267, 0.05470484122633934, -0.20486506819725037, 0.015373590402305126], [0.3019583225250244, 0.013228360563516617, 0.036853961646556854, 0.1375015377998352, 0.05619943514466286, -0.025466253980994225, 0.18515263497829437, 0.02115604653954506, -0.052099380642175674, -0.04933008551597595, -0.09625927358865738, -0.0412687212228775, 0.3770003318786621, -0.1644664704799652, 0.17652475833892822, 0.003386907046660781, -0.2605990469455719, -0.01871860958635807, 0.14353199303150177, 0.05581236258149147, -0.0571422204375267, -0.06768050044775009, -0.12642063200473785, -0.09143884479999542, -0.013274721801280975, 0.14846016466617584, 0.11930637806653976, 0.1071590855717659, -0.3146227300167084, 0.06829986721277237, -0.05675854906439781, -0.023583844304084778, 0.004282725974917412, -0.011826997622847557, -0.031738683581352234, -0.014323052018880844, 0.23710831999778748, -0.09534793347120285, -0.00039355846820399165, -0.0560530349612236, -0.039883121848106384, -0.21157227456569672, 0.13516347110271454, -0.13503549993038177, 0.031712811440229416, -0.04149052873253822, -0.05982563644647598, -0.02902490459382534], [0.14727473258972168, -0.20430965721607208, 0.06345771998167038, -0.1579362004995346, 0.05662771686911583, -0.062222059816122055, -0.2517010569572449, 0.26008468866348267, -0.03808882459998131, -0.02230832166969776, -0.09033926576375961, 0.03277842700481415, 0.1649715006351471, 0.19550825655460358, -0.2561785876750946, -0.17398187518119812, 0.01339829619973898, 0.24757513403892517, 0.048149850219488144, 0.02414156310260296, -0.20463164150714874, -0.0012810813495889306, 0.13625574111938477, 0.18695229291915894, -0.014909837394952774, 0.007930751889944077, -0.19492563605308533, 0.09126447141170502, 0.018896862864494324, -0.16498537361621857, -0.27850309014320374, -0.004970296751707792, 0.0018811288755387068, 0.03320830687880516, 0.028896570205688477, -0.10319487750530243, 0.2325039654970169, -0.01779583841562271, -0.012505977414548397, 0.0538325160741806, 0.05861859396100044, -0.1461670845746994, -0.3309367001056671, -0.2706622779369354, -0.11718855053186417, -0.09605436027050018, 0.00604997668415308, -0.07157792150974274], [-0.17263579368591309, 0.1785675585269928, 0.051190461963415146, 0.11643364280462265, -0.032532695680856705, 0.08944665640592575, 0.06319619715213776, 0.10154987126588821, -0.0838993638753891, 0.05709441751241684, 0.043000444769859314, 0.07932967692613602, 0.1553359180688858, -0.01744156889617443, 0.018245583400130272, 0.21240989863872528, 0.10342312604188919, 0.0629088506102562, 0.013322134502232075, 0.03565836697816849, -0.14979170262813568, 0.07536748796701431, 0.04375433549284935, -0.16423623263835907, -0.037838175892829895, -0.1327490657567978, 0.03525324910879135, 0.011901999823749065, -0.10232168436050415, 0.10098805278539658, 0.43341484665870667, -0.04877469688653946, 0.022899247705936432, 0.0776745080947876, -0.008950525894761086, 0.013289149850606918, 0.011425994336605072, 0.1265464723110199, -0.0046452791430056095, -0.01513200905174017, 0.15595850348472595, -0.009744628332555294, -0.09503287822008133, -0.04838905856013298, 0.04308777302503586, 0.031258076429367065, 0.188995823264122, 0.004140042699873447], [-0.0010272531071677804, 0.030527224764227867, -0.01635555364191532, -0.12891726195812225, 0.02947756089270115, -0.07693906128406525, -0.14824526011943817, 0.06806734949350357, -0.02472170628607273, -0.004841317422688007, 0.05565161630511284, 0.10507892817258835, 0.59432053565979, -0.01923622004687786, 0.00021148976520635188, -0.03508775681257248, -0.018538864329457283, 0.05777296796441078, 0.04719802364706993, 0.052885279059410095, 0.04641178250312805, -0.06880863755941391, 0.15896521508693695, 0.14892002940177917, -0.14604471623897552, -0.15521138906478882, 0.06247851625084877, 0.008791725151240826, 0.013385330326855183, -0.013187078759074211, -0.010914387181401253, 0.04807518422603607, -0.07354111224412918, 0.006443487945944071, -0.00776267983019352, -0.03932681307196617, -0.2121039628982544, 0.1747455894947052, 0.1251128613948822, -0.09655793011188507, 0.07901633530855179, -0.14187096059322357, 0.5579216480255127, -0.10607372224330902, 0.04257799685001373, -0.05719583109021187, 0.016096144914627075, -0.01768924854695797], [-0.07142385095357895, 0.025760160759091377, -0.08517277240753174, -0.21976028382778168, -0.2519341707229614, -0.03349340334534645, 0.030640196055173874, 0.09184760600328445, 0.18388259410858154, 0.10148248076438904, -0.050807543098926544, 0.18431395292282104, -0.4323102533817291, 0.21302446722984314, 0.18541854619979858, -0.002721379278227687, 0.08148679882287979, 0.24502749741077423, -0.07478616386651993, -0.01718176156282425, 0.0006035373662598431, -0.09741632640361786, 0.09196408838033676, 0.10239367187023163, 0.0902152732014656, 0.06645962595939636, 0.08242291212081909, 0.06283193826675415, 0.00675564119592309, 0.022438637912273407, -0.008736368268728256, 0.04228812828660011, 0.18876810371875763, 0.09929072111845016, 0.16774363815784454, 0.17841102182865143, -0.4349929988384247, 0.21307772397994995, 0.19708724319934845, -0.14089089632034302, 0.21185201406478882, 0.07910764217376709, -0.023608149960637093, -0.04032779112458229, 0.022212691605091095, 0.10833577811717987, 0.040776703506708145, 0.16631144285202026], [-0.07265503704547882, 0.2478293478488922, -0.03392786905169487, -0.10912622511386871, -0.12950938940048218, 0.1869141012430191, -0.08131229877471924, 0.1726958006620407, 0.12388591468334198, -0.03701140359044075, -0.132700577378273, 0.05265255272388458, -0.06719667464494705, 0.36775386333465576, -0.11455763876438141, -0.17689858376979828, 0.0096581494435668, -0.11165404319763184, -0.136928990483284, 0.0657384917140007, -0.048014964908361435, 0.04629804193973541, -0.2347334623336792, -0.19361050426959991, -0.10567093640565872, -0.11698324978351593, -0.04223388433456421, 0.05883266404271126, 4.802589683094993e-05, -0.07190832495689392, -0.0952351912856102, -0.2043980062007904, -0.009314731694757938, 0.11523054540157318, -0.029075343161821365, -0.2197151631116867, -0.01939081773161888, -0.20097318291664124, 0.041698310524225235, -0.06989309936761856, 0.009405870921909809, -0.04672009125351906, 0.0030994319822639227, 0.156133770942688, 0.0016629003221169114, 0.024934202432632446, 0.15870064496994019, -0.13678757846355438], [-0.022296858951449394, 0.021778611466288567, 0.04289548099040985, 0.08273042738437653, -0.05482778698205948, 0.06485547125339508, 0.061960019171237946, 0.012187311425805092, -0.04955307021737099, 0.14178098738193512, -0.03512370586395264, -0.02534361183643341, 0.30971458554267883, -0.277973473072052, -0.01205467525869608, 0.053125351667404175, 0.05409335717558861, -0.07294143736362457, 0.048427410423755646, 0.07132980227470398, -0.08502722531557083, 0.13767537474632263, -0.1757342666387558, -0.15430468320846558, 0.04848438501358032, 0.09525313228368759, -0.0025995252653956413, -0.11107852309942245, -0.09867499023675919, -0.10272566974163055, 0.10012463480234146, 0.0060741049237549305, -0.003609050065279007, 0.13033786416053772, 0.09094299376010895, -0.02229347638785839, -0.18232709169387817, 0.14142702519893646, 0.006198561750352383, -0.020388737320899963, -0.01795949786901474, -0.01726526953279972, 0.03395889699459076, 0.2047998458147049, -0.0051124198362231255, -0.05518393591046333, 0.09394493699073792, 0.06010754033923149], [-0.24394778907299042, 0.10529514402151108, 0.007746639661490917, 0.02962765283882618, 0.061682526022195816, -0.07432513684034348, 0.059961430728435516, -0.04964825510978699, -0.08885102719068527, -0.09598270058631897, -0.033442869782447815, -0.11393234133720398, -0.024007493630051613, 0.030304016545414925, -0.019391199573874474, 0.04278947412967682, 0.07128261029720306, -0.2034120112657547, -0.01038164272904396, -0.007619956973940134, -0.10139962285757065, -0.24701851606369019, -0.13547077775001526, -0.12831656634807587, -0.08503127843141556, -0.1108211800456047, -0.0068547665141522884, 0.011933444067835808, -0.17700813710689545, -0.15869860351085663, 0.007904371246695518, 0.08018544316291809, 0.02104121446609497, -0.1462925374507904, -0.007678926456719637, 0.07079652696847916, -0.029159441590309143, 0.3987036645412445, -0.0023891807068139315, 0.18353058397769928, 0.0026248169597238302, 0.23643317818641663, -0.03809869661927223, 0.1688656061887741, -0.10166279971599579, -0.10633103549480438, -0.17646251618862152, 0.19258801639080048], [-0.7505049109458923, 0.40106186270713806, 0.07908202707767487, 0.06811308860778809, -0.16713809967041016, -0.07372625917196274, 0.05176506191492081, 0.03048962727189064, 0.1925298422574997, -0.019686967134475708, -0.05362727865576744, -0.10280152410268784, 0.32330843806266785, -0.03529989346861839, -0.039538465440273285, -0.05780632793903351, 0.14716266095638275, -0.0898342877626419, 0.12330285459756851, -0.04989039897918701, -0.05590682104229927, 0.06783110648393631, -0.01495425496250391, 0.005566052161157131, -0.059220217168331146, 0.09323485940694809, 0.11164625734090805, 0.11818265169858932, -0.17389783263206482, -0.1179073378443718, -0.12343637645244598, 0.06720683723688126, 0.010865189135074615, 0.07161633670330048, -0.027700001373887062, -0.02751065604388714, 0.24785953760147095, -0.16252271831035614, -0.009487959556281567, -0.1103169173002243, -0.1166299507021904, -0.09245175123214722, -0.04128435254096985, 0.11934588849544525, 0.061361439526081085, 0.08703047037124634, -0.08348014205694199, 0.2100769430398941], [-0.10070787370204926, 0.047159284353256226, 0.1353120356798172, 0.20441146194934845, -0.17200705409049988, -0.11853447556495667, 0.03045789711177349, -0.005940902046859264, -0.11978133022785187, 0.18155647814273834, -0.07382775843143463, 0.04937860742211342, 0.16224296391010284, -0.0628354549407959, 0.1463596522808075, -0.03800142928957939, -0.02193351276218891, -0.1520593911409378, 0.25013068318367004, -0.0670887678861618, -0.08335190266370773, -0.030058108270168304, -0.19793769717216492, -0.1555834263563156, 0.20812273025512695, 0.21192482113838196, 0.041132885962724686, -0.10793779790401459, -0.1782110333442688, 0.12532295286655426, -0.0006234474712982774, -0.08152806013822556, -0.04968458041548729, 0.049948349595069885, 0.014149673283100128, 0.2036992907524109, -0.4869740307331085, 0.2545991539955139, 0.06665106862783432, 0.18832333385944366, 0.028443140909075737, 0.10503518581390381, -0.14369016885757446, 0.11924906075000763, 0.1582072377204895, 0.15578196942806244, 0.016599562019109726, 0.01785944402217865], [-0.15780097246170044, 0.00723927840590477, 0.1580566018819809, -0.2445896714925766, -0.01984165608882904, 0.02524159476161003, 0.35374489426612854, 0.03330417349934578, -0.1398259550333023, -0.030246982350945473, -0.1773645281791687, -0.08190515637397766, -0.11577663570642471, -0.050623610615730286, 0.0677890032529831, 0.02733779512345791, -0.10761375725269318, -0.17417268455028534, 0.006541210226714611, -0.006175218615680933, -0.1994709074497223, -0.23159177601337433, 0.09377928823232651, 0.0191190242767334, -0.052567314356565475, -0.14204668998718262, -0.0370231531560421, 0.007900587283074856, -0.2581903338432312, -0.23666222393512726, -0.09864059090614319, -0.0015699758660048246, 0.0004294180544093251, -0.17196711897850037, 0.23145006597042084, 0.07917659729719162, -0.24388399720191956, 0.3832506537437439, -0.119320347905159, 0.1085832417011261, 0.16104410588741302, 0.12503580749034882, -0.09079881757497787, 0.10450579226016998, -0.04343891888856888, 0.06591866165399551, -0.09708735346794128, 0.148735910654068], [-0.014943261630833149, -0.06984793394804001, -0.014394447207450867, -0.018445391207933426, -0.11659789830446243, -0.12141132354736328, 0.023369044065475464, -0.23431582748889923, 0.054574474692344666, 0.07299942523241043, 0.011939751915633678, -0.3911108672618866, -0.26331791281700134, 0.034481193870306015, 0.014645683579146862, 0.1942151039838791, -0.1341579556465149, 0.0006631759461015463, 0.004014212638139725, -0.1372803896665573, -0.02130967751145363, -0.16392511129379272, 0.13986867666244507, 0.00841427966952324, -0.12402642518281937, 0.01693543791770935, -0.13545235991477966, 0.037781424820423126, 0.08190698176622391, -0.10517905652523041, -0.025927981361746788, 0.03166956454515457, 0.004436042625457048, -0.11049450188875198, 0.17218589782714844, 0.16441068053245544, -0.18596482276916504, 0.3700059652328491, -0.05650804564356804, 0.11829996109008789, 0.12125704437494278, 0.25398048758506775, 0.0007484326488338411, 0.11566983908414841, -0.1546492576599121, 0.12622283399105072, 0.0012387892929837108, -0.044547032564878464], [0.06620142608880997, -0.18843252956867218, -0.11288133263587952, -0.040920693427324295, -0.08383740484714508, -0.047824785113334656, 0.0871846079826355, -0.09533105790615082, 0.03455161675810814, 0.16691027581691742, 0.2866714894771576, 0.05359494313597679, -0.3290443420410156, -0.07883437722921371, 0.02403315156698227, 0.08250164985656738, 0.21076522767543793, 0.2814055383205414, -0.042358048260211945, -0.2327987104654312, -0.013404767960309982, 0.00651254178956151, 0.09185720980167389, 0.19771185517311096, 0.10513869673013687, 0.10289309173822403, 0.029611295089125633, -0.05239756032824516, 0.19562993943691254, 0.10558030754327774, -0.22505523264408112, 0.14479251205921173, -0.05499228090047836, 0.1316668838262558, 0.10751569271087646, 0.15030381083488464, 0.13018560409545898, -0.16742439568042755, 0.12479615211486816, 0.034119900315999985, -0.07011020183563232, -0.06435360014438629, 0.17956557869911194, 0.025569120422005653, -0.06094168871641159, 0.13471601903438568, -0.019423210993409157, -0.2409653216600418], [-0.2395581603050232, 0.04168914631009102, -0.11896296590566635, 0.040993258357048035, 0.021737368777394295, 0.03525037690997124, -0.04819359630346298, 0.06121065095067024, -0.04728446528315544, -0.16550160944461823, -0.1956099271774292, 0.13720373809337616, -0.05953144654631615, -0.023981496691703796, 0.1740872710943222, 0.10134734958410263, -0.14100776612758636, -0.2016328126192093, -0.0030850316397845745, 0.03969098627567291, 0.1563706248998642, -0.18295468389987946, -0.07881785184144974, -0.06969328969717026, 0.0011678310111165047, -0.0307424645870924, 0.002200873801484704, 0.022762931883335114, -0.1530097872018814, -0.03696873039007187, 0.041496142745018005, 0.08601578325033188, -0.1624622493982315, -0.14535975456237793, -0.16972842812538147, -0.10591170191764832, 0.039543986320495605, 0.38203325867652893, -0.057624999433755875, -0.009203647263348103, 0.07097513973712921, -0.029294533655047417, -0.012706944718956947, 0.08426094800233841, -0.05423091724514961, -0.07121319323778152, -0.30753281712532043, 0.025806600227952003], [0.21696321666240692, 0.12016437947750092, 0.05576777085661888, -0.11472046375274658, -0.1039109006524086, 0.012983754277229309, 0.20057770609855652, 0.14738307893276215, -0.05043444782495499, 0.21048623323440552, -0.11768788844347, -0.11387624591588974, -0.044850904494524, -0.15706861019134521, 0.019822480157017708, -0.0640445351600647, -0.09061587601900101, -0.06250662356615067, 0.24232029914855957, -0.12119722366333008, -0.016894225031137466, -0.029335664585232735, -0.09345003962516785, 0.019681092351675034, 0.02234722301363945, -0.1005125641822815, -0.04015657305717468, 0.08575376868247986, -0.02412290684878826, 0.0547175332903862, -0.07192803174257278, 0.03804398700594902, -0.04435060918331146, 0.05391319841146469, -0.08235707879066467, 0.0224466435611248, 0.042245201766490936, 0.021565528586506844, -0.16013658046722412, 0.048059381544589996, -0.04116356745362282, 0.11571644246578217, -0.01963782124221325, -0.017272261902689934, 0.05781778693199158, 0.09196837991476059, -0.09858531504869461, 0.14832866191864014], [-0.24563689529895782, 0.2720720171928406, 0.13997824490070343, 0.04852082580327988, 0.1640634983778, 0.17261844873428345, -0.017997436225414276, 0.10627922415733337, 0.14033682644367218, 0.09564513713121414, -0.028591366484761238, 0.0660092756152153, 0.04088439792394638, 0.35048508644104004, 0.020804723724722862, 0.08322880417108536, -0.05224021524190903, -0.1948024034500122, -0.12616580724716187, 0.08154234290122986, 0.23190125823020935, -0.04898616299033165, -0.19331243634223938, 0.01132388785481453, -0.21695150434970856, -0.047595858573913574, -0.09118134528398514, 0.15804539620876312, -0.11148595809936523, 0.012841055169701576, -0.07055816054344177, -0.1771835833787918, 0.00802917592227459, 0.20492568612098694, -0.17796695232391357, -0.20571960508823395, -0.030455399304628372, 0.046538252383470535, 0.010640977881848812, -0.23509769141674042, 0.10077167302370071, -0.08992446213960648, -0.2691901922225952, 0.1567935198545456, 0.0695750042796135, -0.060877952724695206, -0.048653796315193176, 0.01667889393866062], [-0.23308080434799194, 0.17027446627616882, 0.1833028793334961, 0.17225754261016846, -0.007497670128941536, 0.2638804316520691, 0.13126656413078308, 0.08931037783622742, 0.1713869273662567, -0.07655419409275055, 0.24440376460552216, 0.04571189731359482, 0.18282732367515564, -0.15450526773929596, -0.2332502007484436, 0.026703743264079094, 0.0427551344037056, -0.10739805549383163, -0.0018228798871859908, -0.11336399614810944, -0.05584212392568588, -0.10049854964017868, -0.18084697425365448, 0.03887178376317024, -0.09587324410676956, 0.07518783211708069, 0.08614011108875275, 0.010168048553168774, -0.05220642685890198, 0.05765211582183838, 0.04996951296925545, 0.10789678245782852, 0.12197896093130112, 0.07753685116767883, -0.04676756262779236, 0.09364139288663864, -0.3133072257041931, 0.28644391894340515, 0.06901948899030685, 0.14848336577415466, -0.0021082675084471703, -0.008471919223666191, -0.035008788108825684, -0.06140975281596184, 0.1990353912115097, -0.019667252898216248, 0.11988146603107452, 0.2594282627105713], [-0.19936694204807281, 0.3015684485435486, -0.040491119027137756, 0.05149868130683899, 0.19620446860790253, 0.20219293236732483, 0.06982641667127609, 0.22339138388633728, -0.13668373227119446, 0.012206819839775562, -0.1903112232685089, 0.20185507833957672, -0.3658560812473297, 0.27084222435951233, -0.2592034935951233, 0.16360238194465637, 0.07045921683311462, -0.11716625094413757, 0.01849730685353279, 0.031082535162568092, -0.14332227408885956, -0.03707978129386902, -0.05617140233516693, 0.15171968936920166, 0.021774668246507645, 0.03518295660614967, -0.014436831697821617, 0.2000284641981125, 0.06941451877355576, 0.06748613715171814, 0.02908637560904026, 0.019200580194592476, 0.065407894551754, -0.03184327110648155, 0.014410845004022121, -0.0988585576415062, 0.1650988906621933, -0.08103957772254944, 0.10504122078418732, -0.16647495329380035, 0.10453284531831741, -0.027615638449788094, -0.27049240469932556, 0.06802187114953995, 0.006552652921527624, 0.06914946436882019, -0.14129860699176788, -0.08447533845901489], [-0.15745951235294342, -0.007049094419926405, -0.08869415521621704, 0.05912863463163376, -0.22289712727069855, -0.18299196660518646, 0.12717607617378235, -0.13783317804336548, -0.14016684889793396, -0.07512412965297699, -0.13223379850387573, -0.20758219063282013, -0.017403623089194298, -0.08399573713541031, 0.03743547201156616, -0.0869898572564125, 0.049783993512392044, 0.024220170453190804, -0.03857305273413658, -0.0012103916378691792, -0.10893992334604263, 0.010685413144528866, 0.04303792491555214, 0.05225411057472229, 0.13994373381137848, -0.08669797331094742, -0.06801730394363403, 0.06633953005075455, 0.10021655261516571, 0.2159261554479599, -0.153695210814476, -0.10842219740152359, 0.20360685884952545, 0.0019227031152695417, 0.17299310863018036, 0.1107076033949852, -0.40443357825279236, 0.1022990271449089, 0.1101163849234581, -0.02488420531153679, 0.20305150747299194, 0.01173994317650795, -0.12947037816047668, 0.07632991671562195, 0.22370313107967377, 0.11666636168956757, 0.17055056989192963, -0.05856318771839142], [0.2938570976257324, -0.07835857570171356, -0.06458918750286102, -0.1437559574842453, -0.06299696862697601, -0.13900987803936005, 0.03594135493040085, 0.012610352598130703, -0.04388446733355522, 0.160985067486763, -0.16017356514930725, -0.1366245597600937, 0.3195696473121643, -0.24727700650691986, 0.11312219500541687, -0.07183456420898438, 0.011556215584278107, -0.13271771371364594, 0.06259807199239731, 0.1315760314464569, 0.007338600233197212, 0.10514213144779205, -0.15414202213287354, 0.04904131963849068, -0.0550895631313324, 0.14670594036579132, 0.09579399973154068, 0.03696856275200844, -0.2331850528717041, -0.10503002256155014, -0.023486966267228127, 0.0354188047349453, 0.2069765031337738, -0.08070092648267746, -0.1449364572763443, -0.010723540559411049, -0.08348722010850906, 0.05671587213873863, 0.2207244634628296, 0.10667167603969574, -0.08792473375797272, -0.09901951253414154, 0.10441002994775772, 0.16114582121372223, 0.03454267233610153, -0.03996087238192558, -0.04931114614009857, -0.12650085985660553], [0.08821335434913635, -0.024296365678310394, -0.033324483782052994, -0.0377207025885582, -0.14009064435958862, -0.2064286172389984, 0.027868518605828285, 0.10559221357107162, -0.11437900364398956, 0.2159123569726944, -0.22553572058677673, -0.19800183176994324, -0.0015005044406279922, -0.10338639467954636, -0.05684741958975792, 0.08147303014993668, 0.013333214446902275, -0.10141848772764206, 0.18272823095321655, -0.05462260544300079, 0.05258062109351158, -0.05597393959760666, -0.2996326982975006, -0.006070095580071211, -0.07292485237121582, 0.21496503055095673, 0.1184777170419693, -0.11965198069810867, -0.22053298354148865, -0.08665549010038376, -0.09391162544488907, 0.048358459025621414, -0.06115252152085304, -0.10396403074264526, 0.031616613268852234, -0.12965127825737, -0.2571738362312317, 0.13935373723506927, 0.09945353120565414, 0.06899367272853851, 0.22993940114974976, 0.0057627130299806595, -0.1540747433900833, 0.1353815197944641, 0.14239636063575745, 0.06541438400745392, -0.10624340921640396, 0.029335571452975273], [0.08872630447149277, -0.03062722086906433, -0.08264919370412827, -0.02395596168935299, -0.2982315719127655, -0.14006510376930237, 0.058091770857572556, -0.0038715496193617582, 0.11098608374595642, 0.046623408794403076, -0.05505562201142311, -0.09506961703300476, -0.4486353099346161, 0.3442932665348053, 0.2364702969789505, 0.18017537891864777, -0.016288189217448235, -0.0060142274014651775, -0.12686972320079803, 0.1038171574473381, 0.0755435898900032, 0.011661935597658157, -0.15286900103092194, 0.20116135478019714, 0.05872000381350517, 0.12759064137935638, -0.135361447930336, 0.05829181149601936, -0.16251802444458008, 0.03264409676194191, -0.014858921058475971, 0.06430795043706894, 0.21938185393810272, 0.013601478189229965, 0.022268131375312805, -0.01179274171590805, -0.21690325438976288, 0.16330423951148987, 0.23625661432743073, -0.15332894027233124, 0.19350813329219818, -0.048054296523332596, 0.11968865245580673, 0.12289465218782425, -0.007799546699970961, 0.017946738749742508, -0.05422282591462135, 0.02147577330470085], [-0.1462850570678711, 0.15066497027873993, 0.04215263947844505, 0.08687212318181992, -0.04801346734166145, -0.03916950896382332, 0.08117420226335526, 0.2173665165901184, -0.07635511457920074, 0.014828082174062729, 0.19795216619968414, 0.04262138158082962, -0.3097887933254242, 0.3040294945240021, -0.2722701132297516, -0.018932608887553215, 0.11207497119903564, 0.24759605526924133, 0.040781158953905106, 0.05194678157567978, -0.2329869270324707, -0.0029181228019297123, -0.2039121687412262, 0.15234659612178802, -0.11836645007133484, 0.13853894174098969, -0.006618676241487265, 0.10523446649312973, -0.08639374375343323, -0.05893673747777939, -0.032496534287929535, 0.020941754803061485, 0.051909614354372025, 0.04823997616767883, -0.1776765137910843, 0.10662813484668732, 0.02081960067152977, -0.004301170818507671, -0.11386848241090775, 0.05451001971960068, -0.09893855452537537, -0.0076617770828306675, -0.016317835077643394, -0.029217852279543877, 0.008069057948887348, 0.03524297475814819, 0.07100735604763031, 0.06647901237010956], [0.2926735281944275, -0.3623136281967163, -0.03992423042654991, 0.004308565519750118, -0.2914947271347046, -0.1584244966506958, -0.20455940067768097, 0.1074884831905365, -0.048329465091228485, -0.024614710360765457, -0.11577416211366653, 0.023246733471751213, -0.05693706497550011, 0.2422061562538147, 0.09282074868679047, 0.10188240557909012, 0.11614463478326797, -0.23493066430091858, -0.03357560187578201, 0.09555135667324066, 0.07021070271730423, 0.018725404515862465, -0.1301969289779663, -0.012709679082036018, -0.05767722427845001, 0.11720773577690125, -0.13315455615520477, -0.1379968672990799, 0.10916829854249954, -0.09909157454967499, -0.023459792137145996, -0.12455398589372635, -0.01917175203561783, 0.060865093022584915, 0.04992058128118515, 0.19340813159942627, -0.20311769843101501, 0.0669640600681305, 0.1714429259300232, 0.039281174540519714, 0.051449913531541824, -0.03233547508716583, -0.10225093364715576, -0.13837197422981262, 0.11420370638370514, 0.019806111231446266, -0.052460163831710815, -0.04824770241975784], [0.016221078112721443, 0.09600915014743805, 0.07282981276512146, 0.01833943836390972, -0.021267907693982124, 0.0215494055300951, 0.5732144713401794, 0.06707360595464706, -0.032526690512895584, 0.058675579726696014, -0.02700967900454998, 0.036090537905693054, -0.0995287299156189, -0.020053818821907043, 0.17054174840450287, -0.1091356948018074, 0.04568886011838913, 0.07173760235309601, -0.19036313891410828, 0.0756223052740097, 0.02801007404923439, -0.04065791144967079, -0.026602059602737427, -0.009242710657417774, -0.1184975802898407, -0.1752360761165619, -0.08538412302732468, -0.082405686378479, 0.06723030656576157, 0.10665818303823471, 0.3234320878982544, 0.007839277386665344, 0.11697819828987122, -0.06210161745548248, 0.13033591210842133, -0.07980868965387344, 0.05854243412613869, -0.00612566526979208, -0.03613663837313652, 0.11282244324684143, -0.16436734795570374, -0.03731559216976166, 0.4755641520023346, -0.1010666936635971, -0.05841607227921486, -0.007915621623396873, 0.007346763741225004, -0.06000291556119919], [0.29047897458076477, 0.3495854139328003, 0.08970829099416733, -0.04625533148646355, 0.08664414286613464, -0.012169965542852879, 0.154034823179245, 0.02976638823747635, -0.14986860752105713, -0.0742836445569992, 0.18766865134239197, 0.0839305967092514, 0.06592068076133728, -0.06636399030685425, 0.13092182576656342, 0.0016259521944448352, 0.11853698641061783, -0.019028788432478905, 0.06551545113325119, 0.1226564571261406, 0.08782801032066345, 0.04380791634321213, 0.04348073527216911, 0.07377778738737106, 0.03561459481716156, -0.17153067886829376, 0.019137898460030556, 0.10774116218090057, 0.13889391720294952, -0.04526238888502121, -0.009657136164605618, -0.020386449992656708, 0.01581127755343914, -0.16635999083518982, -0.07865779846906662, -0.12164458632469177, -0.06720788031816483, -0.030460309237241745, 0.1601686328649521, -0.06715648621320724, 0.050857607275247574, -0.004764331039041281, 0.21241053938865662, 0.08873336017131805, -0.10517770797014236, 0.015285976231098175, 0.2325303554534912, 0.03902444615960121], [-0.8173958659172058, 0.016514932736754417, 0.07040068507194519, 0.12300294637680054, 0.20635028183460236, 0.27964138984680176, -0.1277802288532257, -0.20343205332756042, 0.09139195084571838, -0.05938305705785751, 0.11029604822397232, 0.11519164592027664, 0.05460979416966438, -0.011038041673600674, -0.09009145200252533, 0.04819618538022041, -0.05645528435707092, -0.010686236433684826, -0.08868911117315292, 0.012776481918990612, -0.03140207752585411, 0.08008205890655518, -0.053400617092847824, -0.06945276260375977, 0.02752775512635708, 0.1253463178873062, 0.24634474515914917, -0.12326078116893768, 0.009118190035223961, 0.0682145282626152, 0.06440912932157516, 0.05264934152364731, -0.07032947987318039, -0.0039203534834086895, -0.07959648966789246, -0.06662581861019135, 0.3606102168560028, -0.19709207117557526, -0.05751193314790726, -0.052799858152866364, 0.0006711130263283849, -0.11236926168203354, 0.10231391340494156, -0.055764347314834595, 0.07893294095993042, 0.1083763837814331, 0.047166671603918076, 0.08119403570890427], [-0.06428635865449905, 0.0068767014890909195, -0.09602152556180954, -0.05184487998485565, -0.05528057739138603, 0.029387416318058968, -0.09696748852729797, -0.06977490335702896, 0.28726327419281006, -0.06562161445617676, -0.08156012743711472, 0.096529521048069, -0.0544009730219841, 0.12297536432743073, 0.12811918556690216, -0.025343820452690125, 0.17549216747283936, 0.14515705406665802, -0.03356314077973366, -0.10020267963409424, 0.22017085552215576, -0.10765592008829117, 0.1413727104663849, -0.21587413549423218, 0.06281711161136627, -0.15083879232406616, -0.05254173278808594, 0.052637871354818344, 0.24068963527679443, -0.12116555124521255, 0.06204070895910263, -0.08852987736463547, -0.21516382694244385, -0.02225686050951481, 0.0006723135011270642, -0.11811788380146027, -0.12179337441921234, 0.0489051416516304, -0.1382136344909668, -0.061442580074071884, -0.08711877465248108, -0.20001855492591858, 0.1484481394290924, -0.02429487556219101, -0.03959367796778679, 0.0007551554590463638, 0.10505859553813934, -0.26200777292251587], [0.006239353679120541, 0.07537396997213364, 0.11259119212627411, 0.046489909291267395, -0.07768021523952484, 0.0047595608048141, -0.6977726817131042, 0.1340075135231018, -0.032328613102436066, -0.027598293498158455, -0.11886931210756302, -0.00805856753140688, 0.1761617809534073, 0.003416429040953517, -0.025826046243309975, -0.09578240662813187, -0.06358204782009125, -0.052330177277326584, -0.0025844150222837925, -0.3611951172351837, -0.02304617501795292, 0.028337957337498665, -0.09579223394393921, -0.13229641318321228, 0.18918746709823608, 0.1064460426568985, -0.13610778748989105, 0.008236821740865707, 0.0321747250854969, 0.1502859890460968, 0.05143240466713905, 0.13527198135852814, 0.009431353770196438, 0.0458432212471962, 0.0021779914386570454, 0.06770465523004532, 0.12722454965114594, -0.050685107707977295, -0.1573798954486847, -0.15714243054389954, 0.08515565097332001, 0.06119569391012192, -0.21842965483665466, -0.0821235403418541, -0.024850336834788322, 0.0663147047162056, 0.05607713386416435, 0.006684643216431141], [0.5522996783256531, 0.025216341018676758, -0.030572405084967613, 0.04455306753516197, 0.08891869336366653, 0.03349453583359718, -0.1248018741607666, 0.02455894649028778, 0.06498634070158005, -0.05037974938750267, 0.03815842792391777, 0.23263151943683624, -0.13705366849899292, -0.034725550562143326, 0.0019181990064680576, 0.1163807213306427, 0.15300996601581573, -0.018107915297150612, 0.10116343200206757, 0.016175534576177597, 0.002398707903921604, -0.015663176774978638, 0.01928497664630413, -0.05956564098596573, -0.05969330295920372, -0.10903779417276382, 0.11075062304735184, 0.08354729413986206, -0.11488843709230423, 0.005793074145913124, -0.030351584777235985, 0.04368997737765312, 0.04058544337749481, 0.08475205302238464, 0.09407341480255127, 0.0774436965584755, -0.12764236330986023, 0.0018449582858011127, -0.001471684081479907, 0.02498037926852703, -0.019339455291628838, 0.11556504666805267, -0.21430093050003052, -0.032610271126031876, 0.046883516013622284, 0.08690257370471954, 0.07517000287771225, 0.05264505743980408], [0.2103244960308075, -0.039724528789520264, -0.03855305165052414, 0.06649111211299896, -0.07480639219284058, -0.17869172990322113, 0.16286562383174896, -0.026500143110752106, -0.1297038048505783, 0.13722486793994904, -0.13152028620243073, -0.2288585603237152, 0.078480064868927, -0.22093094885349274, -0.087338887155056, 0.0015844408189877868, 0.09505375474691391, -0.0960550308227539, 0.05714446306228638, 0.007721319328993559, -0.06779001653194427, 0.12427005916833878, 0.004227235447615385, -0.08525701612234116, -0.055219002068042755, 0.21275050938129425, 0.14177754521369934, -0.023032277822494507, 0.11717653274536133, -0.0872773677110672, -0.08892486989498138, 0.09340103715658188, 0.011816327460110188, -0.06833522021770477, -0.005408361554145813, 0.10599743574857712, 0.24688242375850677, -0.21045735478401184, -0.02103303000330925, 0.037853844463825226, 0.0975821241736412, -0.2034786492586136, 0.06288527697324753, 0.027343057096004486, -0.07910431176424026, 0.12859658896923065, -0.1887151300907135, -0.11233071982860565], [-0.2223983258008957, 0.009036320261657238, -0.10906018316745758, -0.08882814645767212, -0.17320942878723145, 0.12070296704769135, -0.030273091048002243, 0.05619823932647705, -0.09609805047512054, 0.09354976564645767, 0.04948051646351814, 0.08264182507991791, -0.026838557794690132, -0.0016500274650752544, -0.1728135496377945, 0.044493209570646286, -0.22941505908966064, -0.17531655728816986, -0.20445847511291504, -0.08451342582702637, -0.04462498798966408, -0.08509579300880432, 0.04945990815758705, 0.06883366405963898, -0.22905074059963226, -0.23206396400928497, -0.0014181177830323577, 0.07293198257684708, 0.047087062150239944, -0.09021303057670593, -0.07241816073656082, -0.13006748259067535, 0.1268797069787979, 0.050316017121076584, -0.14530496299266815, 0.031185301020741463, -0.13545936346054077, 0.08684813231229782, 0.08416343480348587, -0.09320162981748581, 0.09137941151857376, -0.1475398987531662, 0.008444052189588547, -0.2886352837085724, 0.017571918666362762, -0.21368876099586487, -0.03214056417346001, 0.08403454720973969], [0.2859279215335846, -0.2628118395805359, 0.016974592581391335, -0.10069683194160461, -0.15527963638305664, -0.17372609674930573, -0.004084045998752117, 0.052649982273578644, 0.018223846331238747, 0.08563397079706192, -0.039374470710754395, 0.03357695788145065, 0.012203207239508629, 0.2995527982711792, 0.005452657584100962, -0.02635599486529827, 0.017534708604216576, 0.241715669631958, -0.022478768602013588, 0.01588268205523491, 0.191255122423172, -0.032006796449422836, 0.10528497397899628, 0.19545507431030273, -0.005211212206631899, -0.07194752246141434, 0.04292401298880577, 0.01204763911664486, -0.13953867554664612, 0.034389395266771317, 0.00777769647538662, 0.014158982783555984, 0.11936810612678528, 0.01949802227318287, -0.23695923388004303, 0.15086008608341217, -0.10916869342327118, 0.24930928647518158, 0.02081488072872162, 0.14614447951316833, -0.01365960855036974, 0.10956288874149323, -0.018868451938033104, 0.056647516787052155, 0.048258908092975616, 0.22069232165813446, -0.07887684553861618, 0.07704563438892365], [-0.6712343692779541, 0.1880876123905182, 0.0874578058719635, 0.16440725326538086, 0.1998206079006195, 0.2536558508872986, 0.22539594769477844, 0.008299457840621471, -0.0035310029052197933, -0.04378180578351021, 0.027275674045085907, 0.075589120388031, 0.07952943444252014, -0.1307639330625534, -0.0131028788164258, 0.09934355318546295, 0.10850214213132858, -0.16205568611621857, 0.1753331422805786, 0.05093516781926155, -0.005982616450637579, -0.029069002717733383, -0.09396563470363617, -0.011206752620637417, 0.06994438171386719, -0.03687068819999695, 0.0654899999499321, 0.000270801450824365, 0.0015867764595896006, -0.04179251939058304, -0.02601468563079834, -0.03967640921473503, -0.0607631579041481, 0.04583962634205818, -0.07444306463003159, 0.05567098781466484, -0.5558751821517944, 0.08771482110023499, 0.059606194496154785, 0.17966143786907196, 0.04881931096315384, 0.19265182316303253, -0.10469362884759903, 0.08987069875001907, -0.03318243473768234, 0.1258222609758377, -0.031325146555900574, 0.0547429658472538], [0.1266101598739624, -0.2513827681541443, 0.030591344460844994, 0.08658736944198608, -0.15002788603305817, -0.05728590860962868, 0.07122090458869934, -0.05081002041697502, -0.081364706158638, 0.2803388237953186, -0.17510995268821716, -0.18402118980884552, 0.196997731924057, -0.13889873027801514, 0.07789738476276398, 0.07546855509281158, -0.07918017357587814, -0.16154566407203674, 0.1404138058423996, 0.06688243895769119, -0.0886428952217102, -0.07724792510271072, -0.19809912145137787, 0.012906618416309357, 0.10441676527261734, 0.25753921270370483, 0.0022752885706722736, 0.10173547267913818, -0.09347666054964066, 0.13099989295005798, -0.029585979878902435, -0.059150248765945435, -0.05190010368824005, 0.11755304783582687, -0.05152397230267525, 0.03858686983585358, 0.12374360859394073, 0.22989434003829956, 0.05990404635667801, 0.08907680958509445, 0.14384490251541138, 0.19099818170070648, 0.0347648561000824, -0.05400184541940689, -0.0041673132218420506, 0.1449972242116928, -0.06133788079023361, -0.10175610333681107], [-0.27430278062820435, -0.0995321199297905, 0.14956997334957123, 0.1954672634601593, 0.09261282533407211, 0.03149454668164253, 0.08286532759666443, -0.11413848400115967, 0.0002442880067974329, 0.07308156788349152, 0.025029310956597328, 0.06675609946250916, 0.3093356788158417, -0.13390055298805237, 0.08973002433776855, -0.03908933326601982, 0.11474838852882385, -0.10705786198377609, -0.45099392533302307, 0.13660573959350586, -0.023880138993263245, -0.06507372856140137, 0.002670633839443326, -0.01606689766049385, -0.2313479632139206, 0.11543171852827072, 0.11998294293880463, -0.0257901381701231, 0.1349998563528061, 0.03226499259471893, -0.08418498933315277, -0.03855941817164421, 0.001171479350887239, 0.10102535784244537, -0.20586800575256348, 0.06018318235874176, -0.33465516567230225, 0.10405334085226059, 0.11590074002742767, 0.10014735162258148, 0.062078382819890976, 0.011269664391875267, 0.005380021408200264, -0.15417297184467316, -0.02229115553200245, 0.05452637001872063, 0.14456771314144135, 0.13132405281066895], [0.04903655871748924, 0.2852027118206024, -0.021217862144112587, 0.023520590737462044, 0.0758148729801178, 0.11186905950307846, -0.08027773350477219, 0.046435292810201645, 0.1029675230383873, -0.038904350250959396, 0.25468963384628296, 0.0400397852063179, -0.12200404703617096, 0.3449932634830475, 0.18213039636611938, 0.09151386469602585, 0.0446615107357502, -0.19599410891532898, -0.04064202681183815, 0.061723724007606506, 0.17650173604488373, -0.007569310255348682, -0.042905449867248535, -0.19489648938179016, -0.011486794799566269, -0.1741059273481369, -0.14233867824077606, -0.047607969492673874, -0.1633271425962448, 0.017413118854165077, 0.019223064184188843, -0.02066219225525856, -0.03988632559776306, -0.02035430260002613, 0.053627368062734604, -0.06650560349225998, -0.06788283586502075, 0.00727978115901351, 0.10387282818555832, 0.001076397835277021, 0.23979733884334564, -0.05351438745856285, -0.012470773421227932, -0.020999714732170105, -0.004794038366526365, -0.019619906321167946, -0.041877586394548416, 0.02090424858033657], [-0.4294224977493286, 0.050206031650304794, 0.03376233950257301, 0.05683043971657753, 0.03421247750520706, 0.25976622104644775, -0.06155801936984062, 0.05694320425391197, 0.10882420837879181, 0.01955842413008213, -0.09462094306945801, 0.27644795179367065, -0.39709997177124023, 0.2614683508872986, 0.048381559550762177, 0.056149739772081375, -0.04902318865060806, 0.07586966454982758, -0.06773480772972107, 0.03904227167367935, 0.2427515983581543, 0.06664465367794037, 0.08229762315750122, 0.12663570046424866, 0.0400107316672802, -0.13229483366012573, -0.02248987928032875, 0.13682974874973297, -0.0013995632762089372, -0.09642808139324188, 0.12010221928358078, -0.11860956251621246, 0.09285686910152435, -0.040945667773485184, -0.11402668803930283, 0.06238330155611038, 0.1421022117137909, -0.16515055298805237, 0.03816891089081764, -0.12736265361309052, -0.01608956791460514, -0.01962563581764698, 0.10476374626159668, 0.1317698061466217, 0.017916282638907433, 0.018001355230808258, -0.057857949286699295, -0.0872136577963829], [0.02311418019235134, 0.26617032289505005, -0.11406931281089783, 0.15891358256340027, -0.026227323338389397, -0.07674644887447357, -0.03512364253401756, 0.05472208559513092, -0.03646577522158623, 0.013810289092361927, 0.20587174594402313, 0.01064575370401144, 0.0885230228304863, 0.3323584496974945, 0.08191957324743271, -0.10447262972593307, -0.04354420676827431, -0.10400493443012238, -0.04022466391324997, -0.009188619442284107, -0.11357644945383072, -0.07233063876628876, -0.18826499581336975, -0.014641791582107544, -0.13020634651184082, -0.21517404913902283, -0.0026828432455658913, 0.05249207094311714, -0.22769621014595032, -0.0686022937297821, -0.07895240932703018, 0.005399927031248808, 0.09787432849407196, -0.13241583108901978, -0.057515211403369904, 0.12796500325202942, -0.014450988732278347, 0.30123311281204224, 0.15625552833080292, -0.03402141481637955, -0.020349998027086258, -0.08406750857830048, -0.16246002912521362, 0.2060042768716812, 0.15562696754932404, 0.10224264860153198, -0.19394636154174805, -0.03467278555035591], [0.031728316098451614, 0.14789624512195587, 0.01675686053931713, 0.11665059626102448, 0.005571611225605011, 0.20228609442710876, 0.0561518631875515, -0.005525687709450722, 0.12326829135417938, 0.09353631734848022, 0.12126003950834274, -0.08611108362674713, -0.21157947182655334, 0.10319401323795319, -0.1187518984079361, 0.024216534569859505, -0.13784542679786682, 0.02667061612010002, -0.00973376352339983, 0.021810457110404968, -0.055106986314058304, -0.051376841962337494, 0.11253231018781662, 0.09535708278417587, -0.11223812401294708, -0.02706286683678627, 0.00942271575331688, -0.08866482973098755, -0.05214479938149452, -0.01954650692641735, 0.1007792130112648, 0.09002654254436493, -0.14281558990478516, 0.05820050463080406, 0.14410097897052765, 0.06391215324401855, -0.514265239238739, 0.3058238923549652, -0.30279818177223206, -0.03343521058559418, 0.1494026780128479, 0.20708312094211578, 0.05259430781006813, 0.13237078487873077, -0.19836334884166718, 0.04721326753497124, 0.11224865913391113, 0.10581322759389877], [-0.03803841769695282, -0.014407440088689327, 0.019526122137904167, 0.14591966569423676, -0.1335746794939041, -0.017533019185066223, -0.08166766911745071, -0.1554640382528305, -0.1714024543762207, -0.05161082744598389, -0.1683955192565918, -0.11157228797674179, -1.0891904830932617, -0.23814277350902557, -0.1908247172832489, -0.0840986967086792, 0.09449508041143417, -0.19159740209579468, -0.028280887752771378, 0.033554524183273315, -0.2054423838853836, 0.00635575084015727, 0.08126306533813477, -0.002691441448405385, -0.020001040771603584, 0.19553296267986298, 0.21619831025600433, -0.07238031178712845, 0.11972969770431519, 0.052168939262628555, -0.03152408450841904, -0.04191214218735695, 0.088669054210186, 0.028368985280394554, -0.08962374925613403, 0.06358088552951813, -0.10547628253698349, 0.0806659683585167, -0.13983456790447235, 0.16996227204799652, 0.09058770537376404, 0.128319650888443, -0.19389742612838745, -0.023680124431848526, 0.13195708394050598, 0.03256428614258766, 0.014339249581098557, 0.07902085781097412], [0.21929951012134552, 0.12251606583595276, 0.15023283660411835, 0.10446375608444214, -0.091552734375, -0.09087983518838882, -0.024322493001818657, -0.05295804142951965, 0.03251347318291664, 0.10792458802461624, 0.028794119134545326, -0.05674363672733307, -0.03775569051504135, 0.013003640808165073, -0.09258965402841568, 0.00579817732796073, -0.03964341804385185, -0.03348894417285919, 0.12237640470266342, -0.041702136397361755, -0.1371566355228424, -0.09525030851364136, 0.12552587687969208, -0.04018501564860344, -0.08664919435977936, 0.050984937697649, -0.15012402832508087, 0.07737132906913757, 0.17751380801200867, 0.2091384083032608, 0.3075174391269684, -0.18540821969509125, -0.0777633935213089, -0.06691716611385345, 0.005133535247296095, -0.13671556115150452, 0.42826417088508606, -0.008105942979454994, 0.16702017188072205, 0.13098320364952087, -0.1420336663722992, 0.0010180836543440819, 0.36746448278427124, 0.10720103979110718, -0.021473055705428123, 0.14228329062461853, -0.10707791894674301, -0.06776750832796097], [-0.18130619823932648, 0.08920648694038391, -0.02135000005364418, 0.007030832581222057, 0.03392699360847473, 0.09260243922472, -0.04835236445069313, -0.02230963483452797, -0.09764283895492554, -0.0011278776219114661, 0.08378064632415771, -0.04039377719163895, 0.021320467814803123, -0.06318656355142593, 0.013868022710084915, 0.12854309380054474, 0.10256224870681763, 0.04525146260857582, 0.04691053181886673, -0.07386387139558792, -0.07665056735277176, -0.1540345698595047, -0.09247523546218872, 0.12438372522592545, -0.10484806448221207, -0.07391032576560974, -0.008119908161461353, 0.06759918481111526, -0.08947721123695374, 0.11949983239173889, 0.09875696152448654, -0.08677101880311966, 0.03130827844142914, 0.1035231202840805, 0.07674185931682587, -0.089644655585289, -0.05204104259610176, 0.07768329977989197, -2.4356675567105412e-05, 0.06192963570356369, 0.07630710303783417, 0.01864301785826683, 0.07764953374862671, -0.056693002581596375, -0.009327741339802742, 0.05598948523402214, -0.16736643016338348, 0.02124921977519989], [-0.03256544843316078, 0.3387259840965271, 0.007746255956590176, 0.08111309260129929, 0.28739508986473083, 0.22712290287017822, 0.06014658138155937, 0.08655715733766556, 0.050539374351501465, -0.08562662452459335, 0.21621328592300415, 0.026822343468666077, 0.05145525932312012, -0.07703195512294769, -0.05519512668251991, 0.055490825325250626, 0.12638157606124878, 0.09015829116106033, 0.06180290877819061, 0.05300780385732651, -0.04174165055155754, 0.033564336597919464, 0.14604799449443817, 0.06702569872140884, 0.0033475919626653194, -0.13511545956134796, -0.09904221445322037, 0.09626606106758118, 0.1612757295370102, 0.1659185290336609, -0.013312934897840023, -0.0558939166367054, -0.04958066716790199, 0.018351687118411064, 0.21924567222595215, 0.12428568303585052, -0.16973665356636047, 0.13486915826797485, -0.05805821344256401, -0.052864063531160355, -0.15761971473693848, 0.11996836215257645, 0.03670802339911461, 0.027667418122291565, 0.21176272630691528, -0.0027039707638323307, 0.16752643883228302, 0.029783396050333977], [-0.13386793434619904, 0.2723090350627899, -0.07147806137800217, -0.13414928317070007, 0.1033410131931305, 0.05138034746050835, -0.010352766141295433, 0.22772416472434998, -0.01358863152563572, -0.06402324885129929, -0.08947595953941345, 0.1668330878019333, -0.08350846916437149, 0.0403231643140316, -0.04562665522098541, 0.02219530940055847, -0.2033933699131012, 0.029293572530150414, -0.07290063053369522, -0.10493951290845871, 0.0744803249835968, -0.01822676882147789, 0.08107299357652664, -0.020776350051164627, -0.06892351061105728, -0.04365911707282066, 0.10023496299982071, -0.13463474810123444, -0.08647699654102325, -0.05913088843226433, -0.1681414395570755, 0.03464799001812935, -0.08890558034181595, -0.10477722436189651, 0.17148081958293915, 0.16477908194065094, -0.007905122824013233, 0.13728222250938416, -0.04260002076625824, 0.15858295559883118, 0.08768091350793839, 0.037831861525774, -0.11155875027179718, 0.1606835573911667, -0.24407291412353516, 0.2061338722705841, -0.0014867812860757113, 0.10644639283418655], [-0.757254958152771, 0.3369382321834564, 0.15296748280525208, 0.13001561164855957, 0.15667885541915894, 0.25525736808776855, 0.004095734562724829, 0.15179190039634705, 0.04964672401547432, 0.03418828547000885, 0.060811739414930344, 0.12016821652650833, -0.012020065449178219, -0.07002294063568115, 0.12289859354496002, 0.06398814171552658, -0.027838580310344696, 0.007443849463015795, 0.08175987005233765, 0.005989706609398127, -0.11970691382884979, 0.09136597812175751, 0.030559329316020012, 0.0452527180314064, -0.08509689569473267, 0.18624097108840942, 0.09450153261423111, 0.10412310808897018, 0.05355997756123543, 0.09539104253053665, -0.11445945501327515, 0.002932086819782853, 0.07274726033210754, 0.09895449131727219, 0.10746704041957855, 0.11290081590414047, -0.12807345390319824, 0.07743687182664871, -0.11504867672920227, 0.08300485461950302, 0.012408333830535412, -0.1052188128232956, 0.08917832374572754, -0.06648963689804077, 0.139866441488266, 0.010476198047399521, 0.10024083405733109, 0.11436523497104645], [0.28673264384269714, -0.2760382294654846, -0.03995348885655403, -0.01524947490543127, -0.0947161391377449, -0.08566024899482727, 0.023382170125842094, -0.03023291379213333, 0.12468674778938293, 0.23032420873641968, 0.018532907590270042, -0.08031812310218811, -0.18629111349582672, 0.2040846347808838, 0.057410284876823425, -0.05387107655405998, 0.1227499395608902, 0.09849879145622253, 0.16130578517913818, -0.12415631115436554, 0.1560865342617035, 0.0500280037522316, -0.009611758403480053, 0.09562785923480988, -0.08849582076072693, 0.12027287483215332, -0.08448252081871033, 0.029736267402768135, 0.07660803943872452, 0.017868323251605034, 0.09880625456571579, -0.13369712233543396, 0.030330633744597435, -0.05679731443524361, 0.06589853018522263, 0.09315591305494308, 0.08451647311449051, -0.08149997889995575, 0.04312676936388016, 0.023558668792247772, 0.06942928582429886, -0.14209510385990143, 0.20292355120182037, 0.10715708136558533, -0.05116179585456848, 0.00039729467243887484, -0.2387228012084961, -0.02623477205634117], [0.18612104654312134, -0.044569190591573715, 0.21957828104496002, 0.03298042714595795, -0.06072982773184776, -0.16801214218139648, 0.19689305126667023, -0.031700100749731064, 0.034135960042476654, 0.14917689561843872, -0.1344980001449585, -0.06281773746013641, 0.02478346787393093, -0.043284863233566284, 0.08772235363721848, 0.07118919491767883, 0.06835266947746277, 0.014473365619778633, -0.12113861739635468, 0.045151062309741974, 0.025911908596754074, -0.10337340831756592, 0.07743562012910843, 0.07050073146820068, 0.051710765808820724, 0.06888022273778915, -0.05897156149148941, -0.06266079843044281, 0.09103944897651672, -0.02620011195540428, 0.19657789170742035, -0.11883769929409027, -0.18224546313285828, 0.027956441044807434, -0.04103945195674896, -0.014332489110529423, 0.538942277431488, -0.027334172278642654, 0.06807686388492584, 0.08788668364286423, -0.05676086246967316, -0.010126117616891861, -0.7299783825874329, 0.07301390171051025, 0.07994350045919418, 0.13804437220096588, -0.24950763583183289, -0.2155025452375412], [0.1618068367242813, -0.07521952688694, 0.14695830643177032, 0.14900793135166168, -0.18272747099399567, -0.09661596268415451, 0.08879399299621582, -0.14941440522670746, 0.10477551817893982, 0.29580599069595337, -0.1782425194978714, 0.0016338269924744964, 0.17198729515075684, -0.14883047342300415, 0.13005715608596802, 0.03504437953233719, -0.05944669619202614, -0.08504952490329742, 0.12294591218233109, -0.13746632635593414, 0.0556950606405735, -0.002306184032931924, -0.06089066341519356, -0.0382436141371727, -0.12207964062690735, 0.02811998873949051, -0.08701471239328384, 0.07875192910432816, -0.05805158242583275, -0.20402194559574127, 0.01919122226536274, -0.07891403138637543, 0.17435407638549805, -0.027993999421596527, 0.13035503029823303, 0.20274068415164948, -0.2507740557193756, 0.3022333085536957, 0.21979041397571564, -0.08726856112480164, 0.22408320009708405, 0.15507666766643524, -0.019366495311260223, 0.08178068697452545, 0.05638817325234413, -0.02782205119729042, -0.0481165274977684, -0.09833242744207382], [0.06996919214725494, -0.09330130368471146, -0.30356770753860474, -0.045740336179733276, -0.0549783892929554, -0.26778778433799744, -0.03467778488993645, -0.14309075474739075, -0.3127564489841461, 0.027491677552461624, 0.21143637597560883, -0.02478482574224472, -0.027098193764686584, 0.0006126156658865511, -0.07566830515861511, -0.018423791974782944, -0.14818963408470154, -0.0790010541677475, -0.07332991063594818, -0.0013191231992095709, -0.21220389008522034, 0.04275922477245331, 0.040004994720220566, -0.10296377539634705, -0.07593679428100586, -0.19129669666290283, -0.07297392934560776, 0.14187638461589813, 0.07823282480239868, -0.08193295449018478, -0.08924683183431625, -0.09164980798959732, 0.3170933425426483, 0.17053700983524323, 0.03723663464188576, -0.04689391702413559, 0.08059581369161606, 0.038752481341362, 0.3279254734516144, 0.10761687904596329, -0.1566789746284485, 0.0379917211830616, -0.17006300389766693, -0.08852066844701767, 0.32809191942214966, -0.09552432596683502, 0.10071612149477005, 0.05487953871488571], [-0.2091432809829712, 0.15154151618480682, 0.2526122033596039, -0.11060195416212082, -0.00043876140262000263, -0.1835622638463974, -0.09474241733551025, -0.2041338086128235, 0.3534160852432251, 0.11658984422683716, -0.060184527188539505, 0.05296028032898903, -0.005198738072067499, -0.07919853925704956, 0.2269541174173355, -0.0626211017370224, 0.1485075205564499, -0.03010804019868374, -0.2211751937866211, 0.004456430673599243, 0.05669202283024788, -0.14663450419902802, -0.057648152112960815, -0.060208242386579514, -0.08179572224617004, -0.10487688332796097, -0.26994046568870544, -0.1829380989074707, -0.146131694316864, 0.0522950179874897, 0.1754721701145172, -0.06155828386545181, 0.0003681277157738805, -0.009199860505759716, -0.0200326107442379, -0.02683480829000473, -0.0345914363861084, -0.07940036803483963, -0.17863722145557404, 0.20255254209041595, -0.016411785036325455, 0.002167506143450737, -0.12551671266555786, 0.0730087012052536, 0.19981317222118378, -0.08343232423067093, 0.010973680764436722, -0.1615143120288849], [0.24693050980567932, -0.13418129086494446, -0.055043935775756836, -0.04540996253490448, 0.03898638114333153, -0.10204534977674484, 0.19832122325897217, -0.09318393468856812, -0.005871154367923737, 0.26495057344436646, -0.22040364146232605, -0.14977248013019562, 0.02690771594643593, -0.18431562185287476, -0.07821033895015717, -0.09662418812513351, 0.055157002061605453, 0.07021818310022354, 0.07824382930994034, 0.07756262272596359, -0.04541098698973656, 0.1667306274175644, -0.10348927974700928, -0.12995967268943787, 0.09723106771707535, 0.16360948979854584, 0.0040229191072285175, 0.03242504224181175, 0.009995647706091404, 0.15220056474208832, 0.1444980353116989, 0.062275130301713943, 0.11007148772478104, 0.08754197508096695, -0.012102789245545864, -0.036749307066202164, -0.00593949668109417, -0.0965057983994484, -0.05043962225317955, -0.0445510670542717, -0.17833179235458374, -0.08393307775259018, 0.22402426600456238, 0.01420322060585022, -0.1111500933766365, 0.10358727723360062, -0.08466500788927078, 0.057913150638341904]], "net.0.bias": [-0.07686594128608704, 0.054633669555187225, 0.14570491015911102, 0.009870201349258423, -0.06221441552042961, -0.08698424696922302, -0.1664418876171112, -0.05062595754861832, -0.16656291484832764, 0.07148990780115128, -0.13923892378807068, 0.0041718934662640095, -0.0062460084445774555, -0.06600573658943176, -0.08787567913532257, -0.1686035841703415, -0.053275201469659805, -0.03314567357301712, 0.12825773656368256, -0.05595942214131355, 0.044775381684303284, 0.0989551916718483, 0.05367647483944893, -0.17211972177028656, 0.014344356022775173, -0.17343497276306152, -0.005687093362212181, -0.12927912175655365, 0.046242605894804, 0.09260962903499603, -0.09209824353456497, 0.00900818221271038, 0.08748167753219604, -0.03670163080096245, -0.019612688571214676, -0.011168286204338074, -0.14253219962120056, 0.09135394543409348, 0.06165025010704994, -0.04806336760520935, 0.08668094128370285, -0.09119065850973129, 0.20858439803123474, 0.20463880896568298, -0.04620341584086418, 0.18558837473392487, 0.08027813583612442, -0.00969308614730835, 0.03031316213309765, 0.13752222061157227, 0.09678158164024353, 0.1399097889661789, 0.10559166967868805, -0.012998199090361595, -0.16503643989562988, 0.14638972282409668, -0.06422664225101471, -0.07616075873374939, 0.18231678009033203, 0.1644906997680664, -0.013710057362914085, -0.19416025280952454, -0.07423873245716095, 0.19408053159713745], "net.2.weight": [[-0.04344195872545242, 0.08787228912115097, 0.2397899329662323, 0.05836891755461693, 0.009379819966852665, -0.0439777709543705, -0.05987492948770523, -0.03318217396736145, -0.16062118113040924, -0.10409803688526154, 0.06275751441717148, 0.24913187325000763, 0.15711483359336853, -0.1519126296043396, 0.00806177593767643, -0.014967022463679314, -0.028467025607824326, 0.07256308943033218, 0.19757862389087677, -0.11203914135694504, -0.10240460932254791, 0.1792643517255783, 0.06491772085428238, -0.04973609372973442, 0.05774156376719475, -0.1476355791091919, 0.19680680334568024, -0.1746741384267807, 0.06142999231815338, -0.044088657945394516, -0.0985834077000618, 0.37441524863243103, 0.21682196855545044, 0.03560825064778328, -0.042601197957992554, 0.0513545498251915, 0.46692612767219543, -0.043553031980991364, -0.08082068711519241, -0.109462670981884, 0.15247488021850586, -0.43193700909614563, 0.3523319363594055, -0.23264804482460022, -0.09351959824562073, -0.11619240045547485, 0.09862082451581955, -0.03827759996056557, -0.20262569189071655, -0.23055842518806458, 0.004223571624606848, -0.07181929051876068, 0.12429287284612656, 0.06979093700647354, 0.06700300425291061, -0.1971728652715683, -0.024640081450343132, -0.01100220438092947, 0.16354544460773468, 0.055037710815668106, 0.121768519282341, -0.17719882726669312, -0.27804630994796753, 0.31028804183006287], [0.0997234433889389, -0.15844634175300598, -0.07024186849594116, -0.0018774885684251785, -0.1423559933900833, 0.02943582832813263, -0.023503512144088745, -0.02516188658773899, -0.06336057931184769, 0.09387552738189697, 0.08488050103187561, -0.010982451029121876, 0.10431051254272461, -0.04997687041759491, 0.029123976826667786, -0.07618995755910873, -0.07923347502946854, 0.11244970560073853, -0.16312474012374878, -0.07326400279998779, -0.019483240321278572, 0.0024903551675379276, -0.08126776665449142, -0.03580910339951515, -0.039953429251909256, -0.06855110824108124, -0.14884361624717712, -0.05536313354969025, 0.09457319974899292, -0.11732220649719238, -0.13787801563739777, -0.036688432097435, -0.17356155812740326, -0.05910782888531685, -0.15138591825962067, 0.043982136994600296, 0.06301862001419067, -0.05426747724413872, 0.03330416604876518, -0.024289119988679886, 0.026580648496747017, 0.03662163019180298, 0.02655688114464283, -0.12343345582485199, -0.025200653821229935, -0.013215320184826851, 0.0697612315416336, -0.11035346984863281, -0.09112709760665894, -0.07301846891641617, -0.013127390295267105, 0.005953988526016474, 0.05817476287484169, -0.07393289357423782, -0.005418494343757629, -0.0461074523627758, 0.07710728049278259, -0.13001561164855957, -0.059910375624895096, -0.11808408051729202, -0.05526282638311386, -0.002408042550086975, 0.02984149381518364, 0.03369847685098648], [0.061845406889915466, -0.08034716546535492, -0.03062720037996769, -0.012622586451470852, 0.22642427682876587, 0.030080659314990044, -0.09667627513408661, 0.1180717870593071, 0.2953545153141022, -0.015237892046570778, -0.05062536522746086, 0.009324504993855953, -0.03752248361706734, -0.13599923253059387, -0.04181671142578125, -0.26367005705833435, -0.00019348933710716665, -0.041069913655519485, 0.09731274098157883, 0.17395547032356262, 0.0009503911715000868, 0.09566857665777206, 0.25440171360969543, 0.1560194045305252, 0.07449723035097122, 0.16783970594406128, 0.20940063893795013, -0.2588890492916107, 0.08692605048418045, -0.02881479263305664, 0.1599496304988861, -0.04178750514984131, 0.1129893958568573, 0.009043036960065365, -0.2148188054561615, -0.009936163201928139, 0.26655682921409607, -0.2079721987247467, 0.04330213740468025, -0.1142229214310646, 0.2850653827190399, -0.351791650056839, 0.03930019587278366, 0.0649307370185852, -0.040508776903152466, -0.1564195305109024, 0.042135413736104965, 0.02714904397726059, -0.22371844947338104, -0.17192167043685913, 0.1274758279323578, 0.17098544538021088, -0.18589352071285248, -0.13802114129066467, -0.03704778477549553, 0.013541742227971554, 0.0722440630197525, 0.08667571097612381, -0.021224023774266243, 0.02234254963696003, 0.17372219264507294, 0.13673579692840576, -0.09298840910196304, 0.02507839724421501], [0.1397867202758789, 0.021636145189404488, -0.047566771507263184, 0.07761161774396896, -0.00020137100364081562, 0.10740655660629272, -0.10536922514438629, -0.055546969175338745, 0.19955085217952728, 0.17779400944709778, -0.1040356308221817, -0.007723463699221611, -0.09949346631765366, 0.17171628773212433, -0.11267859488725662, 0.06693491339683533, 0.23459585011005402, 0.172667995095253, -0.08560662716627121, 0.2601780295372009, 0.10363389551639557, 0.13359279930591583, -0.10559204965829849, 0.20760108530521393, 0.0701262354850769, 0.17286774516105652, -0.16808973252773285, 0.33627212047576904, 0.17881351709365845, 0.17057892680168152, 0.009611178189516068, 0.09602160006761551, 0.01651134341955185, 0.1580989956855774, 0.2888880670070648, -0.025032293051481247, -0.417391300201416, 0.050492510199546814, 0.13577695190906525, 0.2146834135055542, -0.14812235534191132, 0.1783653050661087, -0.2978030741214752, 0.3165707290172577, 0.21574217081069946, 0.182784304022789, -0.1420980989933014, -0.06052124500274658, 0.24874761700630188, 0.09300310164690018, 0.21821211278438568, 0.09906547516584396, 0.13425958156585693, -0.007177559658885002, 0.09972897171974182, 0.30472758412361145, 0.2933119237422943, 0.21826978027820587, -0.07214955240488052, -0.03814234584569931, -0.005326511804014444, 0.07893092930316925, 0.25079652667045593, -0.1666170358657837], [0.040743354707956314, 0.20438221096992493, 0.11147013306617737, 0.04668984189629555, 0.16343139111995697, -0.19826102256774902, -0.05049733445048332, -0.00541776604950428, -0.2044902741909027, -0.06414416432380676, -0.009303679689764977, 0.25016456842422485, 0.1320333182811737, -0.2598717510700226, 0.15884828567504883, -0.12187758088111877, -0.11975926160812378, -0.1563412994146347, 0.2333960384130478, -0.18177393078804016, 0.24173831939697266, 0.05279640480875969, -0.27104631066322327, -0.150363028049469, 0.00618927413597703, -0.05474170297384262, -0.035537831485271454, -0.14326176047325134, 0.20831602811813354, 0.11415904015302658, -0.05755960941314697, 0.06189466267824173, 0.08904899656772614, -0.04084872826933861, -0.07959768921136856, -0.0185605026781559, 0.21664729714393616, -0.03734375163912773, 0.1307465136051178, -0.34795716404914856, 0.040963560342788696, 0.3596440255641937, 0.1303945630788803, -0.12186425179243088, -0.15051953494548798, 0.06896292418241501, 0.05872850492596626, 0.19942332804203033, -0.1342504769563675, -0.1125502735376358, -0.12424221634864807, -0.14433123171329498, 0.021390745416283607, 0.008416212163865566, -0.036118678748607635, -0.04147408902645111, 0.18914972245693207, 0.29526063799858093, 0.014266165904700756, 0.18004290759563446, -0.029809344559907913, -0.17729762196540833, 0.045095931738615036, 0.22491581737995148], [-0.23527833819389343, -0.1389603614807129, 0.21721918880939484, -0.14372895658016205, 0.029827257618308067, 0.17527621984481812, 0.10174117982387543, 0.17791736125946045, -0.24834167957305908, 0.21754145622253418, 0.09236523509025574, 0.15215550363063812, -0.04116445779800415, 0.1778956800699234, 0.0912683755159378, 0.2957993745803833, 0.2284594029188156, 0.283114492893219, -0.22961781919002533, -0.26431819796562195, -0.23150500655174255, -0.13138914108276367, -0.1960449367761612, -0.04655478149652481, -0.007437658496201038, -0.0929935947060585, -0.25137096643447876, 0.21444232761859894, -0.22699891030788422, 0.10303139686584473, -0.1626138836145401, -0.2363162785768509, 0.03484104201197624, 0.1333732157945633, 0.22988532483577728, 0.20321637392044067, 0.11985607445240021, -0.28353071212768555, -0.45480501651763916, 0.21862080693244934, -0.05754570662975311, -0.3301783800125122, -0.1222948506474495, 0.021436139941215515, 0.22310538589954376, -0.2247133105993271, 0.07424580305814743, -0.07430142164230347, 0.20570164918899536, 0.14103274047374725, 0.24905727803707123, 0.02707558125257492, -0.1393081098794937, 0.004445700440555811, 0.06755518913269043, -0.10424327850341797, 0.02879667840898037, -0.1604166477918625, 0.05986257642507553, 0.25036707520484924, -0.025822661817073822, -0.34146901965141296, 0.15652017295360565, -0.14603419601917267], [0.10035420209169388, -0.10155168175697327, 0.038828056305646896, 0.09418737143278122, -0.03309965506196022, 0.06701620668172836, 0.07193031907081604, 0.11653062701225281, 0.19936835765838623, 0.03225940465927124, -0.1199071854352951, -0.07691311091184616, -0.11513953655958176, -0.2810100018978119, -0.3311760127544403, -0.311755508184433, 0.2134222537279129, -0.30328240990638733, 0.08765912055969238, 0.15746431052684784, -0.07862929254770279, 0.04536459222435951, 0.33540961146354675, 0.15274393558502197, -0.025229565799236298, 0.10081440955400467, 0.14950834214687347, -0.17514726519584656, 0.23504863679409027, -0.08989439904689789, 0.20861323177814484, 0.10554565489292145, 0.02852107398211956, 0.11733994632959366, -0.0113386120647192, 0.052076131105422974, -0.19310149550437927, 0.2621628940105438, -0.1728513091802597, 0.023927712813019753, 0.1589498370885849, 0.4114088714122772, -0.136321559548378, 0.2044616937637329, 0.026104621589183807, 0.20687830448150635, -0.10678476840257645, 0.20651525259017944, -0.10168177634477615, 0.09624435007572174, 0.10701557248830795, 0.2326345592737198, 0.07695665955543518, -0.3655916154384613, -0.07295957952737808, 0.1953113079071045, 0.17789722979068756, 0.07369743287563324, -0.018472418189048767, -0.1697678416967392, 0.23947468400001526, 0.3126829266548157, 0.15620124340057373, -0.08653731644153595], [-0.12148311734199524, 0.04073421657085419, 0.11624091863632202, 0.11825595796108246, 0.05020016431808472, 0.10035465657711029, -0.12118200957775116, 0.05080612003803253, -0.005777224898338318, 0.00242730975151062, -0.10540562868118286, -0.12067601084709167, 0.0409872829914093, -0.0006097704172134399, 0.11470049619674683, -0.11104899644851685, 0.004165768623352051, -0.0025383830070495605, -0.07914315164089203, -0.10315105319023132, -0.08146736025810242, -0.05706460773944855, 0.0691346824169159, 0.009744256734848022, -0.029352247714996338, 0.008015096187591553, 0.0420139878988266, -0.04402710497379303, -0.03308425843715668, -0.03723213076591492, 0.10835574567317963, -0.1152460128068924, 0.09993413090705872, -0.07727460563182831, -0.09610053896903992, -0.0782470852136612, 0.10011635720729828, -0.08222223818302155, -0.0653509795665741, 0.10267896950244904, -0.016150012612342834, -0.036944448947906494, -0.0388484001159668, 0.04469896852970123, -0.003936782479286194, -0.10866056382656097, 0.0529799610376358, 0.11492235958576202, 0.03743515908718109, -0.09000533819198608, 0.022847533226013184, -9.688735008239746e-05, -0.030377358198165894, -0.07598738372325897, -0.11174964904785156, -0.12284326553344727, 0.042464300990104675, -0.08565157651901245, 0.07362352311611176, -0.03420260548591614, -0.08371753990650177, 0.09564150869846344, -0.03774304687976837, 0.054574280977249146], [0.1861657351255417, 0.06526555120944977, -0.17218323051929474, 0.21368353068828583, 0.012560986913740635, -0.06443484872579575, -0.004483095370233059, 0.20514579117298126, 0.3084264397621155, 0.015798360109329224, -0.1432916224002838, -0.09530935436487198, 0.19505919516086578, -0.09024112671613693, -0.3255634605884552, -0.4689934253692627, 0.11290549486875534, -0.11245593428611755, 0.22370316088199615, 0.12314847111701965, -0.023340141400694847, 0.13864901661872864, 0.292336106300354, 0.17303049564361572, -0.4605647027492523, 0.24372892081737518, 0.028367334976792336, -0.10416301339864731, 0.03974504768848419, -0.08605461567640305, 0.23253165185451508, 0.03018033318221569, 0.13845884799957275, 0.11029684543609619, -0.1440952718257904, 0.13935421407222748, -0.008152926340699196, 0.16817860305309296, -0.07074565440416336, -0.17410880327224731, -0.11665304750204086, 0.24301166832447052, -0.08475302904844284, -0.03966355323791504, 0.1259389966726303, 0.24229034781455994, 0.08407200872898102, 0.21912677586078644, -0.11728087812662125, -0.04547051340341568, 0.02275793068110943, 0.12002388387918472, 0.0058278776705265045, -0.0036490175407379866, -0.012904430739581585, 0.15188252925872803, 0.26146331429481506, 0.14881666004657745, 0.11183855682611465, -0.22867409884929657, 0.1251320093870163, 0.255649209022522, -0.08292634785175323, -0.10301320999860764], [0.0442143939435482, -0.1769019365310669, 0.10145900398492813, -0.20393304526805878, -0.20706287026405334, 0.20387713611125946, -0.06998006254434586, 0.22421927750110626, 0.39638009667396545, 0.04988516867160797, 0.09459874778985977, -0.24851807951927185, -0.17518460750579834, 0.12119664996862411, -0.061614491045475006, -0.24099090695381165, 0.07016956806182861, 0.021820273250341415, 0.036744337528944016, 0.2382054477930069, -0.1950587034225464, 0.15856964886188507, 0.2656143605709076, 0.20619887113571167, 0.06786681711673737, 0.19116516411304474, -0.08848334848880768, -0.1458938717842102, 0.011930622160434723, -0.1816890984773636, 0.11688854545354843, 0.019443506374955177, 0.02554032765328884, 0.160976842045784, 0.01335007045418024, 0.059741631150245667, -0.08996584266424179, -0.1251114010810852, -0.0557071715593338, 0.17029651999473572, -0.05680015683174133, -0.27713096141815186, -0.04017538204789162, 0.2994214594364166, 0.18978729844093323, 0.08597743511199951, -0.06776735931634903, 0.07265466451644897, 0.10800839215517044, -0.09145283699035645, 0.14472219347953796, 0.13178971409797668, 0.267861932516098, -0.23192785680294037, 0.06699878722429276, 0.038388170301914215, 0.09139949828386307, -0.08236594498157501, -0.0053616976365447044, -0.05892900750041008, 0.2468799650669098, 0.41454973816871643, -0.061688702553510666, 0.008227386511862278], [0.12419463694095612, -0.33301931619644165, 0.1434706449508667, -0.01835126429796219, -0.021847454831004143, 0.2026091068983078, 0.07602834701538086, -0.014415795914828777, -0.09136339277029037, 0.10470698028802872, -0.029013052582740784, 0.15660491585731506, -0.010931911878287792, -0.07941390573978424, -0.11276519298553467, 0.6659471392631531, 0.17708763480186462, -0.11702509224414825, -0.19126668572425842, -0.125858336687088, -0.05509590357542038, -0.045079998672008514, -0.08645180612802505, -0.02513675019145012, 0.06746747344732285, 0.09349282085895538, -0.043157849460840225, -0.07194354385137558, -0.11712107807397842, -0.23992407321929932, -0.249861940741539, 0.09848886728286743, -0.10515253245830536, 0.16405771672725677, -0.010097181424498558, -0.08326136320829391, 0.27031540870666504, -0.002888474613428116, 0.07708267122507095, 0.06308986991643906, -0.07083109021186829, -0.2843489944934845, -0.07912659645080566, 0.05260832980275154, 0.08425936847925186, -0.2410641759634018, -0.006482857279479504, -0.012940430082380772, 0.03188076242804527, 0.035017143934965134, -0.15352605283260345, -0.086809903383255, -0.2577653229236603, 0.17933842539787292, -0.15170453488826752, 0.1293814778327942, -0.07532494515180588, -0.004990795161575079, 0.13475503027439117, -0.20288878679275513, 0.15553127229213715, 0.10123852640390396, 0.04912721365690231, 0.05604032427072525], [-0.15674644708633423, -0.0722571536898613, 0.21166037023067474, -0.3020995557308197, -0.03666182607412338, 0.13475048542022705, 0.03535717353224754, 0.14392364025115967, -0.0317448154091835, 0.22857096791267395, 0.06884565949440002, 0.1877760887145996, -0.2141190618276596, 0.34306344389915466, 0.023848429322242737, 0.1561645120382309, 0.130979984998703, 0.16778340935707092, -0.21580103039741516, -0.09306708723306656, -0.12548336386680603, -0.04351438581943512, 0.07458675652742386, -0.041822247207164764, 0.12489748001098633, 0.030344923958182335, -0.04446360096335411, 0.21103818714618683, -0.13967056572437286, 0.07962591201066971, 0.025867117568850517, -0.020707018673419952, -0.020263541489839554, 0.22488188743591309, 0.20480364561080933, 0.2128484845161438, 0.027839170768857002, -0.11717584729194641, -0.1734955906867981, 0.30009278655052185, -0.14465688169002533, -0.3035377860069275, 0.03087819740176201, -0.06193694472312927, 0.22991527616977692, -0.13528257608413696, 0.1027146428823471, -0.21304646134376526, 0.08902907371520996, 0.11014168709516525, -0.0316353477537632, 0.1507442146539688, 0.30529287457466125, -0.00907798670232296, -0.028644984588027, -0.01573924906551838, 0.04755645990371704, -0.19374309480190277, 0.21551869809627533, 0.17531158030033112, 0.12139775604009628, -0.20617906749248505, -0.053124427795410156, 0.10526517033576965], [0.00022509967675432563, -0.049403201788663864, -0.023769760504364967, 0.05990273505449295, 0.08914095908403397, -0.22239872813224792, 0.017459062859416008, -0.003921111114323139, 0.2803417444229126, -0.037689339369535446, 0.018007654696702957, -0.11930672079324722, 0.028713097795844078, -0.2336636483669281, -0.25942566990852356, -0.49570992588996887, 0.16895052790641785, -0.04143964499235153, 0.06768067926168442, 0.2831178307533264, 0.06702294945716858, 0.22719736397266388, 0.12434815615415573, 0.07591059058904648, -0.11055595427751541, 0.23743966221809387, 0.09947340190410614, -0.21263958513736725, 0.02356911078095436, -0.006463109515607357, 0.0051966458559036255, 0.09133289009332657, 0.19188439846038818, -0.06700752675533295, -0.06781741231679916, 0.024176375940442085, -0.04378354549407959, 0.12001421302556992, -0.0807160884141922, -0.055752404034137726, 0.09817316383123398, 0.09368433803319931, -0.03599688410758972, 0.18542565405368805, -0.032351091504096985, 0.2260196954011917, -0.03860074281692505, 0.2420586347579956, 0.018493613228201866, -0.03590347617864609, 0.01165683101862669, 0.23540596663951874, -0.05513373762369156, -0.12125972658395767, -0.09542442858219147, 0.19524094462394714, 0.263256311416626, 0.2378503531217575, -0.057413458824157715, -0.3032958209514618, 0.19472242891788483, 0.35372117161750793, 0.13315297663211823, -0.024297257885336876], [-0.0853172317147255, -0.13445700705051422, 0.19335594773292542, -0.1468585580587387, 0.025894874706864357, 0.1958203762769699, -0.018850944936275482, 0.14794428646564484, -0.013425665907561779, 0.1651056408882141, 0.08086718618869781, 0.16815803945064545, 0.02021953836083412, 0.416581392288208, 0.2718963027000427, 0.4424385726451874, 0.10635031014680862, 0.26875290274620056, -0.002778352005407214, -0.12193046510219574, -0.1291198879480362, 0.031181510537862778, -0.04080135375261307, 0.09825139492750168, 0.17699779570102692, 0.04797494783997536, -0.0893634557723999, -0.03501920402050018, -0.0173218734562397, 0.11826151609420776, 0.033918190747499466, 0.07082238048315048, 0.0633963942527771, 0.1675347089767456, 0.16117265820503235, 0.07749267667531967, 0.04975500702857971, -0.2765811085700989, -0.15489332377910614, 0.28418320417404175, 0.09766402840614319, -0.35244640707969666, 0.261788010597229, -0.2626259922981262, 0.17547641694545746, -0.0515417642891407, 0.13454988598823547, -0.12641331553459167, 0.013904035091400146, 0.1254926323890686, -0.10054849833250046, -0.1598743349313736, 0.1373240351676941, 0.16565412282943726, -0.023207593709230423, -0.29520395398139954, -0.19999456405639648, -0.28510236740112305, 0.17608526349067688, 0.13754139840602875, 0.028286559507250786, -0.1501769870519638, -0.18427583575248718, 0.20442184805870056], [0.166759192943573, 0.08124025166034698, 0.15042585134506226, 0.10907357186079025, 0.046305011957883835, 0.2595796287059784, 0.06498591601848602, 0.19973938167095184, 0.18625620007514954, 0.19134315848350525, -0.08324892073869705, 0.04469328001141548, 0.16372981667518616, 0.16173681616783142, -0.10040552914142609, -0.016548123210668564, 0.30174651741981506, 0.07916964590549469, -0.0428425632417202, 0.31484612822532654, 0.09892834722995758, 0.07569417357444763, 0.18542440235614777, 0.2852720022201538, 0.1450207680463791, 0.27872276306152344, -0.2034517079591751, 0.14283189177513123, 0.14926183223724365, 0.1423683762550354, 0.07386049628257751, 0.1360856592655182, -0.026404976844787598, 0.16912423074245453, 0.22350797057151794, 0.1671646684408188, -0.44176241755485535, -0.05944062024354935, -0.03936118632555008, 0.08361474424600601, -0.1406210958957672, 0.24518845975399017, -0.2665902376174927, -0.07317379862070084, 0.11900117993354797, 0.13462167978286743, 0.01017534639686346, -0.004320977255702019, 0.21489477157592773, 0.17678438127040863, 0.3183025121688843, 0.25776371359825134, 0.04254554584622383, -0.024246420711278915, -0.05670667812228203, 0.05767393857240677, 0.10685519874095917, 0.1645629107952118, 0.0028656187932938337, -0.09725978970527649, 0.03812798112630844, 0.3277224600315094, 0.27601131796836853, -0.22125504910945892], [-0.06813498586416245, -0.16669127345085144, -0.17250753939151764, -0.009527795016765594, -0.010342197492718697, 0.03226562961935997, -0.06212080270051956, 0.18416519463062286, 0.4263181984424591, -0.03784419223666191, -0.0885217934846878, -0.13532236218452454, -0.12333117425441742, -0.25431028008461, -0.13964833319187164, -0.3190688490867615, 0.02316170185804367, -0.2756330668926239, 0.13137327134609222, 0.3302466571331024, -0.18443815410137177, 0.1121193915605545, 0.23330631852149963, 0.2409311830997467, -0.13997478783130646, 0.10389410704374313, 0.15622735023498535, -0.12479576468467712, 0.03454530984163284, -0.12321187555789948, 0.16442586481571198, 0.17218194901943207, 0.17035098373889923, 0.08823136240243912, -0.20222875475883484, 0.04562297835946083, -0.022171998396515846, -0.2086271047592163, -0.14663264155387878, -0.05271259322762489, 0.0167864877730608, -0.33646225929260254, -0.13503682613372803, 0.04436740279197693, 0.13328145444393158, 0.11174695938825607, 0.20595405995845795, 0.006230364087969065, -0.24738053977489471, 0.016243282705545425, 0.06019910052418709, 0.14601512253284454, -0.031473446637392044, -0.2532847821712494, -0.08613507449626923, -0.054015129804611206, -0.06457891315221786, 0.07347790151834488, 0.014608480036258698, -0.13169781863689423, 0.31884831190109253, 0.23900584876537323, -0.010613593272864819, 0.21130932867527008], [0.07155073434114456, -0.012771477922797203, 0.009101507253944874, 0.03529701754450798, 0.10978607088327408, -0.030292637646198273, 0.09576382488012314, -0.17847928404808044, -0.15107256174087524, -0.05275605991482735, -0.07695561647415161, -0.1264350712299347, 0.09782669693231583, -0.18905216455459595, 0.04121812433004379, -0.12624359130859375, -0.029699290171265602, -0.07770045846700668, 0.10934291779994965, -0.1618644893169403, -0.16634412109851837, 0.02766866609454155, 0.02755986899137497, 0.013505727052688599, -0.0750066488981247, 0.01526564545929432, -0.26564109325408936, -0.061909858137369156, 0.0685463696718216, 0.13956168293952942, -0.07356736809015274, 0.02671351283788681, -0.11162235587835312, -0.02064068242907524, -0.06663955003023148, 0.18450413644313812, -0.30915459990501404, -0.01814996637403965, 0.05284275859594345, -0.1231345534324646, 0.0939200296998024, 0.1411743015050888, -0.008854749612510204, 0.02033229172229767, -0.017483556643128395, 0.14563189446926117, 0.058152105659246445, 0.023671595379710197, -0.017993856221437454, 0.14710062742233276, -0.029083574190735817, -0.03146740794181824, 0.18192890286445618, -0.16159279644489288, 0.04687065631151199, -0.04485255479812622, -0.058351922780275345, -0.025937268510460854, -0.043485112488269806, -0.12164588272571564, -0.035545289516448975, 0.04439213126897812, -0.0625850036740303, -0.09530076384544373], [-0.06891915202140808, 0.015719959512352943, -0.05330934002995491, 0.11759956181049347, -0.03249409794807434, 0.03684167563915253, -0.003786921501159668, -0.0024242170620709658, -0.14316539466381073, 0.002805840689688921, 0.053864479064941406, -0.11129734665155411, 0.014593049883842468, -0.0104348910972476, 0.023477137088775635, 0.02384098805487156, -0.05366068333387375, -0.07742318511009216, -0.06400419026613235, 0.09645777940750122, -0.05057891458272934, -0.12901972234249115, -0.08351817727088928, 0.017775148153305054, 0.0874534323811531, -0.11230701208114624, -0.06570711731910706, 0.061967819929122925, -0.09724240750074387, 0.08153675496578217, 0.08024175465106964, -0.031376663595438004, -0.01038856990635395, -0.12235385179519653, 0.03734537959098816, -0.00018027906480710953, -0.05595880746841431, -0.09620390832424164, -0.025187304243445396, -0.10680951178073883, -0.11893181502819061, -0.08258490264415741, 0.004426151514053345, 0.08550778776407242, -0.07547397166490555, -0.032027117908000946, -0.11933109164237976, 0.015528153628110886, -0.07410217821598053, -0.09871657937765121, 0.014850735664367676, -0.05429467558860779, 0.005121534690260887, -0.09714299440383911, -0.12442326545715332, -0.02601727657020092, 0.10334786772727966, -0.021845629438757896, -0.019469009712338448, 0.04827907308936119, 0.027657348662614822, -0.00858021154999733, -0.037180542945861816, -0.07089363783597946], [-0.06832686066627502, -0.1186000183224678, -0.03720462694764137, -0.040748924016952515, 0.050601065158843994, 0.12443511188030243, 0.07252025604248047, 0.06936287879943848, -0.029443442821502686, -0.1361309438943863, 0.007119208574295044, -0.10112157464027405, 0.05565624684095383, -0.11089174449443817, 0.12481427192687988, 0.03997223079204559, -0.039890825748443604, -0.04078282415866852, -0.12285862118005753, -0.03848858177661896, 0.0770847350358963, 0.0443706288933754, 0.0032573440112173557, 0.09243449568748474, -0.02972981333732605, 0.045043621212244034, 0.091082863509655, 0.01757359504699707, 0.03448417782783508, -0.12005762755870819, 0.06079097092151642, 0.04113560914993286, -0.040407855063676834, -0.0600920096039772, -0.07034449279308319, 0.08260510116815567, 0.03694993257522583, -0.05706349015235901, -0.09706657379865646, 0.07705646753311157, -0.03134511783719063, -0.014777466654777527, 0.06027908995747566, 0.08964236080646515, 0.00936452392488718, 0.11039437353610992, -0.09901928156614304, -0.11762705445289612, 0.12282085418701172, 0.020513564348220825, -0.06487865746021271, -0.0817348062992096, -0.02889508195221424, 0.08022671937942505, -0.04723846912384033, -0.048033207654953, -0.11544249206781387, -0.12279579043388367, -0.08339248597621918, 0.060249801725149155, -0.008089904673397541, -0.004966914653778076, 0.07663269340991974, -0.07076359540224075], [-0.12786000967025757, 0.0002730953274294734, 0.22023338079452515, 0.1705355942249298, 0.16220110654830933, -0.005641895346343517, 0.10811091214418411, 0.0871465802192688, 0.1528899371623993, 0.05010456219315529, 0.011332702822983265, 0.17010243237018585, 0.15394262969493866, 0.01743888109922409, -0.21280616521835327, -0.13002192974090576, -0.05345289036631584, 0.027853764593601227, 0.2178640514612198, 0.13735565543174744, -0.09828100353479385, 0.261323481798172, 0.08712465316057205, 0.11929231882095337, -0.07910842448472977, 0.038471512496471405, -0.0171747375279665, -0.061183225363492966, -0.0036507558543235064, -0.12011070549488068, 0.08426482230424881, 0.20117980241775513, 0.1589203029870987, 0.05215827748179436, -0.12448534369468689, 0.24809232354164124, 0.4380558133125305, -0.36324813961982727, -0.10433094203472137, -0.15578366816043854, 0.03653062880039215, -0.2962735891342163, 0.2264007329940796, -0.22432368993759155, 0.2333582639694214, -0.1503468155860901, 0.3295912444591522, 0.031148526817560196, -0.2024870067834854, -0.04067032411694527, -0.21466989815235138, -0.07978054881095886, 0.011356081813573837, 0.01924188807606697, 0.028524765744805336, -0.17097756266593933, 0.036336179822683334, -0.15632830560207367, -0.012151413597166538, -0.08521663397550583, 0.2618982493877411, 0.2777387797832489, -0.28642019629478455, 0.1421561986207962], [0.1086546927690506, 0.08094769716262817, -0.018278367817401886, 0.19110770523548126, 0.047977764159440994, -0.03384343907237053, 0.028118615970015526, -0.1550155133008957, 0.10089749097824097, 0.07486503571271896, -0.07319008558988571, 0.1626925766468048, -0.2547297477722168, -0.1729394942522049, -0.11196749657392502, -0.3626595437526703, 0.059433091431856155, 0.03719337284564972, 0.008306258358061314, 0.22319988906383514, 0.28850674629211426, 0.09422869980335236, 0.07574699074029922, -0.005016786511987448, -0.19912035763263702, 0.18691343069076538, 0.052376192063093185, 0.0497225821018219, 0.10651388019323349, 0.14960674941539764, -0.03794679045677185, -0.1706400066614151, -0.04569411277770996, 0.028481917455792427, -0.04715316370129585, -0.21120207011699677, -0.10476145893335342, 0.08023840934038162, 0.13355199992656708, -0.04443764686584473, 0.09714087098836899, -0.14494316279888153, -0.09251899272203445, 0.1569855958223343, -0.25182968378067017, 0.17932724952697754, -0.0570380724966526, 0.13358131051063538, 0.14569741487503052, 0.06171010434627533, 0.04756210744380951, -0.01700030267238617, 0.031470201909542084, 0.005277673713862896, -0.04766898974776268, 0.24491500854492188, 0.1093519851565361, 0.14182479679584503, -0.07285664975643158, -0.06603659689426422, -0.03330231457948685, -0.05088803917169571, 0.14482949674129486, -0.09564909338951111], [-0.003407894168049097, 0.000663673912640661, 0.014191273599863052, 2.2774256649427116e-06, 0.0022560707293450832, -0.08990848064422607, -0.0045268540270626545, 0.06217784807085991, 0.15876537561416626, -0.038682207465171814, 0.11381242424249649, 0.06624408066272736, 0.11270663142204285, -0.05961201712489128, -0.11771994829177856, -0.16982634365558624, -0.11594799906015396, -0.02249373123049736, 0.09761742502450943, 0.08932893723249435, 0.027079377323389053, 0.17208075523376465, 0.031546879559755325, -0.041468679904937744, 0.012195473536849022, 0.10684142261743546, 0.2391432523727417, -0.11847423762083054, 0.04106150195002556, -0.051232367753982544, 0.08125948905944824, 0.17819295823574066, 0.22038280963897705, 0.14102086424827576, -0.03747034817934036, 0.2701908349990845, 0.35301700234413147, -0.14460013806819916, 0.0328441821038723, -0.25749239325523376, 0.2609187960624695, -0.20530027151107788, 0.0810767263174057, -0.22790120542049408, -0.048355113714933395, -0.14629092812538147, 0.1714785248041153, -0.04711281880736351, -0.19905471801757812, -0.2798355519771576, -0.11067967861890793, 0.033988192677497864, -0.0652083083987236, 0.030030492693185806, -0.12336824089288712, -0.22348789870738983, 0.06371982395648956, 0.06499713659286499, 0.0928460881114006, 0.09766904264688492, 0.19563493132591248, 0.1089523583650589, -0.18206292390823364, 0.15497435629367828], [-0.003191377269104123, 0.08123347908258438, -0.12223386019468307, -0.15108883380889893, 0.18890315294265747, -0.10308612138032913, 0.12122324854135513, 0.23079845309257507, 0.2443644404411316, -0.08254416286945343, -0.002680389676243067, -0.37002354860305786, -0.03717604652047157, -0.17452649772167206, 0.07380781322717667, 0.07656533271074295, 0.21336311101913452, -0.11985991150140762, 0.008870338089764118, 0.3403589129447937, -0.11299005150794983, 0.046301621943712234, 0.4031219482421875, 0.19874422252178192, -0.2501308023929596, 0.2599026560783386, 0.06525473296642303, -0.1531074196100235, 0.11397787183523178, -0.03441020846366882, 0.35105761885643005, 0.08208641409873962, 0.11835473030805588, 0.11411040276288986, -0.040566954761743546, 0.11143112927675247, 0.13433195650577545, -0.14101499319076538, -0.2645575702190399, -0.21804574131965637, -0.11912048608064651, -0.44665858149528503, -0.0795997604727745, 0.10215786844491959, 0.20765502750873566, 0.03679714724421501, 0.2538110613822937, 0.01910245604813099, 0.01593921333551407, -0.006638541352003813, 0.1073954850435257, 0.22512634098529816, 0.21458956599235535, 0.004461328964680433, -0.1089310273528099, 0.13484841585159302, 0.051520947366952896, -0.10542798787355423, -0.05056557059288025, -0.05180753767490387, 0.40891945362091064, 0.19832247495651245, -0.18693463504314423, -0.14097510278224945], [-0.00308779114857316, -0.16066700220108032, -0.13387911021709442, -0.013753538951277733, 0.06072869151830673, -0.01879722997546196, 0.09652602672576904, 0.11826609075069427, 0.40987372398376465, 0.05340674892067909, 0.07538510859012604, -0.0636659637093544, 0.035394202917814255, 0.09835680574178696, -0.13884153962135315, 0.1286291629076004, 0.052962370216846466, -0.11024369299411774, 0.10827529430389404, 0.1606747955083847, -0.3977303206920624, 0.13898974657058716, 0.42724692821502686, 0.300011545419693, -0.06291383504867554, 0.2730635404586792, 0.10001043230295181, -0.05531507357954979, 0.04702197015285492, -0.12447439134120941, 0.16755402088165283, 0.11518830060958862, 0.09023907780647278, 0.013093826361000538, -0.1848975121974945, 0.19400301575660706, 0.2653771936893463, -0.33210986852645874, -0.6969045400619507, -0.24294300377368927, -0.04550556093454361, -0.4573305547237396, -0.016527019441127777, 0.11314316838979721, 0.22238731384277344, -0.18011024594306946, 0.12621095776557922, -0.05358423292636871, -0.1562052220106125, -0.08257458359003067, 0.2718745768070221, 0.05599304288625717, 0.12541146576404572, 0.10995446890592575, 0.1595088541507721, 0.04407681152224541, 0.053863152861595154, -0.2192196398973465, 0.028724273666739464, 0.23251846432685852, 0.1515711098909378, 0.1213446855545044, -0.18455210328102112, 0.11599541455507278], [0.1529921293258667, -0.04191243648529053, -0.017697680741548538, 0.1929890215396881, 0.06097611039876938, 0.06007799133658409, 0.03975649178028107, 0.09754741936922073, 0.2525781989097595, 0.24377880990505219, 0.07633368670940399, 0.011462765745818615, -0.027554679661989212, 0.033885400742292404, -0.04690679535269737, -0.026964742690324783, 0.07456792145967484, 0.03696022927761078, 0.10206916183233261, 0.30365288257598877, 0.03916031867265701, 0.035444289445877075, 0.015856923535466194, 0.25473207235336304, 0.10028859227895737, 0.19896800816059113, -0.18889059126377106, 0.1443985551595688, 0.18385055661201477, 0.18899066746234894, 0.10722590237855911, -0.1339818835258484, 0.12105455249547958, 0.14095067977905273, 0.2695156931877136, 0.04957934096455574, -0.3353957533836365, -0.12427940964698792, 0.12717212736606598, 0.14005158841609955, -0.16051006317138672, 0.23814091086387634, -0.3087159991264343, 0.34465834498405457, 0.20282049477100372, 0.15258021652698517, -0.014945302158594131, 0.04187033325433731, 0.2662141025066376, 0.1050286814570427, 0.27385029196739197, 0.2195964753627777, 0.15290167927742004, -0.11212813854217529, 0.02795303426682949, 0.15215840935707092, 0.29046231508255005, 0.1450437605381012, -0.10586041957139969, -0.15970680117607117, 0.07701689749956131, 0.28543463349342346, 0.13555754721164703, -0.37065601348876953], [0.1810339391231537, -0.19940760731697083, 0.07676525413990021, -0.13162484765052795, -0.03505060076713562, 0.2554810643196106, -0.13521628081798553, 0.13446645438671112, 0.25005868077278137, 0.17691883444786072, -0.010977421887218952, -0.12208615988492966, 0.07987883687019348, 0.10126509517431259, -0.08571221679449081, -0.08913696557283401, 0.3165546953678131, 0.050094909965991974, -0.03793328255414963, 0.11862681806087494, -0.2283729463815689, 0.06721477955579758, 0.27935245633125305, 0.28031373023986816, -0.15323056280612946, 0.114564448595047, 0.022206217050552368, -0.00833522342145443, 0.08855584263801575, 0.10275987535715103, 0.013826359994709492, 0.17128416895866394, 0.13007204234600067, 0.2725166082382202, 0.016959089785814285, 0.101292185485363, -0.04668077081441879, -0.04742271825671196, -0.3286149501800537, 0.1983342170715332, 0.037480972707271576, 0.30727267265319824, -0.47867605090141296, 0.07598693668842316, 0.26294443011283875, -0.13361749053001404, -0.02948113903403282, -0.156913623213768, 0.07346948981285095, -0.01756167970597744, 0.1594829261302948, 0.033701326698064804, -0.011706813238561153, -0.02896716259419918, -0.04878201708197594, 0.07143115252256393, 0.1682278960943222, 0.07523878663778305, 0.0014020386151969433, -0.10555838793516159, 0.19100487232208252, 0.2296232432126999, 0.18656381964683533, -0.3091151714324951], [0.01618293672800064, 0.156442791223526, 0.052440095692873, 0.18527363240718842, 0.14370615780353546, -0.3323683738708496, -0.023735376074910164, 0.013864033855497837, -0.2760537564754486, -0.04427466168999672, -0.0907064750790596, 0.20650285482406616, 0.15608961880207062, -0.21208912134170532, 0.08270096778869629, -0.2072651982307434, -0.09061082452535629, -0.20469394326210022, 0.08305052667856216, -0.18647237122058868, 0.15589606761932373, 0.13191983103752136, -0.3455943763256073, -0.06680849939584732, 0.06908059120178223, -0.11690197885036469, 0.045392956584692, -0.07123354077339172, 0.12385787069797516, 0.05287102237343788, -0.14244545996189117, 0.19705431163311005, 0.04547836259007454, 0.05943617224693298, -0.019469566643238068, 0.000914950855076313, 0.1624913215637207, 0.10060328990221024, 0.19768956303596497, -0.1447851061820984, 0.07845243066549301, 0.2508811056613922, 0.2474457323551178, -0.08028766512870789, -0.1532587856054306, 0.2125505656003952, 0.02427356317639351, 0.09824484586715698, -0.20980164408683777, -0.08689586073160172, -0.09946607798337936, -0.1852494478225708, -0.08165276795625687, -0.05630175769329071, -0.13713183999061584, 0.052495572715997696, 0.14017362892627716, 0.13411903381347656, 0.1386445164680481, 0.027715256437659264, -0.059385258704423904, -0.26104873418807983, 0.0025684405118227005, 0.21908296644687653], [0.12771888077259064, 0.1906740516424179, 0.06257825344800949, 0.09828746318817139, 0.033285245299339294, 0.1317777782678604, -0.0813424214720726, 0.021533939987421036, -0.2099890410900116, -0.008285431191325188, -0.03184633329510689, -0.07005243748426437, -0.03998579457402229, -0.005004086997359991, 0.2839304208755493, -0.04957103356719017, 0.0027383025735616684, -0.25054341554641724, -0.00046756412484683096, -0.09733328223228455, 0.11475220322608948, -0.09087461233139038, -0.5018200278282166, 0.07105783373117447, 0.06935886293649673, 0.08283600956201553, -0.052107036113739014, -0.08784302324056625, 0.13038499653339386, -0.00719794724136591, -0.08993494510650635, 0.0030211510602384806, 0.012775460258126259, -0.030268320813775063, -0.2808774709701538, -0.03153592348098755, 0.008078250102698803, -0.1190902441740036, 0.190080463886261, -0.17747706174850464, -0.11183387041091919, 0.35901206731796265, -0.10254722833633423, -0.04566250741481781, 0.06268200278282166, 0.13074149191379547, -0.015333929099142551, 0.09549173712730408, -0.1805271953344345, 0.11312926560640335, -0.2618747651576996, -0.0779801532626152, 0.17857427895069122, 0.14027540385723114, 0.028116127476096153, 0.09797381609678268, -0.04283832758665085, 0.20927956700325012, 0.004012248944491148, -0.034579042345285416, 0.11239180713891983, -0.052075281739234924, 0.16654956340789795, 0.06318113952875137], [0.06305471062660217, -0.010587022639811039, 0.2913282513618469, -0.23884844779968262, -0.10255217552185059, 0.19883601367473602, 0.0899224802851677, 0.14662624895572662, -0.21414664387702942, 0.20677347481250763, -0.05438172444701195, 0.23994635045528412, -0.22945636510849, 0.10992292314767838, 0.11161323636770248, 0.3939551115036011, 0.12846718728542328, 0.18851473927497864, -0.13548478484153748, -0.272047221660614, -0.2651219964027405, 0.029042351990938187, -0.29244959354400635, -0.02540619857609272, 0.2937045395374298, -0.16869136691093445, 0.01875743828713894, 0.1816299855709076, -0.1627795249223709, 0.1119878888130188, -0.027719080448150635, -0.13695412874221802, 0.023691141977906227, 0.117325559258461, 0.2892416715621948, 0.3061661720275879, 0.06667348742485046, -0.10982725024223328, -0.14264675974845886, 0.24821063876152039, -0.06202000379562378, -0.13438811898231506, 0.02987862378358841, -0.001400092849507928, 0.2801051735877991, -0.14555740356445312, 0.009081803262233734, -0.25736406445503235, 0.2146548181772232, 0.1481553316116333, -0.057630520313978195, 0.034864313900470734, 0.16203603148460388, 0.004899369552731514, 0.001373017206788063, -0.1830308437347412, -0.214572474360466, -0.08449319005012512, 0.186721533536911, -0.006978688761591911, 0.006764651741832495, -0.2950628697872162, -0.00362142501398921, 0.09750476479530334], [0.1421688199043274, -0.03258142247796059, 0.16212381422519684, -0.04654347151517868, 0.17706799507141113, 0.20504026114940643, -0.03506751358509064, 0.006040711887180805, -0.1723601371049881, 0.23647892475128174, 0.08862040936946869, 0.1750725656747818, -0.08848024904727936, 0.0343804731965065, 0.2469044327735901, -0.003929866943508387, 0.07467301934957504, 0.1641102433204651, -0.2254456728696823, -0.2149433195590973, -0.09362126886844635, 0.026608072221279144, -0.15285472571849823, -0.05746543034911156, 0.23245961964130402, 0.041310571134090424, -0.13920265436172485, 0.24814355373382568, 0.052412811666727066, 0.35900288820266724, -0.11268236488103867, -0.04949771985411644, -0.04986848309636116, 0.2666960656642914, 0.21526241302490234, -0.09504810720682144, -0.1967928111553192, 0.0907965824007988, 0.03645779564976692, 0.18222492933273315, -0.18268562853336334, 0.36207857728004456, -0.09699716418981552, 0.18370464444160461, -0.0020530717447400093, 0.08442012220621109, -0.16417165100574493, -0.12243945151567459, 0.30543380975723267, 0.17963488399982452, 0.2792316973209381, 0.0007694931700825691, 0.027145614847540855, 0.05794612690806389, 0.1257806420326233, 0.09014055877923965, 0.05193895101547241, 0.2269219011068344, 0.19235123693943024, -0.024849720299243927, -0.07292141765356064, -0.1397964358329773, 0.26843106746673584, -0.17331552505493164], [-0.0022683758288621902, -0.10924527794122696, 0.16307027637958527, -0.2649690508842468, -0.05029983073472977, 0.13183791935443878, 0.124241404235363, 0.012989730574190617, -0.21521632373332977, 0.2578153908252716, -0.12406924366950989, 0.09980861097574234, -0.12941646575927734, -0.003543719882145524, 0.22754865884780884, 0.13951292634010315, 0.18193675577640533, 0.3901315927505493, -0.12747003138065338, -0.20362716913223267, -0.15169528126716614, 0.03694259747862816, -0.322897344827652, -0.1407984048128128, 0.2058952897787094, 0.03507368639111519, -0.28722184896469116, 0.2737237215042114, -0.0772261694073677, 0.23197104036808014, 0.00043613926391117275, -0.2297430783510208, 0.10432569682598114, 0.1459958553314209, 0.1773800104856491, 0.0615825280547142, -0.2034652829170227, 0.009827550500631332, -0.02435886859893799, 0.09649747610092163, -0.14348845183849335, 0.04794321954250336, 0.051139771938323975, 0.23399628698825836, 0.0003332876367494464, 0.051999274641275406, -0.05857235565781593, -0.10693399608135223, 0.18763604760169983, 0.18789859116077423, 0.26809558272361755, -0.06733854860067368, 0.20974613726139069, -0.19536378979682922, 0.02510274201631546, 0.01250520907342434, 0.08917330205440521, 0.12182096391916275, 0.03290487453341484, -0.027265753597021103, -0.20845340192317963, -0.2717021405696869, 0.18601682782173157, -0.13582119345664978], [-0.08414629846811295, -0.12183918803930283, -0.07927244156599045, -0.060818709433078766, 0.1112515926361084, -0.10872170329093933, -0.043985992670059204, -0.12921835482120514, 0.00682790344581008, 0.08598113805055618, 0.06425352394580841, -0.05993235856294632, 0.033679015934467316, 0.011761230416595936, -0.06849855184555054, 0.03642582893371582, -0.07688427716493607, 0.00014203831960912794, -0.03535564988851547, -0.03913367539644241, -0.0011484459973871708, -0.08974526077508926, 0.02810094691812992, 0.06524109840393066, -0.0022443486377596855, -0.055647820234298706, -0.08187425136566162, -0.04655153676867485, -0.08762922883033752, 0.06627687066793442, -0.12088771909475327, 0.037463121116161346, -0.05259318649768829, -0.09091926366090775, -0.047487370669841766, -0.10443044453859329, 0.07000335305929184, -0.09350735694169998, -0.028510596603155136, -0.09382818639278412, 0.0959211215376854, -0.08036287128925323, 0.06286066770553589, -0.13044476509094238, -0.14638613164424896, 0.07223441451787949, 0.05180738866329193, 0.06308172643184662, -0.08347741514444351, -0.018850235268473625, -0.15264500677585602, -0.09458433836698532, -0.05186206102371216, 0.049952130764722824, 0.11243602633476257, -0.07759380340576172, -0.13481563329696655, -0.09548495709896088, -0.10557612776756287, 0.016028333455324173, 0.06066727265715599, -0.0811678022146225, -0.019627464935183525, -0.047978464514017105], [0.0009187307441607118, -0.14546862244606018, 0.019873786717653275, -0.07910346984863281, -0.07954016327857971, -0.016958050429821014, 0.12416528165340424, 0.08381029218435287, 0.43734484910964966, -0.004731285851448774, -0.053668227046728134, -0.058359481394290924, -0.03205224499106407, -0.12063392996788025, -0.196254163980484, -0.1212088018655777, 0.09115256369113922, -0.114377960562706, 0.0972338318824768, 0.2734123468399048, -0.12305080890655518, 0.24449670314788818, 0.19973452389240265, 0.1861986666917801, -0.16039763391017914, 0.18199773132801056, 0.1581725925207138, -0.236235111951828, -0.02086251974105835, -0.232338085770607, 0.11717759072780609, 0.019561592489480972, 0.17824982106685638, 0.12735579907894135, -0.05368770286440849, 0.18081286549568176, 0.03999341279268265, -0.09761516749858856, -0.3476089835166931, -0.06274162977933884, 0.14354117214679718, -0.28577640652656555, -0.041034992784261703, 0.03711971268057823, 0.24896948039531708, 0.10787573456764221, 0.11641543358564377, 0.1635073870420456, 0.03919311612844467, -0.0389566533267498, 0.06403040885925293, 0.12002340704202652, 0.05938933789730072, -0.12273787707090378, 0.08919238299131393, -0.04185009002685547, -0.05881784111261368, -0.125660702586174, -0.05487328767776489, -0.07459387183189392, 0.22952871024608612, 0.2565826177597046, -0.2600213289260864, 0.03890228271484375], [-0.10257129371166229, 0.09660410135984421, 0.05461551994085312, 0.03930095583200455, 0.061565108597278595, 0.10858490318059921, 0.05155961215496063, -0.097428098320961, -0.13192537426948547, 0.08573814481496811, -0.053659409284591675, 0.03965727612376213, 0.048854436725378036, 0.10826309025287628, 0.10460485517978668, 0.004736031871289015, -0.0889725610613823, 0.00957186333835125, -0.04243243858218193, -0.034954920411109924, 0.10772359371185303, -0.04060406610369682, -0.04736252874135971, 0.044225119054317474, 0.11798377335071564, 0.01457457896322012, 0.04314880445599556, 0.052965398877859116, -0.02862592227756977, 0.014051415957510471, 0.05733606964349747, 0.012202483601868153, -0.037137437611818314, 0.034543227404356, -0.05612972006201744, -0.01708281971514225, 0.09473077207803726, -0.12365016341209412, -0.015786487609148026, 0.11781053245067596, 0.04353233054280281, -0.1409786343574524, -0.15068994462490082, -0.1283854991197586, -0.12765932083129883, -0.027798118069767952, -0.027516726404428482, -0.09370342642068863, -0.1306120902299881, -0.11424251645803452, -0.08499700576066971, -0.14903365075588226, -0.0013381100725382566, 0.04565386846661568, 0.10775837302207947, -0.1628110706806183, 0.08004570007324219, 0.07427824288606644, -0.01435454748570919, 0.0017172007355839014, -0.08611223101615906, -0.0319998599588871, -0.04757470637559891, -0.12884259223937988], [-0.042336445301771164, -0.005227239802479744, 0.2926042377948761, 0.05200939252972603, -0.05003148689866066, 0.0050016287714242935, 0.10707495361566544, 0.009150655940175056, -0.14144665002822876, 0.03687826171517372, 0.08924304693937302, 0.09238645434379578, 0.19009225070476532, 0.09597606211900711, 0.1444600373506546, 0.2988133728504181, 0.03200959414243698, -0.0048798914067447186, 0.132547527551651, -0.028218625113368034, 0.023998809978365898, 0.1219261959195137, -0.0098563889041543, 0.05409136414527893, 0.2740921676158905, -0.022468239068984985, -0.0197673998773098, -0.11118263751268387, -0.06724726408720016, 0.07419683784246445, -0.10508298873901367, 0.2523249387741089, 0.17037031054496765, 0.16223116219043732, -0.1809024214744568, 0.16823728382587433, 0.19864390790462494, -0.21492725610733032, -0.13116849958896637, -0.06882113963365555, 0.041208717972040176, -0.30031704902648926, 0.3084047734737396, -0.2859906554222107, 0.04613320901989937, -0.09130022674798965, 0.2987612187862396, 0.06137144938111305, -0.21928304433822632, -0.16747364401817322, -0.11871611326932907, -0.12534497678279877, 0.054578691720962524, 0.17163653671741486, -0.048776187002658844, -0.1127740889787674, -0.051364485174417496, -0.17759287357330322, 0.2154323309659958, 0.18045423924922943, 0.01623663678765297, -0.20148561894893646, -0.1778777837753296, 0.17859505116939545], [-0.04578584432601929, 0.0019389349035918713, 0.12279561161994934, -0.061352863907814026, 0.23270012438297272, -0.15326768159866333, 0.12661023437976837, 0.05775421857833862, 0.38247808814048767, 0.11790190637111664, 0.06965459883213043, -0.11509449034929276, 0.003853193251416087, -0.08337759226560593, -0.1096356138586998, -0.38388457894325256, 0.09255882352590561, -0.09864538908004761, 0.06066839396953583, 0.1823083609342575, -0.14699001610279083, 0.2501719295978546, 0.271497905254364, 0.15150943398475647, -0.1962810754776001, 0.1548028141260147, 0.060058917850255966, 0.0018864198355004191, 0.1280379593372345, -0.146584615111351, 0.30375993251800537, 0.12975212931632996, 0.2168942242860794, 0.08524306118488312, -0.10610394924879074, 0.09092549979686737, 0.20787876844406128, -0.29634612798690796, -0.26470285654067993, -0.12374981492757797, 0.034719206392765045, -0.23529037833213806, 0.15251271426677704, -0.12261202931404114, 0.18519330024719238, 0.01584060862660408, 0.10780388861894608, 0.19427083432674408, -0.16483180224895477, -0.147008016705513, -0.10891207307577133, 0.13914929330348969, 0.0412587970495224, -0.12518934905529022, 0.03152204677462578, -0.12893369793891907, 0.028490180149674416, 0.018029741942882538, 0.04629182815551758, -0.26379871368408203, 0.1222468763589859, 0.310464084148407, -0.2276410311460495, 0.18639817833900452], [0.15601886808872223, 0.28469109535217285, -0.04279874265193939, 0.20999090373516083, 0.0715067908167839, -0.28310081362724304, 0.13566410541534424, -0.1012377142906189, -0.05637550726532936, 0.06459236145019531, 0.0801687240600586, -0.02556384727358818, 0.019044451415538788, -0.27044934034347534, -0.13972258567810059, -0.3547346591949463, 0.07171660661697388, -0.16379112005233765, 0.11527682095766068, -0.10645728558301926, 0.2451702356338501, 0.05844080448150635, 0.08117189258337021, -0.1418020874261856, -0.033872026950120926, 0.0870518609881401, 0.1579747200012207, -0.2062830924987793, 0.18016445636749268, 0.06297525018453598, 0.08006980270147324, 0.10069303959608078, 0.08879516273736954, 0.009803607128560543, -0.013671587221324444, -0.044060904532670975, 0.053770337253808975, 0.07627516239881516, 0.07872801274061203, -0.33390113711357117, -0.03199459984898567, 0.2904615104198456, -0.031487539410591125, 0.08725559711456299, -0.06200385093688965, 0.17866382002830505, 0.03313663974404335, 0.22678416967391968, 0.057339344173669815, -0.09780958294868469, 0.009671853855252266, 0.13985273241996765, -0.10286221653223038, -0.07010230422019958, 0.051042988896369934, 0.07935946434736252, 0.18636809289455414, 0.18821154534816742, -0.05090070143342018, -0.03026469610631466, -0.03210550174117088, 0.0706869587302208, 0.1744314283132553, 0.11205810308456421], [-0.002939612837508321, -0.017632707953453064, 0.09304678440093994, -0.03935438022017479, 0.02781515382230282, 0.029731718823313713, -0.11705955862998962, -0.011142131872475147, -0.10537455230951309, -0.10677104443311691, -0.0618821382522583, -0.047494690865278244, -0.012152358889579773, -0.03185902535915375, -0.052657559514045715, -0.034749068319797516, 3.289224696345627e-05, -0.07462462782859802, -0.025522656738758087, 0.0028105557430535555, 0.005732044577598572, -0.10547086596488953, 0.08123236894607544, -0.15495090186595917, 0.028713950887322426, 0.005173773039132357, -0.15250013768672943, 0.016391629353165627, -0.08979278802871704, 0.10646349936723709, 0.1262865960597992, -0.09052521735429764, 0.03602093830704689, 0.12288045883178711, -0.0502413772046566, 0.02433212473988533, -0.14668965339660645, 0.07835178822278976, -0.04027936980128288, -0.008457275107502937, 0.06152718886733055, -0.09614965319633484, -0.08224810659885406, -0.16834872961044312, -0.0435384102165699, -0.030399249866604805, 0.08342095464468002, -0.05688635632395744, -0.05684821307659149, 0.08920498937368393, -0.005104276351630688, 0.05319700017571449, 0.060971859842538834, 0.09594092518091202, 0.04887925088405609, -0.026816975325345993, 0.05585801228880882, 0.10103314369916916, -0.08341696858406067, -0.0986240804195404, -0.07875050604343414, -0.026113973930478096, 0.1527533233165741, 0.1608535200357437], [0.011709911748766899, 0.31674447655677795, -0.054952222853899, 0.013815154321491718, -0.03466896712779999, -0.21798551082611084, 0.0569746233522892, 0.022900106385350227, -0.21186411380767822, 0.026859605684876442, 0.10115613043308258, 0.11295090615749359, 0.14877937734127045, -0.13585002720355988, 0.14474578201770782, -0.26494836807250977, -0.1876906007528305, -0.15150202810764313, 0.1532355546951294, -0.3558436930179596, 0.0419674888253212, 0.08455709367990494, -0.3253577649593353, -0.17654895782470703, -0.06222616136074066, -0.22611291706562042, 0.167572021484375, 0.02467009238898754, 0.10403753817081451, 0.0017415020847693086, -0.13397902250289917, 0.17420372366905212, 0.1659521460533142, -0.12266895174980164, -0.1284930557012558, -0.04919528216123581, 0.2356833815574646, 0.06596389412879944, 0.21656076610088348, -0.33912330865859985, 0.08970564603805542, 0.3443295955657959, 0.11753890663385391, -0.050450894981622696, -0.193564310669899, 0.09839032590389252, 0.08157355338335037, 0.0702223926782608, 0.04385026544332504, -0.043133653700351715, -0.20727138221263885, -0.12843357026576996, -0.07916068285703659, 0.0038028659764677286, -0.027978211641311646, -0.03731796145439148, 0.012924259528517723, 0.2688286006450653, 0.02298893593251705, 0.18207135796546936, 0.026388730853796005, -0.1461099535226822, 0.20283430814743042, 0.12264233082532883], [0.21410591900348663, 0.1309070736169815, 0.0706607773900032, 0.0459810271859169, 0.10502055287361145, 0.00406692223623395, -0.042231034487485886, -0.1413794308900833, -0.3850284218788147, 0.12521786987781525, 0.01577119156718254, 0.16099463403224945, 0.09638796746730804, 0.021210307255387306, 0.28740981221199036, 0.25061437487602234, 0.016563182696700096, 0.16763219237327576, -0.07006761431694031, -0.165187805891037, 0.09281961619853973, 0.12116174399852753, -0.2850431203842163, -0.06996847689151764, 0.16245922446250916, -0.14390166103839874, 0.0027680154889822006, 0.23128613829612732, 0.12551340460777283, 0.16017374396324158, -0.20374739170074463, 0.17385771870613098, -0.018305232748389244, 0.032291971147060394, 0.17235811054706573, 0.03797625005245209, -0.1581411063671112, 0.11344343423843384, 0.18499290943145752, -0.05707721784710884, -0.08804897964000702, 0.2722291946411133, 0.13030721247196198, -0.09904221445322037, -0.06817597150802612, -0.04654198884963989, -0.03774622455239296, 0.028753694146871567, 0.1842443197965622, 0.13920606672763824, 0.059081558138132095, 0.01858760043978691, 0.15564316511154175, -0.04016397148370743, -0.01770244725048542, 0.24841465055942535, 0.24657095968723297, 0.21096202731132507, -0.010459131561219692, 0.15910704433918, -0.134028360247612, -0.34402814507484436, 0.2882896959781647, -0.22714006900787354], [0.02070385217666626, -0.0717720165848732, 0.019281048327684402, -0.10215359181165695, 0.02640901505947113, -0.06222821772098541, 0.02002120018005371, -0.13051827251911163, 0.0700032114982605, -0.05807841941714287, 0.08256004750728607, 0.10602341592311859, -0.039615143090486526, -0.030377661809325218, -0.0002312728320248425, 0.0030306591652333736, -0.10817790776491165, 0.03379284217953682, -0.0028454973362386227, -0.07871688157320023, -0.10929040610790253, 0.06294111907482147, 0.0461600124835968, 0.1075134351849556, -0.006270424462854862, -0.12783478200435638, 0.07004405558109283, -0.12291563302278519, -0.12425784766674042, -0.06557729840278625, -0.08698421716690063, -0.04258376732468605, 0.06328156590461731, 0.053171563893556595, 0.051131051033735275, 0.014802290126681328, 0.08257058262825012, 0.05333861708641052, 0.06803682446479797, 0.08252537250518799, 0.08702914416790009, -0.07230313122272491, -0.08948487788438797, 0.05165828391909599, 0.028044885024428368, -0.12755738198757172, -0.008782656863331795, -0.028937706723809242, 0.07562373578548431, -0.06018448248505592, 0.1105671301484108, 0.1157064288854599, 0.1349514126777649, 0.05890042334794998, 0.10681420564651489, -0.04323126748204231, 0.08782859146595001, -0.09467172622680664, -0.10693235695362091, -0.034001193940639496, -0.00711990287527442, 0.05889599025249481, 0.022860299795866013, -0.11469780653715134], [0.04839249327778816, 0.17795372009277344, -0.1092662438750267, 0.1381492018699646, 0.11789655685424805, -0.18394777178764343, -0.08060126006603241, 0.20448969304561615, 0.40267133712768555, -0.049685899168252945, -0.032257597893476486, -0.2906045615673065, -0.049123477190732956, -0.015635503455996513, -0.06913434714078903, -0.2612212300300598, 0.24876710772514343, -0.19394852221012115, 0.0628737211227417, 0.35464611649513245, -0.11925575882196426, 0.09822124987840652, 0.3287995159626007, 0.22959360480308533, -0.20141291618347168, 0.24701029062271118, 0.10171744972467422, -0.12563318014144897, 0.12366380542516708, 0.06457465887069702, -0.001949047902598977, -0.004796502646058798, 0.135720357298851, 0.045318230986595154, -0.04063248261809349, 0.012742705643177032, -0.07018006592988968, -0.16236689686775208, -0.20324110984802246, 0.004142697900533676, -0.12717194855213165, 0.22146286070346832, -0.22382202744483948, 0.10183682292699814, 0.1686875820159912, 0.11698004603385925, 0.08673886209726334, 0.09390917420387268, 0.05572802573442459, -0.19897906482219696, 0.17613308131694794, 0.1927942931652069, -0.03164616599678993, 0.05143726244568825, 0.014206375926733017, 0.09560254216194153, 0.24080978333950043, -0.03923965245485306, -0.05850348621606827, -0.21640661358833313, 0.24560393393039703, 0.11631984263658524, -0.05194895714521408, -0.17724797129631042], [0.06857200711965561, -0.3014146089553833, -0.00018211541464552283, -0.08253182470798492, -0.05708637088537216, 0.2649174928665161, -0.015468567609786987, 0.37524840235710144, 0.2522428035736084, 0.18499721586704254, -0.06937814503908157, -0.022134825587272644, -0.142430379986763, 0.16545787453651428, 0.1043161004781723, 0.13295479118824005, 0.1797819286584854, 0.05958614870905876, -0.06354070454835892, 0.16617825627326965, -0.13305708765983582, 0.13260895013809204, 0.09196142107248306, 0.15941505134105682, 0.04045681655406952, 0.10482005774974823, -0.12840892374515533, 0.24826423823833466, -0.056685589253902435, 0.11862938106060028, 0.20538291335105896, 0.07399138808250427, 0.07048362493515015, 0.10034050047397614, 0.035467833280563354, 0.2231622338294983, -0.016816604882478714, -0.3714671730995178, -0.299900621175766, 0.2193337231874466, -0.1914631724357605, -0.03973305597901344, -0.5648291110992432, -0.19709548354148865, 0.2630239725112915, -0.3223555386066437, 0.0955837219953537, 0.008928454481065273, 0.2866106629371643, 0.05282033607363701, 0.2524137496948242, 0.025194790214300156, -0.3426198959350586, -0.010742481797933578, -0.08262240141630173, -0.17072097957134247, 0.15737061202526093, -0.04824543371796608, 0.16319578886032104, -0.1668081283569336, 0.055510349571704865, 0.3141179084777832, 0.23792427778244019, -0.2308042049407959], [-0.09544973820447922, -0.14255216717720032, -0.003047530073672533, -0.054492510855197906, 0.003397032618522644, 0.030284002423286438, 0.02526351809501648, 0.05900062248110771, -0.052862998098134995, -0.009018306620419025, -0.07741984724998474, -0.05545032024383545, -0.04513608291745186, -0.06101460009813309, 0.03383876383304596, 0.1225394755601883, -0.08412674814462662, 0.09251311421394348, -0.1140674501657486, 0.0926634818315506, -0.05460977926850319, -0.012948338873684406, 0.05253283306956291, -0.07881344854831696, -0.13192830979824066, 0.0820130929350853, -0.12722280621528625, -0.026680320501327515, 0.021249093115329742, -0.07094258815050125, -0.009055322036147118, 0.025383349508047104, -0.005756337195634842, -0.1594529151916504, -0.04693794250488281, -0.07047027349472046, 0.0488661527633667, 0.08247294276952744, -0.11584392189979553, -0.04963120445609093, 0.043955933302640915, -0.0943133682012558, -0.11369965970516205, -0.02461845614016056, -0.07896832376718521, -0.08145467936992645, -0.10718252509832382, -0.10222315043210983, -0.03189750015735626, -0.0752643495798111, -0.03002827800810337, -0.0653240904211998, -0.022319957613945007, -0.10320943593978882, -0.04606996476650238, -0.16263353824615479, -0.09969784319400787, 0.061135679483413696, -0.05146002396941185, 0.07643987983465195, 0.08520922064781189, -0.013385310769081116, 0.08953770250082016, -0.008519221097230911], [0.06552917510271072, 0.002283011795952916, 0.22206948697566986, -0.23287418484687805, 0.08763795346021652, 0.11495522409677505, 0.056280408054590225, 0.159169539809227, -0.28472208976745605, 0.2458714246749878, 0.0328734926879406, 0.20216183364391327, -0.16771024465560913, 0.13703696429729462, 0.22799991071224213, 0.2594667375087738, 0.07274668663740158, 0.2987199127674103, -0.1436956524848938, -0.09625496715307236, -0.1491592973470688, -0.17252521216869354, -0.23996087908744812, -0.14768461883068085, 0.2724469304084778, 0.01712779514491558, -0.19518865644931793, 0.29122433066368103, -0.040391359478235245, 0.31512102484703064, -0.027368925511837006, -0.11804386973381042, -0.017695220187306404, 0.17422038316726685, 0.31124618649482727, 0.0077114528976380825, 0.011364848352968693, -0.11843753606081009, -0.018598120659589767, 0.1963423490524292, -0.07663221657276154, -0.059102948755025864, 0.10265550762414932, -0.0892033576965332, 0.0045150648802518845, -0.10417874157428741, -0.0046694641932845116, -0.10502083599567413, 0.1782579869031906, 0.23955966532230377, 0.021815262734889984, 0.008031150326132774, 0.10144440084695816, -0.006522393319755793, -0.04663568362593651, -0.03175325319170952, 0.12664921581745148, -0.013271350413560867, 0.10085553675889969, 0.004044686444103718, -0.04433887451887131, -0.17292633652687073, 0.046151213347911835, -0.013264980167150497], [-0.008251659572124481, -0.14825673401355743, 0.043897926807403564, -0.08168268948793411, 0.03730088844895363, 0.021119799464941025, 0.11259479075670242, 0.0865272805094719, 0.19282251596450806, -0.06729338318109512, -0.07241615653038025, -0.023096615448594093, 0.1590726673603058, 0.2256777137517929, -0.29768261313438416, -0.2198026329278946, 0.13048775494098663, -0.07691118866205215, 0.10007647424936295, 0.19265632331371307, -0.13078483939170837, 0.2087174355983734, 0.2346629649400711, 0.08926655352115631, -0.08536678552627563, 0.20829997956752777, 0.13285082578659058, -0.21967051923274994, -0.006541622802615166, -0.12869100272655487, 0.1795375794172287, 0.15888221561908722, 0.042869918048381805, 0.03230426460504532, -0.004356694407761097, 0.24257127940654755, 0.1331774741411209, -0.16767165064811707, -0.1226227879524231, -0.1278100162744522, 0.09906233102083206, -0.37059518694877625, 0.024772727862000465, -0.060261841863393784, 0.14397123456001282, -0.07899927347898483, 0.22087207436561584, -0.01673649623990059, -0.10412483662366867, 0.019229155033826828, 0.04682614281773567, 0.15724065899848938, -0.1007949635386467, -0.12043236196041107, 0.08410196006298065, -0.11025366932153702, -0.14123795926570892, -0.10949721932411194, 0.024122318252921104, 0.13896946609020233, 0.3384542167186737, 0.22496215999126434, -0.3050262928009033, 0.13283999264240265], [0.0898459330201149, -0.060645997524261475, -0.035548195242881775, -0.020947003737092018, 0.10027818381786346, 0.1080918237566948, -0.05208674073219299, 0.05347376689314842, 0.05429229140281677, 0.020260481163859367, -0.1079721450805664, 0.046928390860557556, -0.006811719387769699, -0.13319754600524902, -0.05780183523893356, 0.02456510253250599, -0.09252689778804779, -0.048136744648218155, -0.12992723286151886, 0.01034540869295597, -0.1296948939561844, -0.14484626054763794, 0.08427001535892487, -0.005622318014502525, 0.05700387433171272, 0.029950499534606934, 0.009816344827413559, -0.04248996451497078, -0.03946669027209282, -0.1652323305606842, 0.09056418389081955, -0.0018358955858275294, -0.03345947712659836, -0.04370331019163132, 0.07796479761600494, -0.04611413925886154, 0.027230212464928627, 0.02048395946621895, 0.04419083893299103, -0.044507574290037155, 0.011979179456830025, 0.08987092226743698, -0.04475785419344902, -0.08429999649524689, -0.07225388288497925, -0.048238713294267654, -0.1291179060935974, -0.10302216559648514, 0.004316679667681456, -0.08890724927186966, -0.10736335813999176, -0.027675703167915344, -0.0169848445802927, -0.007902367040514946, -0.0311703160405159, -0.10832963138818741, -0.04829848185181618, -0.04938369616866112, -0.06790021806955338, 0.11264188587665558, -0.09910769760608673, -0.09420861303806305, -0.03027108870446682, 0.03584674745798111], [0.22319218516349792, 0.022527648136019707, -0.2024966925382614, 0.2091258019208908, 0.10242106765508652, -0.05876423045992851, -0.02188192680478096, 0.08556388318538666, 0.3341738283634186, -0.04120177775621414, -0.07392966747283936, -0.06317002326250076, -0.030032042413949966, -0.16656608879566193, -0.3242274224758148, -0.45608609914779663, -0.04405108466744423, -0.18516789376735687, 0.23261968791484833, 0.2730334401130676, 0.12196335941553116, 0.11599884927272797, 0.13495589792728424, 5.588399653788656e-05, -0.09769321233034134, 0.058279987424612045, 0.17046202719211578, -0.09648096561431885, 0.0897381380200386, 0.06610547751188278, 0.06223844364285469, 0.15334129333496094, 0.023447265848517418, 0.01832806132733822, -0.01905021443963051, -0.07041116058826447, 0.08893255889415741, 0.05209045857191086, 0.01384037546813488, -0.1693842113018036, 0.13813923299312592, 0.12167734652757645, -0.1636873185634613, 0.0937335342168808, -0.07603871822357178, 0.2654033303260803, 0.0162035059183836, 0.07822874188423157, 0.04802585393190384, -0.08297381550073624, 0.14889028668403625, 0.22520802915096283, -0.10200846195220947, -0.03205801174044609, -0.011614902876317501, 0.22967647016048431, 0.2709481418132782, 0.32067781686782837, 0.07976129651069641, -0.12333735823631287, 0.07169008255004883, 0.3138905465602875, 0.2334287017583847, -0.06458843499422073], [0.07179902493953705, 0.07401464879512787, 0.03166670724749565, 0.12239736318588257, 0.05739741772413254, -0.044854309409856796, -0.022430308163166046, 0.04066535085439682, 0.08057844638824463, 0.06121843308210373, 0.0018142594490200281, 0.21443025767803192, 0.22784993052482605, -0.08825910836458206, -0.003270690329372883, -0.1974838674068451, -0.10779397934675217, -0.11437574028968811, 0.17365969717502594, 0.022269267588853836, 0.098256915807724, 0.10845158249139786, 0.07443106919527054, 0.08642256259918213, 0.029376335442066193, -0.07727497071027756, 0.18942004442214966, -0.29786157608032227, 0.05543580651283264, -0.11244206875562668, 0.00984138622879982, 0.24124778807163239, 0.3390837013721466, 0.11012754589319229, -0.10144579410552979, 0.21858051419258118, 0.5237436890602112, -0.2790622413158417, -0.047019485384225845, -0.255526602268219, 0.14443394541740417, -0.21163839101791382, 0.39135634899139404, -0.3302355408668518, 0.09426894038915634, -0.025275878608226776, 0.18175055086612701, 0.1690378338098526, -0.16920162737369537, -0.08454672247171402, -0.12492973357439041, -0.09731869399547577, 0.012877040542662144, -0.02739964798092842, 0.003929351456463337, -0.22077053785324097, 0.000956332019995898, -0.07457871735095978, 0.1569756120443344, 0.11778656393289566, 0.09373681992292404, -0.09119617938995361, -0.23939251899719238, 0.23155809938907623], [0.039796169847249985, -0.11663525551557541, -0.006681707687675953, -0.10345689207315445, -0.13532118499279022, -0.11899537593126297, -0.08740923553705215, 0.19795379042625427, 0.35658353567123413, 0.0523126982152462, 0.038786426186561584, -0.2739032804965973, -0.06984798610210419, -0.27898427844047546, -0.17107808589935303, -0.5698961019515991, 0.1534852683544159, -0.23252251744270325, 0.010466022416949272, 0.3248074948787689, -0.05675755441188812, 0.19243521988391876, 0.29364755749702454, 0.15597599744796753, -0.04054141044616699, 0.10057803988456726, 0.06614843755960464, -0.21277973055839539, 0.10843157768249512, -0.14115318655967712, 0.20962464809417725, 0.07086558640003204, 0.11796166747808456, 0.07775285094976425, -0.2111278474330902, 0.031266648322343826, 0.05904844403266907, 0.15112972259521484, -0.08486706763505936, -0.11077708005905151, 0.0633963793516159, -0.20717652142047882, -0.07786738872528076, 0.1203596293926239, 0.1072506383061409, 0.22546496987342834, 0.08778813481330872, 0.08041214942932129, -0.0036767825949937105, -0.12642650306224823, 0.22804079949855804, 0.15709753334522247, 0.07965655624866486, -0.1495131552219391, -0.10662266612052917, 0.09667865186929703, 0.09995060414075851, -0.0010943866800516844, -0.0056344494223594666, -0.14739836752414703, 0.21662414073944092, 0.1811436265707016, -0.09443586319684982, 0.10887064784765244], [0.06129000708460808, -0.11545602232217789, -0.09198903292417526, 0.024143453687429428, 0.051932767033576965, 0.11971905827522278, 0.10557126998901367, 0.10412540286779404, -0.12353333085775375, -0.08177820593118668, -0.07988128066062927, 0.10027164220809937, 0.02822689712047577, -0.006246595643460751, -0.06182205677032471, -0.09441777318716049, -0.07336904853582382, -0.08372098207473755, -0.07805521786212921, -0.003540715668350458, -0.09389683604240417, -0.10968118906021118, 0.11788082867860794, -0.09763962030410767, -0.03209688887000084, 0.01961873099207878, -0.10752160847187042, -0.062128420919179916, 0.058965861797332764, -0.07415786385536194, -0.15279442071914673, 0.0029302199836820364, -0.10459505021572113, 0.015197936445474625, 0.07901424169540405, 0.09199965000152588, 0.04015572369098663, 0.018961796537041664, -0.15907828509807587, 0.06945469975471497, -0.0746091902256012, -0.020473552867770195, 0.033283546566963196, -0.07648134231567383, 0.06795112788677216, -0.1352221518754959, -0.07441984117031097, -0.01485613826662302, 0.10271868854761124, -0.09187072515487671, -0.01912451535463333, -0.09114807844161987, -0.14532332122325897, 0.0035469031427055597, 0.014129050076007843, -0.09926493465900421, 0.10664155334234238, 0.06011591851711273, -0.020925190299749374, -0.12874430418014526, 0.06704498082399368, 0.035599760711193085, 0.04774375632405281, -0.14657741785049438], [-0.025602148845791817, 0.11686772853136063, 0.016841460019350052, 0.006754732225090265, 0.11560981720685959, -0.2520124614238739, 0.060268256813287735, 0.01290063839405775, -0.3860768973827362, 0.004006068687886, 0.047937002032995224, 0.08050113916397095, 0.050373658537864685, -0.0596330426633358, 0.09531603008508682, -0.024286732077598572, -0.15625527501106262, -0.12869764864444733, 0.07214518636465073, -0.19804762303829193, 0.1496431827545166, 0.11766607314348221, -0.15600480139255524, -0.10658274590969086, 0.14490389823913574, -0.037684258073568344, 0.22025445103645325, -0.09221655875444412, 0.046372417360544205, -0.03437541797757149, -0.1762322336435318, 0.24089746177196503, 0.03965405747294426, 0.0292044747620821, -0.24483685195446014, -0.1104680597782135, 0.2129596322774887, -0.018352532759308815, 0.188197523355484, -0.2931203544139862, 0.10075932741165161, 0.22387252748012543, 0.08604823797941208, -0.15757760405540466, -0.142099529504776, 0.08419663459062576, 0.16200615465641022, 0.1450444906949997, -0.06066722795367241, 0.021027741953730583, -0.2828335762023926, -0.2592141926288605, 0.03317923843860626, 0.05597348511219025, -0.06903481483459473, -0.03328495845198631, -0.04083777219057083, 0.10709306597709656, 0.07411845028400421, 0.11946875602006912, 0.0171015914529562, -0.25011497735977173, 0.04951944574713707, 0.19092269241809845], [-0.048185303807258606, 0.06660954654216766, -0.0876472145318985, -0.09902772307395935, 0.03420202061533928, -0.07969305664300919, 0.06239062547683716, -0.16314385831356049, 0.1237114816904068, -0.10698637366294861, -0.03581787645816803, -0.009123111143708229, 0.041189659386873245, -0.04530099034309387, 0.027299994602799416, -0.09307544678449631, 0.022116318345069885, 0.10430564731359482, 0.005735280457884073, 0.08275126665830612, -0.09881426393985748, -0.04453941062092781, -0.09374464303255081, 0.0795665830373764, 0.08453692495822906, -0.059050675481557846, -0.011959056369960308, 0.03105621226131916, 0.066944919526577, -0.01841161400079727, -0.06253011524677277, 0.056287601590156555, 0.03128873556852341, -0.08944376558065414, 0.08218281716108322, -0.05173531919717789, -0.12121093273162842, 0.12861880660057068, -0.08070230484008789, -0.10638163983821869, -0.13306286931037903, 0.07741717994213104, 0.08412797749042511, -0.06019711121916771, 0.04447322338819504, -0.0335141085088253, 0.054033808410167694, 0.08014704287052155, -0.09269799292087555, -0.10413140803575516, -0.03936236351728439, 0.07864438742399216, -0.02278669737279415, -0.03392054885625839, 0.06406544893980026, 0.04418868198990822, -0.05346948653459549, -0.1647035926580429, -0.09397827088832855, -0.16690264642238617, 0.11420377343893051, 0.03204973042011261, 0.01907595433294773, -0.0709909200668335], [-0.004328846000134945, -0.10852763801813126, -0.041253842413425446, -0.1140085831284523, -0.07298953086137772, -0.16084374487400055, 0.06070226430892944, -0.2743671238422394, -0.02166309393942356, -0.11485878378152847, -0.07457669079303741, -0.003236380871385336, -0.008815435692667961, -0.1283976286649704, -0.08156448602676392, -0.024467142298817635, 0.03242338076233864, -0.03816545009613037, -0.07703638076782227, 0.012192392721772194, 0.04519636556506157, -0.010125594213604927, 0.4509424865245819, -0.13781976699829102, 0.1655535250902176, -0.12623515725135803, 0.06073256954550743, 0.16550703346729279, 0.07505740225315094, -0.0006307661533355713, 0.2030300348997116, 0.04829321429133415, -0.10653246194124222, 0.18145260214805603, 0.07099118828773499, -0.16042880713939667, 0.7329261302947998, 0.03342238813638687, -0.14930754899978638, -0.003212962532415986, -0.2118179202079773, 0.16877207159996033, -0.012575334869325161, -0.036987919360399246, 0.09873917698860168, 0.13177452981472015, -0.1194106936454773, -0.02085167169570923, -0.14133097231388092, -0.08633448928594589, 0.01682738959789276, -0.03551340103149414, -0.31398633122444153, -0.16259634494781494, -0.08347625285387039, -0.0993700847029686, 0.00238502467982471, -0.12093111872673035, -0.008161789737641811, 0.2678106129169464, 0.06764905899763107, 0.013167561031877995, -0.09376827627420425, 0.14488999545574188], [-0.10015518218278885, -0.14624899625778198, -0.01579008623957634, -0.27097034454345703, -0.220643550157547, -0.08588956296443939, -0.017962457612156868, -0.11354289203882217, 0.028177758678793907, -0.05266124755144119, 0.10409422218799591, -0.3252274692058563, -0.20226027071475983, -0.11519061774015427, 0.06787729263305664, -0.10257289558649063, 0.22362995147705078, -0.09500572830438614, 0.07591274380683899, -0.14764539897441864, -0.1625637710094452, -0.06484595686197281, 0.036125101149082184, 0.03547064960002899, 0.17672646045684814, -0.12971699237823486, -0.12308787554502487, -0.10952436178922653, 0.12818372249603271, -0.16559970378875732, 0.2290274202823639, -0.06865017116069794, -0.0663738027215004, -0.17493797838687897, 0.043390389531850815, -0.09915187209844589, -0.19733457267284393, 0.07133768498897552, -0.03541720286011696, 0.06952926516532898, -0.15067151188850403, 0.1237727701663971, 0.16866591572761536, 0.29342588782310486, -0.025166770443320274, 0.10127930343151093, 0.030589330941438675, -0.018160181120038033, 0.12615005671977997, 0.08325883001089096, 0.2040497213602066, 0.037895143032073975, 0.16693080961704254, -0.1350220888853073, 0.10792746394872665, 0.27517229318618774, 0.07601287961006165, 0.1836373656988144, 0.07992524653673172, 0.04315820708870888, -0.047880593687295914, 0.34086906909942627, -0.011443840339779854, 0.08493820577859879], [0.045672934502363205, -0.10216096043586731, -0.01704709604382515, 0.09118684381246567, -0.044238969683647156, 0.008772652596235275, -0.09080758690834045, 0.167233407497406, 0.30712708830833435, 0.14250987768173218, 0.04135033115744591, -0.11067502945661545, 0.031428128480911255, -0.15106943249702454, -0.09347531199455261, -0.09747454524040222, 0.23434250056743622, 0.022297082468867302, 0.005731061566621065, 0.31344351172447205, -0.0636424794793129, 0.17736609280109406, 0.07823921740055084, 0.05391496419906616, 0.07660581171512604, 0.296982079744339, 0.08697295188903809, 0.010354764759540558, 0.18395397067070007, 0.20666158199310303, 0.0284037534147501, -0.0640311911702156, -7.592645852128044e-05, -0.015925463289022446, 0.03664133697748184, 0.06026732921600342, -0.40536239743232727, 0.12711788713932037, 0.08108741790056229, 0.10292105376720428, -0.014675992541015148, 0.2922199070453644, -0.14276164770126343, 0.2728610038757324, 0.24767392873764038, 0.22036844491958618, -0.17479121685028076, 0.07156209647655487, 0.2436009645462036, 0.13154636323451996, 0.11746387928724289, 0.29656821489334106, 0.08964798599481583, -0.14844422042369843, 0.08934339135885239, 0.2982722818851471, 0.24612119793891907, 0.19010894000530243, -0.04977843165397644, -0.10260655730962753, 0.0709407702088356, 0.3497604727745056, 0.19301925599575043, -0.20978982746601105], [0.21906200051307678, 0.029254665598273277, 0.06820026785135269, 0.1523490995168686, 0.05666618421673775, 0.010641351342201233, 0.004604389425367117, -0.05182588845491409, -0.14129042625427246, 0.12992045283317566, -0.03472165763378143, 0.1487215906381607, -0.06776641309261322, 0.026451781392097473, 0.3464471995830536, 0.03104672208428383, 0.023827914148569107, 0.27528947591781616, -0.0240052230656147, -0.1690695434808731, 0.23860090970993042, 0.0012962047476321459, -0.3298308253288269, -0.022033721208572388, 0.09804131835699081, 0.005661018192768097, -0.009447754360735416, 0.25275781750679016, -0.01749512553215027, 0.3389012813568115, 0.039216991513967514, -0.13381578028202057, -0.16736957430839539, 0.1214161068201065, 0.1514109969139099, -0.11253352463245392, -0.09116502851247787, 0.16805191338062286, 0.224251851439476, -0.01639522984623909, -0.08589191734790802, 0.35121169686317444, 0.004113445989787579, 0.14792630076408386, 0.08850351721048355, 0.07885060459375381, -0.22840367257595062, -0.09560447931289673, 0.06992143392562866, 0.19359290599822998, 0.2671549618244171, -0.020745037123560905, 0.03294937312602997, 0.026189401745796204, 0.06033167615532875, 0.3521086573600769, 0.08359476178884506, 0.20792731642723083, -0.04976819083094597, -0.0830354318022728, -0.10247612744569778, -0.20344379544258118, 0.20945113897323608, -0.12164320051670074], [0.2666589915752411, -0.20932841300964355, 0.24568678438663483, 0.03857581689953804, 0.08941706269979477, 0.3035527467727661, -0.0630456805229187, 0.19886870682239532, -0.05022749304771423, 0.34418606758117676, -0.11700432747602463, 0.2061832994222641, -0.11776598542928696, 0.15105298161506653, 0.23454992473125458, 0.16969020664691925, 0.2639302611351013, 0.40258583426475525, -0.3288672864437103, -0.15528132021427155, -0.20482808351516724, -0.11295031011104584, -0.12817153334617615, -0.06909146159887314, 0.07164335250854492, 0.014099380001425743, -0.17547088861465454, 0.37367093563079834, 0.005178450141102076, 0.12061452120542526, -0.1881362348794937, -0.12070858478546143, -0.23410633206367493, 0.2258342206478119, 0.1911097913980484, 0.23642665147781372, 0.007095401640981436, 0.03968995809555054, 0.07420133799314499, 0.15002520382404327, -0.1943298727273941, -0.01595592498779297, -0.5708651542663574, 0.11901573836803436, 0.23261365294456482, -0.19422303140163422, -0.2547212243080139, -0.22691990435123444, 0.28113311529159546, 0.2809334099292755, 0.2323102056980133, 0.0043365731835365295, -0.24439918994903564, -0.16411003470420837, 0.06964019685983658, -0.045120447874069214, 0.03567437082529068, -0.05224684625864029, 0.10339076071977615, -0.03927711769938469, 0.17234526574611664, -0.11865092068910599, 0.2504810392856598, -0.3739127218723297], [0.18737469613552094, -0.2799304723739624, 0.12564833462238312, -0.09498459100723267, -0.20044457912445068, 0.15677547454833984, -0.08281947672367096, 0.15168459713459015, -0.22341598570346832, 0.2652311325073242, -0.08604161441326141, 0.23790320754051208, -0.16735544800758362, 0.32022687792778015, 0.03884116932749748, 0.44766131043434143, 0.25137442350387573, 0.4082104563713074, -0.24427682161331177, -0.05821186676621437, -0.17130038142204285, -0.033299703150987625, -0.1788133829832077, 0.08357010781764984, 0.18147307634353638, 0.023588573560118675, -0.233833447098732, 0.18820364773273468, -0.18242813646793365, 0.23201781511306763, -0.22124263644218445, -0.0662558451294899, -0.13530151546001434, 0.2254912257194519, 0.10433704406023026, 0.17823655903339386, 0.05734429508447647, -0.12653134763240814, -0.12139315158128738, 0.22340261936187744, -0.16451752185821533, -0.23744076490402222, -0.2805880606174469, -0.03991404548287392, 0.37948843836784363, -0.1636023074388504, -0.15942952036857605, -0.2829221785068512, 0.2891237139701843, 0.316823273897171, 0.10579150915145874, -0.04520830512046814, -0.4425409734249115, -0.07554876804351807, 0.17685063183307648, -0.03603019192814827, 0.030696678906679153, 0.05151229724287987, 0.1603572964668274, -0.03146529570221901, 0.026776231825351715, -0.19030340015888214, 0.19667655229568481, -0.15984556078910828], [-0.09081608057022095, -0.14466801285743713, 0.044528067111968994, 0.07953573763370514, 0.012203547172248363, -0.018395254388451576, 0.08966973423957825, 0.07054666429758072, 0.4198007881641388, 0.07747331261634827, 0.04452606290578842, -0.0879998728632927, -0.08492390066385269, 0.06197065860033035, -0.13249067962169647, 0.12507374584674835, 0.1461150050163269, -0.12988010048866272, 0.02768728882074356, 0.29920700192451477, -0.20824848115444183, 0.18839524686336517, 0.1661563515663147, 0.14234553277492523, 0.004023548681288958, 0.21684511005878448, 0.12630492448806763, -0.11962413787841797, 0.03173878788948059, -0.1427340805530548, 0.24503947794437408, 0.11264287680387497, 0.035222236067056656, -0.016619617119431496, 0.044095396995544434, 0.19120252132415771, -0.11133076250553131, -0.18792042136192322, -0.2870832681655884, 0.09453827887773514, 0.013473335653543472, -0.27439752221107483, -0.05810261517763138, 0.11170635372400284, 0.3253025412559509, 0.03259843960404396, 0.07217007130384445, 0.10372190177440643, -0.06861802190542221, -0.149225115776062, 0.06952346116304398, 0.14856061339378357, 0.03342704474925995, -0.19500267505645752, 0.02277703769505024, 0.03816948086023331, -0.04994094744324684, -0.17640171945095062, 0.06235622614622116, -0.16042236983776093, 0.17960339784622192, 0.35413601994514465, -0.04997941851615906, 0.21399371325969696], [0.09066310524940491, 0.05897769704461098, -0.0003442253510002047, 0.07576613128185272, 0.0987849235534668, -0.268582284450531, -0.03851187974214554, -0.05213259905576706, -0.07305535674095154, -0.11136168986558914, -0.014145052060484886, 0.06991208344697952, 0.11195432394742966, -0.044802241027355194, -0.0665978491306305, -0.1983455866575241, -0.042617686092853546, -0.1138472855091095, 0.15352289378643036, -0.035033054649829865, 0.07917831838130951, 0.2132534384727478, 0.03981505706906319, -0.10140568763017654, 0.0796760842204094, -0.024380924180150032, 0.150498166680336, -0.17822915315628052, -0.026718879118561745, 0.004777072928845882, -0.06948903203010559, 0.2639794647693634, 0.0575002059340477, 0.033016931265592575, -0.062496401369571686, 0.10043148696422577, 0.4472234845161438, -0.006243532989174128, -0.14255979657173157, -0.10389681160449982, 0.27462238073349, -0.3440186381340027, 0.42386871576309204, -0.16871598362922668, -0.07440714538097382, -0.047891080379486084, 0.301365464925766, 0.18782727420330048, 0.012180688790977001, -0.1465129852294922, -0.09241101890802383, -0.07430792599916458, 0.11718612909317017, 0.10968940705060959, -0.09655402600765228, -0.05813631787896156, -0.13383512198925018, 0.09195634722709656, 0.10686934739351273, -0.002040422521531582, 0.10794011503458023, -0.15879613161087036, -0.052160605788230896, 0.42253944277763367], [0.03601522371172905, -0.09250756353139877, -0.1265035718679428, 0.09285193681716919, 0.014595821499824524, 0.06901143491268158, 0.08581481873989105, -0.06488476693630219, -0.052677884697914124, -0.06569267809391022, -0.06518281996250153, -0.15348632633686066, 0.0789046660065651, 0.0904703289270401, -0.12237025797367096, 0.09485886991024017, 0.09469716250896454, -0.0650649219751358, -0.08304621279239655, -0.0616690069437027, 0.056986626237630844, -0.05608881637454033, -0.0839463472366333, 0.08971215784549713, 0.02484568953514099, 0.038990214467048645, -0.09522607922554016, -0.053096652030944824, -0.12898845970630646, 0.05948154628276825, 0.07638955116271973, 0.05274736136198044, -0.057586293667554855, -0.11883403360843658, -0.0857856422662735, 0.03547056391835213, -0.01945720613002777, -0.09229542315006256, 0.04565683379769325, 0.015733540058135986, -0.07589589059352875, -0.031794607639312744, 0.06465036422014236, -0.0739574134349823, 0.05783854424953461, 0.04114801436662674, 0.018628383055329323, -0.05912123620510101, 0.08011996746063232, -0.0813380628824234, -0.11182036995887756, 0.091401606798172, -0.05309648811817169, -0.06283202767372131, 0.008000552654266357, -0.132656529545784, 0.0703773945569992, -0.15077152848243713, -0.07738187164068222, -0.13177910447120667, -0.051604293286800385, -0.045032620429992676, -0.09427234530448914, -0.0874839723110199], [0.12862150371074677, 0.05600034072995186, -0.11256515979766846, 0.014564141631126404, 0.1127658560872078, -0.09407752752304077, -0.08516813069581985, 0.003930089063942432, 0.14645235240459442, 0.0023164579179137945, -0.09472687542438507, 0.027543669566512108, -0.0707796961069107, -0.2509021461009979, -0.2488277554512024, -0.3879687488079071, -0.013065367937088013, 0.03495824709534645, 0.060485322028398514, 0.15536755323410034, 0.2220313996076584, 0.15913918614387512, 0.015608633868396282, -0.04954738914966583, -0.16797727346420288, 0.10297916829586029, 0.11252211779356003, -0.13958489894866943, 0.172366663813591, 0.1358061581850052, 0.1299603134393692, 0.0879279300570488, 0.10637623816728592, -0.10082190483808517, -0.05874718353152275, -0.17188851535320282, 0.061876311898231506, 0.17413662374019623, 0.16694341599941254, -0.21131756901741028, -0.0439210943877697, 0.413787305355072, -0.07398249953985214, 0.011696110479533672, 0.05853479355573654, 0.1634693145751953, 0.018825028091669083, 0.1431550681591034, 0.056283868849277496, -0.0473964549601078, 0.06452689319849014, 0.09281598776578903, -0.11760880798101425, 0.0626705139875412, -0.06202654168009758, 0.23846201598644257, 0.2641460597515106, 0.3043266832828522, 0.0742490366101265, 0.004537871107459068, 0.05655670538544655, 0.16105787456035614, 0.2250407487154007, -0.11745554208755493], [0.0028060826007276773, -0.1118360161781311, 0.08681158721446991, -0.04461391642689705, -0.00837637484073639, 0.20549416542053223, -0.005443270318210125, 0.08581391721963882, 0.3278926908969879, 0.12176921963691711, 0.09366141259670258, -0.16549699008464813, -0.05790949985384941, -0.05390637367963791, -0.2358904927968979, 0.02398369088768959, 0.13628794252872467, 0.04833531752228737, 0.10869031399488449, 0.10223762691020966, 0.054222580045461655, -0.0336606539785862, 0.1587403565645218, 0.10140692442655563, -0.030213234946131706, 0.252103328704834, 0.10904119908809662, 0.060247790068387985, 0.06037645414471626, 0.05592169985175133, 0.21206742525100708, -0.017825109884142876, 0.02940167486667633, 0.14067547023296356, 0.09024673700332642, -0.005855541210621595, -0.4546142816543579, 0.1431952565908432, 0.06401759386062622, 0.22644414007663727, -0.06923197954893112, 0.33600980043411255, -0.13943567872047424, 0.2112031877040863, 0.18011988699436188, 0.16844864189624786, 0.008472439832985401, -0.11665596067905426, 0.04583640396595001, 0.16929912567138672, 0.24974782764911652, 0.29495516419410706, -0.06205907091498375, -0.14955347776412964, 0.12851394712924957, 0.22510863840579987, 0.2405550628900528, 0.24080966413021088, -0.08801840990781784, -0.17246460914611816, 0.15626797080039978, 0.2494523823261261, 0.011033584363758564, -0.24087677896022797]], "net.2.bias": [0.1835310459136963, -0.09438155591487885, -0.058030687272548676, 0.06305430829524994, 0.15648645162582397, 0.04773043096065521, 0.14915339648723602, -0.09442026913166046, -0.11474344879388809, 0.1802818477153778, -0.11591660976409912, 0.07969848811626434, 0.14077554643154144, 0.09480566531419754, -0.08122198283672333, 0.128567174077034, -0.05673617497086525, -0.11059588193893433, -0.0747891440987587, 0.06608700752258301, 0.12253624945878983, -0.0005628804210573435, -0.13670964539051056, -0.06320694833993912, 0.07707604020833969, 0.007793564815074205, 0.12054949998855591, 0.02724565379321575, 0.10284426063299179, 0.13690659403800964, 0.15145738422870636, -0.15002848207950592, 0.1251235455274582, -0.10612034797668457, 0.15243150293827057, -0.04445749893784523, 0.06981640309095383, -0.05747045949101448, 0.12981972098350525, 0.05710512399673462, -0.03878350555896759, -0.09902829676866531, 0.09027343988418579, -0.06804632395505905, 0.07989703863859177, 0.15311674773693085, 0.016438374295830727, 0.05248649790883064, 0.022458991035819054, 0.11449146270751953, -0.04055138677358627, 0.15599483251571655, -0.09486309438943863, -0.1298082321882248, 0.14324040710926056, 0.1417398452758789, 0.10781611502170563, 0.004431046079844236, -0.08149240165948868, 0.16831961274147034, 0.06361835449934006, -0.10265614092350006, 0.10792554169893265, 0.11083199828863144], "net.4.weight": [[0.23296424746513367, -0.02237112633883953, -0.20212891697883606, -0.09643200039863586, 0.266785591840744, 0.11948221921920776, -0.2806316316127777, 0.09813925623893738, -0.2911597192287445, -0.2564341127872467, 0.43451598286628723, 0.06834506243467331, -0.18105767667293549, 0.13045942783355713, -0.22570213675498962, -0.2988141179084778, 0.04688766971230507, 0.06078718602657318, -0.026266004890203476, -0.004300563596189022, -0.0193881094455719, 0.020061800256371498, -0.3614826202392578, -0.34661802649497986, -0.20866961777210236, -0.24742044508457184, 0.3270092308521271, 0.18795917928218842, 0.22260017693042755, 0.17064106464385986, 0.15264973044395447, -0.04925093054771423, -0.2690380811691284, -0.07314609736204147, 0.2428082674741745, -0.22492633759975433, 0.03346512094140053, 0.012910467572510242, 0.20479455590248108, 0.2547193169593811, 0.0009832585928961635, -0.3459306061267853, -0.19353950023651123, -0.01148674264550209, 0.17363591492176056, -0.15399225056171417, 0.07001415640115738, -0.17387811839580536, 0.08483627438545227, -0.33038073778152466, -0.014990475960075855, 0.2327757626771927, -0.024661730974912643, 0.03258896619081497, -0.2706466615200043, -0.2515890598297119, 0.17521902918815613, 0.14574427902698517, 0.1345813274383545, -0.2773370146751404, 0.1252899318933487, 0.01796133816242218, -0.04016394913196564, -0.1796603947877884], [0.276192843914032, -0.0024082364980131388, 0.16983596980571747, -0.1763811707496643, -0.09246686846017838, 0.19140803813934326, -0.12758725881576538, -0.10619562864303589, -0.15485186874866486, 0.07891865074634552, 0.31207647919654846, 0.25191280245780945, -0.11621472984552383, 0.2728954553604126, -0.17161965370178223, 0.12909865379333496, -0.16259536147117615, -0.030648134648799896, -0.08589132130146027, 0.31184667348861694, -0.28356805443763733, 0.15553665161132812, 0.17308175563812256, 0.26562318205833435, -0.2124462127685547, -0.03754441812634468, -0.09643667191267014, -0.1545623242855072, 0.24775521457195282, -0.16712069511413574, -0.02923687733709812, 0.10536231100559235, 0.16171738505363464, 0.07899145036935806, 0.35123568773269653, 0.1459333747625351, -0.12398561835289001, 0.017049910500645638, -0.07571078091859818, -0.11177484691143036, 0.0021506682969629765, -0.05326107516884804, 0.0669470876455307, 0.07800149917602539, 0.03456408530473709, 0.250107079744339, -0.061506059020757675, -0.2142077535390854, 0.24807320535182953, 0.013733137398958206, -0.03703005239367485, -0.03506243973970413, -0.059722308069467545, 0.2044193148612976, -0.05748319625854492, -0.21052053570747375, -0.24795693159103394, 0.010113107040524483, 0.23894739151000977, 0.20868554711341858, 0.1956922560930252, 0.10522826015949249, -0.1887255758047104, -0.13856251537799835], [0.18987955152988434, -0.016797326505184174, 0.20746581256389618, -0.2355228215456009, 0.24178528785705566, -0.3315046429634094, 0.0032083489932119846, 0.1187482476234436, 0.15465940535068512, -0.08147915452718735, -0.19330500066280365, -0.25833702087402344, 0.1606893241405487, -0.09729933738708496, -0.23596635460853577, 0.06596209108829498, 0.06055322289466858, -0.07249778509140015, 0.005344778299331665, 0.1643034666776657, 0.1126023605465889, 0.2141757309436798, 0.056710898876190186, 0.06562753021717072, -0.22840972244739532, -0.19492092728614807, 0.22526760399341583, -0.00690285861492157, -0.31536489725112915, -0.2922760248184204, -0.27364763617515564, -0.08533095568418503, 0.05989999324083328, 0.061448823660612106, 0.07457933574914932, 0.1485435664653778, 0.1718006432056427, 0.0005207551876083016, 0.21943171322345734, -0.08966736495494843, -0.007868279702961445, 0.15158390998840332, -0.2922923266887665, -0.05364900827407837, -0.23559358716011047, 0.10921169817447662, -0.018314151093363762, 0.19466091692447662, 0.2804006338119507, 0.07844934612512589, -0.0958985686302185, 0.12558412551879883, -0.021706698462367058, 0.4124426245689392, -0.24922816455364227, -0.1408674269914627, -0.15222996473312378, -0.5198234915733337, -0.4851689338684082, -0.007348952349275351, 0.24870124459266663, 0.03765416890382767, 0.14544600248336792, -0.10868120193481445]], "net.4.bias": [0.04035351797938347, 0.08364707976579666, -0.06634562462568283]}
    </script>

    <script>
        // ==================== NEURAL NETWORK ====================
        const BRAIN = JSON.parse(document.getElementById('brainData').textContent);
        
        // Simple neural network forward pass
        class NeuralNetwork {
            constructor(weights) {
                this.w0 = weights['net.0.weight'];
                this.b0 = weights['net.0.bias'];
                this.w2 = weights['net.2.weight'];
                this.b2 = weights['net.2.bias'];
                this.w4 = weights['net.4.weight'];
                this.b4 = weights['net.4.bias'];
            }
            
            relu(x) { return Math.max(0, x); }
            
            forward(input) {
                // Layer 0: 48 -> 64
                let h1 = new Array(64).fill(0);
                for (let i = 0; i < 64; i++) {
                    let sum = this.b0[i];
                    for (let j = 0; j < 48; j++) {
                        sum += input[j] * this.w0[i][j];
                    }
                    h1[i] = this.relu(sum);
                }
                
                // Layer 2: 64 -> 32
                let h2 = new Array(32).fill(0);
                for (let i = 0; i < 32; i++) {
                    let sum = this.b2[i];
                    for (let j = 0; j < 64; j++) {
                        sum += h1[j] * this.w2[i][j];
                    }
                    h2[i] = this.relu(sum);
                }
                
                // Layer 4: 32 -> 3 (output)
                let output = new Array(3).fill(0);
                for (let i = 0; i < 3; i++) {
                    let sum = this.b4[i];
                    for (let j = 0; j < 32; j++) {
                        sum += h2[j] * this.w4[i][j];
                    }
                    output[i] = sum;
                }
                
                return output;
            }
            
            decide(input) {
                const output = this.forward(input);
                // 0=left, 1=straight, 2=right
                let maxIdx = 0;
                for (let i = 1; i < 3; i++) {
                    if (output[i] > output[maxIdx]) maxIdx = i;
                }
                return maxIdx;
            }
        }
        
        const neuralBrain = new NeuralNetwork(BRAIN);

        // ==================== RULE ENGINE (G√∂del Layer) ====================
        class RuleEngine {
            constructor() {
                this.rules = [];
                this.pendingCredits = []; // Track which rules influenced recent decisions
                this.stateHistory = {};   // Track recent states per snake for death analysis
                this.deathPatterns = {};  // Count death patterns to find common causes
                this.ruleIdCounter = 0;
                this.tick = 0;
                this.rulesGenerated = 0;
                this.load();
            }

            // Record state before each decision (for death analysis)
            recordState(snakeId, state, chosenAction) {
                if (!this.stateHistory[snakeId]) this.stateHistory[snakeId] = [];
                this.stateHistory[snakeId].push({ state: {...state}, action: chosenAction, tick: this.tick });
                // Keep only last 10 states
                if (this.stateHistory[snakeId].length > 10) this.stateHistory[snakeId].shift();
            }

            // Analyze death and potentially generate a new rule
            analyzeDeathAndGenerateRule(snakeId) {
                const history = this.stateHistory[snakeId];
                if (!history || history.length < 2) return;

                // Look at the last few states before death
                const lastState = history[history.length - 1];
                const state = lastState.state;
                const fatalAction = lastState.action; // 0=left, 1=straight, 2=right

                // Create a "death signature" from key state features
                const signature = this.createSignature(state, fatalAction);

                // Count this death pattern
                this.deathPatterns[signature] = (this.deathPatterns[signature] || 0) + 1;

                // If we've seen this pattern 3+ times, generate a rule
                if (this.deathPatterns[signature] >= 3) {
                    // Check if we already have a similar rule
                    const existingRule = this.rules.find(r =>
                        r.source === 'death_pattern' &&
                        JSON.stringify(r.trigger.conditions) === JSON.stringify(state)
                    );

                    if (!existingRule && this.rules.length < 50) { // Cap at 50 rules
                        // Create rule to avoid the fatal action
                        const bias = [0, 0, 0];
                        bias[fatalAction] = -1.5; // Strongly discourage the fatal action
                        // Slightly encourage alternatives
                        bias[(fatalAction + 1) % 3] = 0.3;
                        bias[(fatalAction + 2) % 3] = 0.3;

                        // Simplify state to key features only
                        const keyConditions = {};
                        if (state.wallAhead) keyConditions.wallAhead = true;
                        if (state.wallLeft) keyConditions.wallLeft = true;
                        if (state.wallRight) keyConditions.wallRight = true;
                        if (state.bodyAhead) keyConditions.bodyAhead = true;
                        if (state.bodyLeft) keyConditions.bodyLeft = true;
                        if (state.bodyRight) keyConditions.bodyRight = true;
                        if (state.enemyAhead) keyConditions.enemyAhead = true;

                        if (Object.keys(keyConditions).length > 0) {
                            const newRule = this.createRule(
                                { type: 'state', conditions: keyConditions },
                                { bias },
                                'death_pattern'
                            );
                            newRule.stats.confidence = 0.35; // Start with low confidence
                            this.rulesGenerated++;
                            console.log(`[G√ñDEL] Generated rule from ${this.deathPatterns[signature]} deaths:`, keyConditions, '‚Üí avoid action', fatalAction);

                            // Reset this pattern count
                            this.deathPatterns[signature] = 0;
                        }
                    }
                }

                // Clear history for dead snake
                delete this.stateHistory[snakeId];
            }

            createSignature(state, action) {
                const parts = [];
                if (state.wallAhead) parts.push('wA');
                if (state.wallLeft) parts.push('wL');
                if (state.wallRight) parts.push('wR');
                if (state.bodyAhead) parts.push('bA');
                if (state.bodyLeft) parts.push('bL');
                if (state.bodyRight) parts.push('bR');
                if (state.enemyAhead) parts.push('eA');
                parts.push(`a${action}`);
                return parts.join('_') || 'clear_a' + action;
            }

            createRule(trigger, action, source = 'manual') {
                const rule = {
                    id: `rule_${this.ruleIdCounter++}`,
                    trigger: trigger,      // { type: 'state', conditions: {...} }
                    action: action,        // { bias: [left, straight, right] }
                    stats: { applied: 0, successes: 0, failures: 0, confidence: 0.5 },
                    source: source,
                    createdAt: Date.now(),
                    active: true
                };
                this.rules.push(rule);
                return rule;
            }

            matchesTrigger(trigger, state) {
                if (trigger.type === 'state') {
                    for (const [key, value] of Object.entries(trigger.conditions)) {
                        if (typeof value === 'boolean') {
                            if (!!state[key] !== value) return false;
                        } else if (typeof value === 'object') {
                            if (value.min !== undefined && state[key] < value.min) return false;
                            if (value.max !== undefined && state[key] > value.max) return false;
                        } else {
                            if (state[key] !== value) return false;
                        }
                    }
                    return true;
                }
                return false;
            }

            applyRules(neuralOutput, gameState, snakeId) {
                let modified = [...neuralOutput];
                let appliedRuleIds = [];

                for (const rule of this.rules) {
                    if (!rule.active) continue;
                    if (this.matchesTrigger(rule.trigger, gameState)) {
                        for (let i = 0; i < 3; i++) {
                            modified[i] += rule.action.bias[i] * rule.stats.confidence;
                        }
                        appliedRuleIds.push(rule.id);
                        rule.stats.applied++;
                    }
                }

                if (appliedRuleIds.length > 0) {
                    this.pendingCredits.push({ snakeId, ruleIds: appliedRuleIds, tick: this.tick });
                    if (this.pendingCredits.length > 200) this.pendingCredits = this.pendingCredits.slice(-100);
                }

                return modified;
            }

            onOutcome(snakeId, outcome) {
                const rewards = { death: -1, ate_food: 0.3, got_kill: 1.0, survived_30: 0.1 };
                const reward = rewards[outcome] || 0;
                const recent = this.pendingCredits.filter(p => p.snakeId === snakeId && this.tick - p.tick < 30);

                for (const credit of recent) {
                    for (const ruleId of credit.ruleIds) {
                        const rule = this.rules.find(r => r.id === ruleId);
                        if (!rule) continue;
                        if (reward > 0) rule.stats.successes++;
                        else rule.stats.failures++;
                        const total = rule.stats.successes + rule.stats.failures;
                        if (total > 0) rule.stats.confidence = 0.3 + 0.7 * (rule.stats.successes / total);
                    }
                }

                if (outcome === 'death') {
                    this.pendingCredits = this.pendingCredits.filter(p => p.snakeId !== snakeId);
                }
            }

            pruneRules() {
                const before = this.rules.length;
                this.rules = this.rules.filter(rule => {
                    if (rule.stats.applied < 10) return true;
                    if (rule.stats.confidence < 0.25) return false;
                    return true;
                });
                if (this.rules.length < before) console.log(`[G√ñDEL] Pruned ${before - this.rules.length} weak rules`);
            }

            update() {
                this.tick++;
                if (this.tick % 500 === 0) { this.pruneRules(); this.save(); }
            }

            save() {
                localStorage.setItem('locomotio_rules', JSON.stringify({
                    rules: this.rules, ruleIdCounter: this.ruleIdCounter, savedAt: Date.now()
                }));
            }

            load() {
                try {
                    const saved = localStorage.getItem('locomotio_rules');
                    if (saved) {
                        const data = JSON.parse(saved);
                        this.rules = data.rules || [];
                        this.ruleIdCounter = data.ruleIdCounter || 0;
                        console.log(`[G√ñDEL] Loaded ${this.rules.length} rules`);
                    }
                } catch (e) { console.log('[G√ñDEL] No saved rules'); }
            }

            getStats() {
                const learned = this.rules.filter(r => r.source === 'death_pattern').length;
                return {
                    total: this.rules.length,
                    active: this.rules.filter(r => r.active).length,
                    learned: learned,
                    generated: this.rulesGenerated,
                    avgConf: this.rules.length > 0
                        ? (this.rules.reduce((s, r) => s + r.stats.confidence, 0) / this.rules.length).toFixed(2) : 0,
                    patterns: Object.keys(this.deathPatterns).length
                };
            }
        }

        const ruleEngine = new RuleEngine();

        // Starter rules if none exist
        if (ruleEngine.rules.length === 0) {
            ruleEngine.createRule({ type: 'state', conditions: { wallAhead: true } }, { bias: [-0.5, -2.0, -0.5] }, 'manual');
            ruleEngine.createRule({ type: 'state', conditions: { bodyLeft: true } }, { bias: [-1.5, 0, 0.3] }, 'manual');
            ruleEngine.createRule({ type: 'state', conditions: { bodyRight: true } }, { bias: [0.3, 0, -1.5] }, 'manual');
            ruleEngine.createRule({ type: 'state', conditions: { foodAhead: true } }, { bias: [0, 0.8, 0] }, 'manual');
            ruleEngine.createRule({ type: 'state', conditions: { foodLeft: true, foodAhead: false } }, { bias: [0.6, 0, 0] }, 'manual');
            ruleEngine.createRule({ type: 'state', conditions: { foodRight: true, foodAhead: false } }, { bias: [0, 0, 0.6] }, 'manual');
            ruleEngine.createRule({ type: 'state', conditions: { enemyAhead: true } }, { bias: [0, 0.5, 0] }, 'manual');
            console.log('[G√ñDEL] Created 7 starter rules');
            ruleEngine.save();
        }

        // ==================== MULTIPLAYER ====================
        // Player username
        let playerName = localStorage.getItem('locomot_username') || 'Train' + Math.floor(Math.random() * 999);

        const Multiplayer = {
            username: playerName,
            socket: null,
            connected: false,
            playerId: null,
            roomId: null,
            otherPlayers: new Map(), // id -> player state
            playerLastSeen: new Map(), // id -> timestamp for inactive cleanup
            INACTIVE_TIMEOUT: 30000, // Boot players after 30 seconds of no updates
            serverUrl: 'locomot-io.savecharlie.partykit.dev',

            connect(roomId = 'main') {
                this.roomId = roomId;
                try {
                    // Use PartySocket for reconnection handling
                    this.socket = new WebSocket(`wss://${this.serverUrl}/party/${roomId}`);

                    this.socket.onopen = () => {
                        console.log('[MP] Connected to room:', roomId);
                        this.connected = true;
                        this.showStatus('Connected!');
                        // Send username to server
                        if (this.username) {
                            this.send({ type: 'name', name: this.username });
                        }
                    };

                    this.socket.onmessage = (event) => {
                        this.handleMessage(JSON.parse(event.data));
                    };

                    this.socket.onclose = () => {
                        console.log('[MP] Disconnected');
                        this.connected = false;
                        this.showStatus('Disconnected');
                        // Try reconnect after 2s
                        setTimeout(() => this.connect(roomId), 2000);
                    };

                    this.socket.onerror = (e) => {
                        console.log('[MP] Error:', e);
                    };
                } catch (e) {
                    console.log('[MP] Connection failed:', e);
                }
            },

            handleMessage(data) {
                switch (data.type) {
                    case 'init':
                        this.playerId = data.playerId;
                        console.log('[MP] Assigned ID:', this.playerId);
                        // Initialize other players
                        for (const p of data.players) {
                            if (p.id !== this.playerId) {
                                this.otherPlayers.set(p.id, p);
                                this.playerLastSeen.set(p.id, Date.now());
                            }
                        }
                        break;

                    case 'player_joined':
                        console.log('[MP] Player joined:', data.player.name);
                        this.otherPlayers.set(data.player.id, data.player);
                        this.playerLastSeen.set(data.player.id, Date.now());
                        this.showStatus(`${data.player.name} joined!`);
                        break;

                    case 'player_left':
                        const left = this.otherPlayers.get(data.playerId);
                        this.otherPlayers.delete(data.playerId);
                        this.playerLastSeen.delete(data.playerId);
                        if (left) this.showStatus(`${left.name} left`);
                        break;

                    case 'state':
                        // Update all other players
                        for (const p of data.players) {
                            if (p.id !== this.playerId) {
                                this.otherPlayers.set(p.id, p);
                                this.playerLastSeen.set(p.id, Date.now());
                            }
                        }
                        break;
                    
                    case 'hit':
                        // We got hit by another player!
                        if (data.targetId === this.playerId) {
                            // Damage a segment - head if no body cars, otherwise random body car
                            const segIdx = snake.length === 1 ? 0 : 1 + Math.floor(Math.random() * (snake.length - 1));
                            if (snake[segIdx]) {
                                snake[segIdx].hp -= data.damage;
                                haptic('medium');
                                // Flash red
                                const seg = snake[segIdx];
                                for (let j = 0; j < 5; j++) {
                                    particles.push({ x: seg.x * GRID, y: seg.y * GRID, vx: (Math.random()-0.5)*3, vy: (Math.random()-0.5)*3, life: 10, color: '#f00' });
                                }
                            }
                        }
                        break;
                }
            },

            send(data) {
                if (this.socket && this.connected) {
                    this.socket.send(JSON.stringify(data));
                }
            },

            // Send our position to server
            sendUpdate(x, y, segments, score) {
                this.send({
                    type: 'update',
                    x, y,
                    segments: segments.map(s => ({ x: s.x, y: s.y })),
                    score
                });
            },

            // Send direction change
            sendMove(dir) {
                this.send({ type: 'move', dir });
            },

            setUsername(name) {
                name = name.trim().slice(0, 12) || 'Train' + Math.floor(Math.random() * 999);
                this.username = name;
                playerName = name;
                localStorage.setItem('locomot_username', name);
                this.send({ type: 'name', name });
            },

            showStatus(msg) {
                const el = document.getElementById('waveAnnounce');
                if (el) {
                    el.textContent = msg;
                    el.classList.add('show');
                    setTimeout(() => el.classList.remove('show'), 1500);
                }
            },

            // Boot inactive players (not updated in INACTIVE_TIMEOUT ms)
            cleanupInactivePlayers() {
                const now = Date.now();
                const toRemove = [];
                for (const [id, lastSeen] of this.playerLastSeen) {
                    if (now - lastSeen > this.INACTIVE_TIMEOUT) {
                        toRemove.push(id);
                    }
                }
                for (const id of toRemove) {
                    const player = this.otherPlayers.get(id);
                    console.log('[MP] Booting inactive player:', player?.name || id);
                    this.otherPlayers.delete(id);
                    this.playerLastSeen.delete(id);
                }
                if (toRemove.length > 0) {
                    console.log(`[MP] Cleaned up ${toRemove.length} inactive player(s)`);
                }
            },

            // Draw other players
            drawOtherPlayers(ctx) {
                for (const player of this.otherPlayers.values()) {
                    if (!player.segments || player.segments.length === 0) continue;

                    // Draw segments
                    for (let i = player.segments.length - 1; i >= 0; i--) {
                        const seg = player.segments[i];
                        const isHead = i === 0;

                        const teamColor = teamMode ? '#0ff' : player.color; ctx.fillStyle = isHead ? teamColor : this.dimColor(teamColor);
                        ctx.fillRect(seg.x * 12, seg.y * 12, 12, 12);

                        // Outline
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(seg.x * 12, seg.y * 12, 12, 12);
                    }

                    // Name tag
                    const head = player.segments[0];
                    ctx.fillStyle = '#fff';
                    ctx.font = '8px "Press Start 2P"';
                    ctx.textAlign = 'center';
                    ctx.fillText(player.name, head.x * 12 + 6, head.y * 12 - 5);
                }
            },

            dimColor(color) {
                // Dim color for body segments
                const r = parseInt(color.slice(1, 3), 16) * 0.6;
                const g = parseInt(color.slice(3, 5), 16) * 0.6;
                const b = parseInt(color.slice(5, 7), 16) * 0.6;
                return `rgb(${r},${g},${b})`;
            }
        };

        // Auto-connect to multiplayer
        const urlParams = new URLSearchParams(window.location.search);
        const roomParam = urlParams.get('room') || 'main';
        // Connect when game starts
        setTimeout(() => Multiplayer.connect(roomParam), 1000);
        
        // === KILL FEED ===
        const killFeed = {
            entries: [],
            add(killer, victim, method = '') {
                const entry = document.createElement('div');
                entry.className = 'kill-feed-entry';
                entry.innerHTML = `<span style="color:#f55">${killer}</span> üî´ <span style="color:#5ff">${victim}</span>`;
                document.getElementById('killFeed').prepend(entry);
                this.entries.push(entry);
                // Fade out after 4s
                setTimeout(() => entry.classList.add('fade'), 4000);
                setTimeout(() => entry.remove(), 4500);
                // Keep max 5
                if (this.entries.length > 5) {
                    const old = this.entries.shift();
                    old.remove();
                }
            }
        };
        
        // === HIGHLIGHT CLIP RECORDER ===
        const HighlightRecorder = {
            isRecording: false,
            mediaRecorder: null,
            chunks: [],
            clips: [],
            events: [],
            lastKillTime: 0,
            killStreak: 0,
            wasLeader: false,
            clipDuration: 10000, // 10 seconds per clip
            autoUpload: true, // Upload exciting clips to Ivy
            uploadThreshold: 120, // Min score to upload (higher = less spam)
            hotStreak: 0, // Track recent excitement
            clipCount: 0, // Total clips uploaded

            init() {
                try {
                    const stream = canvas.captureStream(30);
                    this.mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' });
                    this.mediaRecorder.ondataavailable = (e) => {
                        if (e.data.size > 0) this.chunks.push(e.data);
                    };
                    this.mediaRecorder.onstop = () => this.saveClip();
                    this.startRecording();
                    this.updateClipUI(); // Show UI immediately
                    console.log('üé¨ Highlight recorder initialized - auto-save:', this.autoDownload ? 'ON' : 'OFF');
                } catch (e) {
                    console.log('Highlight recorder not available:', e);
                }
            },

            startRecording() {
                if (!this.mediaRecorder || this.isRecording) return;
                this.chunks = [];
                this.mediaRecorder.start();
                this.isRecording = true;
                // Auto-stop after clipDuration to create rolling buffer
                setTimeout(() => {
                    if (this.isRecording && this.events.length === 0) {
                        // No events, just restart
                        this.mediaRecorder.stop();
                        this.chunks = [];
                        this.isRecording = false;
                        this.startRecording();
                    }
                }, this.clipDuration);
            },

            triggerHighlight(type, details = {}) {
                if (!this.isRecording) return;

                // Calculate score
                let score = 50;
                if (type === 'kill_streak') score = 80 + (details.streak || 0) * 40;
                else if (type === 'became_leader') score = 150;
                else if (type === 'long_train') score = 60 + (details.length || 0) * 2;

                this.events.push({ type, details, time: Date.now(), score });
                this.hotStreak += score;
                console.log('üé¨ Highlight:', type, 'score:', score, 'hot:', this.hotStreak);

                // Stop recording after a short delay to capture aftermath
                setTimeout(() => {
                    if (this.mediaRecorder && this.isRecording) {
                        this.mediaRecorder.stop();
                        this.isRecording = false;
                    }
                }, 3000);
            },

            saveClip() {
                if (this.chunks.length === 0 || this.events.length === 0) {
                    this.events = [];
                    this.hotStreak = Math.max(0, this.hotStreak - 20);
                    this.startRecording();
                    return;
                }

                const blob = new Blob(this.chunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const eventType = this.events[0]?.type || 'highlight';
                const totalScore = this.events.reduce((sum, e) => sum + (e.score || 0), 0);

                const clip = {
                    url, blob, type: eventType, score: totalScore,
                    timestamp: Date.now(), events: [...this.events]
                };

                this.clips.push(clip);

                // UPLOAD to Ivy if score meets threshold!
                if (this.autoUpload && totalScore >= this.uploadThreshold) {
                    this.uploadClip(blob, eventType, totalScore);
                }

                // Keep max 10 clips in memory
                while (this.clips.length > 10) {
                    const old = this.clips.shift();
                    URL.revokeObjectURL(old.url);
                }

                this.events = [];
                this.hotStreak = Math.max(0, this.hotStreak - 30);
                this.updateClipUI();
                this.startRecording();
            },

            async uploadClip(blob, type, score) {
                try {
                    this.clipCount++;
                    const filename = `locomotio_${type}_${score}pts_${Date.now()}.webm`;

                    const formData = new FormData();
                    formData.append('video', blob, filename);
                    formData.append('type', type);
                    formData.append('score', score);
                    formData.append('player', playerName || 'Unknown');

                    const response = await fetch('https://api.locomot.io/api/clip', {
                        method: 'POST',
                        body: formData
                    });

                    if (response.ok) {
                        console.log('üé¨ UPLOADED:', type, score + 'pts');
                        this.showNotification(`üé¨ CLIP UPLOADED! ${type.replace('_',' ').toUpperCase()} (${score}pts)`);
                    } else {
                        console.log('üé¨ Upload failed:', response.status);
                    }
                } catch (e) {
                    console.log('üé¨ Upload error:', e);
                }
            },

            showNotification(msg) {
                const notif = document.createElement('div');
                notif.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,255,0,0.9);color:#000;padding:15px 30px;border-radius:10px;font-size:16px;font-weight:bold;z-index:9999;animation:fadeOut 2s forwards;';
                notif.textContent = msg;
                document.body.appendChild(notif);
                setTimeout(() => notif.remove(), 2000);
            },

            // Event detectors
            onKill(killerName, victimName) {
                const now = Date.now();
                if (now - this.lastKillTime < 5000) {
                    this.killStreak++;
                } else {
                    this.killStreak = 1;
                }
                this.lastKillTime = now;

                if (this.killStreak >= 2) {
                    this.triggerHighlight('kill_streak', { streak: this.killStreak, killer: killerName, victim: victimName });
                } else {
                    this.triggerHighlight('kill', { killer: killerName, victim: victimName });
                }
            },

            onBecameLeader() {
                if (!this.wasLeader) {
                    this.triggerHighlight('became_leader', { length: snake.length });
                    this.wasLeader = true;
                }
            },

            onLostLeader() {
                this.wasLeader = false;
            },

            onLongTrain(length) {
                if (length >= 30 && length % 10 === 0) {
                    this.triggerHighlight('long_train', { length });
                }
            },

            updateClipUI() {
                let container = document.getElementById('clipContainer');
                if (!container) {
                    container = document.createElement('div');
                    container.id = 'clipContainer';
                    container.style.cssText = 'position:fixed;bottom:10px;right:10px;z-index:100;';
                    document.body.appendChild(container);
                }

                const icons = { kill: 'üíÄ', kill_streak: 'üî•', became_leader: 'üëë', long_train: 'üöÇ' };

                container.innerHTML = `
                    <div style="background:rgba(0,0,0,0.85);padding:10px;border-radius:8px;border:2px solid #0f0;min-width:140px;">
                        <div style="color:#0f0;font-size:10px;margin-bottom:5px;">üé¨ CLIPS ${this.clipCount > 0 ? '(' + this.clipCount + ' uploaded)' : ''}</div>
                        ${this.clips.slice(-3).map((c, i) => `
                            <button onclick="HighlightRecorder.downloadClip(${this.clips.length - 3 + i})"
                                style="display:block;background:#222;border:1px solid #0f0;color:#0f0;padding:4px 8px;margin:2px 0;font-size:8px;cursor:pointer;border-radius:4px;width:100%;">
                                ${icons[c.type] || 'üé¨'} ${c.type.replace('_', ' ').toUpperCase()} ${c.score ? '(' + c.score + 'pts)' : ''}
                            </button>
                        `).join('')}
                        ${this.clips.length > 0 ? `
                        <button onclick="HighlightRecorder.downloadAll()"
                            style="background:#0f0;border:none;color:#000;padding:4px 8px;margin-top:5px;font-size:8px;cursor:pointer;border-radius:4px;width:100%;">
                            ‚¨áÔ∏è DOWNLOAD ALL
                        </button>` : ''}
                    </div>
                `;
            },

            downloadClip(index) {
                const clip = this.clips[index];
                if (!clip) return;
                const a = document.createElement('a');
                a.href = clip.url;
                a.download = `locomotio_${clip.type}_${Date.now()}.webm`;
                a.click();
            },

            downloadAll() {
                this.clips.forEach((clip, i) => {
                    setTimeout(() => {
                        const a = document.createElement('a');
                        a.href = clip.url;
                        a.download = `locomotio_${clip.type}_${i + 1}.webm`;
                        a.click();
                    }, i * 500);
                });
            }
        };

        // Make it globally accessible for UI buttons
        window.HighlightRecorder = HighlightRecorder;

        // === INVITE LINK ===
        function updateInviteLink() {
            const room = roomParam || 'main';
            const link = 'locomot.io?room=' + room;
            document.getElementById('inviteLink').textContent = link;
        }
        function copyInvite() {
            const room = roomParam || 'main';
            const link = 'https://locomot.io?room=' + room;
            navigator.clipboard.writeText(link).then(() => {
                document.getElementById('inviteLink').textContent = 'COPIED!';
                setTimeout(updateInviteLink, 1500);
            });
        }
        setTimeout(updateInviteLink, 100);
        
        // === IDEA SUBMISSION ===
        document.getElementById('submitIdeaBtn')?.addEventListener('click', submitIdea);
        function submitIdea() {
            const idea = prompt("Got an idea for LOCOMOT.IO? Share it!");
            if (idea && idea.trim()) {
                const _e = ["s","a","v","e","c","h","a","r","l","i","e","@","g","m","a","i","l",".","c","o","m"].join(""); fetch("https://formsubmit.co/ajax/" + _e, {
                    method: "POST",
                    headers: { "Content-Type": "application/json", "Accept": "application/json" },
                    body: JSON.stringify({ message: idea, _subject: "LOCOMOT.IO Idea" })
                }).then(() => alert("Thanks! Idea sent üí°")).catch(() => alert("Failed to send - try again"));
            }
        }
        
        // === SCREEN SHAKE ===
        function screenShake() {
            document.body.classList.add('shake');
            setTimeout(() => document.body.classList.remove('shake'), 300);
        }
        
        // === SOUND EFFECTS ===
        const sounds = {
            ctx: null,
            init() {
                if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            },
            play(type) {
                this.init();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                
                if (type === 'shoot') {
                    osc.frequency.value = 200;
                    osc.type = 'square';
                    gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                    gain.gain.exponentialDecayTo && gain.gain.exponentialDecayTo(0.01, this.ctx.currentTime + 0.1);
                    osc.start(); osc.stop(this.ctx.currentTime + 0.05);
                } else if (type === 'pickup') {
                    osc.frequency.value = 600;
                    osc.type = 'sine';
                    gain.gain.setValueAtTime(0.15, this.ctx.currentTime);
                    osc.start(); osc.stop(this.ctx.currentTime + 0.1);
                } else if (type === 'hit') {
                    osc.frequency.value = 150;
                    osc.type = 'sawtooth';
                    gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                    osc.start(); osc.stop(this.ctx.currentTime + 0.15);
                } else if (type === 'death') {
                    osc.frequency.value = 100;
                    osc.type = 'sawtooth';
                    gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(30, this.ctx.currentTime + 0.5);
                    osc.start(); osc.stop(this.ctx.currentTime + 0.5);
                } else if (type === 'powerup') {
                    osc.frequency.value = 400;
                    osc.type = 'sine';
                    gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(800, this.ctx.currentTime + 0.2);
                    osc.start(); osc.stop(this.ctx.currentTime + 0.2);
                }
            }
        };

        // ==================== GAME CODE ====================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
        resize();
        window.addEventListener('resize', resize);
        
        const GRID = 12;
        const WORLD_COLS = 300;
        const WORLD_ROWS = 200;
        const WORLD_WIDTH = WORLD_COLS * GRID;
        const WORLD_HEIGHT = WORLD_ROWS * GRID;
        
        let cameraX = 0, cameraY = 0, targetCameraX = 0, targetCameraY = 0;
        let cameraZoom = 2, targetZoom = 2; // Start zoomed in
        let gameState = 'start';
        let currentMVP = null; // Track most interesting player for spectating
        let mvpScore = 0;
        
        // Qwen AI name generator - generates realistic player names
        const FALLBACK_NAMES = ['xX_Pro_Xx', 'NoobMaster', 'ShadowKing', 'DarkWolf', 'IceQueen', 'BlazeFury', 'NightOwl', 'StormRider', 'Ninja99', 'ProSniper', 'GhostRider', 'DeathBlade'];
        const generatedNames = new Set();
        
        async function generateTrainName() {
            // Try Cloudflare tunnel first, then localhost
            const endpoints = [
                'https://ollama.locomot.io/api/generate',
                'http://localhost:11434/api/generate'
            ];
            for (const endpoint of endpoints) {
            try {
                const res = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: 'qwen2.5:0.5b',
                        prompt: 'Gaming usernames: xXShadowXx, NightWolf99, BlazeMaster, IceKing2000,',
                        stream: false,
                        options: { num_predict: 10, temperature: 1.2 }
                    }),
                    signal: AbortSignal.timeout(5000)
                });
                const data = await res.json();
                const matches = data.response.match(/[A-Za-z][A-Za-z0-9_]{2,11}/g);
                if (matches) {
                    for (const name of matches) {
                        if (!generatedNames.has(name) && name.length >= 3) {
                            generatedNames.add(name);
                            return name;
                        }
                    }
                }
            } catch (e) { continue; }
            }
            return FALLBACK_NAMES[Math.floor(Math.random() * FALLBACK_NAMES.length)] + Math.floor(Math.random() * 999);
        }
        
        let teamMode = false; // Set by mode selection at start
        let playerTeam = 'blue'; // Player's team (blue or red)
        let score = 0, wave = 1, lastTime = 0, moveTimer = 0, MOVE_INTERVAL = 70; // Faster!
        let aimAngle = 0, isAiming = false;
        let mouseX = 0, mouseY = 0, isMouseAiming = false;
        let trainFrame = 0; // For wheel animation
        
        const DIR = { UP: {x:0,y:-1}, DOWN: {x:0,y:1}, LEFT: {x:-1,y:0}, RIGHT: {x:1,y:0} };
        // Security: HTML escape to prevent XSS
        const esc = s => String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
        const GUNS = {
            HEAD: { color: '#0f0', fireRate: 200, damage: 12, range: 200 },
            MACHINEGUN: { color: '#f80', fireRate: 80, damage: 5, range: 180 },
            SHOTGUN: { color: '#f55', fireRate: 350, damage: 8, range: 150, spread: 0.4, pellets: 5 },
            CANNON: { color: '#5af', fireRate: 600, damage: 35, range: 250, size: 8 },
            PULSE: { color: '#f0f', fireRate: 500, damage: 15, range: 80, aoe: true }
        };
        const GUN_NAMES = ['MACHINEGUN', 'SHOTGUN', 'CANNON', 'PULSE'];

        // TRAIN PALETTE - warm industrial 8-bit colors
        const TRAIN = {
            black: '#1a1a2e',
            dark_metal: '#4a4a5c',
            metal: '#7a7a8c',
            light_metal: '#b0b0bc',
            rust: '#8b4513',
            rust_light: '#cd853f',
            red: '#c0392b',
            red_light: '#e74c3c',
            gold: '#d4a017',
            gold_light: '#ffd700',
            smoke: '#555566',
            smoke_light: '#888899',
            window: '#87ceeb',
            window_dark: '#5f9ea0',
            green: '#27ae60',
            green_light: '#2ecc71'
        };

        // Smoke puffs from locomotive
        let smokePuffs = [];

        function drawLocomotive(ctx, x, y, size, direction, frame) {
            // CHUNKY BLOCKY DESIGN - reads at any distance
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(Math.atan2(direction.y, direction.x));

            const s = size * 0.5;

            // Main body - big red block
            ctx.fillStyle = TRAIN.red;
            ctx.fillRect(-s, -s*0.7, s*1.8, s*1.4);

            // Cabin (taller back section)
            ctx.fillStyle = TRAIN.red_light;
            ctx.fillRect(-s*1.1, -s, s*0.5, s*2);

            // Smokestack - obvious block on top
            ctx.fillStyle = TRAIN.dark_metal;
            ctx.fillRect(s*0.2, -s*1.2, s*0.4, s*0.5);

            // Headlight - bright yellow/gold
            ctx.fillStyle = (frame % 16 < 8) ? '#fff' : TRAIN.gold_light;
            ctx.fillRect(s*0.7, -s*0.2, s*0.3, s*0.4);

            // Cow catcher - front wedge
            ctx.fillStyle = TRAIN.dark_metal;
            ctx.fillRect(s*0.8, -s*0.5, s*0.3, s*1);

            // Thick black outline for readability
            ctx.strokeStyle = TRAIN.black;
            ctx.lineWidth = 2;
            ctx.strokeRect(-s*1.1, -s, s*2.2, s*2);

            // Wheels - simple black rectangles at edges
            ctx.fillStyle = TRAIN.black;
            ctx.fillRect(-s*0.8, s*0.5, s*0.4, s*0.3);
            ctx.fillRect(s*0.2, s*0.5, s*0.4, s*0.3);
            ctx.fillRect(-s*0.8, -s*0.8, s*0.4, s*0.3);
            ctx.fillRect(s*0.2, -s*0.8, s*0.4, s*0.3);

            ctx.restore();
        }

        function drawBoxcar(ctx, x, y, size, direction, gunType, frame, hp, maxHp) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(Math.atan2(direction.y, direction.x));

            const s = size * 0.5;

            // Determine car color based on gun type
            let carColor = TRAIN.rust;
            if (gunType) {
                if (gunType.color === '#f80') carColor = '#f80';      // Machinegun - orange
                else if (gunType.color === '#f55') carColor = '#e44'; // Shotgun - red
                else if (gunType.color === '#5af') carColor = '#5af'; // Cannon - blue
                else if (gunType.color === '#f0f') carColor = '#f0f'; // Pulse - purple
            }

            // Damage flash
            if (hp < maxHp * 0.25 && Math.sin(frame * 0.5) > 0) carColor = '#600';
            else if (hp < maxHp * 0.5 && Math.sin(frame * 0.3) > 0.5) carColor = '#880';

            // Simple boxcar - just a rectangle
            ctx.fillStyle = carColor;
            ctx.fillRect(-s*0.8, -s*0.6, s*1.6, s*1.2);

            // Thick black outline
            ctx.strokeStyle = TRAIN.black;
            ctx.lineWidth = 2;
            ctx.strokeRect(-s*0.8, -s*0.6, s*1.6, s*1.2);

            // Gun turret - bright colored square on top
            if (gunType) {
                ctx.fillStyle = '#fff';
                ctx.fillRect(-s*0.2, -s*0.2, s*0.4, s*0.4);
                ctx.fillStyle = gunType.color;
                ctx.fillRect(-s*0.15, -s*0.15, s*0.3, s*0.3);
            }

            // Wheels - black rectangles
            ctx.fillStyle = TRAIN.black;
            ctx.fillRect(-s*0.6, s*0.4, s*0.3, s*0.25);
            ctx.fillRect(s*0.3, s*0.4, s*0.3, s*0.25);
            ctx.fillRect(-s*0.6, -s*0.65, s*0.3, s*0.25);
            ctx.fillRect(s*0.3, -s*0.65, s*0.3, s*0.25);

            ctx.restore();
        }

        function drawCaboose(ctx, x, y, size, direction, frame) {
            const s = size / 12;
            ctx.save();
            ctx.translate(x, y);

            let angle = Math.atan2(direction.y, direction.x);
            ctx.rotate(angle);

            // CABOOSE BODY (bright red!)
            ctx.fillStyle = TRAIN.red_light;
            ctx.fillRect(-5*s, -4*s, 10*s, 8*s);
            ctx.strokeStyle = TRAIN.black;
            ctx.lineWidth = s;
            ctx.strokeRect(-5*s, -4*s, 10*s, 8*s);

            // CUPOLA (raised section)
            ctx.fillStyle = TRAIN.red;
            ctx.fillRect(-3*s, -6*s, 6*s, 3*s);
            ctx.strokeRect(-3*s, -6*s, 6*s, 3*s);

            // Cupola windows
            ctx.fillStyle = TRAIN.window;
            ctx.fillRect(-2*s, -5*s, 4*s, 2*s);

            // Side windows
            ctx.fillRect(-4*s, -2*s, 3*s, 3*s);
            ctx.fillRect(1*s, -2*s, 3*s, 3*s);

            // LANTERN (blinking!)
            const lanternBlink = Math.sin(frame * 0.4) > 0;
            ctx.fillStyle = lanternBlink ? TRAIN.gold_light : TRAIN.gold;
            ctx.fillRect(-6*s, -3*s, 2*s, 3*s);
            ctx.strokeStyle = TRAIN.gold;
            ctx.strokeRect(-6*s, -3*s, 2*s, 3*s);

            // Railing
            ctx.strokeStyle = TRAIN.gold;
            ctx.lineWidth = s * 0.8;
            ctx.beginPath();
            ctx.moveTo(-5*s, 4*s);
            ctx.lineTo(-7*s, 4*s);
            ctx.lineTo(-7*s, -4*s);
            ctx.lineTo(-5*s, -4*s);
            ctx.stroke();

            // WHEELS
            const wheelOffset = (frame % 4) * (Math.PI / 2);
            for (let wy of [-3, 3]) {
                ctx.fillStyle = TRAIN.dark_metal;
                ctx.beginPath();
                ctx.arc(0, wy*s, 2*s, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        function spawnSmoke(x, y, direction) {
            // Spawn cloud puff behind the smokestack
            const offsetX = -direction.x * 10;
            const offsetY = -direction.y * 10;
            // Spawn a cluster of overlapping circles for cloud effect
            for (let i = 0; i < 3; i++) {
                smokePuffs.push({
                    x: x + offsetX + (Math.random() - 0.5) * 6,
                    y: y + offsetY + (Math.random() - 0.5) * 6,
                    vx: -direction.x * 0.3 + (Math.random() - 0.5) * 0.8,
                    vy: -0.8 - Math.random() * 0.4,
                    size: 4 + Math.random() * 3,
                    life: 50 + Math.random() * 20,
                    maxLife: 50
                });
            }
        }

        function updateSmoke() {
            for (let i = smokePuffs.length - 1; i >= 0; i--) {
                const p = smokePuffs[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy *= 0.98; // Slow down rise
                p.vx *= 0.98;
                p.size += 0.3; // Grow as it dissipates
                p.life--;
                if (p.life <= 0) smokePuffs.splice(i, 1);
            }
            // Limit total puffs
            if (smokePuffs.length > 100) smokePuffs.splice(0, 20);
        }

        function drawSmoke(ctx) {
            for (const p of smokePuffs) {
                const alpha = (p.life / p.maxLife) * 0.6;
                // Lighter gray that fades
                const gray = 150 + (1 - p.life / p.maxLife) * 80;
                ctx.fillStyle = `rgba(${gray}, ${gray}, ${gray + 10}, ${alpha})`;
                // BLOCKY squares instead of circles
                const sz = Math.floor(p.size);
                ctx.fillRect(Math.floor(p.x) - sz/2, Math.floor(p.y) - sz/2, sz, sz);
            }
        }

        let snake = [], dir = DIR.RIGHT, nextDir = DIR.RIGHT;
        let dirQueue = []; // Queue for fast direction changes
        let tronTrail = [];
        let enemies = [], projectiles = [], enemyProjectiles = [], pickups = [], particles = [];
        let isLeader = false, trailBoostTimer = 0;
        let waveEnemies = 0, waveKills = 0, spawnTimer = 0, waveDelay = 0;
        let bestRank = 999, maxLength = 2;
        let invincibleTimer = 0; // 30 seconds of spawn protection
        let speedTimer = 0; // Speed boost duration
        let magnetTimer = 0; // Magnet pull duration
        const BASE_MOVE_INTERVAL = 80; // Normal move speed (ms)
        
        // Power-up types
        const POWERUPS = {
            SPEED: { name: 'SPEED', color: '#0ff', icon: 'üöÄ', duration: 10000 },
            SHIELD: { name: 'SHIELD', color: '#ff0', icon: 'üõ°Ô∏è', duration: 15000 },
            MAGNET: { name: 'MAGNET', color: '#f0f', icon: 'üß≤', duration: 12000 }
        };
        let deathReason = ''; // Track what killed the player
        let deathDebugInfo = null; // Full debug info at death

        // === PATTERN TRACKER - Real-time player behavior learning ===
        const patternTracker = {
            leftTurns: 0,
            rightTurns: 0,
            straightMoves: 0,
            turnsNearThreat: [],
            fleeDistances: [],
            recentTurns: [],
            lastTurnTime: 0,

            reset() {
                // Only reset session data, keep cumulative totals
                this.recentTurns = [];
                this.lastTurnTime = 0;
                this.turnsNearThreat = [];
                // Note: leftTurns, rightTurns, fleeDistances persist across games!
            },

            fullReset() {
                // Full reset - only when explicitly requested
                this.leftTurns = 0;
                this.rightTurns = 0;
                this.straightMoves = 0;
                this.turnsNearThreat = [];
                this.fleeDistances = [];
                this.recentTurns = [];
                this.lastTurnTime = 0;
            },

            recordTurn(oldDir, newDir, threatDist) {
                const turnDir = this.getTurnDirection(oldDir, newDir);
                if (turnDir === 0) { this.straightMoves++; return; }

                if (turnDir < 0) this.leftTurns++;
                else this.rightTurns++;

                if (threatDist < 10) {
                    this.turnsNearThreat.push({ dist: threatDist, turnDir });
                    if (threatDist < 5) this.fleeDistances.push(threatDist);
                }

                this.recentTurns.push(turnDir);
                if (this.recentTurns.length > 10) this.recentTurns.shift();

                if ((this.leftTurns + this.rightTurns) % 12 === 0) {
                    showPatternFlash('adapting');
                }
            },

            getTurnDirection(oldDir, newDir) {
                if (oldDir === DIR.UP) return newDir === DIR.LEFT ? -1 : newDir === DIR.RIGHT ? 1 : 0;
                if (oldDir === DIR.DOWN) return newDir === DIR.RIGHT ? -1 : newDir === DIR.LEFT ? 1 : 0;
                if (oldDir === DIR.LEFT) return newDir === DIR.DOWN ? -1 : newDir === DIR.UP ? 1 : 0;
                if (oldDir === DIR.RIGHT) return newDir === DIR.UP ? -1 : newDir === DIR.DOWN ? 1 : 0;
                return 0;
            },

            predictTurn() {
                const total = this.leftTurns + this.rightTurns;
                if (total < 5) return null;
                const leftBias = this.leftTurns / total;
                let recentBias = 0.5;
                if (this.recentTurns.length >= 3) {
                    recentBias = this.recentTurns.filter(t => t < 0).length / this.recentTurns.length;
                }
                const finalBias = (leftBias * 0.3) + (recentBias * 0.7);
                return { predictedDir: finalBias > 0.5 ? -1 : 1, confidence: Math.abs(finalBias - 0.5) * 2 };
            },

            getFleeDistance() {
                if (this.fleeDistances.length < 3) return 5;
                return this.fleeDistances.reduce((a,b) => a+b, 0) / this.fleeDistances.length;
            },

            getStats() {
                const turns = this.leftTurns + this.rightTurns;
                return {
                    leftBias: turns > 0 ? Math.round((this.leftTurns / turns) * 100) : 50,
                    totalTurns: turns,
                    fleeDistance: this.getFleeDistance().toFixed(1),
                    threatReactions: this.turnsNearThreat.length
                };
            },

            // Save patterns to localStorage
            save() {
                const data = {
                    leftTurns: this.leftTurns,
                    rightTurns: this.rightTurns,
                    straightMoves: this.straightMoves,
                    fleeDistances: this.fleeDistances.slice(-50), // Keep last 50
                    savedAt: Date.now()
                };
                localStorage.setItem('locomotio_patterns', JSON.stringify(data));
            },

            // Load patterns from localStorage
            load() {
                try {
                    const saved = localStorage.getItem('locomotio_patterns');
                    if (saved) {
                        const data = JSON.parse(saved);
                        this.leftTurns = data.leftTurns || 0;
                        this.rightTurns = data.rightTurns || 0;
                        this.straightMoves = data.straightMoves || 0;
                        this.fleeDistances = data.fleeDistances || [];
                        console.log('Loaded pattern data:', this.getStats());
                    }
                } catch (e) { console.log('No saved patterns'); }
            },

            // Get data for collective upload
            getCollectiveData() {
                return {
                    patterns: this.getStats(),
                    fleeDistances: this.fleeDistances,
                    timestamp: Date.now(),
                    version: 'v1'
                };
            }
        };

        let patternFlashTimer = 0, patternFlashType = '';
        function showPatternFlash(type) { patternFlashType = type; patternFlashTimer = 90; }

        // === STRATEGY CLASSIFIER - Makes player strategy backfire ===
        const strategyClassifier = {
            // Raw metrics
            killTimestamps: [],
            distanceSamples: [],
            centerTicks: 0,
            totalTicks: 0,
            healthPickups: 0,
            gunPickups: 0,
            killSizes: [],
            chaseEvents: 0,    // Times player moved toward enemy
            fleeEvents: 0,     // Times player moved away from enemy

            // Computed metrics (updated periodically)
            metrics: {
                killsPerMinute: 0,
                avgDistToEnemy: 15,
                centerPct: 0.5,
                healthRatio: 0.5,
                aggression: 0.5,
                avgKillSize: 5
            },

            // Current archetype weights
            archetypes: {
                rusher: 0.2,
                sniper: 0.2,
                farmer: 0.2,
                survivor: 0.2,
                hunter: 0.2
            },

            // Dominant archetype
            dominant: 'neutral',
            confidence: 0,

            // Counter parameters applied to enemies
            counterParams: {
                leftBias: 0,
                straightBias: 0,
                rightBias: 0,
                speedMult: 1.0,
                flankTendency: 0.3
            },

            // Enemy reputation tracking
            enemyReps: new Map(),

            reset() {
                this.killTimestamps = [];
                this.distanceSamples = [];
                this.centerTicks = 0;
                this.totalTicks = 0;
                this.chaseEvents = 0;
                this.fleeEvents = 0;
                this.enemyReps.clear();
            },

            // Called when player kills an enemy
            onKill(enemySize) {
                this.killTimestamps.push(Date.now());
                this.killSizes.push(enemySize);
                if (this.killSizes.length > 30) this.killSizes.shift();
                // Keep last 2 minutes of kills
                this.killTimestamps = this.killTimestamps.filter(t => Date.now() - t < 120000);
            },

            // Called when player picks up item
            onPickup(isHealth) {
                if (isHealth) this.healthPickups++;
                else this.gunPickups++;
            },

            // Called every frame to track position and behavior
            update(playerPos, nearestEnemyDist, playerDir, prevPlayerPos) {
                this.totalTicks++;

                // Track center vs edge positioning
                const inCenter = playerPos.x > WORLD_COLS * 0.33 && playerPos.x < WORLD_COLS * 0.67 &&
                                playerPos.y > WORLD_ROWS * 0.33 && playerPos.y < WORLD_ROWS * 0.67;
                if (inCenter) this.centerTicks++;

                // Track distance to enemies
                if (nearestEnemyDist < 50) {
                    this.distanceSamples.push(nearestEnemyDist);
                    if (this.distanceSamples.length > 100) this.distanceSamples.shift();
                }

                // Track chase vs flee behavior (every 10 frames)
                if (this.totalTicks % 10 === 0 && prevPlayerPos && nearestEnemyDist < 20) {
                    const prevDist = Math.sqrt((prevPlayerPos.x - playerPos.x)**2 + (prevPlayerPos.y - playerPos.y)**2);
                    // This is simplified - would need enemy pos to do properly
                }
            },

            // Called every ~60 frames to recompute metrics
            computeMetrics() {
                // Kills per minute
                const recentKills = this.killTimestamps.filter(t => Date.now() - t < 60000);
                this.metrics.killsPerMinute = recentKills.length;

                // Average distance to enemies
                if (this.distanceSamples.length > 10) {
                    this.metrics.avgDistToEnemy = this.distanceSamples.reduce((a,b) => a+b, 0) / this.distanceSamples.length;
                }

                // Center percentage
                this.metrics.centerPct = this.totalTicks > 0 ? this.centerTicks / this.totalTicks : 0.5;

                // Health vs gun pickup ratio
                const totalPickups = this.healthPickups + this.gunPickups;
                this.metrics.healthRatio = totalPickups > 0 ? this.healthPickups / totalPickups : 0.5;

                // Average kill size
                if (this.killSizes.length > 3) {
                    this.metrics.avgKillSize = this.killSizes.reduce((a,b) => a+b, 0) / this.killSizes.length;
                }

                // Aggression (kills + close distance + center position)
                this.metrics.aggression = Math.min(1, (
                    (this.metrics.killsPerMinute / 5) * 0.4 +
                    (1 - this.metrics.avgDistToEnemy / 20) * 0.3 +
                    this.metrics.centerPct * 0.3
                ));
            },

            // Called every ~120 frames to reclassify player
            classify() {
                this.computeMetrics();
                const m = this.metrics;

                // Score each archetype
                let scores = {
                    // RUSHER: High kills, close to enemies, center map
                    rusher: m.killsPerMinute * 0.15 + (1 - m.avgDistToEnemy/20) * 0.5 + m.centerPct * 0.3,

                    // SNIPER: Moderate kills, stays distant
                    sniper: Math.min(m.killsPerMinute, 3) * 0.2 + (m.avgDistToEnemy/20) * 0.6,

                    // FARMER: Low kills, prioritizes pickups
                    farmer: (1 - Math.min(m.killsPerMinute, 4)/4) * 0.5 + m.healthRatio * 0.3,

                    // SURVIVOR: Avoids combat, edges of map
                    survivor: (1 - m.aggression) * 0.5 + (1 - m.centerPct) * 0.3,

                    // HUNTER: Targets smaller/weaker enemies
                    hunter: m.avgKillSize < 4 ? 0.6 : m.avgKillSize < 6 ? 0.3 : 0.1
                };

                // Normalize to sum to 1
                const total = Object.values(scores).reduce((a,b) => a+b, 0.001);
                for (const key of Object.keys(scores)) {
                    this.archetypes[key] = scores[key] / total;
                }

                // Find dominant archetype
                let maxScore = 0;
                for (const [arch, score] of Object.entries(this.archetypes)) {
                    if (score > maxScore) {
                        maxScore = score;
                        this.dominant = arch;
                    }
                }
                this.confidence = maxScore;

                // Update counter parameters based on dominant archetype
                this.updateCounterParams();

                // Show flash if confident enough
                if (this.confidence > 0.35 && this.totalTicks > 300) {
                    showPatternFlash('strategy');
                }
            },

            // Set counter-strategy parameters
            updateCounterParams() {
                const arch = this.dominant;
                const conf = this.confidence;

                // Base counters for each archetype (no speed boosts - not allowed)
                const counters = {
                    // vs RUSHER: Enemies flank and retreat-bait
                    rusher: { left: 0.4, straight: -0.3, right: 0.4, speed: 1.0, flank: 0.7 },

                    // vs SNIPER: Enemies rush directly, zigzag
                    sniper: { left: 0.2, straight: 0.5, right: 0.2, speed: 1.0, flank: 0.2 },

                    // vs FARMER: Aggressive chase
                    farmer: { left: 0, straight: 0.6, right: 0, speed: 1.0, flank: 0.4 },

                    // vs SURVIVOR: Pincer movement, cut off escape
                    survivor: { left: 0.3, straight: 0.2, right: 0.3, speed: 1.0, flank: 0.8 },

                    // vs HUNTER: Protect weak, bodyguard behavior
                    hunter: { left: 0.1, straight: 0.3, right: 0.1, speed: 1.0, flank: 0.5 }
                };

                const c = counters[arch] || counters.farmer;

                // Apply with confidence scaling
                this.counterParams.leftBias = c.left * conf;
                this.counterParams.straightBias = c.straight * conf;
                this.counterParams.rightBias = c.right * conf;
                this.counterParams.speedMult = 1 + (c.speed - 1) * conf;
                this.counterParams.flankTendency = c.flank * conf;
            },

            // Get bias for a specific enemy based on situation
            getCounterBias(enemyPos, playerPos, enemyId) {
                const dist = Math.abs(enemyPos.x - playerPos.x) + Math.abs(enemyPos.y - playerPos.y);

                // Scale bias by distance (stronger when closer)
                const distScale = dist < 15 ? 1.0 : dist < 25 ? 0.5 : 0.2;

                // Check enemy reputation
                const rep = this.enemyReps.get(enemyId) || { kills: 0, deaths: 0 };
                const repBonus = rep.kills > 0 ? 0.2 : 0; // Successful enemies get bonus

                return {
                    left: this.counterParams.leftBias * distScale * (1 + repBonus),
                    straight: this.counterParams.straightBias * distScale,
                    right: this.counterParams.rightBias * distScale * (1 + repBonus)
                };
            },

            // Track enemy success/failure
            onEnemyKilledPlayer(enemyId) {
                const rep = this.enemyReps.get(enemyId) || { kills: 0, deaths: 0 };
                rep.kills++;
                this.enemyReps.set(enemyId, rep);
            },

            onPlayerKilledEnemy(enemyId) {
                const rep = this.enemyReps.get(enemyId) || { kills: 0, deaths: 0 };
                rep.deaths++;
                this.enemyReps.set(enemyId, rep);
            },

            // Get stats for display
            getDisplayStats() {
                return {
                    dominant: this.dominant.toUpperCase(),
                    confidence: Math.round(this.confidence * 100),
                    kpm: this.metrics.killsPerMinute,
                    aggression: Math.round(this.metrics.aggression * 100)
                };
            }
        };

        // === PHASE 2: REPUTATION SYSTEM ===
        const reputationSystem = {
            // Player reputation (persists across games)
            playerRep: {
                gamesPlayed: 0,
                totalKills: 0,
                totalDeaths: 0,
                avgSurvivalTime: 60,
                dominantStyle: 'neutral',
                styleHistory: [],      // Last 10 game styles
                weaknesses: [],        // What killed them most
                lastPlayed: 0
            },

            // Enemy reputations this game
            enemies: new Map(),

            // Successful strategies (what killed player)
            successfulMoves: [],

            // Failed strategies (what got enemies killed)
            failedMoves: [],

            // Initialize enemy reputation
            initEnemy(enemyId, enemyName) {
                this.enemies.set(enemyId, {
                    id: enemyId,
                    name: enemyName,
                    kills: 0,
                    deaths: 0,
                    streak: 0,
                    bestStreak: 0,
                    recentMoves: [],      // Last 5 move directions
                    isDangerous: false,
                    isPackLeader: false
                });
            },

            // Enemy killed the player
            onEnemyKilledPlayer(enemyId, moveHistory) {
                const rep = this.enemies.get(enemyId);
                if (rep) {
                    rep.kills++;
                    rep.streak++;
                    rep.bestStreak = Math.max(rep.bestStreak, rep.streak);
                    rep.isDangerous = rep.kills >= 2;

                    // Record successful moves for other enemies to copy
                    if (moveHistory && moveHistory.length > 0) {
                        this.successfulMoves.push({
                            enemyId,
                            moves: moveHistory.slice(-5),
                            timestamp: Date.now()
                        });
                        // Keep last 10 successful patterns
                        if (this.successfulMoves.length > 10) this.successfulMoves.shift();
                    }

                    // Update pack leader
                    this.updatePackLeader();
                    console.log(`[REP] ${rep.name} killed player! Streak: ${rep.streak}`);
                }

                // Update player reputation
                this.playerRep.totalDeaths++;
            },

            // Player killed enemy
            onPlayerKilledEnemy(enemyId, moveHistory) {
                const rep = this.enemies.get(enemyId);
                if (rep) {
                    rep.deaths++;
                    rep.streak = 0;
                    rep.isDangerous = false;

                    // Record failed moves for other enemies to avoid
                    if (moveHistory && moveHistory.length > 0) {
                        this.failedMoves.push({
                            enemyId,
                            moves: moveHistory.slice(-5),
                            timestamp: Date.now()
                        });
                        if (this.failedMoves.length > 10) this.failedMoves.shift();
                    }

                    console.log(`[REP] ${rep.name} killed by player`);
                }

                this.playerRep.totalKills++;
            },

            // Find the pack leader (most successful enemy)
            updatePackLeader() {
                let bestKills = 0;
                let leader = null;

                for (const [id, rep] of this.enemies) {
                    rep.isPackLeader = false;
                    if (rep.kills > bestKills) {
                        bestKills = rep.kills;
                        leader = rep;
                    }
                }

                if (leader && leader.kills >= 2) {
                    leader.isPackLeader = true;
                }
            },

            // Get advice for an enemy based on collective learning
            getAdvice(enemyId) {
                const advice = {
                    copyMoves: null,      // Moves to copy from successful enemy
                    avoidMoves: null,     // Moves to avoid from failed enemy
                    followLeader: false,  // Should follow pack leader
                    leaderPos: null
                };

                // Find most recent successful pattern
                if (this.successfulMoves.length > 0) {
                    const recent = this.successfulMoves[this.successfulMoves.length - 1];
                    if (recent.enemyId !== enemyId) {
                        advice.copyMoves = recent.moves;
                    }
                }

                // Find recent failed pattern to avoid
                if (this.failedMoves.length > 0) {
                    const recent = this.failedMoves[this.failedMoves.length - 1];
                    advice.avoidMoves = recent.moves;
                }

                // Check if should follow pack leader
                for (const [id, rep] of this.enemies) {
                    if (rep.isPackLeader && id !== enemyId) {
                        advice.followLeader = true;
                        // Could add leader position tracking here
                        break;
                    }
                }

                return advice;
            },

            // Get reputation-based bias for enemy decisions
            getReputationBias(enemyId) {
                const rep = this.enemies.get(enemyId);
                const advice = this.getAdvice(enemyId);
                let bias = { left: 0, straight: 0, right: 0 };

                if (!rep) return bias;

                // Dangerous enemies are more aggressive
                if (rep.isDangerous) {
                    bias.straight += 0.2;
                }

                // Pack leaders are confident
                if (rep.isPackLeader) {
                    bias.straight += 0.3;
                }

                // Copy successful moves (if we have them)
                if (advice.copyMoves && advice.copyMoves.length > 0) {
                    const lastMove = advice.copyMoves[advice.copyMoves.length - 1];
                    // Bias toward similar moves
                    bias.left += lastMove === 0 ? 0.15 : 0;
                    bias.straight += lastMove === 1 ? 0.15 : 0;
                    bias.right += lastMove === 2 ? 0.15 : 0;
                }

                // Scale by streak (hot enemies are bolder)
                const streakBonus = Math.min(rep.streak * 0.1, 0.3);
                bias.straight += streakBonus;

                return bias;
            },

            // Record enemy move (for pattern tracking)
            recordEnemyMove(enemyId, moveDir) {
                const rep = this.enemies.get(enemyId);
                if (rep) {
                    rep.recentMoves.push(moveDir);
                    if (rep.recentMoves.length > 5) rep.recentMoves.shift();
                }
            },

            // Save player reputation to localStorage
            save() {
                this.playerRep.lastPlayed = Date.now();
                localStorage.setItem('locomotio_player_rep', JSON.stringify(this.playerRep));
            },

            // Load player reputation
            load() {
                try {
                    const saved = localStorage.getItem('locomotio_player_rep');
                    if (saved) {
                        const data = JSON.parse(saved);
                        Object.assign(this.playerRep, data);
                        console.log('[REP] Loaded player reputation:', this.playerRep);
                    }
                } catch (e) { console.log('[REP] No saved reputation'); }
            },

            // Reset for new game
            reset() {
                this.enemies.clear();
                this.successfulMoves = [];
                this.failedMoves = [];
            },

            // End of game - update player rep
            onGameEnd(survivalTime, dominantStyle) {
                this.playerRep.gamesPlayed++;
                this.playerRep.avgSurvivalTime = (this.playerRep.avgSurvivalTime * 0.8) + (survivalTime * 0.2);
                this.playerRep.styleHistory.push(dominantStyle);
                if (this.playerRep.styleHistory.length > 10) this.playerRep.styleHistory.shift();

                // Find most common style
                const styleCounts = {};
                for (const s of this.playerRep.styleHistory) {
                    styleCounts[s] = (styleCounts[s] || 0) + 1;
                }
                let maxCount = 0;
                for (const [style, count] of Object.entries(styleCounts)) {
                    if (count > maxCount) {
                        maxCount = count;
                        this.playerRep.dominantStyle = style;
                    }
                }

                this.save();
            },

            // Get display stats
            getDisplayStats() {
                return {
                    gamesPlayed: this.playerRep.gamesPlayed,
                    kd: this.playerRep.totalDeaths > 0
                        ? (this.playerRep.totalKills / this.playerRep.totalDeaths).toFixed(1)
                        : this.playerRep.totalKills,
                    avgSurvival: Math.round(this.playerRep.avgSurvivalTime),
                    dominantStyle: this.playerRep.dominantStyle.toUpperCase(),
                    dangerousEnemies: [...this.enemies.values()].filter(e => e.isDangerous).length,
                    packLeader: [...this.enemies.values()].find(e => e.isPackLeader)?.name || 'None'
                };
            }
        };

        function drawPatternFlash(ctx) {
            if (patternFlashTimer <= 0) return;
            patternFlashTimer--;
            const alpha = Math.min(1, patternFlashTimer / 30);
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.font = '10px "Press Start 2P"';
            ctx.textAlign = 'center';
            if (patternFlashType === 'adapting') {
                ctx.fillStyle = `rgba(0, 255, 200, ${alpha})`;
                ctx.fillText('ADAPTING...', canvas.width / 2, 70);
            } else if (patternFlashType === 'detected') {
                ctx.fillStyle = `rgba(255, 100, 100, ${alpha})`;
                ctx.fillText('PATTERN DETECTED', canvas.width / 2, 70);
            } else if (patternFlashType === 'strategy') {
                const stats = strategyClassifier.getDisplayStats();
                ctx.fillStyle = `rgba(255, 50, 150, ${alpha})`;
                ctx.fillText(`STRATEGY: ${stats.dominant}`, canvas.width / 2, 70);
                ctx.font = '7px "Press Start 2P"';
                ctx.fillStyle = `rgba(255, 150, 200, ${alpha * 0.8})`;
                ctx.fillText('COUNTERING...', canvas.width / 2, 85);
            }
            ctx.restore();
        }

        function haptic(style = 'light') {
            if (!navigator.vibrate) return;
            switch(style) {
                case 'light': navigator.vibrate(10); break;
                case 'medium': navigator.vibrate(25); break;
                case 'heavy': navigator.vibrate(50); break;
                case 'double': navigator.vibrate([20, 30, 20]); break;
                case 'death': navigator.vibrate([50, 50, 100, 50, 200]); break;
            }
        }
        
        // Vision system for neural network - matches training exactly
        // LOOKAHEAD AI - Simulate future moves to predict outcomes
        function simulateLookahead(headX, headY, currentDir, segments, allEnemies, allPickups, playerSnake, depth = 4) {
            const scores = [0, 0, 0]; // left, straight, right
            const directions = [turnLeft(currentDir), currentDir, turnRight(currentDir)];
            
            for (let d = 0; d < 3; d++) {
                let simX = headX;
                let simY = headY;
                let simDir = directions[d];
                let simSegments = segments.map(s => ({x: s.x, y: s.y}));
                let alive = true;
                let foodCollected = 0;
                let score = 0;
                
                // Simulate several steps ahead
                for (let step = 0; step < depth && alive; step++) {
                    // Move in current direction
                    simX += simDir.x;
                    simY += simDir.y;
                    
                    // Wrap around world
                    if (simX < 0) simX = WORLD_COLS - 1;
                    if (simX >= WORLD_COLS) simX = 0;
                    if (simY < 0) simY = WORLD_ROWS - 1;
                    if (simY >= WORLD_ROWS) simY = 0;
                    
                    // Check self collision
                    for (const seg of simSegments) {
                        if (seg.x === simX && seg.y === simY) {
                            alive = false;
                            score -= 100; // Death is very bad
                            break;
                        }
                    }
                    
                    if (!alive) break;
                    
                    // Check collision with other enemies
                    for (const enemy of allEnemies) {
                        if (!enemy.segments) continue;
                        for (const seg of enemy.segments) {
                            if (seg.x === simX && seg.y === simY) {
                                // Collision - bad if they're bigger
                                if (enemy.segments.length >= simSegments.length) {
                                    alive = false;
                                    score -= 80;
                                } else {
                                    score += 30; // Could eat them!
                                }
                                break;
                            }
                        }
                        if (!alive) break;
                    }
                    
                    if (!alive) break;
                    
                    // Check collision with player
                    if (playerSnake && playerSnake.length > 0) {
                        for (let i = 0; i < playerSnake.length; i++) {
                            const seg = playerSnake[i];
                            if (seg.x === simX && seg.y === simY) {
                                if (i === 0) {
                                    // Head collision - depends on size
                                    if (playerSnake.length >= simSegments.length) {
                                        alive = false;
                                        score -= 90;
                                    } else {
                                        score += 50; // Kill player!
                                    }
                                } else {
                                    alive = false;
                                    score -= 70;
                                }
                                break;
                            }
                        }
                    }
                    
                    if (!alive) break;
                    
                    // Check for nearby food (bonus for paths near food)
                    for (const pickup of allPickups) {
                        const px = Math.floor(pickup.x / GRID);
                        const py = Math.floor(pickup.y / GRID);
                        const dist = Math.abs(simX - px) + Math.abs(simY - py);
                        if (dist === 0) {
                            foodCollected++;
                            score += 20;
                        } else if (dist < 3) {
                            score += 5 / dist; // Closer food = better
                        }
                    }
                    
                    // Update simulated segments (move forward)
                    simSegments.unshift({x: simX, y: simY});
                    if (foodCollected === 0) simSegments.pop();
                    
                    // Slight preference for going straight (more predictable)
                    if (d === 1) score += 0.5;
                    
                    // After first step, continue straight for simulation
                    // (simplification - real tree search would branch)
                }
                
                // Bonus for staying alive
                if (alive) score += 10;
                
                scores[d] = score;
            }
            
            return scores; // [leftScore, straightScore, rightScore]
        }

        function getVision(headX, headY, currentDir, segments, allEnemies, allPickups, playerSnake) {
            // 8 directions relative to heading (matches training order)
            const angles = [0, Math.PI/4, Math.PI/2, 3*Math.PI/4, Math.PI, -3*Math.PI/4, -Math.PI/2, -Math.PI/4];
            const RAY_DIST = 25; // Match training ray distance

            // Heading angles (matches training: UP=-œÄ/2, DOWN=œÄ/2, LEFT=œÄ, RIGHT=0)
            let headingAngle = 0;
            if (currentDir === DIR.UP) headingAngle = -Math.PI/2;
            else if (currentDir === DIR.DOWN) headingAngle = Math.PI/2;
            else if (currentDir === DIR.LEFT) headingAngle = Math.PI;
            else if (currentDir === DIR.RIGHT) headingAngle = 0;

            const myLength = segments.length;

            // 8 directions √ó 6 values = 48 inputs
            // Order: [food, self_body, wall, smaller_head, bigger_head, enemy_body]
            const input = new Array(48).fill(0);

            for (let i = 0; i < 8; i++) {
                const angle = headingAngle + angles[i];
                const dx = Math.round(Math.cos(angle));
                const dy = Math.round(Math.sin(angle));

                let foodDist = 0, selfDanger = 0, wallDist = 0;
                let enemySmallerDist = 0, enemyBiggerDist = 0, enemyBodyDist = 0;

                // Cast ray - NO WRAPPING (walls are solid obstacles)
                for (let dist = 1; dist <= RAY_DIST; dist++) {
                    const checkX = headX + dx * dist;
                    const checkY = headY + dy * dist;

                    // Bounds check - out of world = wall, stop ray
                    if (checkX < 0 || checkX >= WORLD_COLS || checkY < 0 || checkY >= WORLD_ROWS) {
                        if (wallDist === 0) wallDist = 1 / dist;
                        break;
                    }

                    // Wall proximity (2-cell buffer like training)
                    if (wallDist === 0) {
                        if (checkX <= 1 || checkX >= WORLD_COLS-2 || checkY <= 1 || checkY >= WORLD_ROWS-2) {
                            wallDist = 1 / dist;
                        }
                    }

                    // Self collision (skip head)
                    if (selfDanger === 0) {
                        for (let s = 1; s < segments.length; s++) {
                            if (segments[s].x === checkX && segments[s].y === checkY) {
                                selfDanger = 1 / dist;
                                break;
                            }
                        }
                    }

                    // Other snakes
                    const allSnakes = [...allEnemies];
                    if (playerSnake && playerSnake.length > 0) {
                        allSnakes.push({ segments: playerSnake, isPlayer: true });
                    }

                    for (const other of allSnakes) {
                        const otherSegs = other.segments || other;
                        if (!otherSegs || otherSegs.length === 0) continue;
                        if (otherSegs === segments) continue;

                        const otherLength = otherSegs.length;

                        for (let s = 0; s < otherSegs.length; s++) {
                            const seg = otherSegs[s];
                            if (seg.x === checkX && seg.y === checkY) {
                                if (s === 0) {
                                    // Head - check size
                                    if (otherLength < myLength && enemySmallerDist === 0) {
                                        enemySmallerDist = 1 / dist;
                                    } else if (otherLength >= myLength && enemyBiggerDist === 0) {
                                        enemyBiggerDist = 1 / dist;
                                    }
                                } else if (enemyBodyDist === 0) {
                                    enemyBodyDist = 1 / dist;
                                }
                                break;
                            }
                        }
                    }

                    // Food (all pickups)
                    if (foodDist === 0) {
                        for (const p of allPickups) {
                            const px = Math.floor(p.x / GRID);
                            const py = Math.floor(p.y / GRID);
                            if (px === checkX && py === checkY) {
                                foodDist = 1 / dist;
                                break;
                            }
                        }
                    }
                }

                // Store: [food, self, wall, smaller, bigger, body]
                input[i * 6 + 0] = foodDist;
                input[i * 6 + 1] = selfDanger;
                input[i * 6 + 2] = wallDist;
                input[i * 6 + 3] = enemySmallerDist;
                input[i * 6 + 4] = enemyBiggerDist;
                input[i * 6 + 5] = enemyBodyDist;
            }

            return input;
        }
        
        function turnLeft(d) {
            if (d === DIR.UP) return DIR.LEFT;
            if (d === DIR.LEFT) return DIR.DOWN;
            if (d === DIR.DOWN) return DIR.RIGHT;
            return DIR.UP;
        }
        
        function turnRight(d) {
            if (d === DIR.UP) return DIR.RIGHT;
            if (d === DIR.RIGHT) return DIR.DOWN;
            if (d === DIR.DOWN) return DIR.LEFT;
            return DIR.UP;
        }
        
        // Spawn an established enemy at a specific location (for pre-population)
        function spawnEstablishedEnemy(x, y, length, isAlpha = false) {
            const dirs = [DIR.UP, DIR.DOWN, DIR.LEFT, DIR.RIGHT];
            const startDir = dirs[Math.floor(Math.random() * dirs.length)];
            
            const isNeural = Math.random() < 0.5;
            let color, personality;
            
            if (isNeural) {
                color = '#f0f';
                personality = { aggression: 0.5, greed: 0.5, caution: 0.5, neural: true };
            } else {
                const personalities = [
                    { aggression: 0.8, greed: 0.3, caution: 0.2 },
                    { aggression: 0.2, greed: 0.9, caution: 0.4 },
                    { aggression: 0.5, greed: 0.5, caution: 0.7 },
                    { aggression: 0.9, greed: 0.1, caution: 0.1 },
                ];
                personality = personalities[Math.floor(Math.random() * personalities.length)];
                
                if (isAlpha) color = '#ff0'; // Alpha predators are gold
                else if (personality.aggression > 0.7) color = '#f55';
                else if (personality.greed > 0.7) color = '#ff0';
                else if (personality.caution > 0.5) color = '#5af';
                else color = '#f80';
            }
            
            const baseHp = 20 + wave * 5;
            const segments = [];
            
            // Build snake body following a path (not just straight line)
            let curX = x, curY = y, curDir = startDir;
            for (let i = 0; i < length; i++) {
                segments.push({
                    x: curX, y: curY,
                    hp: i === 0 ? Infinity : baseHp,
                    maxHp: i === 0 ? Infinity : baseHp,
                    type: i === 0 ? GUNS.HEAD : GUNS[GUN_NAMES[Math.floor(Math.random() * GUN_NAMES.length)]],
                    lastFired: 0
                });
                // Move backwards from head, occasionally turning
                if (i > 0 && Math.random() < 0.3) {
                    curDir = dirs[Math.floor(Math.random() * dirs.length)];
                }
                curX = (curX - curDir.x + WORLD_COLS) % WORLD_COLS;
                curY = (curY - curDir.y + WORLD_ROWS) % WORLD_ROWS;
            }
            
            enemies.push({
                // Assign team to balance (alternate)
                team: enemies.filter(e => e.team === 'blue').length <= enemies.filter(e => e.team === 'red').length ? 'blue' : 'red',
                segments, dir: startDir, nextDir: startDir,
                baseSpeed: 8 + wave * 0.5, damage: 10 + wave * 2,
                moveTimer: Math.random() * 500, // Stagger movement
                lastFired: 0, fireRate: 1200 - wave * 40,
                score: 10 * length, personality,
                targetPos: null, avoidPos: null, lastDecision: 0,
                decisionInterval: 300 + Math.random() * 200
            });
            // Set color based on team in team mode
            const newEnemy = enemies[enemies.length - 1];
            if (teamMode) newEnemy.color = newEnemy.team === "blue" ? "#0af" : "#f55";
            else newEnemy.color = color;
            
            // Generate AI name asynchronously
            generateTrainName().then(name => {
                if (newEnemy.segments.length > 0) newEnemy.name = name;
            });
            
        }
        
        function simulateWorld(ticks) {
            // Run the world simulation for a while before player joins
            for (let t = 0; t < ticks; t++) {
                // Update enemies (simplified - just movement)
                for (const e of enemies) {
                    if (!e.segments || e.segments.length === 0) continue;
                    
                    e.moveTimer += 16; // ~60fps
                    const myLen = e.segments.length;
                    const speedMultiplier = 1 / (1 + (myLen - 1) * 0.05);
                    const actualSpeed = e.baseSpeed * speedMultiplier;
                    const moveInterval = 150 / actualSpeed * 10;
                    
                    if (e.moveTimer >= moveInterval) {
                        e.moveTimer = 0;
                        
                        const head = e.segments[0];
                        let newDir = e.dir;
                        
                        // Simple AI for simulation
                        if (Math.random() < 0.1) {
                            const dirs = [turnLeft(e.dir), e.dir, turnRight(e.dir)];
                            newDir = dirs[Math.floor(Math.random() * dirs.length)];
                        }
                        
                        // Go towards nearest pickup
                        if (pickups.length > 0 && Math.random() < 0.5) {
                            let nearestDist = Infinity, nearestPickup = null;
                            for (const p of pickups) {
                                const px = Math.floor(p.x / GRID), py = Math.floor(p.y / GRID);
                                const dist = Math.abs(head.x - px) + Math.abs(head.y - py);
                                if (dist < nearestDist) { nearestDist = dist; nearestPickup = p; }
                            }
                            if (nearestPickup && nearestDist < 30) {
                                const px = Math.floor(nearestPickup.x / GRID);
                                const py = Math.floor(nearestPickup.y / GRID);
                                const dx = px - head.x, dy = py - head.y;
                                if (Math.abs(dx) > Math.abs(dy)) newDir = dx > 0 ? DIR.RIGHT : DIR.LEFT;
                                else if (Math.abs(dy) > 0) newDir = dy > 0 ? DIR.DOWN : DIR.UP;
                            }
                        }
                        
                        // Don't reverse
                        if (newDir.x === -e.dir.x && newDir.y === -e.dir.y) newDir = e.dir;
                        e.dir = newDir;
                        
                        // Move
                        const prevPositions = e.segments.map(s => ({ x: s.x, y: s.y }));
                        head.x = (head.x + e.dir.x + WORLD_COLS) % WORLD_COLS;
                        head.y = (head.y + e.dir.y + WORLD_ROWS) % WORLD_ROWS;
                        for (let j = 1; j < e.segments.length; j++) {
                            e.segments[j].x = prevPositions[j - 1].x;
                            e.segments[j].y = prevPositions[j - 1].y;
                        }
                        
                        // Pickup collection
                        for (let pi = pickups.length - 1; pi >= 0; pi--) {
                            const p = pickups[pi];
                            const px = Math.floor(p.x / GRID), py = Math.floor(p.y / GRID);
                            if (head.x === px && head.y === py && !p.isHealth) {
                                const tail = e.segments[e.segments.length - 1];
                                e.segments.push({ 
                                    x: tail.x, y: tail.y, 
                                    hp: 20 + wave * 5, maxHp: 20 + wave * 5, 
                                    type: p.type, lastFired: 0 
                                });
                                pickups.splice(pi, 1);
                                // Track recent activity for MVP
                                e.recentPoints = (e.recentPoints || 0) + 10;
                                e.lastPointTime = Date.now();
                            }
                        }
                    }
                }
                
                // Spawn new pickups occasionally
                if (t % 60 === 0 && pickups.length < 20) {
                    const px = Math.floor(Math.random() * WORLD_COLS) * GRID + GRID/2;
                    const py = Math.floor(Math.random() * WORLD_ROWS) * GRID + GRID/2;
                    pickups.push({
                        x: px, y: py,
                        type: GUNS[GUN_NAMES[Math.floor(Math.random() * GUN_NAMES.length)]],
                        isHealth: false, bob: Math.random() * Math.PI * 2
                    });
                }
                // Spawn power-ups rarely
                if (t % 300 === 0 && pickups.filter(p => p.isPowerup).length < 3) {
                    const px = Math.floor(Math.random() * WORLD_COLS) * GRID + GRID/2;
                    const py = Math.floor(Math.random() * WORLD_ROWS) * GRID + GRID/2;
                    const powerupTypes = Object.values(POWERUPS);
                    const powerup = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];
                    pickups.push({
                        x: px, y: py,
                        type: powerup,
                        isPowerup: true,
                        bob: Math.random() * Math.PI * 2
                    });
                }
            }
        }
        
        function init() {
            score = 0; wave = 3; // Start at wave 3 - world is already established
            enemies = []; projectiles = []; enemyProjectiles = []; pickups = []; particles = [];
            waveEnemies = 0; waveKills = 0; spawnTimer = 0; waveDelay = 0;
            bestRank = 999; maxLength = 4; // Reset tracking
            invincibleTimer = 10000; // 10 seconds of spawn protection
            speedTimer = 0; magnetTimer = 0; // Reset power-up timers
            patternTracker.reset(); // Reset pattern tracking for new game
            strategyClassifier.reset(); // Reset strategy classifier
            reputationSystem.reset(); // Reset enemy reputations for new game

            // Scatter pickups around the world first
            for (let i = 0; i < 200; i++) {
                const px = Math.floor(Math.random() * WORLD_COLS) * GRID + GRID/2;
                const py = Math.floor(Math.random() * WORLD_ROWS) * GRID + GRID/2;
                pickups.push({
                    x: px, y: py,
                    type: GUNS[GUN_NAMES[Math.floor(Math.random() * GUN_NAMES.length)]],
                    isHealth: Math.random() < 0.15,
                    healAmount: 40,
                    bob: Math.random() * Math.PI * 2
                });
            }
            
            // Spawn initial power-ups
            const powerupTypes = Object.values(POWERUPS);
            for (let i = 0; i < 5; i++) {
                const px = Math.floor(Math.random() * WORLD_COLS) * GRID + GRID/2;
                const py = Math.floor(Math.random() * WORLD_ROWS) * GRID + GRID/2;
                pickups.push({
                    x: px, y: py,
                    type: powerupTypes[Math.floor(Math.random() * powerupTypes.length)],
                    isPowerup: true,
                    bob: Math.random() * Math.PI * 2
                });
            }
            
            // Spawn established enemies across the map
            // Alpha predators (big snakes, 12-25 segments) - fewer of them
            for (let i = 0; i < 6; i++) {
                const x = Math.floor(Math.random() * (WORLD_COLS - 20)) + 10;
                const y = Math.floor(Math.random() * (WORLD_ROWS - 20)) + 10;
                spawnEstablishedEnemy(x, y, 12 + Math.floor(Math.random() * 14), true);
            }
            
            // Medium snakes (5-11 segments) - fewer
            for (let i = 0; i < 20; i++) {
                const x = Math.floor(Math.random() * (WORLD_COLS - 10)) + 5;
                const y = Math.floor(Math.random() * (WORLD_ROWS - 10)) + 5;
                spawnEstablishedEnemy(x, y, 5 + Math.floor(Math.random() * 7));
            }
            
            // Small snakes (2-5 segments) - your peers
            for (let i = 0; i < 50; i++) {
                const x = Math.floor(Math.random() * (WORLD_COLS - 6)) + 3;
                const y = Math.floor(Math.random() * (WORLD_ROWS - 6)) + 3;
                spawnEstablishedEnemy(x, y, 2 + Math.floor(Math.random() * 4));
            }
            
            // Simulate the world for a bit so snakes have moved around
            simulateWorld(600);
            
            // Find a safe spawn location for player (away from big snakes)
            let spawnX, spawnY, attempts = 0;
            do {
                spawnX = Math.floor(Math.random() * (WORLD_COLS - 10)) + 5;
                spawnY = Math.floor(Math.random() * (WORLD_ROWS - 10)) + 5;
                attempts++;
                
                // Check distance from all enemies
                let safe = true;
                for (const e of enemies) {
                    if (e.segments.length === 0) continue;
                    const head = e.segments[0];
                    const dist = Math.abs(head.x - spawnX) + Math.abs(head.y - spawnY);
                    // Stay far away from big snakes
                    if (e.segments.length > 5 && dist < 30) safe = false;
                    // Decent distance from any snake
                    if (dist < 15) safe = false;
                }
                if (safe || attempts > 100) break;
            } while (true);
            
            // Player starts small but tough - head is 5x tougher than body cars
            const HEAD_HP = 1500; // 5x body HP (300)
            snake = [
                { x: spawnX, y: spawnY, type: GUNS.HEAD, hp: HEAD_HP, maxHp: HEAD_HP, lastFired: 0 },
                { x: spawnX - 1, y: spawnY, type: GUNS.MACHINEGUN, hp: 300, maxHp: 300, lastFired: 0 },
                { x: spawnX - 2, y: spawnY, type: GUNS.SHOTGUN, hp: 300, maxHp: 300, lastFired: 0 },
                { x: spawnX - 3, y: spawnY, type: GUNS.CANNON, hp: 300, maxHp: 300, lastFired: 0 }
            ];
            
            dir = DIR.RIGHT; nextDir = DIR.RIGHT;
            aimAngle = 0; isAiming = true;
            
            cameraZoom = 2; targetZoom = 2; // Start zoomed in
            cameraX = spawnX * GRID - canvas.width / 2 / cameraZoom;
            cameraY = spawnY * GRID - canvas.height / 2 / cameraZoom;
            dirQueue = []; // Clear direction queue
            
            updateHUD(); updateLeaderboard(); announceSpawn();
        }
        
        function announceSpawn() {
            const el = document.getElementById('waveAnnounce');
            el.textContent = 'üõ°Ô∏è 45s SHIELD';
            el.classList.add('show');
            waveDelay = 1500;
            haptic('medium');
            setTimeout(() => el.classList.remove('show'), 1500);
        }
        
        function announceWave() {
            const el = document.getElementById('waveAnnounce');
            el.textContent = `WAVE ${wave}`;
            el.classList.add('show');
            waveDelay = 2000;
            haptic('medium');
            setTimeout(() => el.classList.remove('show'), 1500);
        }

        function respawn() {
            // Death effects
            screenShake();
            // sounds disabled
            
            // Capture debug info at death
            const otherPlayersDebug = [];
            if (Multiplayer.connected) {
                for (const [pid, op] of Multiplayer.otherPlayers) {
                    otherPlayersDebug.push({
                        id: pid,
                        name: op.name,
                        segments: op.segments ? op.segments.length : 0,
                        head: op.segments && op.segments[0] ? op.segments[0] : null,
                        color: op.color
                    });
                }
            }
            
            deathDebugInfo = {
                timestamp: new Date().toISOString(),
                reason: deathReason,
                myPosition: snake[0] ? { x: snake[0].x, y: snake[0].y } : null,
                myLength: snake.length,
                myScore: score,
                multiplayer: {
                    connected: Multiplayer.connected,
                    playerId: Multiplayer.playerId,
                    roomId: Multiplayer.roomId,
                    otherPlayers: otherPlayersDebug
                },
                nearbyEnemies: enemies.filter(e => {
                    if (!e.segments || !snake[0]) return false;
                    const dist = Math.abs(e.segments[0].x - snake[0].x) + Math.abs(e.segments[0].y - snake[0].y);
                    return dist < 15;
                }).map(e => ({
                    len: e.segments.length,
                    head: e.segments[0],
                    personality: e.personality?.neural ? 'neural' : 'basic'
                }))
            };
            console.log('DEATH DEBUG:', deathDebugInfo);
            
            // Show death screen with learning stats
            patternTracker.save();
            ruleEngine.save();

            // Report leave to server for player history
            devMode.reportLeave(
                Multiplayer.username || 'Anonymous',
                maxLength,      // Track max length achieved this session
                waveKills,      // Segments destroyed this session
                score           // Final score
            );

            // Update reputation system
            const survivalTime = strategyClassifier.totalTicks / 60; // ~seconds
            reputationSystem.onGameEnd(survivalTime, strategyClassifier.dominant);

            // Update game over screen stats
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalWave').textContent = '#' + (enemies.filter(e => e.segments.length >= snake.length).length + 1);
            document.getElementById('finalLength').textContent = maxLength;
            document.getElementById('deathReasonText').textContent = deathReason || 'Unknown';

            // Pattern stats
            const pStats = patternTracker.getStats();
            document.getElementById('patternStatsText').innerHTML =
                `Turn bias: ${pStats.leftBias}% left<br>` +
                `Flee distance: ${pStats.fleeDistance} tiles`;

            // Strategy classifier stats
            const sStats = strategyClassifier.getDisplayStats();
            const counterDesc = {
                rusher: 'Enemies flanked and retreat-baited you',
                sniper: 'Enemies rushed you directly at high speed',
                farmer: 'Enemies chased you relentlessly',
                survivor: 'Enemies used pincer movements to trap you',
                hunter: 'Enemies protected their weak with bodyguards',
                neutral: 'Enemies are still learning your style...'
            };
            document.getElementById('strategyStatsText').innerHTML =
                `Detected: <span style="color:#ff0">${sStats.dominant}</span> (${sStats.confidence}% confidence)<br>` +
                `Kills/min: ${sStats.kpm} | Aggression: ${sStats.aggression}%<br>` +
                `<span style="color:#f88">${counterDesc[strategyClassifier.dominant] || counterDesc.neutral}</span>`;

            // Reputation stats
            const rStats = reputationSystem.getDisplayStats();
            document.getElementById('reputationStatsText').innerHTML =
                `Games: ${rStats.gamesPlayed} | K/D: ${rStats.kd}<br>` +
                `Usual style: <span style="color:#ff0">${rStats.dominantStyle}</span><br>` +
                `‚ò† Dangerous enemies: ${rStats.dangerousEnemies}<br>` +
                `‚òÖ Pack leader: <span style="color:#ff0">${rStats.packLeader}</span>`;

            // G√∂del learning stats
            const gStats = ruleEngine.getStats();
            let godelText = `${gStats.total} rules active (${gStats.learned} learned from deaths)<br>`;
            godelText += `Avg confidence: ${(gStats.avgConf * 100).toFixed(0)}%<br>`;
            godelText += `Death patterns tracked: ${gStats.patterns}`;

            // Show recently generated rules
            const recentRules = ruleEngine.rules.filter(r => r.source === 'death_pattern').slice(-3);
            if (recentRules.length > 0) {
                godelText += `<br><br>Recent learnings:`;
                for (const rule of recentRules) {
                    const conditions = Object.keys(rule.trigger.conditions).join(', ');
                    const avoid = rule.action.bias[0] < -1 ? 'left' : rule.action.bias[2] < -1 ? 'right' : 'straight';
                    godelText += `<br>‚Ä¢ "${conditions}" ‚Üí avoid ${avoid}`;
                }
            }
            document.getElementById('godelStatsText').innerHTML = godelText;

            // Show game over screen
            gameState = 'dead';
            canvas.classList.remove('playing');
            document.getElementById('gameOverScreen').classList.remove('hidden');
        }

        function doRespawn() {
            document.getElementById('gameOverScreen').classList.add('hidden');

            // Find safe spawn location
            let spawnX, spawnY, attempts = 0;
            do {
                spawnX = Math.floor(Math.random() * (WORLD_COLS - 10)) + 5;
                spawnY = Math.floor(Math.random() * (WORLD_ROWS - 10)) + 5;
                attempts++;

                let safe = true;
                for (const e of enemies) {
                    if (e.segments.length === 0) continue;
                    const head = e.segments[0];
                    const dist = Math.abs(head.x - spawnX) + Math.abs(head.y - spawnY);
                    if (e.segments.length > 5 && dist < 30) safe = false;
                    if (dist < 15) safe = false;
                }
                if (safe || attempts > 100) break;
            } while (true);

            // Fresh start with new train - head is 5x tougher
            const HEAD_HP_RESPAWN = 1500;
            snake = [
                { x: spawnX, y: spawnY, type: GUNS.HEAD, hp: HEAD_HP_RESPAWN, maxHp: HEAD_HP_RESPAWN, lastFired: 0 },
                { x: spawnX - 1, y: spawnY, type: GUNS.MACHINEGUN, hp: 300, maxHp: 300, lastFired: 0 },
                { x: spawnX - 2, y: spawnY, type: GUNS.SHOTGUN, hp: 300, maxHp: 300, lastFired: 0 },
                { x: spawnX - 3, y: spawnY, type: GUNS.CANNON, hp: 300, maxHp: 300, lastFired: 0 }
            ];

            dir = DIR.RIGHT; nextDir = DIR.RIGHT;
            aimAngle = 0; isAiming = true;
            invincibleTimer = 5000; // 5s spawn protection

            cameraZoom = 2; targetZoom = 2;
            cameraX = spawnX * GRID - canvas.width / 2 / cameraZoom;
            cameraY = spawnY * GRID - canvas.height / 2 / cameraZoom;
            dirQueue = [];

            // Reset score on death (io game style)
            score = 0;
            maxLength = 4;
            deathReason = '';
            deathDebugInfo = null;

            gameState = 'playing';
            canvas.classList.add('playing');

            const el = document.getElementById('waveAnnounce');
            el.textContent = 'üõ°Ô∏è RESPAWNING...';
            el.classList.add('show');
            haptic('medium');
            setTimeout(() => el.classList.remove('show'), 1500);
        }

        function spawnEnemy() {
            const edge = Math.floor(Math.random() * 4);
            let x, y, startDir;
            
            switch (edge) {
                case 0: x = 0; y = Math.floor(Math.random() * WORLD_ROWS); startDir = DIR.RIGHT; break;
                case 1: x = WORLD_COLS - 1; y = Math.floor(Math.random() * WORLD_ROWS); startDir = DIR.LEFT; break;
                case 2: x = Math.floor(Math.random() * WORLD_COLS); y = 0; startDir = DIR.DOWN; break;
                case 3: x = Math.floor(Math.random() * WORLD_COLS); y = WORLD_ROWS - 1; startDir = DIR.UP; break;
            }
            
            let trainLength = 2;
            if (wave >= 2 && Math.random() > 0.6) trainLength = 3;
            if (wave >= 4 && Math.random() > 0.7) trainLength = 4;
            if (wave >= 6 && Math.random() > 0.8) trainLength = 5;
            
            // 50% chance to be neural AI, rest are personality-based
            const isNeural = Math.random() < 0.5;
            
            let color, personality;
            if (isNeural) {
                color = '#f0f'; // Magenta for neural AI
                personality = { aggression: 0.5, greed: 0.5, caution: 0.5, neural: true };
            } else {
                const personalities = [
                    { aggression: 0.8, greed: 0.3, caution: 0.2 },
                    { aggression: 0.2, greed: 0.9, caution: 0.4 },
                    { aggression: 0.5, greed: 0.5, caution: 0.7 },
                    { aggression: 0.9, greed: 0.1, caution: 0.1 },
                ];
                personality = personalities[Math.floor(Math.random() * personalities.length)];
                
                if (personality.aggression > 0.7) color = '#f55';
                else if (personality.greed > 0.7) color = '#ff0';
                else if (personality.caution > 0.5) color = '#5af';
                else color = '#f80';
            }
            
            const baseHp = 20 + wave * 5;
            const segments = [];
            for (let i = 0; i < trainLength; i++) {
                let gunType = i === 0 ? GUNS.HEAD : GUNS[GUN_NAMES[Math.floor(Math.random() * GUN_NAMES.length)]];
                const segX = (x - startDir.x * i + WORLD_COLS) % WORLD_COLS;
                const segY = (y - startDir.y * i + WORLD_ROWS) % WORLD_ROWS;
                segments.push({
                    x: segX, y: segY,
                    hp: i === 0 ? Infinity : baseHp,
                    maxHp: i === 0 ? Infinity : baseHp,
                    type: gunType, lastFired: 0
                });
            }
            
            const enemyId = enemies.length;
            enemies.push({
                // Assign team to balance (alternate)
                team: enemies.filter(e => e.team === 'blue').length <= enemies.filter(e => e.team === 'red').length ? 'blue' : 'red',
                name: '...', // Placeholder until Qwen generates name
                segments, dir: startDir, nextDir: startDir,
                baseSpeed: 8 + wave * 0.5, damage: 10 + wave * 2,
                moveTimer: 0, lastFired: 0, fireRate: 1200 - wave * 40,
                score: 10 * trainLength, personality,
                targetPos: null, avoidPos: null, lastDecision: 0,
                decisionInterval: 300 + Math.random() * 200,
                recentPoints: 0, lastPointTime: 0, isMVP: false
            });
            // Set color based on team in team mode
            const newEnemy = enemies[enemies.length - 1];
            if (teamMode) newEnemy.color = newEnemy.team === "blue" ? "#0af" : "#f55";
            else newEnemy.color = color;
            
            // Generate AI name asynchronously
            generateTrainName().then(name => {
                if (newEnemy.segments.length > 0) {
                    newEnemy.name = name;
                    // Update reputation with real name
                    reputationSystem.initEnemy(newEnemy.id, name);
                }
            });

            // Initialize reputation for this enemy
            newEnemy.id = enemyId;
            reputationSystem.initEnemy(enemyId, newEnemy.name);
        }

        function updateSnake() {
            // Consume from direction queue for responsive controls
            if (dirQueue.length > 0) {
                const newDir = dirQueue.shift();
                // Extra check to prevent 180 turns
                if (!(dir.x === -newDir.x && dir.y === -newDir.y)) {
                    dir = newDir;
                    nextDir = newDir;
                }
            } else {
                dir = nextDir;
            }
            const head = snake[0];
            const newX = head.x + dir.x;
            const newY = head.y + dir.y;
            const wrappedX = (newX + WORLD_COLS) % WORLD_COLS;
            const wrappedY = (newY + WORLD_ROWS) % WORLD_ROWS;
            
            for (let i = 1; i < snake.length; i++) {
                if (snake[i].x === wrappedX && snake[i].y === wrappedY) {
                    snake[0].hp = 0;
                    deathReason = 'Self collision - ran into own body';
                    return true;
                }
            }
            
            const prevPositions = snake.map(s => ({ x: s.x, y: s.y }));
            // Leader trail logic
            let maxLen = snake.length;
            for(const e of enemies) if(e.segments.length > maxLen) maxLen = e.segments.length;
            if(Multiplayer.connected) for(const [,p] of Multiplayer.otherPlayers) if(p.segments && p.segments.length > maxLen) maxLen = p.segments.length;
            const wasLeaderBefore = isLeader;
            isLeader = (snake.length >= maxLen);
            if (isLeader && !wasLeaderBefore) HighlightRecorder.onBecameLeader();
            if (!isLeader && wasLeaderBefore) HighlightRecorder.onLostLeader();
            if (isLeader) { tronTrail.push({x:wrappedX,y:wrappedY}); if(tronTrail.length>50) tronTrail.shift(); }
            else { for(const t of tronTrail) if(t.x===wrappedX && t.y===wrappedY) { trailBoostTimer = 500; break; } }
            HighlightRecorder.onLongTrain(snake.length);
            snake[0].x = wrappedX;
            snake[0].y = wrappedY;
            
            for (let i = 1; i < snake.length; i++) {
                snake[i].x = prevPositions[i - 1].x;
                snake[i].y = prevPositions[i - 1].y;
            }
            
            const headPx = wrappedX * GRID + GRID / 2;
            const headPy = wrappedY * GRID + GRID / 2;
            
            for (let i = pickups.length - 1; i >= 0; i--) {
                const p = pickups[i];
                const dist = Math.sqrt((p.x - headPx) ** 2 + (p.y - headPy) ** 2);
                
                if (dist < GRID) {
                    if (p.isPowerup) {
                        // Collect power-up!
                        if (p.type.name === 'SPEED') {
                            speedTimer = p.type.duration;
                        } else if (p.type.name === 'SHIELD') {
                            invincibleTimer = Math.max(invincibleTimer, p.type.duration);
                        } else if (p.type.name === 'MAGNET') {
                            magnetTimer = p.type.duration;
                        }
                        haptic('heavy');
                        // sounds disabled
                        // Big flashy particles
                        for (let j = 0; j < 20; j++) {
                            particles.push({ x: p.x, y: p.y, vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8, life: 40, color: p.type.color });
                        }
                        pickups.splice(i, 1);
                        continue;
                    } else if (p.isHealth) {
                        let mostDamaged = null, lowestHp = Infinity;
                        for (let j = 1; j < snake.length; j++) {
                            if (snake[j].hp < snake[j].maxHp && snake[j].hp < lowestHp) {
                                lowestHp = snake[j].hp;
                                mostDamaged = snake[j];
                            }
                        }
                        if (mostDamaged) {
                            mostDamaged.hp = Math.min(mostDamaged.maxHp, mostDamaged.hp + p.healAmount);
                            haptic('double');
                            for (let j = 0; j < 8; j++) {
                                particles.push({ x: p.x, y: p.y, vx: (Math.random() - 0.5) * 4, vy: (Math.random() - 0.5) * 4, life: 25, color: '#4f4' });
                            }
                        }
                    } else {
                        const tailPos = prevPositions[prevPositions.length - 1];
                        snake.push({ x: tailPos.x, y: tailPos.y, type: p.type, hp: 200, maxHp: 200, lastFired: 0 });
                        haptic('double');
                        // sounds disabled
                        score += 50;
                        for (let j = 0; j < 12; j++) {
                            particles.push({ x: p.x, y: p.y, vx: (Math.random() - 0.5) * 6, vy: (Math.random() - 0.5) * 6, life: 30, color: p.type.color });
                        }
                    }
                    // Track pickup for strategy classification
                    strategyClassifier.onPickup(p.isHealth);
                    pickups.splice(i, 1);
                }
            }

            // Send position to multiplayer server
            if (Multiplayer.connected) {
                Multiplayer.sendUpdate(snake[0].x, snake[0].y, snake, score);
                
                // PVP COLLISION DETECTION (disabled in team mode)
                if (!teamMode) {
                for (const [playerId, otherPlayer] of Multiplayer.otherPlayers) {
                    if (!otherPlayer.segments || otherPlayer.segments.length === 0) continue;
                    
                    const otherHead = otherPlayer.segments[0];
                    const myLen = snake.length;
                    const theirLen = otherPlayer.segments.length;
                    
                    // Check head vs other player's body (with 1-tile tolerance for lag)
                    for (let i = 0; i < otherPlayer.segments.length; i++) {
                        const seg = otherPlayer.segments[i];
                        const dx = Math.abs(wrappedX - seg.x);
                        const dy = Math.abs(wrappedY - seg.y);
                        
                        // Exact collision or within 1 tile (lag compensation)
                        if (dx <= 1 && dy <= 1 && dx + dy <= 1) {
                            // Collision detected
                            
                            if (i === 0) {
                                // Head-to-head collision!
                                if (myLen > theirLen) {
                                    // We win!
                                    score += theirLen * 100;
                                    haptic('heavy');
                                    // sounds disabled
                                    killFeed.add(playerName, otherPlayer.name);
                                    HighlightRecorder.onKill(playerName, otherPlayer.name);
                                    for (let j = 0; j < 20; j++) {
                                        particles.push({ x: seg.x * GRID, y: seg.y * GRID, vx: (Math.random()-0.5)*8, vy: (Math.random()-0.5)*8, life: 40, color: otherPlayer.color });
                                    }
                                    Multiplayer.send({ type: 'kill', targetId: playerId });
                                } else if (myLen < theirLen) {
                                    // We die!
                                    deathReason = 'Killed by ' + otherPlayer.name + ' (head-on, ' + theirLen + ' vs ' + myLen + ')';
                                    return true;
                                }
                                // Equal size = both survive
                            } else {
                                // Hit their body - we die!
                                deathReason = 'Ran into ' + otherPlayer.name + "'s body (seg " + i + ')';
                                return true;
                            }
                        }
                    }
                }
                
                } // end teamMode check
                
            }

            return false;
        }

        function updateEnemies(dt) {
            const playerHead = snake[0];
            const playerLen = snake.length;
            
            // Track which player segments have been damaged this frame (prevent stacking)
            const playerSegmentsDamagedThisFrame = new Set();
            
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                if (!e.segments || e.segments.length === 0) { enemies.splice(i, 1); continue; }
                
                const head = e.segments[0];
                const myLen = e.segments.length;
                const speedMultiplier = 1 / (1 + (myLen - 1) * 0.05); // Reduced penalty
                const actualSpeed = e.baseSpeed * speedMultiplier;
                
                e.moveTimer += dt;
                const moveInterval = 150 / actualSpeed * 10; // Fixed formula - lower = faster
                
                if (e.moveTimer >= moveInterval) {
                    e.moveTimer = 0;
                    
                    let newDir = e.dir;
                    
                    // NEURAL NETWORK AI + RULE ENGINE
                    if (e.personality.neural) {
                        const vision = getVision(head.x, head.y, e.dir, e.segments, enemies.filter(oe => oe !== e), pickups, snake);

                        // Extract gameState from vision for rule matching
                        // Vision: 8 directions √ó 6 values [food, self, wall, smaller_head, bigger_head, enemy_body]
                        // Dir 0=ahead, 2=right, 6=left
                        // Find leader (biggest snake) direction
                        let leaderDir = null;
                        let maxLen = e.segments.length;
                        for (const other of enemies) {
                            if (other !== e && other.segments && other.segments.length > maxLen) {
                                maxLen = other.segments.length;
                                const dx = other.segments[0].x - head.x;
                                const dy = other.segments[0].y - head.y;
                                leaderDir = { dx, dy, len: other.segments.length };
                            }
                        }
                        // Check player too
                        if (snake.length > maxLen) {
                            maxLen = snake.length;
                            const dx = snake[0].x - head.x;
                            const dy = snake[0].y - head.y;
                            leaderDir = { dx, dy, len: snake.length };
                        }
                        
                        // Calculate leader direction relative to our heading
                        let leaderAhead = false, leaderLeft = false, leaderRight = false;
                        if (leaderDir) {
                            const { dx, dy } = leaderDir;
                            if (e.dir === DIR.UP) { leaderAhead = dy < 0; leaderLeft = dx < 0; leaderRight = dx > 0; }
                            else if (e.dir === DIR.DOWN) { leaderAhead = dy > 0; leaderLeft = dx > 0; leaderRight = dx < 0; }
                            else if (e.dir === DIR.LEFT) { leaderAhead = dx < 0; leaderLeft = dy > 0; leaderRight = dy < 0; }
                            else { leaderAhead = dx > 0; leaderLeft = dy < 0; leaderRight = dy > 0; }
                        }
                        
                        const gameState = {
                            foodAhead: vision[0] > 0,
                            foodLeft: vision[36] > 0,
                            foodRight: vision[12] > 0,
                            wallAhead: vision[2] > 0.3,
                            wallLeft: vision[38] > 0.3,
                            wallRight: vision[14] > 0.3,
                            bodyAhead: vision[1] > 0,
                            bodyLeft: vision[37] > 0,
                            bodyRight: vision[13] > 0,
                            enemyAhead: vision[5] > 0 || vision[3] > 0 || vision[4] > 0,
                            enemyLeft: vision[41] > 0 || vision[39] > 0 || vision[40] > 0,
                            enemyRight: vision[17] > 0 || vision[15] > 0 || vision[16] > 0,
                            enemyCloser: vision[3] > vision[4],
                            leaderAhead,
                            leaderLeft, 
                            leaderRight,
                            iAmBigger: leaderDir ? e.segments.length > leaderDir.len : true
                        };

                        // Get raw neural output
                        let output = neuralBrain.forward(vision);

                        // Apply rules (G√∂del layer)
                        output = ruleEngine.applyRules(output, gameState, e.id);

                        // Apply player strategy counter (makes their strategy backfire)
                        const counterBias = strategyClassifier.getCounterBias(
                            { x: head.x, y: head.y },
                            { x: playerHead.x, y: playerHead.y },
                            e.id
                        );
                        output[0] += counterBias.left;
                        output[1] += counterBias.straight;
                        output[2] += counterBias.right;

                        // Apply reputation-based bias (pack behavior, dangerous enemies)
                        const repBias = reputationSystem.getReputationBias(e.id);
                        output[0] += repBias.left;
                        output[1] += repBias.straight;
                        output[2] += repBias.right;

                        // LOOKAHEAD: Simulate future moves to avoid bad outcomes
                        const lookaheadScores = simulateLookahead(
                            head.x, head.y, e.dir, e.segments,
                            enemies.filter(oe => oe !== e), pickups, snake, 5
                        );
                        
                        // Combine neural output with lookahead (lookahead can veto bad moves)
                        // Normalize neural output to 0-1 range
                        const maxNeural = Math.max(output[0], output[1], output[2]);
                        const minNeural = Math.min(output[0], output[1], output[2]);
                        const range = maxNeural - minNeural || 1;
                        const neuralNorm = output.map(v => (v - minNeural) / range);
                        
                        // If lookahead predicts death (very negative), heavily penalize
                        for (let i = 0; i < 3; i++) {
                            if (lookaheadScores[i] < -50) {
                                output[i] -= 100; // Veto this direction
                            } else {
                                // Add lookahead bonus scaled by neural confidence
                                output[i] += lookaheadScores[i] * 0.1;
                            }
                        }

                        // LEADER HUNTING: Bias toward the biggest snake (if we're bigger, hunt; if smaller, maybe flee)
                        if (gameState.leaderAhead || gameState.leaderLeft || gameState.leaderRight) {
                            const huntBias = gameState.iAmBigger ? 2 : -1; // Hunt if bigger, slight avoid if smaller
                            if (gameState.leaderAhead) output[1] += huntBias;
                            if (gameState.leaderLeft) output[0] += huntBias;
                            if (gameState.leaderRight) output[2] += huntBias;
                        }

                        // Make decision from modified output
                        let decision = 1; // default straight
                        if (output[0] > output[1] && output[0] > output[2]) decision = 0;
                        else if (output[2] > output[1] && output[2] > output[0]) decision = 2;

                        // Record state for death analysis (G√∂del learning)
                        ruleEngine.recordState(e.id, gameState, decision);

                        if (decision === 0) newDir = turnLeft(e.dir);
                        else if (decision === 2) newDir = turnRight(e.dir);
                        // decision === 1 means go straight

                        // PATTERN PREDICTION: Override when near player
                        const distToPlayer = Math.abs(head.x - playerHead.x) + Math.abs(head.y - playerHead.y);
                        if (distToPlayer < 8 && distToPlayer > 2) {
                            const prediction = patternTracker.predictTurn();
                            if (prediction && prediction.confidence > 0.3) {
                                // Predict where player will be based on their turn bias
                                const playerDir = dir;
                                let predictedPos = { x: playerHead.x, y: playerHead.y };

                                // If player tends to turn left, anticipate that
                                if (prediction.predictedDir < 0) {
                                    const leftDir = turnLeft(playerDir);
                                    predictedPos.x += leftDir.x * 3;
                                    predictedPos.y += leftDir.y * 3;
                                } else {
                                    const rightDir = turnRight(playerDir);
                                    predictedPos.x += rightDir.x * 3;
                                    predictedPos.y += rightDir.y * 3;
                                }

                                // Move toward predicted position
                                const dx = predictedPos.x - head.x;
                                const dy = predictedPos.y - head.y;

                                if (Math.abs(dx) > Math.abs(dy)) {
                                    const wantDir = dx > 0 ? DIR.RIGHT : DIR.LEFT;
                                    if (!(wantDir.x === -e.dir.x && wantDir.y === -e.dir.y)) {
                                        newDir = wantDir;
                                        // Flash pattern detected occasionally
                                        if (Math.random() < 0.08) showPatternFlash('detected');
                                    }
                                } else {
                                    const wantDir = dy > 0 ? DIR.DOWN : DIR.UP;
                                    if (!(wantDir.x === -e.dir.x && wantDir.y === -e.dir.y)) {
                                        newDir = wantDir;
                                        if (Math.random() < 0.08) showPatternFlash('detected');
                                    }
                                }
                            }
                        }
                    } else {
                        // Original personality-based AI
                        let targetX = playerHead.x, targetY = playerHead.y;
                        const p = e.personality;
                        
                        if (p.greed > 0.5 && pickups.length > 0) {
                            let nearestDist = Infinity;
                            for (const pickup of pickups) {
                                const px = Math.floor(pickup.x / GRID);
                                const py = Math.floor(pickup.y / GRID);
                                const dist = Math.abs(head.x - px) + Math.abs(head.y - py);
                                if (dist < nearestDist && dist < 30) {
                                    nearestDist = dist;
                                    targetX = px; targetY = py;
                                }
                            }
                        }
                        
                        if (p.aggression > 0.7) {
                            for (const other of enemies) {
                                if (other === e || other.segments.length === 0) continue;
                                if (myLen > other.segments.length) {
                                    const dist = Math.abs(head.x - other.segments[0].x) + Math.abs(head.y - other.segments[0].y);
                                    if (dist < 20) { targetX = other.segments[0].x; targetY = other.segments[0].y; break; }
                                }
                            }
                        }
                        
                        if (p.caution > 0.5 && myLen < playerLen) {
                            const dist = Math.abs(head.x - playerHead.x) + Math.abs(head.y - playerHead.y);
                            if (dist < 15) {
                                targetX = head.x + (head.x - playerHead.x) * 2;
                                targetY = head.y + (head.y - playerHead.y) * 2;
                            }
                        }
                        
                        const dx = targetX - head.x, dy = targetY - head.y;
                        if (Math.abs(dx) > Math.abs(dy)) newDir = dx > 0 ? DIR.RIGHT : DIR.LEFT;
                        else if (Math.abs(dy) > 0) newDir = dy > 0 ? DIR.DOWN : DIR.UP;
                    }
                    
                    // Don't reverse
                    if (newDir.x === -e.dir.x && newDir.y === -e.dir.y) newDir = e.dir;
                    
                    // Collision avoidance
                    const nextX = (head.x + newDir.x + WORLD_COLS) % WORLD_COLS;
                    const nextY = (head.y + newDir.y + WORLD_ROWS) % WORLD_ROWS;
                    let willCollide = false;
                    
                    for (let j = 1; j < e.segments.length; j++) {
                        if (e.segments[j].x === nextX && e.segments[j].y === nextY) { willCollide = true; break; }
                    }
                    
                    if (willCollide) {
                        const dirs = [DIR.UP, DIR.DOWN, DIR.LEFT, DIR.RIGHT];
                        for (const tryDir of dirs) {
                            if (tryDir.x === -e.dir.x && tryDir.y === -e.dir.y) continue;
                            const tryX = (head.x + tryDir.x + WORLD_COLS) % WORLD_COLS;
                            const tryY = (head.y + tryDir.y + WORLD_ROWS) % WORLD_ROWS;
                            let safe = true;
                            for (let j = 1; j < e.segments.length; j++) {
                                if (e.segments[j].x === tryX && e.segments[j].y === tryY) { safe = false; break; }
                            }
                            if (safe) { newDir = tryDir; break; }
                        }
                    }
                    
                    e.dir = newDir;
                    
                    // Move
                    const prevPositions = e.segments.map(s => ({ x: s.x, y: s.y }));
                    head.x = (head.x + e.dir.x + WORLD_COLS) % WORLD_COLS;
                    head.y = (head.y + e.dir.y + WORLD_ROWS) % WORLD_ROWS;
                    for (let j = 1; j < e.segments.length; j++) {
                        e.segments[j].x = prevPositions[j - 1].x;
                        e.segments[j].y = prevPositions[j - 1].y;
                    }
                    
                    // Pickup collection
                    for (let pi = pickups.length - 1; pi >= 0; pi--) {
                        const p = pickups[pi];
                        const px = Math.floor(p.x / GRID), py = Math.floor(p.y / GRID);
                        if (head.x === px && head.y === py) {
                            if (!p.isHealth) {
                                const tail = e.segments[e.segments.length - 1];
                                e.segments.push({ x: tail.x, y: tail.y, hp: 20 + wave * 5, maxHp: 20 + wave * 5, type: p.type, lastFired: 0 });
                            }
                            pickups.splice(pi, 1);
                            ruleEngine.onOutcome(e.id, 'ate_food'); // Credit rules for eating
                            for (let j = 0; j < 6; j++) {
                                particles.push({ x: head.x * GRID + GRID/2, y: head.y * GRID + GRID/2, vx: (Math.random()-0.5)*4, vy: (Math.random()-0.5)*4, life: 20, color: e.color });
                            }
                        }
                    }
                }
                
                // Shooting - find best target (player or other enemies)
                const now = performance.now();
                let targetX = null, targetY = null, targetDist = Infinity;
                
                // Check player distance
                const playerDist = Math.abs(head.x - playerHead.x) + Math.abs(head.y - playerHead.y);
                if (playerDist < 25) {
                    targetX = playerHead.x;
                    targetY = playerHead.y;
                    targetDist = playerDist;
                }
                
                // Check other enemies - prioritize smaller ones or threats
                for (const other of enemies) {
                    if (other === e || !other.segments || other.segments.length === 0) continue;
                    const otherHead = other.segments[0];
                    const dist = Math.abs(head.x - otherHead.x) + Math.abs(head.y - otherHead.y);
                    
                    // Engage if: close enough AND (we're bigger OR they're a threat)
                    if (dist < 20) {
                        const dominated = e.segments.length > other.segments.length;
                        const threatened = other.segments.length > e.segments.length && dist < 12;
                        
                        if ((dominated || threatened) && dist < targetDist) {
                            targetX = otherHead.x;
                            targetY = otherHead.y;
                            targetDist = dist;
                        }
                    }
                }
                
                // Fire at target if we have one
                if (targetX !== null) {
                    for (let si = 0; si < e.segments.length; si++) {
                        const seg = e.segments[si];
                        if (!seg.type) continue;
                        if (seg.lastFired === undefined) seg.lastFired = 0;
                        const type = seg.type;
                        if (now - seg.lastFired < type.fireRate) continue;
                        seg.lastFired = now;
                        
                        const sx = seg.x * GRID + GRID/2, sy = seg.y * GRID + GRID/2;
                        const tx = targetX * GRID + GRID/2, ty = targetY * GRID + GRID/2;
                        const angle = Math.atan2(ty - sy, tx - sx);
                        
                        if (si === 0) { e.aimAngle = angle; e.aimX = sx; e.aimY = sy; }
                        
                        if (type.aoe) {
                            // AOE damages player (if not invincible) and other enemies
                            if (invincibleTimer <= 0) {
                                for (const ps of snake) {
                                    const psx = ps.x * GRID + GRID/2, psy = ps.y * GRID + GRID/2;
                                    const dist = Math.sqrt((psx - sx)**2 + (psy - sy)**2);
                                    if (dist < type.range) ps.hp -= type.damage;
                                }
                            }
                            for (const other of enemies) {
                                if (other === e || !other.segments) continue;
                                for (const oseg of other.segments) {
                                    const osx = oseg.x * GRID + GRID/2, osy = oseg.y * GRID + GRID/2;
                                    const dist = Math.sqrt((osx - sx)**2 + (osy - sy)**2);
                                    if (dist < type.range) oseg.hp -= type.damage;
                                }
                            }
                            particles.push({ x: sx, y: sy, vx: 0, vy: 0, life: 15, color: type.color, isAoe: true, radius: 10 });
                        } else if (type.spread) {
                            for (let p = 0; p < type.pellets; p++) {
                                const spread = (Math.random() - 0.5) * type.spread * 2;
                                const a = angle + spread;
                                enemyProjectiles.push({ x: sx, y: sy, vx: Math.cos(a)*5, vy: Math.sin(a)*5, damage: type.damage, size: 3, color: type.color, life: 300, owner: e });
                            }
                        } else {
                            const size = type.size || 4;
                            enemyProjectiles.push({ x: sx, y: sy, vx: Math.cos(angle)*5, vy: Math.sin(angle)*5, damage: type.damage, size, color: type.color, life: 400, owner: e });
                        }
                    }
                }
                
                // Collisions - skip fatal ones during invincibility, grace period, or same team
                if (teamMode && e.team === playerTeam) continue; // Same team, no collision
                // Grace: for 500ms after shield drops, head collisions just push through
                if (head.x === playerHead.x && head.y === playerHead.y) {
                    // If player only has head (no body), any collision is instant death
                    if (playerLen <= 1 && invincibleTimer <= 0) {
                        deathReason = 'Head-only collision - no protection!';
                        return true;
                    }
                    if (invincibleTimer > -2000) {
                        // During invincibility or 2 second grace period, just pass through
                        // But deal significant damage to the enemy for touching us
                        if (e.segments.length > 1) e.segments[1].hp -= 50;
                    } else if (myLen > playerLen + 6) {
                        // Only instant death if enemy is MUCH bigger (7+ segments more)
                        deathReason = `Head collision with MUCH bigger enemy (${myLen} vs ${playerLen} segments)`;
                        console.log('DEATH: Enemy much bigger', { myLen, playerLen, invincibleTimer });
                        return true;
                    } else if (myLen > playerLen) {
                        // Bigger but not by much - take heavy damage instead of instant death
                        // Head takes damage if no body cars, otherwise body cars
                        if (snake.length === 1) {
                            snake[0].hp -= 50;
                        } else {
                            for (let si = 1; si < snake.length && si < 3; si++) {
                                snake[si].hp -= 50;
                            }
                        }
                        haptic('heavy');
                    } else if (myLen < playerLen) {
                        // Player killed this enemy - track for strategy classifier
                        strategyClassifier.onKill(e.segments.length);
                        strategyClassifier.onPlayerKilledEnemy(e.id);
                        for (const seg of e.segments) {
                            pickups.push({ x: seg.x*GRID+GRID/2, y: seg.y*GRID+GRID/2, type: GUNS[GUN_NAMES[Math.floor(Math.random()*GUN_NAMES.length)]], isHealth: false, bob: Math.random()*Math.PI*2 });
                            score += 15; waveKills++;
                        }
                        e.segments = [];
                        haptic('medium');
                    } else {
                        // Equal size - both take damage, neither dies instantly
                        // Head takes damage if no body cars
                        if (snake.length === 1) {
                            snake[0].hp -= 30;
                        } else {
                            for (let si = 1; si < snake.length && si < 2; si++) {
                                snake[si].hp -= 30;
                            }
                        }
                        if (e.segments.length === 1) {
                            e.segments[0].hp -= 30;
                        } else {
                            for (let si = 1; si < e.segments.length && si < 2; si++) {
                                e.segments[si].hp -= 30;
                            }
                        }
                    }
                }
                
                // Enemy vs enemy collisions
                for (const other of enemies) {
                    if (other === e || !other.segments || other.segments.length === 0) continue;
                    if (e.segments.length === 0) break;
                    const otherHead = other.segments[0];
                    if (head.x === otherHead.x && head.y === otherHead.y) {
                        const otherLen = other.segments.length;
                        if (myLen > otherLen) {
                            for (const seg of other.segments) { pickups.push({ x: seg.x*GRID+GRID/2, y: seg.y*GRID+GRID/2, type: GUNS[GUN_NAMES[Math.floor(Math.random()*GUN_NAMES.length)]], isHealth: false, bob: Math.random()*Math.PI*2 }); waveKills++; }
                            ruleEngine.onOutcome(other.id, 'death');
                            ruleEngine.analyzeDeathAndGenerateRule(other.id);
                            ruleEngine.onOutcome(e.id, 'got_kill');
                            e.recentPoints = (e.recentPoints || 0) + 50; // Big points for kill!
                            e.lastPointTime = Date.now();
                            if (e.isMVP) HighlightRecorder.onKill(e.name, other.name); // MVP kill!
                            other.segments = [];
                        } else if (myLen < otherLen) {
                            for (const seg of e.segments) { pickups.push({ x: seg.x*GRID+GRID/2, y: seg.y*GRID+GRID/2, type: GUNS[GUN_NAMES[Math.floor(Math.random()*GUN_NAMES.length)]], isHealth: false, bob: Math.random()*Math.PI*2 }); waveKills++; }
                            ruleEngine.onOutcome(e.id, 'death');
                            ruleEngine.analyzeDeathAndGenerateRule(e.id);
                            ruleEngine.onOutcome(other.id, 'got_kill');
                            other.recentPoints = (other.recentPoints || 0) + 50;
                            other.lastPointTime = Date.now();
                            if (other.isMVP) HighlightRecorder.onKill(other.name, e.name); // MVP kill!
                            e.segments = [];
                        } else {
                            for (const seg of e.segments) { pickups.push({ x: seg.x*GRID+GRID/2, y: seg.y*GRID+GRID/2, type: GUNS[GUN_NAMES[Math.floor(Math.random()*GUN_NAMES.length)]], isHealth: false, bob: Math.random()*Math.PI*2 }); waveKills++; }
                            for (const seg of other.segments) { pickups.push({ x: seg.x*GRID+GRID/2, y: seg.y*GRID+GRID/2, type: GUNS[GUN_NAMES[Math.floor(Math.random()*GUN_NAMES.length)]], isHealth: false, bob: Math.random()*Math.PI*2 }); waveKills++; }
                            ruleEngine.onOutcome(e.id, 'death');
                            ruleEngine.analyzeDeathAndGenerateRule(e.id);
                            ruleEngine.onOutcome(other.id, 'death');
                            ruleEngine.analyzeDeathAndGenerateRule(other.id);
                            e.segments = [];
                            other.segments = [];
                        }
                    }
                }

                // Self collision
                for (let j = 1; j < e.segments.length; j++) {
                    if (head.x === e.segments[j].x && head.y === e.segments[j].y) {
                        for (const seg of e.segments) { pickups.push({ x: seg.x*GRID+GRID/2, y: seg.y*GRID+GRID/2, type: GUNS[GUN_NAMES[Math.floor(Math.random()*GUN_NAMES.length)]], isHealth: false, bob: Math.random()*Math.PI*2 }); waveKills++; }
                        ruleEngine.onOutcome(e.id, 'death');
                        ruleEngine.analyzeDeathAndGenerateRule(e.id);
                        e.segments = [];
                        break;
                    }
                }
                
                // Body collisions with player - limit damage per frame globally
                for (let si = 0; si < e.segments.length; si++) {
                    const seg = e.segments[si];
                    for (let j = 0; j < snake.length; j++) {
                        const ps = snake[j];
                        if (seg.x === ps.x && seg.y === ps.y) {
                            if (si === 0 && j > 0) { seg.hp -= 50; haptic('medium'); }
                            else if (si > 0 && j === 0) {
                                seg.hp = 0; // Kill enemy body
                                // If player has no body cars, head takes damage
                                if (snake.length === 1 && invincibleTimer <= 0) {
                                    const dmg = invincibleTimer > -2000 ? e.damage * 0.3 : e.damage;
                                    snake[0].hp -= dmg;
                                    haptic('heavy');
                                }
                            }
                            else if (si > 0 && j > 0) { 
                                seg.hp -= 30; 
                                // Only damage each player segment once per frame total (not per enemy)
                                // Reduced damage during grace period
                                if (invincibleTimer <= 0 && !playerSegmentsDamagedThisFrame.has(j)) { 
                                    const dmg = invincibleTimer > -2000 ? e.damage * 0.3 : e.damage;
                                    ps.hp -= dmg; 
                                    playerSegmentsDamagedThisFrame.add(j);
                                    haptic('heavy'); 
                                }
                            }
                        }
                    }
                }
                
                // Remove dead segments
                for (let j = e.segments.length - 1; j >= 0; j--) {
                    if (e.segments[j].hp <= 0) {
                        const seg = e.segments[j];
                        score += 10; waveKills++;
                        // Track segment kills for strategy classifier
                        strategyClassifier.onKill(1); // Single segment kill
                        let totalHp = 0, maxTotalHp = 0;
                        for (let k = 1; k < snake.length; k++) { totalHp += snake[k].hp; maxTotalHp += snake[k].maxHp; }
                        const healthPct = maxTotalHp > 0 ? totalHp / maxTotalHp : 1;
                        let dropHealth = healthPct < 0.4 ? Math.random() < 0.8 : Math.random() > healthPct;
                        if (healthPct >= 0.95) dropHealth = false;
                        
                        if (dropHealth) {
                            pickups.push({ x: seg.x*GRID+GRID/2, y: seg.y*GRID+GRID/2, type: { color: '#4f4', name: 'HEALTH' }, isHealth: true, healAmount: 40, bob: Math.random()*Math.PI*2 });
                        } else {
                            pickups.push({ x: seg.x*GRID+GRID/2, y: seg.y*GRID+GRID/2, type: GUNS[GUN_NAMES[Math.floor(Math.random()*GUN_NAMES.length)]], isHealth: false, bob: Math.random()*Math.PI*2 });
                        }
                        for (let k = 0; k < 8; k++) { particles.push({ x: seg.x*GRID+GRID/2, y: seg.y*GRID+GRID/2, vx: (Math.random()-0.5)*6, vy: (Math.random()-0.5)*6, life: 25, color: e.color }); }
                        e.segments.splice(j);
                        break;
                    }
                }
                
                if (e.segments.length === 0) enemies.splice(i, 1);
            }
            
            const playerSpeedMultiplier = 1 / (1 + (playerLen - 3) * 0.1);
            const speedBoost = speedTimer > 0 ? 1.8 : (trailBoostTimer > 0 ? 1.5 : 1); // 80% faster with speed power-up
            MOVE_INTERVAL = 120 / playerSpeedMultiplier / speedBoost;
            
            // Passive health regen for player segments (2 HP per 100ms = 20 HP/sec)
            for (let i = 1; i < snake.length; i++) {
                const seg = snake[i];
                if (seg.hp < seg.maxHp) {
                    seg.hp = Math.min(seg.maxHp, seg.hp + dt * 0.02);
                }
            }
            
            // Passive health regen for enemy segments (slower - 5 HP/sec)
            for (const e of enemies) {
                if (!e.segments) continue;
                for (let i = 1; i < e.segments.length; i++) {
                    const seg = e.segments[i];
                    if (seg.hp < seg.maxHp) {
                        seg.hp = Math.min(seg.maxHp, seg.hp + dt * 0.005);
                    }
                }
            }
            
            // Check if head (locomotive) is destroyed
            if (snake[0] && snake[0].hp <= 0) {
                deathReason = 'Locomotive destroyed - took too much damage';
                return true;
            }

            for (let i = snake.length - 1; i >= 1; i--) {
                if (snake[i].hp <= 0) {
                    const seg = snake[i];
                    for (let j = 0; j < 10; j++) { particles.push({ x: seg.x*GRID+GRID/2, y: seg.y*GRID+GRID/2, vx: (Math.random()-0.5)*5, vy: (Math.random()-0.5)*5, life: 30, color: seg.type.color }); }
                    snake.splice(i);
                    haptic('heavy');
                    break;
                }
            }

            // Now you can survive with just the head - death only when head HP <= 0
            return false;
        }
        
        function updateEnemyProjectiles(dt) {
            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const p = enemyProjectiles[i];
                p.x += p.vx * dt * 0.2; p.y += p.vy * dt * 0.2; p.life -= dt;
                
                // Check hit on player (skip if invincible, same team, or reduced damage during grace)
                if (!(teamMode && p.owner && p.owner.team === playerTeam))
                if (invincibleTimer <= 0) {
                    for (const seg of snake) {
                        const sx = seg.x * GRID + GRID/2, sy = seg.y * GRID + GRID/2;
                        const dist = Math.sqrt((p.x - sx)**2 + (p.y - sy)**2);
                        if (dist < p.size + GRID/2) {
                            // Reduced damage during 2 second grace period
                            const dmg = invincibleTimer > -2000 ? p.damage * 0.3 : p.damage;
                            seg.hp -= dmg; p.life = 0; haptic('medium');
                            particles.push({ x: p.x, y: p.y, vx: 0, vy: 0, life: 10, color: '#f00' });
                            break;
                        }
                    }
                }
                
                // Check hit on other enemies (not the owner)
                if (p.life > 0) {
                    for (const e of enemies) {
                        if (e === p.owner || !e.segments) continue;
                        if (teamMode && p.owner && e.team === p.owner.team) continue; // Same team
                        for (const seg of e.segments) {
                            const sx = seg.x * GRID + GRID/2, sy = seg.y * GRID + GRID/2;
                            const dist = Math.sqrt((p.x - sx)**2 + (p.y - sy)**2);
                            if (dist < p.size + GRID/2) {
                                seg.hp -= p.damage; p.life = 0;
                                particles.push({ x: p.x, y: p.y, vx: 0, vy: 0, life: 10, color: '#ff0' });
                                break;
                            }
                        }
                        if (p.life <= 0) break;
                    }
                }
                
                if (p.life <= 0) enemyProjectiles.splice(i, 1);
            }
        }
        
        function updateProjectiles(dt) {
            // Combine enemies + other players into one target list
            const allTargets = [...enemies];
            if (Multiplayer.connected) {
                for (const [playerId, op] of Multiplayer.otherPlayers) {
                    if (op.segments && op.segments.length > 0) {
                        allTargets.push({
                            segments: op.segments.map(s => ({ x: s.x, y: s.y, hp: 999, maxHp: 999 })),
                            color: op.color,
                            isPlayer: true,
                            team: teamMode ? "blue" : null, // All human players on blue in team mode
                            playerId: playerId
                        });
                    }
                }
            }
            
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.x += p.vx * dt * 0.25; p.y += p.vy * dt * 0.25; p.life -= dt;
                
                // Hit any target (enemies or players)
                outer: for (const e of allTargets) {
                    // Skip same team in team mode
                    if (teamMode && e.team === playerTeam) continue;
                    if (!e.segments) continue;
                    for (const seg of e.segments) {
                        const sx = seg.x * GRID + GRID/2, sy = seg.y * GRID + GRID/2;
                        const dist = Math.sqrt((p.x - sx)**2 + (p.y - sy)**2);
                        if (dist < GRID/2 + p.size) {
                            p.life = 0;
                            particles.push({ x: p.x, y: p.y, vx: (Math.random()-0.5)*2, vy: (Math.random()-0.5)*2, life: 10, color: e.color || '#fff' });
                            
                            if (e.isPlayer) {
                                // Hit another player
                                score += 10;
                                haptic('light');
                                // sounds disabled
                                Multiplayer.send({ type: 'hit', targetId: e.playerId, damage: p.damage });
                            } else {
                                // Hit enemy AI
                                seg.hp -= p.damage;
                                // sounds disabled
                            }
                            break outer;
                        }
                    }
                }
                
                if (p.life <= 0) projectiles.splice(i, 1);
            }
        }
        
        function fireGuns(time) {
            if (!isAiming) return;
            let fired = false;
            for (let i = 0; i < snake.length; i++) {
                const seg = snake[i], type = seg.type;
                if (time - seg.lastFired < type.fireRate) continue;
                seg.lastFired = time;
                const cx = seg.x * GRID + GRID/2, cy = seg.y * GRID + GRID/2;
                if (type.aoe) {
                    for (const e of enemies) {
                        for (const seg of e.segments) {
                            const sx = seg.x * GRID + GRID/2, sy = seg.y * GRID + GRID/2;
                            const dist = Math.sqrt((sx - cx)**2 + (sy - cy)**2);
                            if (dist < type.range) seg.hp -= type.damage;
                        }
                    }
                    particles.push({ x: cx, y: cy, vx: 0, vy: 0, life: 15, color: type.color, isAoe: true, radius: 10 });
                } else if (type.spread) {
                    for (let p = 0; p < type.pellets; p++) {
                        const spread = (Math.random() - 0.5) * type.spread * 2;
                        const angle = aimAngle + spread;
                        projectiles.push({ x: cx, y: cy, vx: Math.cos(angle)*6, vy: Math.sin(angle)*6, damage: type.damage, size: 3, color: type.color, life: 300 });
                    }
                } else {
                    const size = type.size || 4;
                    projectiles.push({ x: cx, y: cy, vx: Math.cos(aimAngle)*7, vy: Math.sin(aimAngle)*7, damage: type.damage, size, color: type.color, life: 400 });
                }
                fired = true;
            }
            
        }
        
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx; p.y += p.vy; p.vx *= 0.92; p.vy *= 0.92; p.life--;
                if (p.isAoe) p.radius += 5;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }
        
        function drawLeaderArrow() {
            if (!snake[0]) return;
            
            // Find the biggest snake (not us)
            let leader = null;
            let maxLen = snake.length;
            
            // Check AI enemies
            for (const e of enemies) {
                if (e.segments && e.segments.length > maxLen) {
                    maxLen = e.segments.length;
                    leader = { x: e.segments[0].x, y: e.segments[0].y, name: 'ALPHA', len: e.segments.length, color: e.color };
                }
            }
            
            // Check other players
            if (Multiplayer.connected) {
                for (const [pid, op] of Multiplayer.otherPlayers) {
                    if (op.segments && op.segments.length > maxLen) {
                        maxLen = op.segments.length;
                        leader = { x: op.segments[0].x, y: op.segments[0].y, name: op.name, len: op.segments.length, color: op.color };
                    }
                }
            }
            
            if (!leader) return; // We're the biggest!
            
            // Calculate angle from player to leader
            const px = snake[0].x * GRID + GRID/2;
            const py = snake[0].y * GRID + GRID/2;
            const lx = leader.x * GRID + GRID/2;
            const ly = leader.y * GRID + GRID/2;
            const angle = Math.atan2(ly - py, lx - px);
            const dist = Math.sqrt((lx-px)**2 + (ly-py)**2);
            
            // Only show if leader is off-screen (far away)
            if (dist < 300) return;
            
            // Draw arrow at edge of view pointing to leader
            const arrowDist = 120;
            const ax = px + Math.cos(angle) * arrowDist;
            const ay = py + Math.sin(angle) * arrowDist;
            
            ctx.save();
            ctx.translate(ax, ay);
            ctx.rotate(angle);
            
            // Pulsing glow
            const pulse = 0.7 + Math.sin(Date.now() / 200) * 0.3;
            ctx.globalAlpha = pulse;
            
            // Arrow shape
            ctx.fillStyle = '#ff0';
            ctx.beginPath();
            ctx.moveTo(15, 0);
            ctx.lineTo(-8, -10);
            ctx.lineTo(-8, 10);
            ctx.closePath();
            ctx.fill();
            
            // Crown icon
            ctx.fillStyle = '#ff0';
            ctx.font = '10px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText('üëë', -20, 4);
            
            ctx.restore();
            
            // Show leader name + length near arrow
            ctx.save();
            ctx.fillStyle = '#ff0';
            ctx.font = '6px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.globalAlpha = pulse;
            ctx.fillText(leader.name + ' (' + leader.len + ')', ax, ay + 20);
            ctx.restore();
        }
        
        function updateWaves(time, dt) {
            if (waveDelay > 0) { waveDelay -= dt; return; }
            
            // Update power-up timers
            if (invincibleTimer > 0) invincibleTimer -= dt;
            if (speedTimer > 0) speedTimer -= dt; if (trailBoostTimer > 0) trailBoostTimer -= dt;
            if (magnetTimer > 0) magnetTimer -= dt;
            
            // Magnet effect - pull pickups toward player
            if (magnetTimer > 0 && snake.length > 0) {
                const head = snake[0];
                const hx = head.x * GRID + GRID/2;
                const hy = head.y * GRID + GRID/2;
                for (const p of pickups) {
                    const dx = hx - p.x;
                    const dy = hy - p.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 200 && dist > 5) { // Pull range
                        const pull = 3; // Pull strength
                        p.x += (dx / dist) * pull;
                        p.y += (dy / dist) * pull;
                    }
                }
            }
            
            // Maintain population - slither.io style continuous spawning
            const targetPopulation = 80 + Math.floor(snake.length / 2); // More enemies as player grows
            const spawnRate = 1000; // Spawn every second if needed
            
            // Spawn new snakes to maintain population
            if (enemies.length < targetPopulation && time - spawnTimer > spawnRate) {
                // Spawn size varies - some small, some medium, occasionally big
                const sizes = [2, 2, 2, 3, 3, 3, 4, 4, 5, 6, 7, 8];
                const size = sizes[Math.floor(Math.random() * sizes.length)];
                spawnEnemy();
                spawnTimer = time;
            }
            
            // Spawn pickups to keep the world interesting
            if (pickups.length < 120 && Math.random() < 0.05) {
                const px = Math.floor(Math.random() * WORLD_COLS) * GRID + GRID/2;
                const py = Math.floor(Math.random() * WORLD_ROWS) * GRID + GRID/2;
                pickups.push({
                    x: px, y: py,
                    type: GUNS[GUN_NAMES[Math.floor(Math.random() * GUN_NAMES.length)]],
                    isHealth: Math.random() < 0.1,
                    healAmount: 40,
                    bob: Math.random() * Math.PI * 2
                });
            }
            
            // Difficulty scales with player size
            wave = 3 + Math.floor(snake.length / 4);
        }
        
        function updateCamera() {
            let followTarget = null;
            let followLength = 0;

            // SPECTATOR MODE: When dead, PRIORITIZE real players, fall back to AI
            if (gameState === 'dead') {
                let bestScore = 0;
                let newMVP = null;
                const now = Date.now();
                let hasRealPlayer = false;

                // Clear old MVP status
                for (const e of enemies) if (e) e.isMVP = false;

                // FIRST: Check real multiplayer players (PRIORITY)
                if (Multiplayer.connected) {
                    for (const [pid, op] of Multiplayer.otherPlayers) {
                        if (!op.segments || op.segments.length === 0) continue;
                        hasRealPlayer = true;
                        // Real players get 10x score bonus to always be prioritized
                        const lengthScore = op.segments.length * 20;
                        if (lengthScore > bestScore) {
                            bestScore = lengthScore;
                            followTarget = { x: op.segments[0].x, y: op.segments[0].y };
                            followLength = op.segments.length;
                            newMVP = op;
                        }
                    }
                }

                // SECOND: If no real players, check AI enemies
                if (!hasRealPlayer) {
                    for (let i = 0; i < enemies.length; i++) {
                        const e = enemies[i];
                        if (!e || !e.segments || e.segments.length === 0) continue;

                        // Decay recentPoints over time (halves every 5 seconds)
                        const timeSincePoint = now - (e.lastPointTime || 0);
                        const decayFactor = Math.pow(0.5, timeSincePoint / 5000);
                        const decayedPoints = (e.recentPoints || 0) * decayFactor;

                        // Interest score = length weight + recent activity weight
                        const lengthScore = e.segments.length * 2;
                        const activityScore = decayedPoints * 3;
                        const totalScore = lengthScore + activityScore;

                        if (totalScore > bestScore) {
                            bestScore = totalScore;
                            followTarget = { x: e.segments[0].x, y: e.segments[0].y };
                            followLength = e.segments.length;
                            newMVP = e;
                        }
                    }
                }

                // Mark MVP and update tracking
                if (newMVP && newMVP !== currentMVP) {
                    currentMVP = newMVP;
                    mvpScore = bestScore;
                    if (newMVP.isMVP !== undefined) newMVP.isMVP = true;
                }
            }

            // Dev mode override - follow selected real player
            const devTarget = devMode.getFollowTarget();
            if (devTarget) {
                followTarget = { x: devTarget.x, y: devTarget.y };
                followLength = devTarget.length;
            }

            // When spectating, use leader; otherwise use player
            const head = (gameState === 'dead' && followTarget) || devTarget ? followTarget : snake[0];
            const len = (gameState === 'dead' && followTarget) || devTarget ? followLength : snake.length;
            
            if (!head || head.x === undefined) return; // Safety check

            targetCameraX = head.x * GRID + GRID/2 - canvas.width/2/cameraZoom;
            targetCameraY = head.y * GRID + GRID/2 - canvas.height/2/cameraZoom;
            const minZoom = 0.6, maxZoom = 2.0, zoomPerSegment = 0.025;
            targetZoom = Math.max(minZoom, maxZoom - (len - 2) * zoomPerSegment);
            cameraX += (targetCameraX - cameraX) * 0.1;
            cameraY += (targetCameraY - cameraY) * 0.1;
            cameraZoom += (targetZoom - cameraZoom) * 0.02;
            const viewWidth = canvas.width / cameraZoom, viewHeight = canvas.height / cameraZoom;
            cameraX = Math.max(0, Math.min(WORLD_WIDTH - viewWidth, cameraX));
            cameraY = Math.max(0, Math.min(WORLD_HEIGHT - viewHeight, cameraY));
        }
        
        function updateLeaderboard() {
            const entries = [{ name: playerName || 'YOU', length: snake.length, isPlayer: true }];
            
            // Add other multiplayer players
            if (Multiplayer.connected) {
                for (const [pid, op] of Multiplayer.otherPlayers) {
                    if (op.segments && op.segments.length > 0) {
                        entries.push({ 
                            name: op.name || 'Player', 
                            length: op.segments.length, 
                            isPlayer: false, 
                            isMultiplayer: true,
                            color: op.color 
                        });
                    }
                }
            }
            
            // Add AI enemies
            for (const e of enemies) {
                if (e.segments.length > 0) {
                    entries.push({ 
                        name: e.name || 'Train', 
                        length: e.segments.length, 
                        isPlayer: false, 
                        color: e.color, 
                        isNeural: e.personality.neural,
                        isMVP: e.isMVP && gameState === 'dead'
                    });
                }
            }
            entries.sort((a, b) => b.length - a.length);
            const top = entries.slice(0, 12);
            document.getElementById('leaderboardEntries').innerHTML = top.map((e, i) => {
                const mvpIcon = e.isMVP ? 'üìπ ' : '';
                return `<div class="leaderboard-entry ${e.isPlayer ? 'player' : ''} ${e.isNeural ? 'neural' : ''} ${e.isMultiplayer ? 'multiplayer' : ''} ${e.isMVP ? 'mvp' : ''}" style="${!e.isPlayer ? 'color:' + (e.color && /^#[0-9a-f]{3,6}$/i.test(e.color) ? e.color : '#fff') : ''}"><span class="leaderboard-rank">${i + 1}.</span><span class="leaderboard-name">${mvpIcon}${esc(e.name)}</span><span class="leaderboard-score">${e.length}</span></div>`;
            }).join('');
        }
        
        function updateHUD() {
            document.getElementById('snakeLen').textContent = snake.length;
            // Calculate rank
            let rank = 1;
            for (const e of enemies) {
                if (e.segments && e.segments.length > snake.length) rank++;
            }
            document.getElementById('waveNum').textContent = '#' + rank;

            // Show active power-ups or score
            let powerupStatus = [];
            if (invincibleTimer > 0) powerupStatus.push('üõ°Ô∏è' + Math.ceil(invincibleTimer / 1000));
            if (speedTimer > 0) powerupStatus.push('üöÄ' + Math.ceil(speedTimer / 1000));
            if (trailBoostTimer > 0) powerupStatus.push("‚ö°DRAFTING"); if (isLeader) powerupStatus.push("üëëLEADER"); if (teamMode) powerupStatus.push("üë•TEAM"); if (magnetTimer > 0) powerupStatus.push('üß≤' + Math.ceil(magnetTimer / 1000));
            
            if (powerupStatus.length > 0) {
                document.getElementById('score').textContent = powerupStatus.join(' ');
            } else {
                document.getElementById('score').textContent = score;
            }

            // Pattern tracking display
            const stats = patternTracker.getStats();
            if (stats.totalTurns >= 5) {
                const arrow = stats.leftBias > 55 ? '‚Üê' : stats.leftBias < 45 ? '‚Üí' : '‚Üî';
                document.getElementById('patternHud').textContent = arrow + stats.leftBias + '%';
            } else {
                document.getElementById('patternHud').textContent = '...';
            }

            // Track best stats
            if (rank < bestRank) bestRank = rank;
            if (snake.length > maxLength) maxLength = snake.length;
        }
        
        function drawGrid() {
            ctx.strokeStyle = '#150d20'; ctx.lineWidth = 1;
            const startX = Math.floor(cameraX / GRID) * GRID, startY = Math.floor(cameraY / GRID) * GRID;
            const endX = Math.min(WORLD_WIDTH, cameraX + canvas.width/cameraZoom + GRID);
            const endY = Math.min(WORLD_HEIGHT, cameraY + canvas.height/cameraZoom + GRID);
            for (let x = startX; x <= endX; x += GRID) { ctx.beginPath(); ctx.moveTo(x, startY); ctx.lineTo(x, endY); ctx.stroke(); }
            for (let y = startY; y <= endY; y += GRID) { ctx.beginPath(); ctx.moveTo(startX, y); ctx.lineTo(endX, y); ctx.stroke(); }
            ctx.strokeStyle = '#402040'; ctx.lineWidth = 3; ctx.strokeRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);
        }
        
        function drawSnake() {
            // Update train frame for wheel animation
            for(let i=1;i<tronTrail.length;i++){const t0=tronTrail[i-1],t1=tronTrail[i];if(Math.abs(t1.x-t0.x)>2||Math.abs(t1.y-t0.y)>2)continue;ctx.strokeStyle="rgba(255,215,0,"+(i/tronTrail.length)*0.7+")";ctx.lineWidth=2+(i/tronTrail.length)*3;ctx.shadowColor="#ff0";ctx.shadowBlur=8;ctx.beginPath();ctx.moveTo(t0.x*GRID+GRID/2,t0.y*GRID+GRID/2);ctx.lineTo(t1.x*GRID+GRID/2,t1.y*GRID+GRID/2);ctx.stroke();}ctx.shadowBlur=0;
            trainFrame++;

            // Draw smoke behind everything
            drawSmoke(ctx);

            // Invincibility shield effect
            if (invincibleTimer > 0) {
                const head = snake[0];
                const hx = head.x * GRID + GRID/2, hy = head.y * GRID + GRID/2;
                const pulseSize = 25 + Math.sin(Date.now() / 100) * 5;
                const alpha = 0.3 + Math.sin(Date.now() / 150) * 0.2;
                ctx.strokeStyle = `rgba(100, 200, 255, ${alpha})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(hx, hy, pulseSize, 0, Math.PI * 2);
                ctx.stroke();
                ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.5})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(hx, hy, pulseSize - 5, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Get direction for each segment (use next segment or dir for head)
            function getSegDir(i) {
                if (i === 0) return dir;
                const curr = snake[i];
                const prev = snake[i - 1];
                const dx = prev.x - curr.x;
                const dy = prev.y - curr.y;
                if (dx > 0 || (dx < -1)) return DIR.RIGHT; // Handle wrap
                if (dx < 0 || (dx > 1)) return DIR.LEFT;
                if (dy > 0 || (dy < -1)) return DIR.DOWN;
                if (dy < 0 || (dy > 1)) return DIR.UP;
                return dir;
            }

            // Draw from back to front
            for (let i = snake.length - 1; i >= 0; i--) {
                const seg = snake[i];
                const x = seg.x * GRID + GRID/2, y = seg.y * GRID + GRID/2;
                const segDir = getSegDir(i);

                // Slight bounce based on frame
                const bounce = Math.sin(trainFrame * 0.3 + i * 0.5) * 1;
                const drawY = y + bounce;

                ctx.shadowColor = invincibleTimer > 0 ? '#5ff' : '#000';
                ctx.shadowBlur = invincibleTimer > 0 ? 15 : 5;

                if (i === 0) {
                    // LOCOMOTIVE HEAD
                    drawLocomotive(ctx, x, drawY, GRID, segDir, trainFrame);

                    // Spawn smoke occasionally
                    if (trainFrame % 8 === 0) {
                        spawnSmoke(x, drawY, segDir);
                    }
                } else {
                    // BOXCARS (gun cars)
                    drawBoxcar(ctx, x, drawY, GRID, segDir, seg.type, trainFrame, seg.hp, seg.maxHp);
                }

                ctx.shadowBlur = 0;

                // Health bar for damaged cars
                if (i > 0 && seg.hp !== undefined && seg.maxHp > 0 && seg.hp < seg.maxHp) {
                    const bw = 16, bh = 3;
                    ctx.fillStyle = '#300';
                    ctx.fillRect(x - bw/2, y - GRID/2 - 10, bw, bh);
                    const pct = Math.max(0, Math.min(1, seg.hp / seg.maxHp));
                    ctx.fillStyle = pct > 0.5 ? '#0f0' : pct > 0.25 ? '#ff0' : '#f00';
                    ctx.fillRect(x - bw/2, y - GRID/2 - 10, bw * pct, bh);
                }
            }

            // Update smoke particles
            updateSmoke();

            // Draw player name tag above head
            if (snake.length > 0 && Multiplayer.username) {
                const head = snake[0];
                ctx.save();
                ctx.fillStyle = '#0f0';
                ctx.font = '8px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#000';
                ctx.shadowBlur = 3;
                ctx.fillText(Multiplayer.username, head.x * GRID + GRID/2, head.y * GRID - 8);
                ctx.restore();
            }
        }
        
        function drawAimLine() {
            const head = snake[0];
            const hx = head.x * GRID + GRID/2, hy = head.y * GRID + GRID/2;

            // Aim line is more visible when actively aiming (touch hold or mouse)
            const isActive = isHolding || isMouseAiming;
            ctx.strokeStyle = isActive ? '#0f0' : '#0f04';
            ctx.lineWidth = isActive ? 3 : 2;
            ctx.setLineDash(isActive ? [] : [8, 8]);
            ctx.beginPath();
            ctx.moveTo(hx, hy);
            ctx.lineTo(hx + Math.cos(aimAngle) * 100, hy + Math.sin(aimAngle) * 100);
            ctx.stroke();
            ctx.setLineDash([]);

            // Reticle at aim point
            if (isActive) {
                const rx = hx + Math.cos(aimAngle) * 80, ry = hy + Math.sin(aimAngle) * 80;
                ctx.strokeStyle = '#0f0';
                ctx.lineWidth = 2;
                // Crosshair
                ctx.beginPath();
                ctx.moveTo(rx - 10, ry); ctx.lineTo(rx - 4, ry);
                ctx.moveTo(rx + 4, ry); ctx.lineTo(rx + 10, ry);
                ctx.moveTo(rx, ry - 10); ctx.lineTo(rx, ry - 4);
                ctx.moveTo(rx, ry + 4); ctx.lineTo(rx, ry + 10);
                ctx.stroke();
                // Circle
                ctx.beginPath();
                ctx.arc(rx, ry, 12, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        
        // Enemy train colors based on type
        const ENEMY_PALETTES = {
            normal: { body: '#4a5568', light: '#718096', dark: '#2d3748' },
            hunter: { body: '#9b2c2c', light: '#e53e3e', dark: '#742a2a' },
            alpha: { body: '#d69e2e', light: '#ecc94b', dark: '#b7791f' },
            neural: { body: '#805ad5', light: '#b794f4', dark: '#553c9a' }
        };

        function drawEnemyLocomotive(ctx, x, y, size, direction, frame, color, isNeural) {
            // CHUNKY SIMPLE ENEMY TRAIN - same style as player
            const palette = isNeural ? ENEMY_PALETTES.neural :
                           color === '#f55' ? ENEMY_PALETTES.hunter :
                           color === '#ff0' ? ENEMY_PALETTES.alpha : ENEMY_PALETTES.normal;

            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(Math.atan2(direction.y, direction.x));

            const s = size * 0.5;

            // Main body - colored block
            ctx.fillStyle = palette.body;
            ctx.fillRect(-s, -s*0.7, s*1.8, s*1.4);

            // Cabin (taller back section)
            ctx.fillStyle = palette.light;
            ctx.fillRect(-s*1.1, -s, s*0.5, s*2);

            // Smokestack
            ctx.fillStyle = palette.dark;
            ctx.fillRect(s*0.2, -s*1.2, s*0.4, s*0.5);

            // Headlight - enemy = red/magenta
            ctx.fillStyle = isNeural ? '#f0f' : '#f44';
            ctx.fillRect(s*0.7, -s*0.2, s*0.3, s*0.4);

            // Front
            ctx.fillStyle = palette.dark;
            ctx.fillRect(s*0.8, -s*0.5, s*0.3, s*1);

            // Thick outline
            ctx.strokeStyle = palette.dark;
            ctx.lineWidth = 2;
            ctx.strokeRect(-s*1.1, -s, s*2.2, s*2);

            // Neural glow ring
            if (isNeural) {
                ctx.strokeStyle = '#f0f';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, s*1.3, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Wheels
            ctx.fillStyle = '#111';
            ctx.fillRect(-s*0.8, s*0.5, s*0.4, s*0.3);
            ctx.fillRect(s*0.2, s*0.5, s*0.4, s*0.3);
            ctx.fillRect(-s*0.8, -s*0.8, s*0.4, s*0.3);
            ctx.fillRect(s*0.2, -s*0.8, s*0.4, s*0.3);

            ctx.restore();
        }

        function drawEnemyBoxcar(ctx, x, y, size, direction, frame, color, hp, maxHp) {
            // CHUNKY SIMPLE - matches player boxcar style
            const isHunter = color === '#f55';
            const isAlpha = color === '#ff0';
            const palette = isHunter ? ENEMY_PALETTES.hunter :
                           isAlpha ? ENEMY_PALETTES.alpha : ENEMY_PALETTES.normal;

            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(Math.atan2(direction.y, direction.x));

            const s = size * 0.5;

            // Damage flash
            let bodyColor = palette.body;
            if (hp < maxHp * 0.25 && Math.sin(frame * 0.5) > 0) bodyColor = '#600';
            else if (hp < maxHp * 0.5 && Math.sin(frame * 0.3) > 0.5) bodyColor = '#880';

            // Simple boxcar rectangle
            ctx.fillStyle = bodyColor;
            ctx.fillRect(-s*0.8, -s*0.6, s*1.6, s*1.2);

            // Thick outline
            ctx.strokeStyle = palette.dark;
            ctx.lineWidth = 2;
            ctx.strokeRect(-s*0.8, -s*0.6, s*1.6, s*1.2);

            // Wheels
            ctx.fillStyle = '#111';
            ctx.fillRect(-s*0.6, s*0.4, s*0.3, s*0.25);
            ctx.fillRect(s*0.3, s*0.4, s*0.3, s*0.25);
            ctx.fillRect(-s*0.6, -s*0.65, s*0.3, s*0.25);
            ctx.fillRect(s*0.3, -s*0.65, s*0.3, s*0.25);

            ctx.restore();
        }

        function drawEnemies() {
            for (const e of enemies) {
                if (e.segments.length === 0) continue;

                // Aim line
                if (e.aimX !== undefined) {
                    ctx.strokeStyle = e.color + '44'; ctx.lineWidth = 2; ctx.setLineDash([4, 4]);
                    ctx.beginPath(); ctx.moveTo(e.aimX, e.aimY); ctx.lineTo(e.aimX + Math.cos(e.aimAngle) * 80, e.aimY + Math.sin(e.aimAngle) * 80); ctx.stroke();
                    ctx.setLineDash([]);
                }

                // Get direction for each segment
                function getEnemySegDir(i) {
                    if (i === 0) return e.dir;
                    const curr = e.segments[i];
                    const prev = e.segments[i - 1];
                    const dx = prev.x - curr.x;
                    const dy = prev.y - curr.y;
                    if (dx > 0 || dx < -1) return DIR.RIGHT;
                    if (dx < 0 || dx > 1) return DIR.LEFT;
                    if (dy > 0 || dy < -1) return DIR.DOWN;
                    if (dy < 0 || dy > 1) return DIR.UP;
                    return e.dir;
                }

                // Draw from back to front
                for (let i = e.segments.length - 1; i >= 0; i--) {
                    const seg = e.segments[i];
                    const x = seg.x * GRID + GRID/2, y = seg.y * GRID + GRID/2;
                    const segDir = getEnemySegDir(i);

                    // Slight bounce
                    const bounce = Math.sin(trainFrame * 0.3 + i * 0.5) * 1;
                    const drawY = y + bounce;

                    ctx.shadowColor = e.color;
                    ctx.shadowBlur = 5;

                    if (i === 0) {
                        // LOCOMOTIVE
                        drawEnemyLocomotive(ctx, x, drawY, GRID, segDir, trainFrame, e.color, e.personality.neural);
                    } else {
                        // BOXCAR
                        drawEnemyBoxcar(ctx, x, drawY, GRID, segDir, trainFrame, e.color, seg.hp, seg.maxHp);
                    }

                    ctx.shadowBlur = 0;

                    // Health bar
                    if (i > 0 && seg.hp !== undefined && seg.maxHp > 0 && seg.hp < seg.maxHp) {
                        const bw = 10;
                        const pct = Math.max(0, Math.min(1, seg.hp / seg.maxHp));
                        ctx.fillStyle = '#400';
                        ctx.fillRect(x - bw/2, y - GRID/2 - 8, bw, 2);
                        ctx.fillStyle = '#f44';
                        ctx.fillRect(x - bw/2, y - GRID/2 - 8, bw * pct, 2);
                    }
                }

                // Length indicator
                if (e.segments.length >= 3) {
                    const head = e.segments[0];
                    ctx.fillStyle = '#fff';
                    ctx.font = '8px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(e.segments.length.toString(), head.x * GRID + GRID/2, head.y * GRID - 12);
                }

                // Danger indicator - skull for enemies that killed player
                const enemyRep = reputationSystem.enemies.get(e.id);
                if (enemyRep && enemyRep.isDangerous) {
                    const head = e.segments[0];
                    const hx = head.x * GRID + GRID/2 + 12;
                    const hy = head.y * GRID - 8;
                    ctx.font = '10px monospace';
                    ctx.fillStyle = '#f55';
                    ctx.shadowColor = '#f00';
                    ctx.shadowBlur = 8;
                    ctx.fillText('‚ò†', hx, hy);
                    ctx.shadowBlur = 0;
                }

                // Pack leader indicator - star for most successful enemy
                if (enemyRep && enemyRep.isPackLeader) {
                    const head = e.segments[0];
                    const hx = head.x * GRID + GRID/2 - 12;
                    const hy = head.y * GRID - 8;
                    ctx.font = '10px monospace';
                    ctx.fillStyle = '#ff0';
                    ctx.shadowColor = '#ff0';
                    ctx.shadowBlur = 8;
                    ctx.fillText('‚òÖ', hx, hy);
                    ctx.shadowBlur = 0;
                }

                // MVP indicator - crown for the most interesting player
                if (e.isMVP && gameState === 'dead') {
                    const head = e.segments[0];
                    const hx = head.x * GRID + GRID/2;
                    const hy = head.y * GRID - 20;
                    ctx.fillStyle = '#ff0';
                    ctx.shadowColor = '#ff0';
                    ctx.shadowBlur = 10;
                    ctx.font = 'bold 12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('‚òÖ MVP ‚òÖ', hx, hy);
                    ctx.shadowBlur = 0;
                }
            }
        }
        
        function drawProjectiles() {
            for (const p of projectiles) { ctx.shadowColor = p.color; ctx.shadowBlur = 8; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); }
            for (const p of enemyProjectiles) { ctx.shadowColor = p.color; ctx.shadowBlur = 10; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); }
            ctx.shadowBlur = 0;
        }
        
        function drawPickups(time) {
            for (const p of pickups) {
                const x = p.x, y = p.y + Math.sin(time / 150 + p.bob) * 3;
                ctx.shadowColor = p.type.color; ctx.shadowBlur = 15;
                
                if (p.isPowerup) {
                    // Power-ups: big pulsing icon with glow
                    const pulse = 1 + Math.sin(time / 100) * 0.2;
                    const radius = 14 * pulse;
                    
                    // Outer glow ring
                    ctx.strokeStyle = p.type.color + '44';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(x, y, radius + 8, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Inner filled circle
                    ctx.fillStyle = p.type.color;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Icon text
                    ctx.fillStyle = '#000';
                    ctx.font = '12px "Press Start 2P"';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(p.type.icon, x, y);
                } else if (p.isHealth) {
                    ctx.fillStyle = p.type.color;
                    ctx.fillRect(x - 2, y - 6, 4, 12);
                    ctx.fillRect(x - 6, y - 2, 12, 4);
                } else {
                    ctx.strokeStyle = p.type.color + '66';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, 8 + Math.sin(time / 200 + p.bob) * 2, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.fillStyle = p.type.color;
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.shadowBlur = 0;
            }
        }
        
        function drawParticles() {
            for (const p of particles) {
                if (p.isAoe) {
                    const alpha = Math.floor((p.life / 15) * 200).toString(16).padStart(2, '0');
                    ctx.strokeStyle = p.color + alpha; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); ctx.stroke();
                } else { ctx.globalAlpha = p.life / 30; ctx.fillStyle = p.color; ctx.fillRect(p.x - 2, p.y - 2, 4, 4); ctx.globalAlpha = 1; }
            }
        }
        
        function drawScanlines() { ctx.fillStyle = '#0002'; for (let y = 0; y < canvas.height; y += 4) ctx.fillRect(0, y, canvas.width, 2); }

        function drawFogOfWar() {
            const head = snake[0];
            if (!head) return;

            // Player position in screen space
            const px = (head.x * GRID + GRID/2 - cameraX) * cameraZoom;
            const py = (head.y * GRID + GRID/2 - cameraY) * cameraZoom;

            // Visibility radius scales with zoom
            const baseRadius = 250;
            const radius = baseRadius * cameraZoom;

            // Create radial gradient for fog
            const gradient = ctx.createRadialGradient(px, py, radius * 0.6, px, py, radius);
            gradient.addColorStop(0, 'rgba(10, 6, 16, 0)');
            gradient.addColorStop(0.7, 'rgba(10, 6, 16, 0.3)');
            gradient.addColorStop(1, 'rgba(10, 6, 16, 0.85)');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        function gameLoop(time) {
            try {
                const dt = time - lastTime; lastTime = time;
                ctx.fillStyle = '#0a0610'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                if (gameState === 'playing') {
                    moveTimer += dt;
                    let selfCollision = false;
                    if (moveTimer >= MOVE_INTERVAL) { selfCollision = updateSnake(); moveTimer = 0; }
                    if (selfCollision) {
                        console.log('RESPAWN: Self collision');
                        haptic('death');
                        respawn();
                    }
                    const gameOver = updateEnemies(dt);
                    if (gameOver) {
                        console.log('RESPAWN:', deathReason || 'Destroyed');
                        haptic('death');
                        respawn();
                    }
                    updateEnemyProjectiles(dt); updateProjectiles(dt); fireGuns(time); updateParticles();
                    updateWaves(time, dt); updateCamera(); updateHUD(); updateLeaderboard();
                    ruleEngine.update(); // G√∂del layer tick

                    // Strategy classifier - learns player behavior and counters it
                    if (snake[0]) {
                        let nearestDist = 999;
                        for (const e of enemies) {
                            if (e.segments && e.segments[0]) {
                                const d = Math.abs(e.segments[0].x - snake[0].x) + Math.abs(e.segments[0].y - snake[0].y);
                                if (d < nearestDist) nearestDist = d;
                            }
                        }
                        strategyClassifier.update({ x: snake[0].x, y: snake[0].y }, nearestDist);

                        // Reclassify every ~2 seconds (120 frames at 60fps)
                        if (strategyClassifier.totalTicks % 120 === 0 && strategyClassifier.totalTicks > 60) {
                            strategyClassifier.classify();
                        }
                    }
                }
                
                // SPECTATOR MODE: Keep updating when dead so player can watch
                if (gameState === 'dead') {
                    updateEnemies(dt);
                    updateEnemyProjectiles(dt);
                    updateParticles();
                    updateCamera();
                    updateLeaderboard();
                }
                
                ctx.save(); ctx.scale(cameraZoom, cameraZoom); ctx.translate(-cameraX, -cameraY);
                drawGrid(); drawPickups(time); drawEnemies(); Multiplayer.drawOtherPlayers(ctx); drawSnake(); drawAimLine(); drawProjectiles(); drawParticles(); drawLeaderArrow();
                ctx.restore(); drawScanlines(); drawPatternFlash(ctx); devMode.draw(ctx);
            } catch (err) { console.error('Game loop error:', err); }
            requestAnimationFrame(gameLoop);
        }
        
        // Controls
        let activeTouch = null, touchStartX = 0, touchStartY = 0, lastSwipeX = 0, lastSwipeY = 0, isHolding = false, holdStartTime = 0;
        const SWIPE_THRESHOLD = 30, HOLD_DELAY = 150;
        
        function setDirection(newDir) {
            if (newDir === DIR.UP && dir === DIR.DOWN) return;
            if (newDir === DIR.DOWN && dir === DIR.UP) return;
            if (newDir === DIR.LEFT && dir === DIR.RIGHT) return;
            if (newDir === DIR.RIGHT && dir === DIR.LEFT) return;

            // Track pattern: find nearest threat distance
            let nearestThreat = 999;
            if (snake.length > 0) {
                const head = snake[0];
                for (const e of enemies) {
                    if (e.segments && e.segments.length > 0) {
                        const eh = e.segments[0];
                        const dist = Math.abs(eh.x - head.x) + Math.abs(eh.y - head.y);
                        if (dist < nearestThreat) nearestThreat = dist;
                    }
                }
            }
            patternTracker.recordTurn(dir, newDir, nearestThreat);

            nextDir = newDir;
            if (!isHolding) {
                if (newDir === DIR.UP) aimAngle = -Math.PI / 2;
                else if (newDir === DIR.DOWN) aimAngle = Math.PI / 2;
                else if (newDir === DIR.LEFT) aimAngle = Math.PI;
                else if (newDir === DIR.RIGHT) aimAngle = 0;
            }
            haptic('light');
        }
        
        document.addEventListener('touchstart', e => {
            const touch = e.changedTouches[0];
            // Check dev mode tap first
            if (devMode.handleTap(touch.clientX, touch.clientY)) {
                e.preventDefault();
                return;
            }
            if (gameState !== 'playing') return;
            e.preventDefault();
            activeTouch = touch.identifier; touchStartX = touch.clientX; touchStartY = touch.clientY;
            lastSwipeX = touch.clientX; lastSwipeY = touch.clientY;
            isHolding = false; holdStartTime = Date.now();
        }, { passive: false });
        
        document.addEventListener('touchmove', e => {
            if (gameState !== 'playing') return;
            e.preventDefault();
            for (const touch of e.changedTouches) {
                if (touch.identifier === activeTouch) {
                    const dx = touch.clientX - lastSwipeX, dy = touch.clientY - lastSwipeY;
                    const totalDx = touch.clientX - touchStartX, totalDy = touch.clientY - touchStartY;
                    const totalDist = Math.sqrt(totalDx * totalDx + totalDy * totalDy);
                    if (!isHolding && (Math.abs(dx) > SWIPE_THRESHOLD || Math.abs(dy) > SWIPE_THRESHOLD)) {
                        if (Math.abs(dx) > Math.abs(dy)) setDirection(dx > 0 ? DIR.RIGHT : DIR.LEFT);
                        else setDirection(dy > 0 ? DIR.DOWN : DIR.UP);
                        lastSwipeX = touch.clientX; lastSwipeY = touch.clientY;
                    }
                    if (Date.now() - holdStartTime > HOLD_DELAY && totalDist > 20) {
                        isHolding = true; isAiming = true;
                        aimAngle = Math.atan2(totalDy, totalDx);
                    }
                }
            }
        }, { passive: false });
        
        document.addEventListener('touchend', e => {
            for (const touch of e.changedTouches) {
                if (touch.identifier === activeTouch) {
                    activeTouch = null; isHolding = false;
                    if (dir === DIR.UP) aimAngle = -Math.PI / 2;
                    else if (dir === DIR.DOWN) aimAngle = Math.PI / 2;
                    else if (dir === DIR.LEFT) aimAngle = Math.PI;
                    else if (dir === DIR.RIGHT) aimAngle = 0;
                }
            }
        }, { passive: true });
        
        document.addEventListener('touchcancel', e => { activeTouch = null; isHolding = false; }, { passive: true });
        
        function updateAimAngle(touchX, touchY) {
            const head = snake[0];
            const hx = head.x * GRID + GRID/2, hy = head.y * GRID + GRID/2;
            aimAngle = Math.atan2(touchY - hy, touchX - hx);
        }
        
        // Initialize username inputs with saved value
        const savedName = localStorage.getItem('locomot_username') || '';
        document.getElementById('usernameInput').value = savedName;
        document.getElementById('usernameInputDeath').value = savedName;

        function startGame(isTeamMode) {
            teamMode = isTeamMode;
            const nameInput = document.getElementById('usernameInput').value;
            if (nameInput) Multiplayer.setUsername(nameInput);
            document.getElementById('startScreen').classList.add('hidden');
            // Initialize highlight recorder
            HighlightRecorder.init();
        }

        document.getElementById('startFFA').addEventListener('click', () => {
            startGame(false);
            init();
            gameState = 'playing';
            canvas.classList.add('playing');
            // Report join to server for player history
            devMode.reportJoin(Multiplayer.username || 'Anonymous', Multiplayer.playerId);
        });

        document.getElementById('startTeams').addEventListener('click', () => {
            startGame(true);
            init();
            gameState = 'playing';
            canvas.classList.add('playing');
            // Report join to server for player history
            devMode.reportJoin(Multiplayer.username || 'Anonymous', Multiplayer.playerId);
        });

        document.getElementById('usernameInputDeath').addEventListener('change', (e) => {
            if (e.target.value) Multiplayer.setUsername(e.target.value);
        });
        document.getElementById('pauseBtn').addEventListener('click', () => { if (gameState === 'playing') { gameState = 'paused'; canvas.classList.remove('playing'); document.getElementById('pauseScreen').classList.remove('hidden'); } });
        
        document.getElementById('debugBtn').addEventListener('click', () => {
            const debugInfo = {
                gameState,
                invincibleTimer,
                snakeLength: snake.length,
                snakeSegments: snake.map((s, i) => ({ index: i, x: s.x, y: s.y, hp: s.hp, maxHp: s.maxHp, type: s.type?.color })),
                nearbyEnemies: enemies.filter(e => {
                    if (!e.segments || e.segments.length === 0) return false;
                    const head = e.segments[0];
                    const dist = Math.abs(head.x - snake[0].x) + Math.abs(head.y - snake[0].y);
                    return dist < 15;
                }).map(e => ({
                    length: e.segments.length,
                    headPos: { x: e.segments[0].x, y: e.segments[0].y },
                    distToPlayer: Math.abs(e.segments[0].x - snake[0].x) + Math.abs(e.segments[0].y - snake[0].y),
                    color: e.color
                })),
                totalEnemies: enemies.length,
                projectilesNearby: enemyProjectiles.filter(p => {
                    const dist = Math.sqrt((p.x - snake[0].x * GRID) ** 2 + (p.y - snake[0].y * GRID) ** 2);
                    return dist < 200;
                }).length
            };
            const debugText = JSON.stringify(debugInfo, null, 2);
            navigator.clipboard.writeText(debugText).then(() => {
                alert('Debug info copied to clipboard!');
            }).catch(() => {
                console.log('DEBUG INFO:', debugText);
                alert('Check console for debug info');
            });
        });
        document.getElementById('resumeBtn').addEventListener('click', () => { document.getElementById('pauseScreen').classList.add('hidden'); gameState = 'playing'; canvas.classList.add('playing'); });
        document.getElementById('restartBtn').addEventListener('click', () => { doRespawn(); });
        document.getElementById('spectateBtn').addEventListener('click', () => {
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('spectatingLabel').style.display = 'block';
            // Create floating label that stays visible
            let floatingLabel = document.getElementById('floatingSpectateLabel');
            if (!floatingLabel) {
                floatingLabel = document.createElement('div');
                floatingLabel.id = 'floatingSpectateLabel';
                floatingLabel.style.cssText = 'position:fixed; top:20px; left:50%; transform:translateX(-50%); color:#5ff; font-size:14px; text-shadow:0 0 10px #5ff; z-index:200; pointer-events:none;';
                floatingLabel.innerHTML = '‚òÖ SPECTATING MVP ‚òÖ<br><span style="font-size:10px">Tap to respawn</span>';
                document.body.appendChild(floatingLabel);
            }
            floatingLabel.style.display = 'block';
            // Tap anywhere to respawn
            const respawnOnTap = () => {
                floatingLabel.style.display = 'none';
                doRespawn();
                document.removeEventListener('click', respawnOnTap);
            };
            setTimeout(() => document.addEventListener('click', respawnOnTap), 500);
        });
        
        document.getElementById('copyDeathBtn').addEventListener('click', () => {
            // Compact debug format
            const mp = Multiplayer;
            const ops = [];
            if (mp.connected) {
                for (const [id, p] of mp.otherPlayers) {
                    ops.push(p.name + ':' + (p.segments?.length || 0) + '@' + (p.segments?.[0]?.x || '?') + ',' + (p.segments?.[0]?.y || '?'));
                }
            }
            const compact = [
                'reason:' + (deathReason || '?'),
                'me:' + snake.length + '@' + (snake[0]?.x || '?') + ',' + (snake[0]?.y || '?'),
                'mp:' + (mp.connected ? 'Y' : 'N') + '/' + mp.otherPlayers.size + 'p',
                'players:[' + ops.join('|') + ']'
            ].join(' | ');
            
            navigator.clipboard.writeText(compact).then(() => {
                document.getElementById('copyDeathBtn').textContent = '‚úì COPIED!';
                setTimeout(() => {
                    document.getElementById('copyDeathBtn').textContent = 'üìã COPY DEBUG';
                }, 2000);
            }).catch(() => {
                alert(compact);
            });
        });
        
        document.getElementById('uploadCollectiveBtn').addEventListener('click', () => {
            const btn = document.getElementById('uploadCollectiveBtn');
            const originalText = btn.textContent;
            btn.textContent = '‚è≥ UPLOADING...';
            btn.disabled = true;
            
            // Gather training data
            const trainingData = {
                rules: ruleEngine.rules,
                patterns: patternTracker.getStats(),
                deathInfo: deathDebugInfo,
                timestamp: Date.now(),
                version: '1.0'
            };
            
            // Upload to Partykit server (or could be a separate endpoint)
            fetch('https://locomot-io.savecharlie.partykit.dev/party/collective', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ type: 'upload_training', data: trainingData })
            })
            .then(res => {
                if (res.ok) {
                    btn.textContent = '‚úÖ UPLOADED!';
                    btn.style.background = '#0f0';
                    haptic('heavy');
                } else {
                    throw new Error('Upload failed');
                }
            })
            .catch(err => {
                console.error('Upload error:', err);
                btn.textContent = '‚ùå FAILED';
                btn.style.background = '#f00';
            })
            .finally(() => {
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '#0a6';
                    btn.disabled = false;
                }, 3000);
            });
        });
        
        // === DEV SPECTATE MODE - Watch real players ===
        const devMode = {
            active: new URLSearchParams(window.location.search).get('dev') === '1',
            spectating: false,
            playerIndex: 0,
            selectedPlayer: null,
            playerHistory: { players: [], sessions: [] },
            lastHistoryFetch: 0,

            toggle() {
                this.spectating = !this.spectating;
                if (this.spectating) {
                    this.playerIndex = 0;
                    this.updateSelection();
                }
                console.log('[DEV] Spectate mode:', this.spectating);
            },

            // Fetch player history from server
            async fetchHistory() {
                try {
                    const res = await fetch('https://api.locomot.io/api/players');
                    if (res.ok) {
                        this.playerHistory = await res.json();
                        console.log('[DEV] Fetched player history:', this.playerHistory.players.length, 'players');
                    }
                } catch (e) {
                    console.log('[DEV] Could not fetch player history');
                }
            },

            // Report player join to server
            async reportJoin(name, id) {
                try {
                    await fetch('https://api.locomot.io/api/player/join', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name, id })
                    });
                } catch (e) {}
            },

            // Report player leave with stats
            async reportLeave(name, maxLength, kills, score) {
                try {
                    await fetch('https://api.locomot.io/api/player/leave', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name, maxLength, kills, score })
                    });
                } catch (e) {}
            },

            // Periodic activity heartbeat
            async reportActivity(name, length, score) {
                try {
                    await fetch('https://api.locomot.io/api/player/activity', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name, length, score })
                    });
                } catch (e) {}
            },

            getPlayers() {
                const players = [];
                if (Multiplayer.connected) {
                    for (const [pid, op] of Multiplayer.otherPlayers) {
                        if (op.segments && op.segments.length > 0) {
                            players.push({ id: pid, ...op });
                        }
                    }
                }
                return players;
            },

            // Get recent sessions from history (for when no one is online)
            getRecentSessions() {
                if (!this.playerHistory.sessions) return [];
                const now = Date.now();
                return this.playerHistory.sessions
                    .filter(s => s.left) // Only completed sessions
                    .slice(-10)
                    .reverse();
            },

            nextPlayer() {
                const players = this.getPlayers();
                if (players.length === 0) return;
                this.playerIndex = (this.playerIndex + 1) % players.length;
                this.updateSelection();
            },

            prevPlayer() {
                const players = this.getPlayers();
                if (players.length === 0) return;
                this.playerIndex = (this.playerIndex - 1 + players.length) % players.length;
                this.updateSelection();
            },

            updateSelection() {
                const players = this.getPlayers();
                if (players.length > 0 && this.playerIndex < players.length) {
                    this.selectedPlayer = players[this.playerIndex];
                    console.log('[DEV] Following:', this.selectedPlayer.name, '- Length:', this.selectedPlayer.segments.length);
                } else {
                    this.selectedPlayer = null;
                }
            },

            getFollowTarget() {
                if (!this.spectating || !this.selectedPlayer) return null;
                // Refresh from live data
                const op = Multiplayer.otherPlayers.get(this.selectedPlayer.id);
                if (op && op.segments && op.segments.length > 0) {
                    return { x: op.segments[0].x, y: op.segments[0].y, length: op.segments.length, name: op.name };
                }
                return null;
            },

            draw(ctx) {
                if (!this.active) return;
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0);

                const players = this.getPlayers();
                const recentSessions = this.getRecentSessions();
                const showHistory = players.length === 0 && recentSessions.length > 0;
                const boxHeight = this.spectating && players.length > 0
                    ? 90 + Math.min(players.length, 8) * 15
                    : showHistory ? 90 + Math.min(recentSessions.length, 6) * 15 : 70;

                // Semi-transparent background for visibility
                ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                ctx.fillRect(5, 100, 280, boxHeight);
                ctx.strokeStyle = '#f0f';
                ctx.lineWidth = 2;
                ctx.strokeRect(5, 100, 280, boxHeight);

                ctx.font = '10px "Press Start 2P"';
                ctx.textAlign = 'left';

                // Dev mode indicator
                ctx.fillStyle = '#f0f';
                ctx.fillText('üîß DEV MODE', 15, 120);

                ctx.font = '8px "Press Start 2P"';
                ctx.fillStyle = '#fff';
                ctx.fillText(`Real players online: ${players.length}`, 15, 140);
                ctx.fillStyle = '#888';
                ctx.fillText('Tap here or Ctrl+Shift+S', 15, 155);

                // Debug: Show info about ALL entities (real + AI)
                ctx.fillStyle = '#f80';
                const mpCount = Multiplayer.otherPlayers.size;
                const aiCount = enemies.filter(e => e.segments && e.segments.length > 0).length;
                ctx.fillText(`MP: ${mpCount} | AI: ${aiCount}`, 200, 120);

                // Debug: Show who we're spectating
                if (gameState === 'dead') {
                    let foundTarget = null;
                    let targetType = 'none';
                    
                    // Check multiplayer players
                    for (const [pid, op] of Multiplayer.otherPlayers) {
                        if (op.name === 'grease' || (op.segments && op.segments.length > 0)) {
                            if (!foundTarget || op.name === 'grease') {
                                foundTarget = { ...op, pid };
                                targetType = 'REAL MP';
                            }
                        }
                    }
                    
                    // Check AI enemies for "grease"
                    for (const e of enemies) {
                        if (e.name === 'grease' && e.segments && e.segments.length > 0) {
                            foundTarget = e;
                            targetType = 'AI ENEMY';
                        }
                    }
                    
                    if (foundTarget && foundTarget.name === 'grease') {
                        ctx.fillStyle = '#f00';
                        ctx.fillText(`üîç grease = ${targetType}`, 15, 170);
                        if (foundTarget.pid) {
                            ctx.fillText(`   ID: ${foundTarget.pid.slice(0,12)}...`, 15, 182);
                        }
                        const lastSeen = Multiplayer.playerLastSeen.get(foundTarget.pid);
                        if (lastSeen) {
                            const ago = Math.floor((Date.now() - lastSeen) / 1000);
                            ctx.fillText(`   Last update: ${ago}s ago`, 15, 194);
                        }
                    }
                }

                if (this.spectating && players.length > 0) {
                    ctx.fillStyle = '#ff0';
                    ctx.fillText('SPECTATING - swipe ‚Üê/‚Üí to cycle', 15, 175);

                    // Player list
                    for (let i = 0; i < Math.min(players.length, 8); i++) {
                        const p = players[i];
                        const selected = i === this.playerIndex;
                        ctx.fillStyle = selected ? '#0f0' : '#888';
                        const marker = selected ? '‚ñ∫ ' : '  ';
                        ctx.fillText(`${marker}${p.name || 'Unknown'} (${p.segments?.length || 0})`, 15, 195 + i * 15);
                    }
                } else if (showHistory) {
                    ctx.fillStyle = '#5cf';
                    ctx.fillText('üìú Recent players:', 15, 175);

                    for (let i = 0; i < Math.min(recentSessions.length, 6); i++) {
                        const s = recentSessions[i];
                        const ago = this.timeAgo(s.left);
                        ctx.fillStyle = '#888';
                        ctx.fillText(`${s.name} - ${s.score}pts (${ago})`, 15, 195 + i * 15);
                    }
                } else if (players.length === 0) {
                    ctx.fillStyle = '#f55';
                    ctx.fillText('No players yet. Fetching...', 15, 175);
                }

                ctx.restore();
            },

            // Helper to format time ago
            timeAgo(isoString) {
                if (!isoString) return '?';
                const diff = Date.now() - new Date(isoString).getTime();
                const mins = Math.floor(diff / 60000);
                if (mins < 1) return 'just now';
                if (mins < 60) return `${mins}m ago`;
                const hours = Math.floor(mins / 60);
                if (hours < 24) return `${hours}h ago`;
                return `${Math.floor(hours / 24)}d ago`;
            },

            // Check if tap is in dev box
            handleTap(x, y) {
                if (!this.active) return false;
                if (x >= 5 && x <= 285 && y >= 100 && y <= 200) {
                    this.toggle();
                    return true;
                }
                return false;
            }
        };

        document.addEventListener('keydown', e => {
            // Dev mode controls (always active if dev=1)
            if (devMode.active) {
                if (e.ctrlKey && e.shiftKey && e.code === 'KeyS') {
                    devMode.toggle();
                    e.preventDefault();
                    return;
                }
                if (devMode.spectating) {
                    if (e.code === 'ArrowLeft' || e.code === 'KeyA') { devMode.prevPlayer(); e.preventDefault(); return; }
                    if (e.code === 'ArrowRight' || e.code === 'KeyD') { devMode.nextPlayer(); e.preventDefault(); return; }
                    if (e.code === 'Escape') { devMode.spectating = false; e.preventDefault(); return; }
                }
            }

            if (gameState !== 'playing') return;
            // Queue direction changes for responsive controls
            let newDir = null;
            if (e.code === 'ArrowUp' || e.code === 'KeyW') newDir = DIR.UP;
            else if (e.code === 'ArrowDown' || e.code === 'KeyS') newDir = DIR.DOWN;
            else if (e.code === 'ArrowLeft' || e.code === 'KeyA') newDir = DIR.LEFT;
            else if (e.code === 'ArrowRight' || e.code === 'KeyD') newDir = DIR.RIGHT;

            if (newDir && dirQueue.length < 3) {
                const lastDir = dirQueue.length > 0 ? dirQueue[dirQueue.length - 1] : dir;
                // Prevent 180 degree turns
                if (!(lastDir.x === -newDir.x && lastDir.y === -newDir.y)) {
                    dirQueue.push(newDir);
                }
            }
            else if (e.code === 'Space') { gameState = 'paused'; canvas.classList.remove('playing'); document.getElementById('pauseScreen').classList.remove('hidden'); }
        });
        
        // Desktop mouse aiming - continuous tracking
        document.addEventListener('mousemove', e => {
            if (gameState !== 'playing') return;
            mouseX = e.clientX;
            mouseY = e.clientY;
            isMouseAiming = true;
            // Update aim angle to point at mouse cursor
            const head = snake[0];
            if (head) {
                const hx = (head.x * GRID + GRID/2 - cameraX) * cameraZoom;
                const hy = (head.y * GRID + GRID/2 - cameraY) * cameraZoom;
                aimAngle = Math.atan2(mouseY - hy, mouseX - hx);
            }
        });
        document.addEventListener('mouseleave', () => { isMouseAiming = false; });
        document.addEventListener('mouseenter', e => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            isMouseAiming = true;
        });
        
        patternTracker.load(); // Load saved patterns from localStorage
        reputationSystem.load(); // Load player reputation from localStorage
        devMode.fetchHistory(); // Fetch recent player history
        init();
        requestAnimationFrame(gameLoop);

        // Periodic activity heartbeat (every 30 seconds)
        setInterval(() => {
            if (gameState === 'playing' && Multiplayer.connected) {
                const playerName = Multiplayer.username || 'Anonymous';
                devMode.reportActivity(playerName, snake.length, score);
            }
        }, 30000);

        // Clean up inactive players every 10 seconds
        setInterval(() => {
            if (Multiplayer.connected) {
                Multiplayer.cleanupInactivePlayers();
            }
        }, 10000);

        // PWA: Register service worker for offline play
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('./sw.js')
                .then(reg => console.log('Offline mode enabled'))
                .catch(err => console.log('Offline mode unavailable'));
        }
    </script>
</body>
</html>
